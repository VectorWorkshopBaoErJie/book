<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Reference</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">介绍</a></li><li class="chapter-item expanded "><a href="notation.html"><strong aria-hidden="true">1.</strong> 符号约定</a></li><li class="chapter-item expanded "><a href="lexical-structure.html"><strong aria-hidden="true">2.</strong> 词法结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="input-format.html"><strong aria-hidden="true">2.1.</strong> 输入格式</a></li><li class="chapter-item expanded "><a href="keywords.html"><strong aria-hidden="true">2.2.</strong> 关键字</a></li><li class="chapter-item expanded "><a href="identifiers.html"><strong aria-hidden="true">2.3.</strong> 标识符</a></li><li class="chapter-item expanded "><a href="comments.html"><strong aria-hidden="true">2.4.</strong> 注释</a></li><li class="chapter-item expanded "><a href="whitespace.html"><strong aria-hidden="true">2.5.</strong> 空白</a></li><li class="chapter-item expanded "><a href="tokens.html"><strong aria-hidden="true">2.6.</strong> 记号</a></li></ol></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">3.</strong> 宏</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macros-by-example.html"><strong aria-hidden="true">3.1.</strong> 实例宏</a></li><li class="chapter-item expanded "><a href="procedural-macros.html"><strong aria-hidden="true">3.2.</strong> 过程宏</a></li></ol></li><li class="chapter-item expanded "><a href="crates-and-source-files.html"><strong aria-hidden="true">4.</strong> Crate和源文件</a></li><li class="chapter-item expanded "><a href="conditional-compilation.html"><strong aria-hidden="true">5.</strong> 条件编译</a></li><li class="chapter-item expanded "><a href="items.html"><strong aria-hidden="true">6.</strong> 条目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="items/modules.html"><strong aria-hidden="true">6.1.</strong> 模块</a></li><li class="chapter-item expanded "><a href="items/extern-crates.html"><strong aria-hidden="true">6.2.</strong> 外部Crate</a></li><li class="chapter-item expanded "><a href="items/use-declarations.html"><strong aria-hidden="true">6.3.</strong> Use 声明</a></li><li class="chapter-item expanded "><a href="items/functions.html"><strong aria-hidden="true">6.4.</strong> 函数</a></li><li class="chapter-item expanded "><a href="items/type-aliases.html"><strong aria-hidden="true">6.5.</strong> 类型别名</a></li><li class="chapter-item expanded "><a href="items/structs.html"><strong aria-hidden="true">6.6.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="items/enumerations.html"><strong aria-hidden="true">6.7.</strong> 枚举</a></li><li class="chapter-item expanded "><a href="items/unions.html"><strong aria-hidden="true">6.8.</strong> 联合体</a></li><li class="chapter-item expanded "><a href="items/constant-items.html"><strong aria-hidden="true">6.9.</strong> 常量条目</a></li><li class="chapter-item expanded "><a href="items/static-items.html"><strong aria-hidden="true">6.10.</strong> 静态条目</a></li><li class="chapter-item expanded "><a href="items/traits.html"><strong aria-hidden="true">6.11.</strong> Trait</a></li><li class="chapter-item expanded "><a href="items/implementations.html"><strong aria-hidden="true">6.12.</strong> 实现</a></li><li class="chapter-item expanded "><a href="items/external-blocks.html"><strong aria-hidden="true">6.13.</strong> 外部块</a></li><li class="chapter-item expanded "><a href="items/generics.html"><strong aria-hidden="true">6.14.</strong> 泛型参数</a></li><li class="chapter-item expanded "><a href="items/associated-items.html"><strong aria-hidden="true">6.15.</strong> 关联条目</a></li></ol></li><li class="chapter-item expanded "><a href="attributes.html"><strong aria-hidden="true">7.</strong> 属性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="attributes/testing.html"><strong aria-hidden="true">7.1.</strong> 测试</a></li><li class="chapter-item expanded "><a href="attributes/derive.html"><strong aria-hidden="true">7.2.</strong> 派生</a></li><li class="chapter-item expanded "><a href="attributes/diagnostics.html"><strong aria-hidden="true">7.3.</strong> 诊断</a></li><li class="chapter-item expanded "><a href="attributes/codegen.html"><strong aria-hidden="true">7.4.</strong> 代码生成</a></li><li class="chapter-item expanded "><a href="attributes/limits.html"><strong aria-hidden="true">7.5.</strong> 约束</a></li><li class="chapter-item expanded "><a href="attributes/type_system.html"><strong aria-hidden="true">7.6.</strong> 类型系统</a></li></ol></li><li class="chapter-item expanded "><a href="statements-and-expressions.html"><strong aria-hidden="true">8.</strong> 语句和表达式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="statements.html"><strong aria-hidden="true">8.1.</strong> 语句</a></li><li class="chapter-item expanded "><a href="expressions.html"><strong aria-hidden="true">8.2.</strong> 表达式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="expressions/literal-expr.html"><strong aria-hidden="true">8.2.1.</strong> 字面值表达式</a></li><li class="chapter-item expanded "><a href="expressions/path-expr.html"><strong aria-hidden="true">8.2.2.</strong> 路径表达式</a></li><li class="chapter-item expanded "><a href="expressions/block-expr.html"><strong aria-hidden="true">8.2.3.</strong> 块表达式</a></li><li class="chapter-item expanded "><a href="expressions/operator-expr.html"><strong aria-hidden="true">8.2.4.</strong> 运算符表达式</a></li><li class="chapter-item expanded "><a href="expressions/grouped-expr.html"><strong aria-hidden="true">8.2.5.</strong> 分组表达式</a></li><li class="chapter-item expanded "><a href="expressions/array-expr.html"><strong aria-hidden="true">8.2.6.</strong> 数组和索引表达式</a></li><li class="chapter-item expanded "><a href="expressions/tuple-expr.html"><strong aria-hidden="true">8.2.7.</strong> 元组和索引表达式</a></li><li class="chapter-item expanded "><a href="expressions/struct-expr.html"><strong aria-hidden="true">8.2.8.</strong> 结构体表达式</a></li><li class="chapter-item expanded "><a href="expressions/call-expr.html"><strong aria-hidden="true">8.2.9.</strong> 调用表达式</a></li><li class="chapter-item expanded "><a href="expressions/method-call-expr.html"><strong aria-hidden="true">8.2.10.</strong> 方法调用表达式</a></li><li class="chapter-item expanded "><a href="expressions/field-expr.html"><strong aria-hidden="true">8.2.11.</strong> 字段访问表达式</a></li><li class="chapter-item expanded "><a href="expressions/closure-expr.html"><strong aria-hidden="true">8.2.12.</strong> 闭包表达式</a></li><li class="chapter-item expanded "><a href="expressions/loop-expr.html"><strong aria-hidden="true">8.2.13.</strong> 循环表达式</a></li><li class="chapter-item expanded "><a href="expressions/range-expr.html"><strong aria-hidden="true">8.2.14.</strong> 区间表达式</a></li><li class="chapter-item expanded "><a href="expressions/if-expr.html"><strong aria-hidden="true">8.2.15.</strong> if 和 if let 表达式</a></li><li class="chapter-item expanded "><a href="expressions/match-expr.html"><strong aria-hidden="true">8.2.16.</strong> 匹配表达式</a></li><li class="chapter-item expanded "><a href="expressions/return-expr.html"><strong aria-hidden="true">8.2.17.</strong> 返回表达式</a></li><li class="chapter-item expanded "><a href="expressions/await-expr.html"><strong aria-hidden="true">8.2.18.</strong> 等待表达式</a></li><li class="chapter-item expanded "><a href="expressions/underscore-expr.html"><strong aria-hidden="true">8.2.19.</strong> 下划线表达式</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="patterns.html"><strong aria-hidden="true">9.</strong> 模式</a></li><li class="chapter-item expanded "><a href="type-system.html"><strong aria-hidden="true">10.</strong> 类型系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">10.1.</strong> 类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/boolean.html"><strong aria-hidden="true">10.1.1.</strong> 布尔类型</a></li><li class="chapter-item expanded "><a href="types/numeric.html"><strong aria-hidden="true">10.1.2.</strong> 数字类型</a></li><li class="chapter-item expanded "><a href="types/textual.html"><strong aria-hidden="true">10.1.3.</strong> 文本类型</a></li><li class="chapter-item expanded "><a href="types/never.html"><strong aria-hidden="true">10.1.4.</strong> 永远不存在的类型</a></li><li class="chapter-item expanded "><a href="types/tuple.html"><strong aria-hidden="true">10.1.5.</strong> 元组类型</a></li><li class="chapter-item expanded "><a href="types/array.html"><strong aria-hidden="true">10.1.6.</strong> 数组类型</a></li><li class="chapter-item expanded "><a href="types/slice.html"><strong aria-hidden="true">10.1.7.</strong> 切片类型</a></li><li class="chapter-item expanded "><a href="types/struct.html"><strong aria-hidden="true">10.1.8.</strong> 结构体类型</a></li><li class="chapter-item expanded "><a href="types/enum.html"><strong aria-hidden="true">10.1.9.</strong> 枚举类型</a></li><li class="chapter-item expanded "><a href="types/union.html"><strong aria-hidden="true">10.1.10.</strong> 联合类型</a></li><li class="chapter-item expanded "><a href="types/function-item.html"><strong aria-hidden="true">10.1.11.</strong> 函数条目类型</a></li><li class="chapter-item expanded "><a href="types/closure.html"><strong aria-hidden="true">10.1.12.</strong> 闭包类型</a></li><li class="chapter-item expanded "><a href="types/pointer.html"><strong aria-hidden="true">10.1.13.</strong> 指针类型</a></li><li class="chapter-item expanded "><a href="types/function-pointer.html"><strong aria-hidden="true">10.1.14.</strong> 函数指针类型</a></li><li class="chapter-item expanded "><a href="types/trait-object.html"><strong aria-hidden="true">10.1.15.</strong> Trait 对象类型</a></li><li class="chapter-item expanded "><a href="types/impl-trait.html"><strong aria-hidden="true">10.1.16.</strong> 实现 Trait 的类型</a></li><li class="chapter-item expanded "><a href="types/parameters.html"><strong aria-hidden="true">10.1.17.</strong> 类型参数</a></li><li class="chapter-item expanded "><a href="types/inferred.html"><strong aria-hidden="true">10.1.18.</strong> 推导出的类型</a></li></ol></li><li class="chapter-item expanded "><a href="dynamically-sized-types.html"><strong aria-hidden="true">10.2.</strong> 动态大小类型</a></li><li class="chapter-item expanded "><a href="type-layout.html"><strong aria-hidden="true">10.3.</strong> 类型布局</a></li><li class="chapter-item expanded "><a href="interior-mutability.html"><strong aria-hidden="true">10.4.</strong> 内部可变性</a></li><li class="chapter-item expanded "><a href="subtyping.html"><strong aria-hidden="true">10.5.</strong> 子类型和协变</a></li><li class="chapter-item expanded "><a href="trait-bounds.html"><strong aria-hidden="true">10.6.</strong> Trait 和生命周期约束</a></li><li class="chapter-item expanded "><a href="type-coercions.html"><strong aria-hidden="true">10.7.</strong> 类型强制转换</a></li><li class="chapter-item expanded "><a href="destructors.html"><strong aria-hidden="true">10.8.</strong> 析构函数</a></li><li class="chapter-item expanded "><a href="lifetime-elision.html"><strong aria-hidden="true">10.9.</strong> 生命周期省略</a></li></ol></li><li class="chapter-item expanded "><a href="special-types-and-traits.html"><strong aria-hidden="true">11.</strong> 特殊类型和Trait</a></li><li class="chapter-item expanded "><a href="names.html"><strong aria-hidden="true">12.</strong> 名称</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="names/namespaces.html"><strong aria-hidden="true">12.1.</strong> 命名空间</a></li><li class="chapter-item expanded "><a href="names/scopes.html"><strong aria-hidden="true">12.2.</strong> 作用域</a></li><li class="chapter-item expanded "><a href="names/preludes.html"><strong aria-hidden="true">12.3.</strong> 预定义</a></li><li class="chapter-item expanded "><a href="paths.html"><strong aria-hidden="true">12.4.</strong> 路径</a></li><li class="chapter-item expanded "><a href="names/name-resolution.html"><strong aria-hidden="true">12.5.</strong> 名称解析</a></li><li class="chapter-item expanded "><a href="visibility-and-privacy.html"><strong aria-hidden="true">12.6.</strong> 可见性和私有性</a></li></ol></li><li class="chapter-item expanded "><a href="memory-model.html"><strong aria-hidden="true">13.</strong> 内存模型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="memory-allocation-and-lifetime.html"><strong aria-hidden="true">13.1.</strong> 内存分配和生命周期</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">13.2.</strong> 变量</a></li></ol></li><li class="chapter-item expanded "><a href="linkage.html"><strong aria-hidden="true">14.</strong> 链接</a></li><li class="chapter-item expanded "><a href="inline-assembly.html"><strong aria-hidden="true">15.</strong> 内联汇编</a></li><li class="chapter-item expanded "><a href="unsafety.html"><strong aria-hidden="true">16.</strong> Unsafety</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="unsafe-keyword.html"><strong aria-hidden="true">16.1.</strong> unsafe 关键字</a></li><li class="chapter-item expanded "><a href="behavior-considered-undefined.html"><strong aria-hidden="true">16.2.</strong> 被视为未定义行为的行为</a></li><li class="chapter-item expanded "><a href="behavior-not-considered-unsafe.html"><strong aria-hidden="true">16.3.</strong> 不被视为不安全的行为</a></li></ol></li><li class="chapter-item expanded "><a href="const_eval.html"><strong aria-hidden="true">17.</strong> 常量求值</a></li><li class="chapter-item expanded "><a href="abi.html"><strong aria-hidden="true">18.</strong> 应用程序二进制接口</a></li><li class="chapter-item expanded "><a href="runtime.html"><strong aria-hidden="true">19.</strong> Rust 运行时</a></li><li class="chapter-item expanded "><a href="appendices.html"><strong aria-hidden="true">20.</strong> 附录</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macro-ambiguity.html"><strong aria-hidden="true">20.1.</strong> 宏 Follow-Set 歧义正式规范</a></li><li class="chapter-item expanded "><a href="influences.html"><strong aria-hidden="true">20.2.</strong> 影响</a></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">20.3.</strong> 术语表</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p>本书是 Rust 编程语言的主要参考资料，提供了三种类型的内容：</p>
<ul>
<li>介绍语言构造及使用的章节。</li>
<li>介绍内存模型、并发模型、运行时服务、链接模型和调试功能的章节。</li>
<li>介绍相关语言设计基本原理和其他对设计有影响的参考资料的附录章节。</li>
</ul>
<div class="warning">
<p>提醒:
本书还不完整，要记录所有内容还需要一段时间。
可以查看 <a href="https://github.com/rust-lang/reference/issues">GitHub issues</a> 了解本书还未记录的内容。</p>
</div>
<h2 id="rust-发布"><a class="header" href="#rust-发布">Rust 发布</a></h2>
<p>Rust 语言每六周发布一个新的版本。
第一个稳定版本是 Rust 1.0.0 ，随后是 Rust 1.1.0 等等。
<code>rustc</code> 、 <code>cargo</code> 等工具和 <a href="../std/index.html">标准库</a> 、本书等文档都随同语言版本一起发布。</p>
<p>本书原版新版本与最新的 Rust 版本匹配，可在 <a href="https://doc.rust-lang.org/reference/">https://doc.rust-lang.org/reference/</a> 找到。之前版本可通过在 &quot;reference&quot; 前添加 Rust 版本号找到。
例如 <a href="https://doc.rust-lang.org/1.49.0/reference/">https://doc.rust-lang.org/1.49.0/reference/</a> 。</p>
<p>【矢量工坊宝儿姐】注：当前的中文译本以2023年1月25日源为基础，虽然当前使用的翻译工作流十分有效，但中文译本的更新周期也不会太过频繁。如有贡献、建议和问题，请移步译本仓库
<a href="https://github.com/VectorWorkshopBaoErJie/RustReferenceTranslate/">https://github.com/VectorWorkshopBaoErJie/RustReferenceTranslate/</a></p>
<h2 id="参考-中没有的内容"><a class="header" href="#参考-中没有的内容"><em>参考</em> 中没有的内容</a></h2>
<p>本书不是 Rust 语言的入门教程，假定读者已经对 Rust 有一定的了解。
如果有需要可以查阅 Rust 官方提供的入门教程 <a href="../book/index.html">文档</a> 。</p>
<p>本书也不作为语言发行版所包含 <a href="../std/index.html">标准库</a> 的参考文献。
标准库通过从源代码中提取文档属性而单独记录。
许多学习者所期望的语言特性在 Rust 中可能是库，因此有可能查找的内容在标准库中，而不是本书中。</p>
<p>同理，本书通常不会记录 <code>rustc</code> 和 Cargo 这两个工具的具体细节。
<code>rustc</code> 有其自己的 <a href="../rustc/index.html">文档</a> 。
Cargo 也有一本 <a href="../cargo/index.html">文档</a> ，其中包含 <a href="../cargo/reference/index.html">参考</a>。
但有些页，如 <a href="linkage.html">linkage</a> 仍然描述 <code>rustc</code> 的工作原理。</p>
<p>本书仅作为 Rust 稳定版本可用功能的参考。
对于正在开发中的不稳定特性，请参见 <a href="https://doc.rust-lang.org/nightly/unstable-book/">未稳定性文档</a>。</p>
<p>Rust 编译器，包括 <code>rustc</code> ，会执行优化操作。
本参考手册没有明确指定允许或禁止哪些优化。
而是，将编译后的程序视为黑盒。
您只能通过运行程序、提供输入和观察输出的方式来探测它。
而，这样产生的效果应符合参考手册所阐述的内容。</p>
<p>当前，本书还没有达到完全规范的标准。
还可能包含一些依赖于特定 <code>rustc</code> 的细节，这些不应将其视为 Rust 语言的规范。
我们打算有一天出版这样的书，但在那之前，本参考是最接近规范的。</p>
<h2 id="如何使用本书"><a class="header" href="#如何使用本书">如何使用本书</a></h2>
<p>本书并不假设您是顺序阅读。
每个章节通常可以单独阅读，在其内容涉及但未展开讨论时，会交叉链接到其他章节。</p>
<p>本文有两种主要的阅读方式。</p>
<p>第一种是回答特定的问题。
如果你知道哪个章节可以回答这个问题，可以在目录中跳转到该章节。
你可以按下 <code>s</code> 键或点击顶部栏上的放大镜搜索与您的问题相关的关键词。
例如，假设你想知道在 let 语句中创建的临时值何时被丢弃。
如果你不知道 <a href="expressions.html#temporaries">临时值的生命周期</a> 在 <a href="expressions.html">表达式章节</a> 中定义，你可以搜索 &quot;temporary let&quot; ，其搜索结果就是相关章节。</p>
<p>第二种是提高对语言某个方面的了解。
那么，只需浏览目录，针对某一主题展开阅读。</p>
<p>开卷有益，学而不怠，与君共勉。</p>
<h3 id="约定"><a class="header" href="#约定">约定</a></h3>
<p>本书作为技术书籍，在信息表达上有一些约定。</p>
<ul>
<li>
<p>定义术语的语句中，该术语会以 <em>斜体</em> 的形式出现。
在该章节之外的任意地方使用该术语时，通常都是指向包含此定义部分的链接。</p>
<p>如 <em>示例术语</em> 这样的术语定义。</p>
</li>
<li>
<p>在以 <strong>粗体</strong> 标识的块引用中，使用 &quot;版次差异:&quot; 这样的字眼来说明不同版本中编译 crate 的差异。</p>
<blockquote>
<p><strong>版次差异</strong>: 在 2015 版中，这个语法是有效的，但在 2018 版中不允许。</p>
</blockquote>
</li>
<li>
<p>&quot;注意:&quot; 为粗体的块引用，包含有关书的状态，或者指出有用而超出本书范围的信息。</p>
<blockquote>
<p><strong>注意</strong>: 这是一个说明示例。</p>
</blockquote>
</li>
<li>
<p>警告信息将显示为特殊的警告框，用于显示语言中的不安全行为或可能引起混淆的语言特性，作为读者间的交互。</p>
<div class="warning">
<p>警告: 这是一个警告的示例。</p>
</div>
</li>
<li>
<p>正文中的内联代码片段包含在 <code>&lt;code&gt;</code> 标签内。</p>
<p>更长的代码示例在一个语法高亮的框中展示，该框右上角有复制、执行和显示隐藏行的控制按钮。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">// 这是隐藏行。
</span>fn main() {
    println!(&quot;这是代码示例&quot;);
}</code></pre></pre>
<p>所有的示例都是针对最新版本的 Rust 编写的，除非另有说明。</p>
</li>
<li>
<p>语法和词法结构出现在引用块中，第一行以 <sup><strong>粗体上标</strong></sup> 的形式显示 &quot;词法&quot; 或 &quot;语法&quot; 。</p>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>示例语法</em>:<br />
      <code>~</code> <a href="expressions.html"><em>表达式</em></a><br />
   | <code>box</code> <a href="expressions.html"><em>表达式</em></a></p>
</blockquote>
<p>更多信息参见 <a href="notation.html">符号</a> 。</p>
</li>
</ul>
<h2 id="贡献"><a class="header" href="#贡献">贡献</a></h2>
<p>我们欢迎各种贡献。</p>
<p>您可以通过打开一个 issue 或发送一个 pull request 到 <a href="https://github.com/rust-lang/reference/">Rust 参考仓库</a> 做出贡献。
如果你的问题这本书没有回答，并且你认为该问题有必要范围包含在本书中，请 <a href="https://github.com/rust-lang/reference/issues">提交 issue</a> 或在 <a href="https://rust-lang.zulipchat.com/#narrow/stream/237824-t-lang.2Fdoc">Zulip</a> 的 <code>t-lang/doc</code> 频道提问。
了解本书最常使用的内容，有助于集中精力使这些部分变得更好。
我们还希望本书尽可能成为标准规范，对于发现的任何错误或不规范的问题，请 <a href="https://github.com/rust-lang/reference/issues">提交 issue</a> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="符号"><a class="header" href="#符号">符号</a></h1>
<h2 id="语法"><a class="header" href="#语法">语法</a></h2>
<p>以下符号在 &quot;词法&quot; 和 &quot;语法&quot; 的代码表示段中使用：</p>
<div class="table-wrapper"><table><thead><tr><th>符号</th><th>示例</th><th>意义</th></tr></thead><tbody>
<tr><td>大写字母</td><td>KW_IF，INTEGER_LITERAL</td><td>表示词法分析器所生成的标记</td></tr>
<tr><td><em>驼峰斜体</em></td><td><em>LetStatement</em>，<em>Item</em></td><td>表示语法标记</td></tr>
<tr><td><code>string</code></td><td><code>x</code>，<code>while</code>，<code>*</code></td><td>表示精确的字符</td></tr>
<tr><td>\x</td><td>\n，\r，\t，\0</td><td>表示此转义字符所代表的字符</td></tr>
<tr><td>x<sup>?</sup></td><td><code>pub</code><sup>?</sup></td><td>表示可选项</td></tr>
<tr><td>x<sup>*</sup></td><td><em>外部属性</em><sup>*</sup></td><td>表示 0 个或多个 x</td></tr>
<tr><td>x<sup>+</sup></td><td><em>宏匹配</em><sup>+</sup></td><td>表示 1 个或多个 x</td></tr>
<tr><td>x<sup>a..b</sup></td><td>十六进制数<sup>1..6</sup></td><td>表示 x 重复 a 到 b 次</td></tr>
<tr><td>|</td><td><code>u8</code> | <code>u16</code>，块 | 条目</td><td>两个选项中的一个</td></tr>
<tr><td>[ ]</td><td>[<code>b</code> <code>B</code>]</td><td>列举出中括号内的任意一个字符</td></tr>
<tr><td>[ - ]</td><td>[<code>a</code>-<code>z</code>]</td><td>列举出指定范围内的任意一个字符</td></tr>
<tr><td>~[ ]</td><td>~[<code>b</code> <code>B</code>]</td><td>列举除中括号内的任意一个字符之外的所有字符</td></tr>
<tr><td>~<code>string</code></td><td>~<code>\n</code>，~<code>*/</code></td><td>列举除指定序列之外的所有字符</td></tr>
<tr><td>( )</td><td>(<code>,</code> <em>参数</em>)<sup>?</sup></td><td>分组</td></tr>
</tbody></table>
</div>
<p>译注：中文翻译无法表达驼峰形式，仅用斜体表示。无法表达大小写形式。如有必要可查看翻译仓库中的条目。</p>
<h2 id="string-符号"><a class="header" href="#string-符号"><code>string</code> 符号</a></h2>
<p>语法中的一些规则，特别是 <a href="expressions/operator-expr.html#borrow-operators">一元运算符</a> 、 <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">二元运算符</a> 和 <a href="keywords.html">关键字</a> ，采用了简化形式，以可打印的字符串列表的形式给出。
这些情况构成了与 <a href="tokens.html">token</a> 令牌规则相关的规则子集，假定其编译驱动为确定性有限自动机 <abbr title="Deterministic Finite Automaton">DFA</abbr>
运行的语法分析器的词法分析阶段的结果，那么，该 DFA 操作于所有这些 <code>string</code> 表的分支上。</p>
<p>当在语法中看到用 <code>monospace</code> 等宽字体显示的字符串时，它隐式地引用了该 <code>string</code> 表标记的一个成员。有关更多信息，请参见 <a href="tokens.html">tokens</a> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lexical-structure"><a class="header" href="#lexical-structure">Lexical structure</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="输入格式"><a class="header" href="#输入格式">输入格式</a></h1>
<p>Rust 的输入被解释为一系列以 UTF-8 编码的 Unicode 代码序列。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关键字"><a class="header" href="#关键字">关键字</a></h1>
<p>Rust 关键字分为三类:</p>
<ul>
<li><a href="keywords.html#strict-keywords">严格字</a></li>
<li><a href="keywords.html#reserved-keywords">保留字</a></li>
<li><a href="keywords.html#weak-keywords">松散字</a></li>
</ul>
<h2 id="严格字"><a class="header" href="#严格字">严格字</a></h2>
<p>这些关键字只能在其正确的上下文中使用。不能用作以下内容的名称：</p>
<ul>
<li><a href="items.html">条目</a></li>
<li><a href="variables.html">变量</a> 和函数参数</li>
<li>字段 和 <a href="items/enumerations.html">变体</a></li>
<li><a href="types/parameters.html">类型参数</a></li>
<li>生命周期参数 或 <a href="expressions/loop-expr.html#loop-labels">loop 标签</a></li>
<li><a href="macros.html">宏</a> 或 <a href="attributes.html">属性</a></li>
<li><a href="macros-by-example.html">宏占位符</a></li>
<li><a href="crates-and-source-files.html">Crates</a></li>
</ul>
<blockquote>
<p><strong><sup>词法:<sup></strong><br />
KW_AS             : <code>as</code><br />
KW_BREAK          : <code>break</code><br />
KW_CONST          : <code>const</code><br />
KW_CONTINUE       : <code>continue</code><br />
KW_CRATE          : <code>crate</code><br />
KW_ELSE           : <code>else</code><br />
KW_ENUM           : <code>enum</code><br />
KW_EXTERN         : <code>extern</code><br />
KW_FALSE          : <code>false</code><br />
KW_FN             : <code>fn</code><br />
KW_FOR            : <code>for</code><br />
KW_IF             : <code>if</code><br />
KW_IMPL           : <code>impl</code><br />
KW_IN             : <code>in</code><br />
KW_LET            : <code>let</code><br />
KW_LOOP           : <code>loop</code><br />
KW_MATCH          : <code>match</code><br />
KW_MOD            : <code>mod</code><br />
KW_MOVE           : <code>move</code><br />
KW_MUT            : <code>mut</code><br />
KW_PUB            : <code>pub</code><br />
KW_REF            : <code>ref</code><br />
KW_RETURN         : <code>return</code><br />
KW_SELFVALUE      : <code>self</code><br />
KW_SELFTYPE       : <code>Self</code><br />
KW_STATIC         : <code>static</code><br />
KW_STRUCT         : <code>struct</code><br />
KW_SUPER          : <code>super</code><br />
KW_TRAIT          : <code>trait</code><br />
KW_TRUE           : <code>true</code><br />
KW_TYPE           : <code>type</code><br />
KW_UNSAFE         : <code>unsafe</code><br />
KW_USE            : <code>use</code><br />
KW_WHERE          : <code>where</code><br />
KW_WHILE          : <code>while</code></p>
</blockquote>
<p>以下关键字从 2018 版开始添加。</p>
<blockquote>
<p><strong><sup>词法 2018+</sup></strong><br />
KW_ASYNC          : <code>async</code><br />
KW_AWAIT          : <code>await</code><br />
KW_DYN            : <code>dyn</code></p>
</blockquote>
<h2 id="保留字"><a class="header" href="#保留字">保留字</a></h2>
<p>这些关键字目前还没有被使用，但是它们被保留以供将来使用。
它们的使用规则与严格关键字相同。
这样做的原因是通过禁止当前程序使用这些关键字，从而，使其与 Rust 的将来版本保持向前兼容。</p>
<blockquote>
<p><strong><sup>词法</sup></strong><br />
KW_ABSTRACT       : <code>abstract</code><br />
KW_BECOME         : <code>become</code><br />
KW_BOX            : <code>box</code><br />
KW_DO             : <code>do</code><br />
KW_FINAL          : <code>final</code><br />
KW_MACRO          : <code>macro</code><br />
KW_OVERRIDE       : <code>override</code><br />
KW_PRIV           : <code>priv</code><br />
KW_TYPEOF         : <code>typeof</code><br />
KW_UNSIZED        : <code>unsized</code><br />
KW_VIRTUAL        : <code>virtual</code><br />
KW_YIELD          : <code>yield</code></p>
</blockquote>
<p>以下关键字从 2018 版本开始保留。</p>
<blockquote>
<p><strong><sup>词法 2018+</sup></strong><br />
KW_TRY   : <code>try</code></p>
</blockquote>
<h2 id="松散字"><a class="header" href="#松散字">松散字</a></h2>
<p>这些关键字只有在特定上下文中才具有特殊意义。
例如，可以使用名称 <code>union</code> 声明变量或方法。</p>
<ul>
<li>
<p><code>macro_rules</code> 用于创建自定义 <a href="macros.html">宏</a> 。</p>
</li>
<li>
<p><code>union</code> 用于声明 <a href="items/unions.html">联合体</a> ，只有在使用 union 声明时才是一个关键字。</p>
</li>
<li>
<p><code>'static</code> 用于静态生命周期，不能作为 <a href="items/generics.html">泛型生命周期参数</a> 或 <a href="expressions/loop-expr.html#loop-labels">loop 标签</a> 使用。</p>
<pre><code class="language-compile_fail">// error[E0262]: invalid lifetime parameter name: `'static`
fn invalid_lifetime_parameter&lt;'static&gt;(s: &amp;'static str) -&gt; &amp;'static str { s }
</code></pre>
</li>
<li>
<p>在 2015 版中，<a href="types/trait-object.html"><code>dyn</code></a> 当用在类型位置且随后的路径不以 <code>::</code> 开头时，是一个关键字。</p>
<p>从 2018 版开始， <code>dyn</code> 已提升为严格关键词。</p>
</li>
</ul>
<blockquote>
<p><strong><sup>词法</sup></strong><br />
KW_UNION          : <code>union</code><br />
KW_STATICLIFETIME : <code>'static</code></p>
<p><strong><sup>词法 2015</sup></strong><br />
KW_DYN            : <code>dyn</code></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标识符"><a class="header" href="#标识符">标识符</a></h1>
<blockquote>
<p><strong><sup>词法:<sup></strong><br />
标识符或关键字 :<br />
      XID_起始 XID_继续<sup>*</sup><br />
   | <code>_</code> XID_继续<sup>+</sup></p>
<p>原始标识符 : <code>r#</code> 标识符或关键字 <sub><em>不包括 <code>crate</code>, <code>self</code>, <code>super</code>, <code>Self</code></em></sub></p>
<p>非关键字标识符 : 标识符或关键字 <sub><em>包括 <a href="keywords.html#strict-keywords">strict</a> 或 <a href="keywords.html#reserved-keywords">reserved</a> 关键字</em></sub></p>
<p>关键字 :<br />
非关键字标识符 | 原始标识符</p>
</blockquote>
<!-- 更新版本时，也要更新 UAX 链接。 -->
<p>标识符遵循 <a href="https://www.unicode.org/reports/tr31/tr31-37.html">Unicode 标准附录 #31</a> 的规范，使用的是 Unicode 15.0 版本，此外还有下面的增强规则。以下是一些标识符的例子：</p>
<ul>
<li><code>foo</code></li>
<li><code>_identifier</code></li>
<li><code>r#true</code></li>
<li><code>Москва</code></li>
<li><code>東京</code></li>
</ul>
<p>UAX #31 使用的编译设置是:</p>
<ul>
<li>起始 := <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&amp;abb=on&amp;g=&amp;i="><code>XID_起始</code></a>, 加下划线字符 (U+005F)</li>
<li>继续 := <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&amp;abb=on&amp;g=&amp;i="><code>XID_继续</code></a></li>
<li>中间 := 空白</li>
</ul>
<p>附加约束条件是，单个下划线字符不是标识符。</p>
<blockquote>
<p><strong>注意</strong>: 以下划线开头的标识符通常用于指示有意未使用的标识符，并将消除 <code>rustc</code> 中的未使用警告。</p>
</blockquote>
<p>标识符不能是 <a href="keywords.html#strict-keywords">严格</a> 或 <a href="keywords.html#reserved-keywords">保留</a> 的关键词，可以是下面 <code>r#</code> 前缀的 <a href="identifiers.html#raw-identifiers">原始标识符</a> 。</p>
<p>零宽度不连字符 (ZWNJ U+200C) 和零宽度连字符 (ZWJ U+200D) 不能出现在标识符中。</p>
<p>在以下情况下，标识符受到 ASCII 子集的 [XID_起始][XID_Start] 和 [XID_继续][XID_Continue] 的限制：</p>
<ul>
<li><a href="items/extern-crates.html"><code>extern crate</code></a> 声明</li>
<li>在 <a href="paths.html">path</a> 中引用的外部 crate 的名称</li>
<li>从文件系统加载的没有 <a href="items/modules.html#the-path-attribute"><code>path</code> 属性</a> 的 <a href="items/modules.html">模块</a> 名称 。</li>
<li><a href="abi.html#the-no_mangle-attribute"><code>no_mangle</code></a> 所属条目</li>
<li>外部块]<a href="items/external-blocks.html">external blocks</a> 中条目的名称</li>
</ul>
<h2 id="规范化"><a class="header" href="#规范化">规范化</a></h2>
<p>标识符使用 <a href="https://www.unicode.org/reports/tr15/tr15-53.html">Unicode Standard Annex #15</a> 中定义的规范化形式 C (NFC) 进行规范化。如果两个标识符的 NFC 形式相同，那么它们就是相等的。</p>
<p><a href="procedural-macros.html">过程宏</a> 和 <a href="macros-by-example.html">声明宏</a> 在其输入中接收规范化的标识符。</p>
<h2 id="原始标识符"><a class="header" href="#原始标识符">原始标识符</a></h2>
<p>原始标识符类似于普通标识符，但带有 <code>r#</code> 前缀。
(注意，实际的标识符不包括 <code>r#</code> 。)
与普通标识符不同，原始标识符可以是任何严格字或保留字，除了列在 <code>原始标识符</code> 中的那些关键字。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="注释"><a class="header" href="#注释">注释</a></h1>
<blockquote>
<p><strong><sup>词法</sup></strong><br />
行注释 :<br />
      <code>//</code> (~[<code>/</code> <code>!</code> <code>\n</code>] | <code>//</code>) ~<code>\n</code><sup>*</sup><br />
   | <code>//</code></p>
<p>块注释 :<br />
      <code>/*</code> (~[<code>*</code> <code>!</code>] | <code>**</code> | <em>行注释或文档</em>)
(<em>行注释或文档</em> | ~<code>*/</code>)<sup>*</sup> <code>*/</code><br />
   | <code>/**/</code><br />
   | <code>/***/</code></p>
<p>内部行文档 :<br />
   <code>//!</code> ~[<code>\n</code> <em>孤立CR</em>]<sup>*</sup></p>
<p>内部块文档 :<br />
   <code>/*!</code> ( <em>行注释或文档</em> | ~[<code>*/</code> <em>孤立CR</em>] )<sup>*</sup> <code>*/</code></p>
<p>外部行文档 :<br />
   <code>///</code> (~<code>/</code> ~[<code>\n</code> <em>孤立CR</em>]<sup>*</sup>)<sup>?</sup></p>
<p>外部块文档 :<br />
   <code>/**</code> (~<code>*</code> | <em>行注释或文档</em> )
(<em>行注释或文档</em> | ~[<code>*/</code> <em>孤立CR</em>])<sup>*</sup> <code>*/</code></p>
<p><em>行注释或文档</em> :<br />
      块注释<br />
   | 外部块文档<br />
   | 内部块文档</p>
<p><em>孤立CR</em> :<br />
   _ <code>\r</code> 不紧随 <code>\n</code>_</p>
</blockquote>
<h2 id="非文档注释"><a class="header" href="#非文档注释">非文档注释</a></h2>
<p>注释遵循 C++ 风格的行 (<code>//</code>) 和 (<code>/* ... */</code>) 块注释的一般形式。支持嵌套的块注释。</p>
<p>非文档注释被解释为空白的一种形式。</p>
<h2 id="文档注释"><a class="header" href="#文档注释">文档注释</a></h2>
<p>以三个斜线开始的行文档注释 (<code>///</code>)，以及块文档注释 (<code>/** ... */</code>)，都是内部文档注释，被解释为 <a href="../rustdoc/the-doc-attribute.html"><code>doc</code> 属性</a> 的特殊语法。
也就是说，它们相当于在注释主体的周围写上 <code>#[doc=&quot;...&quot;]</code> ，即， <code>/// Foo</code> 转换成 <code>#[doc=&quot;Foo&quot;]</code> ， <code>/** Bar */</code> 转换成 <code>#[doc=&quot;Bar&quot;</code> 。</p>
<p>以 <code>//!</code> 开头的行注释和 <code>/*! ... */</code> 块注释也是文档注释，应用于注释的父级，而不是之后条目。
也就是说，它们相当于在注释主体的周围写上 <code>#![doc=&quot;...&quot;]</code> 。 <code>//!</code> 注释通常应用于记录拥有源文件的模块。</p>
<p>在文档注释中不允许孤立的 CR (<code>\r</code>) ，即后面没有 LF (<code>\n</code>) 。</p>
<h2 id="示例"><a class="header" href="#示例">示例</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! 应用于这个 crate 的隐式匿名模块的文档注释

pub mod outer_module {

    //!  - 内部行文档
    //!! - 仍是内部行文档 (但开始有感叹号)

    /*!  - 内部块文档 */
    /*!! - 仍是内部块文档 (但开始有感叹号) */

    //   - 仅是注释
    ///  - 外部行文档 (正好 3 斜线)
    //// - 仅是注释

    /*   - 仅是注释 */
    /**  - 外部块文档 (正好 2 星号) */
    /*** - 仅是注释 */

    pub mod inner_module {}

    pub mod nested_comments {
        /* 在 Rust /* 可以 /* 嵌套注释 */ */ */

        // 所有三种类型的块注释都可以包含或嵌套任何其他类型的注释:

        /*   /* */  /** */  /*! */  */
        /*!  /* */  /** */  /*! */  */
        /**  /* */  /** */  /*! */  */
        pub mod dummy_item {}
    }

    pub mod degenerate_cases {
        // 空内部行文档
        //!

        // 空内部块文档
        /*!*/

        // 空行注释
        //

        // 空外部行文档
        ///

        // 空块注释
        /**/

        pub mod dummy_item {}

        // 空的 2 星号块不是块文档，而是块注释。
        /***/

    }

    /* 下一个是不允许的，
       外部文档注释需要一个条目来接收文档 */

    /// 我的条目在哪里?
<span class="boring">  mod boo {}
</span>}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="空白"><a class="header" href="#空白">空白</a></h1>
<p>空白是指非空字符串中包含的 <a href="https://www.unicode.org/reports/tr31/"><code>Pattern_White_Space</code></a> Unicode 属性的字符，即:</p>
<ul>
<li><code>U+0009</code> (水平制表符, <code>'\t'</code>)</li>
<li><code>U+000A</code> (换行符, <code>'\n'</code>)</li>
<li><code>U+000B</code> (垂直制表符)</li>
<li><code>U+000C</code> (换页符)</li>
<li><code>U+000D</code> (回车符, <code>'\r'</code>)</li>
<li><code>U+0020</code> (空格, <code>' '</code>)</li>
<li><code>U+0085</code> (下一行)</li>
<li><code>U+200E</code> (从左到右标记)</li>
<li><code>U+200F</code> (从右到左标记)</li>
<li><code>U+2028</code> (行分割符)</li>
<li><code>U+2029</code> (段落分隔符)</li>
</ul>
<p>Rust 是一种 &quot;形式自由&quot; 的语言，这意味着所有形式的空白仅用于分隔语法中的 <em>Token</em> ，空白自身没有语义。</p>
<p>如果每个空白元素被替换成任何其他合法的空白元素，例如单独的空格字符，那么 Rust 程序认为具有相同的意义。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokens"><a class="header" href="#tokens">Tokens</a></h1>
<p>Token 是非递归的常规编程语言描述语法的原始制品。 Rust 源码解析 Token 有以下几种 :</p>
<ul>
<li><a href="keywords.html">关键字</a> </li>
<li><a href="identifiers.html">标识符</a> </li>
<li><a href="tokens.html#literals">字面值</a> </li>
<li><a href="tokens.html#lifetimes-and-loop-labels">生命周期</a> </li>
<li><a href="tokens.html#punctuation">标点符号</a> </li>
<li><a href="tokens.html#delimiters">定界符号</a> </li>
</ul>
<p>在本文档的语法中，&quot;简单&quot; Token 以 <a href="notation.html#string-table-productions">string 标记</a> 的形式给出，并以 <code>monospace</code> &quot;等宽&quot; 字体呈现。</p>
<h2 id="字面值"><a class="header" href="#字面值">字面值</a></h2>
<p>字面值 Token 用于 <a href="expressions/literal-expr.html">字面值表达式</a> 。</p>
<h3 id="示例-1"><a class="header" href="#示例-1">示例</a></h3>
<h4 id="字符和字符串"><a class="header" href="#字符和字符串">字符和字符串</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>示例</th><th><code>#</code> 标记*</th><th>字符集</th><th>转义</th></tr></thead><tbody>
<tr><td><a href="tokens.html#character-literals">字符</a></td><td><code>'H'</code></td><td>0</td><td>All Unicode</td><td><a href="tokens.html#quote-escapes">Quote</a> &amp; <a href="tokens.html#ascii-escapes">ASCII</a> &amp; <a href="tokens.html#unicode-escapes">Unicode</a></td></tr>
<tr><td><a href="tokens.html#string-literals">字符串</a></td><td><code>&quot;hello&quot;</code></td><td>0</td><td>All Unicode</td><td><a href="tokens.html#quote-escapes">Quote</a> &amp; <a href="tokens.html#ascii-escapes">ASCII</a> &amp; <a href="tokens.html#unicode-escapes">Unicode</a></td></tr>
<tr><td><a href="tokens.html#raw-string-literals">原始字符串</a></td><td><code>r#&quot;hello&quot;#</code></td><td>&lt;256</td><td>All Unicode</td><td><code>N/A</code></td></tr>
<tr><td><a href="tokens.html#byte-literals">字节</a></td><td><code>b'H'</code></td><td>0</td><td>All ASCII</td><td><a href="tokens.html#quote-escapes">Quote</a> &amp; <a href="tokens.html#byte-escapes">Byte</a></td></tr>
<tr><td><a href="tokens.html#byte-string-literals">字节字符串</a></td><td><code>b&quot;hello&quot;</code></td><td>0</td><td>All ASCII</td><td><a href="tokens.html#quote-escapes">Quote</a> &amp; <a href="tokens.html#byte-escapes">Byte</a></td></tr>
<tr><td><a href="tokens.html#raw-byte-string-literals">原始字节字符串</a></td><td><code>br#&quot;hello&quot;#</code></td><td>&lt;256</td><td>All ASCII</td><td><code>N/A</code></td></tr>
</tbody></table>
</div>
<p>* 同一字面值两侧 <code>#</code> 的数量必须相等。</p>
<h4 id="ascii-转义符"><a class="header" href="#ascii-转义符">ASCII 转义符</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>名称</th></tr></thead><tbody>
<tr><td><code>\x41</code></td><td>7位字符编码(确切说是 2 位数字，最高为 0x7F )</td></tr>
<tr><td><code>\n</code></td><td>换行</td></tr>
<tr><td><code>\r</code></td><td>回车</td></tr>
<tr><td><code>\t</code></td><td>制表符</td></tr>
<tr><td><code>\\</code></td><td>反斜杠</td></tr>
<tr><td><code>\0</code></td><td>空字符</td></tr>
</tbody></table>
</div>
<h4 id="byte-转义符"><a class="header" href="#byte-转义符">Byte 转义符</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>名称</th></tr></thead><tbody>
<tr><td><code>\x7F</code></td><td>8位字符编码 (确切地说是 2 位数字)</td></tr>
<tr><td><code>\n</code></td><td>换行</td></tr>
<tr><td><code>\r</code></td><td>回车</td></tr>
<tr><td><code>\t</code></td><td>制表符</td></tr>
<tr><td><code>\\</code></td><td>反斜杠</td></tr>
<tr><td><code>\0</code></td><td>空字符</td></tr>
</tbody></table>
</div>
<h4 id="unicode-转义符"><a class="header" href="#unicode-转义符">Unicode 转义符</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>名称</th></tr></thead><tbody>
<tr><td><code>\u{7FFF}</code></td><td>24 位 Unicode 字符编码 (最多 6 位)</td></tr>
</tbody></table>
</div>
<h4 id="quote-转义符"><a class="header" href="#quote-转义符">Quote 转义符</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>名称</th></tr></thead><tbody>
<tr><td><code>\'</code></td><td>单引号</td></tr>
<tr><td><code>\&quot;</code></td><td>双引号</td></tr>
</tbody></table>
</div>
<h4 id="数字"><a class="header" href="#数字">数字</a></h4>
<div class="table-wrapper"><table><thead><tr><th><a href="tokens.html#number-literals">数字字面值</a><code>*</code></th><th>示例</th><th>指数运算</th></tr></thead><tbody>
<tr><td>十进制整数</td><td><code>98_222</code></td><td><code>N/A</code></td></tr>
<tr><td>十六进制整数</td><td><code>0xff</code></td><td><code>N/A</code></td></tr>
<tr><td>八进制整数</td><td><code>0o77</code></td><td><code>N/A</code></td></tr>
<tr><td>二进制整数</td><td><code>0b1111_0000</code></td><td><code>N/A</code></td></tr>
<tr><td>浮点数</td><td><code>123.0E+77</code></td><td><code>可选的</code></td></tr>
</tbody></table>
</div>
<p><code>*</code> 所有的数字字面值允许 <code>_</code> 作为可视化分隔符: <code>1_234.0E+18f64</code></p>
<h4 id="后缀"><a class="header" href="#后缀">后缀</a></h4>
<p>后缀是在字面值主体部分之后的一串字符(中间没有空白)，其形式与非原始标识符或关键词相同。</p>
<blockquote>
<p><strong><sup>词法</sup></strong><br />
后缀 : 标识符或关键字<br />
后缀非E : 后缀 <sub><em>不以 <code>e</code> 或 <code>E</code> 开始</em></sub></p>
</blockquote>
<p>任何种类的字面值字符串、整数等可带有任意后缀，将作为单个 Token 。</p>
<p>带有任意后缀的字面值 Token 可以传递给宏而不产生错误。
宏本身去决定如何解释这类 Token 以及是否产生错误。
特别是，示例宏的 <code>literal</code> 片段指示器可以匹配具有任意后缀的字面值 Token。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! blackhole { ($tt:tt) =&gt; () }
macro_rules! blackhole_lit { ($l:literal) =&gt; () }

blackhole!(&quot;string&quot;suffix); // OK
blackhole_lit!(1suffix); // OK
<span class="boring">}</span></code></pre></pre>
<p>然而，在被解释为字面值表达式或模式的字面值 Token 的后缀是受限的。
会拒绝在非数字字面值 Token 上的任意后缀。
而数字字面值 Token 只接受以下列表中的后缀。</p>
<div class="table-wrapper"><table><thead><tr><th>整数</th><th>浮点数</th></tr></thead><tbody>
<tr><td><code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>, <code>i64</code>, <code>u128</code>, <code>i128</code>, <code>usize</code>, <code>isize</code></td><td><code>f32</code>, <code>f64</code></td></tr>
</tbody></table>
</div>
<h3 id="字符和字符串字面值"><a class="header" href="#字符和字符串字面值">字符和字符串字面值</a></h3>
<h4 id="字符字面值"><a class="header" href="#字符字面值">字符字面值</a></h4>
<blockquote>
<p><strong><sup>词法</sup></strong><br />
字符字面值 :<br />
   <code>'</code> ( ~[<code>'</code> <code>\</code> \n \r \t] | 引号转义 | ASCII转义 | UNICODE转义 ) <code>'</code> 后缀<sup>?</sup></p>
<p>引号转义 :<br />
   <code>\'</code> | <code>\&quot;</code></p>
<p>ASCII转义 :<br />
      <code>\x</code> 八进制数 十六进制数<br />
   | <code>\n</code> | <code>\r</code> | <code>\t</code> | <code>\\</code> | <code>\0</code></p>
<p>UNICODE转义 :<br />
   <code>\u{</code> ( 十六进制数 <code>_</code><sup>*</sup> )<sup>1..6</sup> <code>}</code></p>
</blockquote>
<p><em>字符字面值</em> 是指被两个 <code>U+0027</code> (单引号) 字符包围的单个 Unicode 字符，
但 <code>U+0027</code> 本身除外，单引号必须在前面以 <code>U+005C</code> 字符 (<code>\</code>)  <em>转义</em> 。</p>
<h4 id="字符串字面值"><a class="header" href="#字符串字面值">字符串字面值</a></h4>
<blockquote>
<p><strong><sup>词法</sup></strong><br />
字符串字面值 :<br />
   <code>&quot;</code> (<br />
      ~[<code>&quot;</code> <code>\</code> <em>孤立CR</em>]<br />
      | 引用转义<br />
      | ASCII转义<br />
      | UNICODE转义<br />
      | 字符串继续<br />
   )<sup>*</sup> <code>&quot;</code> 后缀<sup>?</sup></p>
<p>字符串继续 :<br />
   <code>\</code> <em>随后</em> \n</p>
</blockquote>
<p><em>字符串字面值</em> 是由两个 <code>U+0022</code> (双引号) 字符包围的任意 Unicode 字符序列，
但 <code>U+0022</code> 本身除外，双引号必须在前面以 <code>U+005C</code> 字符 (<code>\</code>)  <em>转义</em> 。</p>
<p>字符串字面值中允许断行。换行符是换行符 (<code>U+000A</code>) 或一对回车和换行符 (<code>U+000D</code>, <code>U+000A</code>) ，
这两个字节序列通常被翻译成 <code>U+000A</code> ，但有一种特殊的例外，
当一个未转义的 <code>U+005C</code>  (<code>\</code>) 字符出现在换行之前，那么忽略断行符和所有紧随其后的 <code> </code> (<code>U+0020</code>) 、 <code>\t</code> (<code>U+0009</code>) 、 <code>\n</code> (<code>U+000A</code>) 、 <code>\r</code> (<code>U+0000D</code>) 字符。
因此 <code>a</code> 、 <code>b</code> 、 <code>c</code> 相同:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = &quot;foobar&quot;;
let b = &quot;foo\
         bar&quot;;
let c = &quot;foo\

     bar&quot;;

assert_eq!(a, b);
assert_eq!(b, c);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>注意: Rust 跳过额外的新行 (比如在例子 <code>c</code> 中) ，这有可能会令人困惑和意外。 
在未来可能会调整这种行为。在做出决定之前，建议避免使用,也就是说，目前，会跳过多个连续的换行。
更多内容见这个 <a href="https://github.com/rust-lang/reference/pull/1042">Issue</a> 。</p>
</blockquote>
<h4 id="字符转义"><a class="header" href="#字符转义">字符转义</a></h4>
<p>可以在字符或非原始字符串字面值中使用一些额外的 <em>转义</em> ，
转义以 <code>U+005C</code> (<code>\</code>) 开始，并以下列形式延续:</p>
<ul>
<li><em>7 位编码转义</em> 以 <code>U+0078</code> (<code>x</code>) 开始，后面正好有两个数值不超过 <code>0x7F</code> 的 <em>十六进制数字</em> 。
它表示 ASCII 字符，其值等于提供的十六进制值。不允许更高的值，因为无法明确是指 Unicode 编码还是字节值。</li>
<li><em>24位编码转义</em> 以 <code>U+0075</code> (<code>u</code>) 开始，后面是最多六个 <em>十六位数字</em> ，由大括号 <code>U+007B</code> (<code>{</code>) 和 <code>U+007D</code> (<code>}</code>) 包围。它表示 Unicode 编码，等于所提供的十六进制值。</li>
<li><em>空白转义</em> 是字符 <code>U+006E</code> (<code>n</code>) 、 <code>U+0072</code> (<code>r</code>) 或 <code>U+0074</code> (<code>t</code>) 之一，分别表示 Unicode 值 <code>U+000A</code> (LF) 、 <code>U+000D</code> (CR) 或 <code>U+0009</code> (HT) 。</li>
<li><em>null 转义</em> 是字符 <code>U+0030</code> (<code>0</code>) ，表示 Unicode 值 <code>U+0000</code> (NUL) 。</li>
<li><em>反斜线转义</em> 是字符 <code>U+005C</code> (<code>\</code>) ，必须经过转义以表示自身。</li>
</ul>
<h4 id="原始字符串字面值"><a class="header" href="#原始字符串字面值">原始字符串字面值</a></h4>
<blockquote>
<p><strong><sup>词法</sup></strong><br />
原始字符串字面值 :<br />
   <code>r</code> 原始字符串上下文 后缀<sup>?</sup></p>
<p>原始字符串上下文 :<br />
      <code>&quot;</code> ( ~ <em>孤立CR</em> )<sup>* (非贪婪)</sup> <code>&quot;</code><br />
   | <code>#</code> 原始字符串上下文 <code>#</code></p>
</blockquote>
<p>原始字符串字面值不处理任何转义。
以字符 <code>U+0072</code> (<code>r</code>) 开始，后面是少于 256 个的 <code>U+0023</code> (<code>#</code>) 和 <code>U+0022</code> (双引号) 字符。
<em>原始字符串主体</em> 可以包含任何 Unicode 字符序列，并且只能由另一个 <code>U+0022</code> (双引号) 字符结束，后面是 <code>U+0022</code> (双引号) 字符与开头相同数量的 <code>U+0023</code> (<code>#</code>) 字符。</p>
<p>原始字符串主体中包含的所有 Unicode 字符都表示自己。
字符 <code>U+0022</code> (双引号)  或 <code>U+005C</code> (<code>\</code>) 不具有任何特殊含义 (除非后面有至少相同数量的 <code>U+0023</code> (<code>#</code>) 字符用于表达原始字符串字面值)。</p>
<p>字符串字面值示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&quot;foo&quot;; r&quot;foo&quot;;                     // foo
&quot;\&quot;foo\&quot;&quot;; r#&quot;&quot;foo&quot;&quot;#;             // &quot;foo&quot;

&quot;foo #\&quot;# bar&quot;;
r##&quot;foo #&quot;# bar&quot;##;                // foo #&quot;# bar

&quot;\x52&quot;; &quot;R&quot;; r&quot;R&quot;;                 // R
&quot;\\x52&quot;; r&quot;\x52&quot;;                  // \x52
<span class="boring">}</span></code></pre></pre>
<h3 id="byte-和-byte-字符串字面值"><a class="header" href="#byte-和-byte-字符串字面值">Byte 和 byte 字符串字面值</a></h3>
<h4 id="byte-字面值"><a class="header" href="#byte-字面值">Byte 字面值</a></h4>
<blockquote>
<p><strong><sup>词法</sup></strong><br />
字节字面值 :<br />
   <code>b'</code> ( ASCII字符 | 字节转义 )  <code>'</code> 后缀<sup>?</sup></p>
<p>ASCII字符 :<br />
   <em>任意ASCII (如 0x00 至 0x7F), 不包括</em> <code>'</code>, <code>\</code>, \n, \r 或 \t</p>
<p>字节转义 :<br />
      <code>\x</code> 十六进制数 十六进制数<br />
   | <code>\n</code> | <code>\r</code> | <code>\t</code> | <code>\\</code> | <code>\0</code> | <code>\'</code> | <code>\&quot;</code></p>
</blockquote>
<p><em>字节字面值</em> 表示是一个 ASCII 字符 (在 <code>U+0000</code> 到 <code>U+007F</code> 范围内) 或单一的 <em>转义</em> ，前面是字符 <code>U+0062</code> (<code>b</code>) 和 <code>U+0027</code> (单引号)，后面是字符 <code>U+0027</code> 。
如果字面值有 <code>U+0027</code> 字符，必须由前置 <code>U+005C</code> (<code>\</code>) 字符来 <em>转义</em> 。其相当于一个 <code>u8</code> 无符号 8 位整数 <em>数字字面值</em> 。</p>
<h4 id="字节字符串字面值"><a class="header" href="#字节字符串字面值">字节字符串字面值</a></h4>
<blockquote>
<p><strong><sup>词法</sup></strong><br />
字节字符串字面值 :<br />
   <code>b&quot;</code> ( ASCII字符串 | 字节转义 | 字符串继续 )<sup>*</sup> <code>&quot;</code> 后缀<sup>?</sup></p>
<p>ASCII字符串 :<br />
   <em>任意ASCII (如 0x00 至 0x7F), 不包括</em> <code>&quot;</code>, <code>\</code> <em>和 孤立CR</em></p>
</blockquote>
<p>非原始的 <em>字节字符串字面值</em> 是一串 ASCII 字符和 <em>转义</em> 。
前面是字符 <code>U+0062</code> (<code>b</code>) 和 <code>U+0022</code> (双引号) ，后面是字符 <code>U+0022</code> 。
如果字面值有 <code>U+0022</code> 字符，必须前置 <code>U+005C</code> (<code>\</code>) 字符来转义。
或者，字节字符串字面值是 <em>原始字节字符串字面值</em> ，定义如下。
长度为 <code>n</code> 的字节字符串字面值的类型是 <code>&amp;'static [u8; n]</code> 。</p>
<p>一些额外的 <em>转义</em> 在字节或非原始字节的字符串字面值中都是可用的。
转义以 <code>U+005C</code> (<code>\</code>) 开始，并以下列形式延续。</p>
<ul>
<li><em>字节转义</em> 以 <code>U+0078</code> (<code>x</code>) 开始，后面正好有两个 <em>十六进制数字</em> 。表示相当于所提供的十六进制值的字节。</li>
<li><em>空白转义</em> 是字符 <code>U+006E</code> (<code>n</code>) 、<code>U+0072</code> (<code>r</code>) ，或 <code>U+0074</code> (<code>t</code>) ，分别表示字节值 <code>0x0A</code> (ASCII LF) 、 <code>0x0D</code> (ASCII CR) 或 <code>0x09</code> (ASCII HT) 。</li>
<li><em>null 转义</em> 是字符 <code>U+0030</code> (<code>0</code>) ，表示字节值 <code>0x00</code> (ASCII NUL) 。</li>
<li><em>反斜线转义</em> 是字符 <code>U+005C</code> (<code>\</code>)  ，必须转义以表示其 ASCII 编码 <code>0x5C</code> 。</li>
</ul>
<h4 id="原始字节字符串字面值"><a class="header" href="#原始字节字符串字面值">原始字节字符串字面值</a></h4>
<blockquote>
<p><strong><sup>词法</sup></strong><br />
原始字节字符串字面值 :<br />
   <code>br</code> 原始字节字符串上下文 后缀<sup>?</sup></p>
<p>原始字节字符串上下文 :<br />
      <code>&quot;</code> ASCII<sup>* (非贪婪)</sup> <code>&quot;</code><br />
   | <code>#</code> 原始字节字符串上下文 <code>#</code></p>
<p>ASCII :<br />
   <em>任意ASCII (如 0x00 至 0x7F)</em></p>
</blockquote>
<p>原始字节字符串字面值不处理任何转义。
它们以字符 <code>U+0062</code> (<code>b</code>) 开始，然后是 <code>U+0072</code> (<code>r</code>) ，后面是少于 256 的字符 <code>U+0023</code> (<code>#</code>)，以及一个 <code>U+0022</code> (双引号) 字符。
<em>原始字符串主体</em> 可以包含任何 ASCII 字符序列，并且只能由另一个 <code>U+0022</code> (双引号) 字符终止，后面是 <code>U+0022</code> (双引号) 字符与开头数量相同 <code>U+0023</code> (<code>#</code>) 字符。
原始的字节字符串字面值不能包含任何非 ASCII 字节。</p>
<p>原始字符串主体中包含的所有字符表示其 ASCII 编码。
字符 <code>U+0022</code> (双引号) 或 <code>U+005C</code> (<code>\</code>) 不具有任何特殊含义 (除非后面有至少相同数量的 <code>U+0023</code> (<code>#</code>) 字符表达原始字符串字面值）。</p>
<p>字符串字面值示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>b&quot;foo&quot;; br&quot;foo&quot;;                     // foo
b&quot;\&quot;foo\&quot;&quot;; br#&quot;&quot;foo&quot;&quot;#;             // &quot;foo&quot;

b&quot;foo #\&quot;# bar&quot;;
br##&quot;foo #&quot;# bar&quot;##;                 // foo #&quot;# bar

b&quot;\x52&quot;; b&quot;R&quot;; br&quot;R&quot;;                // R
b&quot;\\x52&quot;; br&quot;\x52&quot;;                  // \x52
<span class="boring">}</span></code></pre></pre>
<h3 id="数字字面值"><a class="header" href="#数字字面值">数字字面值</a></h3>
<p><em>数字字面值</em> 是一个 <em>整数字面值</em> 或 <em>浮点字面值</em> 。语法上混合识别这两种字面值。</p>
<h4 id="整数字面值"><a class="header" href="#整数字面值">整数字面值</a></h4>
<blockquote>
<p><strong><sup>词法</sup></strong><br />
整数字面值 :<br />
   ( 十进制字面值 | 二进制字面值 | 八进制字面值 | 十六进制字面值 )
SUFFIX_NO_E<sup>?</sup></p>
<p>十进制字面值 :<br />
   十进制数 (十进制数|<code>_</code>)<sup>*</sup></p>
<p>二进制字面值 :<br />
   <code>0b</code> (二进制数|<code>_</code>)<sup>*</sup> 二进制数 (二进制数|<code>_</code>)<sup>*</sup></p>
<p>八进制字面值 :<br />
   <code>0o</code> (八进制数|<code>_</code>)<sup>*</sup> 八进制数 (八进制数|<code>_</code>)<sup>*</sup></p>
<p>十六进制字面值 :<br />
   <code>0x</code> (十六进制数|<code>_</code>)<sup>*</sup> 十六进制数 (十六进制数|<code>_</code>)<sup>*</sup></p>
<p>十进制数 : [<code>0</code>-<code>1</code>]</p>
<p>二进制数 : [<code>0</code>-<code>7</code>]</p>
<p>八进制数 : [<code>0</code>-<code>9</code>]</p>
<p>十六进制数 : [<code>0</code>-<code>9</code> <code>a</code>-<code>f</code> <code>A</code>-<code>F</code>]</p>
</blockquote>
<p><em>整数字面值</em> 的四种形式:</p>
<ul>
<li><em>十进制字面值</em> 以一个 <em>十进制数字</em> 开始，然后以任何 <em>十进制数字</em> 和 <em>下划线</em> 的混合。</li>
<li><em>十六进制字面值</em> 以字符序列 <code>U+0030</code> <code>U+0078</code> (<code>0x</code>) 开始，然后以任何十六进制数字和下划线混合(至少有一个数字)。</li>
<li><em>八进制字面值</em> 以字符序列 <code>U+0030</code> <code>U+006F</code> (<code>0o</code>) 开始，然后以任何八进制数字和下划线混合(至少有一个数字)。</li>
<li><em>二进制字面值</em> 以字符序列 <code>U+0030</code> <code>U+0062</code> (<code>0b</code>) 开始，然后以任何二进制数字和下划线混合(至少有一个数字)。</li>
</ul>
<p>像其他字面值一样，整数字面值可以在后面加一个后缀(紧随而没有空格)，如上所述。
后缀不能以 <code>e</code> 或 <code>E</code> 开头，因为这将被解释为浮点字面值的指数。
关于这些后缀的实现，见 <a href="expressions/literal-expr.html">字面值表达式</a> 。</p>
<p>字面值表达式允许的整数字面值的示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(overflowing_literals)]
</span>123;
123i32;
123u32;
123_u32;

0xff;
0xff_u8;
0x01_f32; // 整数 7986, 非浮点 1.0
0x01_e3;  // 整数 483, 非浮点 1000.0

0o70;
0o70_i16;

0b1111_1111_1001_0000;
0b1111_1111_1001_0000i64;
0b________1;

0usize;

// 这对于其类型来说值太大，但允许在字面值表达式。
128_i8;
256_u8;

// 这是整数字面值，允许在浮点字面值表达式。
5f32;
<span class="boring">}</span></code></pre></pre>
<p>注意，比如 <code>-1i8</code> 将被解析为两个标记: <code>-</code> 和 <code>1i8</code>。</p>
<p>字面值表达式不允许的整数字面值示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(FALSE)] {
</span>0invalidSuffix;
123AFB43;
0b010a;
0xAB_CD_EF_GH;
0b1111_f32;
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h4 id="元组索引"><a class="header" href="#元组索引">元组索引</a></h4>
<blockquote>
<p><strong><sup>词法</sup></strong><br />
元组索引: <br />
   整数字面值</p>
</blockquote>
<p>元组索引用于指代 <a href="types/tuple.html">元组</a> 、<a href="items/structs.html">元组结构体</a> 和 <a href="items/enumerations.html">元组变体</a> 的字段。</p>
<p>元组索引直接与字面值 Token 进行对比。元组索引从 <code>0</code> 开始，每一个连续的索引其值增加 <code>1</code> ，为一个十进制值。
因此，只有十进制的值才能匹配，其值不能有任何额外的 <code>0</code> 前缀字符。</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let example = (&quot;dog&quot;, &quot;cat&quot;, &quot;horse&quot;);
let dog = example.0;
let cat = example.1;
// 下面的例子是无效的。
let cat = example.01;  // ERROR 字段名不能为 `01`
let horse = example.0b10;  // ERROR 字段名不能为 `0b10`
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>注意</strong>: 元组索引可能包括某些后缀，但这并不意味着是有效的，在未来的版本中可能会删除。
更多内容见 <a href="https://github.com/rust-lang/rust/issues/60210">https://github.com/rust-lang/rust/issues/60210</a> 。</p>
</blockquote>
<h4 id="浮点字面值"><a class="header" href="#浮点字面值">浮点字面值</a></h4>
<blockquote>
<p><strong><sup>词法</sup></strong><br />
浮点字面值 :<br />
      十进制数 <code>.</code>
<em>(不是紧跟着 <code>.</code> , <code>_</code> 或 XID_起始 字符)</em><br />
   | 十进制字面值 <code>.</code> 十进制字面值 后缀非E<sup>?</sup><br />
   | 十进制字面值 (<code>.</code> 十进制字面值)<sup>?</sup> 浮点指数 后缀<sup>?</sup></p>
<p>浮点指数 :<br />
   (<code>e</code>|<code>E</code>) (<code>+</code>|<code>-</code>)<sup>?</sup>
(十进制数|<code>_</code>)<sup>*</sup> 十进制数 (十进制数|<code>_</code>)<sup>*</sup></p>
</blockquote>
<p><em>浮点字面值</em> 两种形式:</p>
<ul>
<li><em>十进制字面值</em> 后面一个句号字符 <code>U+002E</code> (<code>.</code>)，随后是可选的另一个十进制的字面值，并有一个可选的 <em>指数</em> 。</li>
<li>单一的 <em>十进制字面值</em> 后随一个 <em>指数</em> 。</li>
</ul>
<p>和整数字面值一样，浮点字面值后面可以有后缀，只要前缀部分不以 <code>U+002E</code> (<code>.</code>) 结尾。
如果字面值内容不包含指数，后缀不能以 <code>e</code> 或 <code>E</code> 开头。
关于这些后缀的实现，请参见 <a href="expressions/literal-expr.html">字面值表达式</a>。</p>
<p>字面值表达式允许的的浮点字面值的示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>123.0f64;
0.1f64;
0.1f32;
12E+99_f64;
let x: f64 = 2.;
<span class="boring">}</span></code></pre></pre>
<p>最后一个例子是不同的，因为不能对以句点结尾的浮点字面值使用后缀语法。
<code>2.f64</code> 将试图在 <code>2</code> 上调用一个名为 <code>f64</code> 的方法。</p>
<p>注意，比如 <code>-1.0</code> 将被解析为两个符号: <code>-</code> 和 <code>1.0</code> 。</p>
<p>字面值表达式不允许的浮点字面值示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(FALSE)] {
</span>2.0f80;
2e5f80;
2e5e6;
2.0e5e6;
1.3e10u64;
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h4 id="类似于数字字面值的保留形式"><a class="header" href="#类似于数字字面值的保留形式">类似于数字字面值的保留形式</a></h4>
<blockquote>
<p><strong><sup>词法</sup></strong><br />
保留数 :<br />
      二进制字面值 [<code>2</code>-<code>9</code>&amp;零空白;]<br />
   | 八进制字面值 [<code>8</code>-<code>9</code>&amp;零空白;]<br />
   | ( 二进制字面值 | 八进制字面值 | 十六进制字面值 ) <code>.</code> <br />
         <em>(不是紧随着 <code>.</code>, <code>_</code> 或 XID_起始 字符)</em><br />
   | ( 二进制字面值 | 八进制字面值 ) (<code>e</code>|<code>E</code>)<br />
   | <code>0b</code> <code>_</code><sup>*</sup> <em>输入结束或非二进制数</em><br />
   | <code>0o</code> <code>_</code><sup>*</sup> <em>输入结束或非八进制数</em><br />
   | <code>0x</code> <code>_</code><sup>*</sup> <em>输入结束或非十六进制数</em><br />
   | 十进制字面值 ( . 十进制字面值)<sup>?</sup> (<code>e</code>|<code>E</code>) (<code>+</code>|<code>-</code>)<sup>?</sup> <em>输入结束或非十进制数</em></p>
</blockquote>
<p>以下类似于数字字面值的词法是 <em>保留形式</em> 。
由于这些形式可能引起歧义，编译器会拒绝它们，而不会解释为独立 Token 。</p>
<ul>
<li>
<p>一个无后缀的二进制或八进制字面值，中间没有空白，随后是一个超出其小数范围的十进制数字。</p>
</li>
<li>
<p>一个无后缀的二进制、八进制或十六进制字面值，中间没有空白，随后是一个点号(对点号后面的限制与浮点字面值相同)。</p>
</li>
<li>
<p>一个无后缀的二进制或八进制字面值，中间没有空白，随后是字符 <code>e</code> 或 <code>E</code> 组成。</p>
</li>
<li>
<p>以一个小数点前缀开始的输入，但不是一个有效的二进制、八进制或十六进制字面值(因为它不包含数字)。</p>
</li>
<li>
<p>具有浮点字面值形式的输入，指数中没有数字。</p>
</li>
</ul>
<p>保留形式的示例:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>0b0102;  // 这不是 `0b010` 随后有 `2`
0o1279;  // 这不是 `0o127` 随后有 `9`
0x80.0;  // 这不是 `0x80` 随后有 `.` 和 `0`
0b101e;  // 这不是有后缀的字面值或 `0b101` 随后有 `e`
0b;      // 这不是一个整数字面值或 `0`随后有 `b`
0b_;     // 这不是一个整数字面值或 `0` 随后有 `b_`
2e;      // 这不是一个浮点字面值或 `2` 随后有 `e`
2.0e;    // 这不是一个浮点字面值或 `2.0` 随后有 `e`
2em;     // 这不是有后缀的字面值或 `2` 随后有 `em`
2.0em;   // 这不是有后缀的字面值或 `2.0` 随后有 `em`
<span class="boring">}</span></code></pre></pre>
<h2 id="生命周期和循环标签"><a class="header" href="#生命周期和循环标签">生命周期和循环标签</a></h2>
<blockquote>
<p><strong><sup>词法</sup></strong><br />
生命周期TOKEN :<br />
      <code>'</code> <a href="identifiers.html">标识符或关键字</a><br />
   | <code>'_</code></p>
<p>生命周期或标签 :<br />
      <code>'</code> <a href="identifiers.html">非关键字标识符</a></p>
</blockquote>
<p>生命周期参数和 <a href="expressions/loop-expr.html">循环标签</a> 使用 '生命周期或标签' 标记。词法分析器接受任何 '生命周期TOKEN' ，比如，可以在宏中使用。</p>
<h2 id="标点符号"><a class="header" href="#标点符号">标点符号</a></h2>
<p>为了完整，这里列出了标点符号 Token 。它们各自的用途和含义定义在链接的页面中。</p>
<div class="table-wrapper"><table><thead><tr><th>符号</th><th>名称</th><th>用法</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>加号</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">加法</a>，[trait约束][trait-bounds]，<a href="macros-by-example.html">宏重复匹配器</a></td></tr>
<tr><td><code>-</code></td><td>减号</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">减法</a>，<a href="expressions/operator-expr.html#negation-operators">否定</a></td></tr>
<tr><td><code>*</code></td><td>星号</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">乘法</a>，<a href="expressions/operator-expr.html#the-dereference-operator">解引用</a>，[原始指针][raw-pointers]，<a href="macros-by-example.html">宏重复匹配器</a>，[用作通配符][wildcards]</td></tr>
<tr><td><code>/</code></td><td>斜线</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">除法</a></td></tr>
<tr><td><code>%</code></td><td>百分号</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">取余</a></td></tr>
<tr><td><code>^</code></td><td>插入符号</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">位运算异或和逻辑运算异或</a></td></tr>
<tr><td><code>!</code></td><td>感叹号</td><td><a href="expressions/operator-expr.html#negation-operators">位运算非和逻辑运算非</a>，<a href="macros-by-example.html">宏调用</a>，<a href="attributes.html">内部属性</a>，[永不类型][never-type]，[否定的impl][negative-impls]</td></tr>
<tr><td><code>&amp;</code></td><td>与符号</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">位运算与和逻辑运算与</a>，<a href="expressions/operator-expr.html#borrow-operators">借用</a>，<a href="types/pointer.html">引用</a>，[引用模式][reference-patterns]</td></tr>
<tr><td><code>|</code></td><td>或符号</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">位运算或和逻辑运算或</a>，<a href="expressions/closure-expr.html">闭包</a>，<a href="expressions/match-expr.html">模式匹配</a>中的模式，<a href="expressions/if-expr.html#if-let-expressions">if let</a>和<a href="expressions/loop-expr.html#predicate-pattern-loops">while let</a>中的模式</td></tr>
<tr><td><code>&amp;&amp;</code></td><td>与运算符</td><td><a href="expressions/operator-expr.html#lazy-boolean-operators">惰性与运算</a>，<a href="expressions/operator-expr.html#borrow-operators">借用</a>，<a href="types/pointer.html">引用</a>，[引用模式][reference-patterns]</td></tr>
<tr><td><code>||</code></td><td>或运算符</td><td><a href="expressions/operator-expr.html#lazy-boolean-operators">惰性或运算</a>，<a href="expressions/closure-expr.html">闭包</a></td></tr>
<tr><td><code>&lt;&lt;</code></td><td>左移运算符</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">左移</a>，<a href="items/generics.html">嵌套泛型</a></td></tr>
<tr><td><code>&gt;&gt;</code></td><td>右移运算符</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">右移</a>，<a href="items/generics.html">嵌套泛型</a></td></tr>
<tr><td><code>+=</code></td><td>加等于运算符</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">加法赋值</a></td></tr>
<tr><td><code>-=</code></td><td>减等于运算符</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">减法赋值</a></td></tr>
<tr><td><code>*=</code></td><td>乘等于运算符</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">乘法赋值</a></td></tr>
<tr><td><code>/=</code></td><td>除等于运算符</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">除法赋值</a></td></tr>
<tr><td><code>%=</code></td><td>取余等于运算符</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">取余赋值</a></td></tr>
<tr><td><code>^=</code></td><td>异或等于运算符</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">位异或赋值</a></td></tr>
<tr><td><code>&amp;=</code></td><td>与等于运算符</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">位与赋值</a></td></tr>
<tr><td><code>|=</code></td><td>或等于运算符</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">位或赋值</a></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td>左移等于运算符</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">左移赋值</a></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td>右移等于运算符</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">右移赋值</a>, <a href="items/generics.html">嵌套泛型</a></td></tr>
<tr><td><code>=</code></td><td>等号</td><td><a href="expressions/operator-expr.html#assignment-expressions">赋值</a>，<a href="attributes.html">属性</a>，各种类型定义</td></tr>
<tr><td><code>==</code></td><td>双等号</td><td>[等于][比较]</td></tr>
<tr><td><code>!=</code></td><td>不等于号</td><td>[不等于][比较]</td></tr>
<tr><td><code>&gt;</code></td><td>大于号</td><td>[大于][比较]，<a href="items/generics.html">泛型</a>，<a href="paths.html">路径</a></td></tr>
<tr><td><code>&lt;</code></td><td>小于号</td><td>[小于][比较]，<a href="items/generics.html">泛型</a>，<a href="paths.html">路径</a></td></tr>
<tr><td><code>&gt;=</code></td><td>大于等于号</td><td>[大于等于][比较]，<a href="items/generics.html">泛型</a></td></tr>
<tr><td><code>&lt;=</code></td><td>小于等于号</td><td>[小于等于][比较]</td></tr>
<tr><td><code>@</code></td><td>At</td><td><a href="patterns.html#identifier-patterns">子模式绑定</a></td></tr>
<tr><td><code>_</code></td><td>下划线</td><td><a href="patterns.html#wildcard-pattern">通配符模式</a>，<a href="types/inferred.html">推断类型</a>，<a href="items/constant-items.html">常量</a>、<a href="items/extern-crates.html">extern crates</a>、[use 声明]和<a href="expressions/underscore-expr.html">解构赋值</a>中的未命名条目</td></tr>
<tr><td><code>.</code></td><td>点号</td><td><a href="expressions/field-expr.html">字段访问</a>，<a href="expressions/tuple-expr.html#tuple-indexing-expressions">元组索引</a></td></tr>
<tr><td><code>..</code></td><td>双点号</td><td><a href="expressions/range-expr.html">区间</a>，<a href="expressions/struct-expr.html">结构体表达式</a>，<a href="patterns.html">模式</a>，<a href="patterns.html#range-patterns">区间模式</a><a href="patterns.html#range-patterns">rangepat</a></td></tr>
<tr><td><code>...</code></td><td>三点号</td><td><a href="items/external-blocks.html">可变参数函数</a>，<a href="patterns.html#range-patterns">区间模式</a></td></tr>
<tr><td><code>..=</code></td><td>双点等号</td><td><a href="expressions/range-expr.html">闭区间</a>，<a href="patterns.html#range-patterns">区间模式</a></td></tr>
<tr><td><code>,</code></td><td>逗号</td><td>各种分隔符</td></tr>
<tr><td><code>;</code></td><td>分号</td><td>用于各种条目和语句的终止符，<a href="types/array.html">数组类型</a></td></tr>
<tr><td><code>:</code></td><td>冒号</td><td>各种分隔符</td></tr>
<tr><td><code>::</code></td><td>路径分隔符</td><td><a href="paths.html">路径分隔符</a></td></tr>
<tr><td><code>-&gt;</code></td><td>箭头符</td><td><a href="items/functions.html">函数返回类型</a>，<a href="expressions/closure-expr.html">闭包返回类型</a>，<a href="types/function-pointer.html">函数指针类型</a></td></tr>
<tr><td><code>=&gt;</code></td><td>双箭头符</td><td><a href="expressions/match-expr.html">匹配分支</a>，<a href="macros-by-example.html">宏</a></td></tr>
<tr><td><code>#</code></td><td>井号</td><td><a href="attributes.html">属性</a></td></tr>
<tr><td><code>$</code></td><td>美元符</td><td><a href="macros-by-example.html">宏</a></td></tr>
<tr><td><code>?</code></td><td>问号</td><td><a href="expressions/operator-expr.html#the-question-mark-operator">问号运算符</a>，<a href="trait-bounds.html#sized">大小可变</a>，<a href="macros-by-example.html">宏重复匹配器</a></td></tr>
<tr><td><code>~</code></td><td>波浪符</td><td>Rust 1.0 之前就已经不再使用了，但其标记仍可使用</td></tr>
</tbody></table>
</div>
<h2 id="定界符号"><a class="header" href="#定界符号">定界符号</a></h2>
<p>括号标点符号用在语法的各部分。一个左括号必须总是与一个右括号相配对。括号和其中的 Token 在 <a href="macros-by-example.html">宏</a> 中被称为 &quot;token 树&quot; 。三种类型的括号是：</p>
<div class="table-wrapper"><table><thead><tr><th>括号</th><th>类型</th></tr></thead><tbody>
<tr><td><code>{</code> <code>}</code></td><td>大括号</td></tr>
<tr><td><code>[</code> <code>]</code></td><td>方括号</td></tr>
<tr><td><code>(</code> <code>)</code></td><td>圆括号</td></tr>
</tbody></table>
</div>
<h2 id="保留前缀"><a class="header" href="#保留前缀">保留前缀</a></h2>
<blockquote>
<p><strong><sup>词法 2021+</sup></strong><br />
<code>保留TOKEN双引号</code>: (标识符或关键字<sub><em>不包括 <code>b</code> 或 <code>r</code> 或 <code>br</code></em></sub> | <code>_</code> ) <code>&quot;</code><br />
<code>保留TOKEN单引号</code>: (标识符或关键字<sub>不包括 <code>b</code>_</sub> | <code>_</code> ) <code>'</code><br />
<code>保留TOKEN井号</code>: (标识符或关键字<sub><em>不包括 <code>r</code> 或 <code>br</code></em></sub> | <code>_</code> ) <code>#</code></p>
</blockquote>
<p>一些被称为 <em>保留前缀</em> 的词法形式被保留下来，供将来使用。</p>
<p>如果源码输入在词法上被解析为非原始标识符(或关键字或 <code>_</code> )，紧随其后的是 <code>#</code> 、 <code>'</code> 或 <code>&quot;</code> 字符(没有中间的空白) ，刚将其标识为保留前缀。</p>
<p>请注意，原始标识符、原始字符串字面值和原始字节字符串字面值可能包含 <code>#</code> 字符，但不会被解释为包含保留前缀。</p>
<p>同样，在原始字符串字面值、字节字面值、字节字符串字面值和原始字节字符串字面值中使用的 <code>r</code> 、 <code>b</code> 和 <code>br</code> 前缀也不被解释为保留前缀。</p>
<blockquote>
<p><strong>版次差异</strong>: 从 2021 版开始，保留前缀会被词法分析器报告为错误 (尤其不能传递给宏)。</p>
<p>在 2021 版本之前，保留前缀被词法分析器接受，并被解释为多个 Token (比如，Token 为标识符或关键词，后面是 <code>#</code> token)。</p>
<p>所有版次允许的示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! lexes {($($_:tt)*) =&gt; {}}
lexes!{a #foo}
lexes!{continue 'foo}
lexes!{match &quot;...&quot; {}}
lexes!{r#let#foo}         // 三个 token: r#let # foo
<span class="boring">}</span></code></pre></pre>
<p>示例在 2021 版本之前是允许的，之后不允许:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! lexes {($($_:tt)*) =&gt; {}}
lexes!{a#foo}
lexes!{continue'foo}
lexes!{match&quot;...&quot; {}}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="宏"><a class="header" href="#宏">宏</a></h1>
<p>Rust 的功能和语法可以通过自定义宏来扩展。
这些宏被赋予名称，并通过一致的语法调用：<code>some_extension!(...)</code>。</p>
<p>有两种定义新宏的方式：</p>
<ul>
<li><a href="macros-by-example.html">实例宏</a> 以更高级、声明式的方式定义新的语法。</li>
<li><a href="procedural-macros.html">过程宏</a> 通过在输入 Token 上操作的函数，定义函数式宏、自定义衍生和自定义属性。</li>
</ul>
<h2 id="宏调用"><a class="header" href="#宏调用">宏调用</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>宏调用</em> :<br />
   [<em>简单路径</em>] <code>!</code> <em>定界Token树</em></p>
<p><em>定界Token树</em> :<br />
       <code>(</code> <em>Token树</em><sup>*</sup> <code>)</code><br />
   | <code>[</code> <em>Token树</em><sup>*</sup> <code>]</code><br />
   | <code>{</code> <em>Token树</em><sup>*</sup> <code>}</code></p>
<p><em>Token树</em> :<br />
   <a href="tokens.html"><em>Token</em></a><sub><em>不包括 <a href="tokens.html#delimiters">delimiters</a></em></sub> | <em>定界Token树</em></p>
<p><em>宏调用语句</em> :<br />
      <a href="paths.html#simple-paths"><em>SimplePath</em></a> <code>!</code> <code>(</code> <em>Token树</em><sup>*</sup> <code>)</code> <code>;</code><br />
   | <a href="paths.html#simple-paths"><em>SimplePath</em></a> <code>!</code> <code>[</code> <em>Token树</em><sup>*</sup> <code>]</code> <code>;</code><br />
   | <a href="paths.html#simple-paths"><em>SimplePath</em></a> <code>!</code> <code>{</code> <em>Token树</em><sup>*</sup> <code>}</code></p>
</blockquote>
<p>在编译时展开宏并用宏的结果替换调用时，发生宏调用。宏可以在以下情况下被调用：</p>
<ul>
<li><a href="expressions.html">表达式</a> 和 <a href="statements.html">语句</a> </li>
<li><a href="patterns.html">模式</a></li>
<li><a href="types.html">类型</a></li>
<li><a href="items.html">条目</a> 包括 <a href="items/associated-items.html">关联条目</a></li>
<li><a href="macros-by-example.html"><code>macro_rules</code></a> 转换器</li>
<li><a href="items/external-blocks.html">外部块</a> </li>
</ul>
<p>当它被用作条目或语句时，使用 <code>_宏调用语句_</code> 形式，当不使用花括号时需要在末尾加上分号。
在宏调用或 <a href="macros-by-example.html"><code>macro_rules</code></a> 定义之前，不允许出现 <a href="visibility-and-privacy.html">可见性限定符</a> 。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 用作表达式
let x = vec![1,2,3];

// 用作语句
println!(&quot;Hello!&quot;);

// 用在模式
macro_rules! pat {
    ($i:ident) =&gt; (Some($i))
}

if let pat!(x) = Some(1) {
    assert_eq!(x, 1);
}

// 用在类型
macro_rules! Tuple {
    { $A:ty, $B:ty } =&gt; { ($A, $B) };
}

type N2 = Tuple!(i32, i32);

// 用在条目
<span class="boring">use std::cell::RefCell;
</span>thread_local!(static FOO: RefCell&lt;u32&gt; = RefCell::new(1));

// 用在关联条目
macro_rules! const_maker {
    ($t:ty, $v:tt) =&gt; { const CONST: $t = $v; };
}
trait T {
    const_maker!{i32, 7}
}

// 宏中的宏调用。
macro_rules! example {
    () =&gt; { println!(&quot;Macro call in a macro!&quot;) };
}
// 外部宏 `example` 被展开，然后内部宏 `println` 被展开。
example!();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实例宏"><a class="header" href="#实例宏">实例宏</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>宏规则定义</em> :<br />
   <code>macro_rules</code> <code>!</code> [标识符] <em>实例宏规则定义</em></p>
<p><em>实例宏规则定义</em> :<br />
      <code>(</code> <em>实例宏规则组</em> <code>)</code> <code>;</code><br />
   | <code>[</code> <em>实例宏规则组</em> <code>]</code> <code>;</code><br />
   | <code>{</code> <em>实例宏规则组</em> <code>}</code></p>
<p><em>实例宏规则组</em> :<br />
   <em>实例宏规则</em> ( <code>;</code> <em>实例宏规则</em> )<sup>*</sup> <code>;</code><sup>?</sup></p>
<p><em>实例宏规则</em> :<br />
   <em>宏匹配器</em> <code>=&gt;</code> <em>宏转录器</em></p>
<p><em>宏匹配器</em> :<br />
      <code>(</code> <em>宏匹配</em><sup>*</sup> <code>)</code><br />
   | <code>[</code> <em>宏匹配</em><sup>*</sup> <code>]</code><br />
   | <code>{</code> <em>宏匹配</em><sup>*</sup> <code>}</code></p>
<p><em>宏匹配</em> :<br />
      <a href="tokens.html"><em>Token</em></a><sub><em>除了 <code>$</code> 和 <a href="tokens.html#delimiters">分隔符</a> 之外的任意 token</em></sub><br />
   | <em>宏匹配器</em><br />
   | <code>$</code> ( <a href="identifiers.html">标识符或关键字</a> <sub><em>除了 <code>crate</code> 之外的任意标识符或关键字</em></sub> | <a href="identifiers.html">原始标识符</a> | <code>_</code> ) <code>:</code> <em>宏片段规格</em><br />
   | <code>$</code> <code>(</code> <em>宏匹配</em><sup>+</sup> <code>)</code> <em>宏表示分割</em><sup>?</sup> <em>宏表示操作符</em></p>
<p><em>宏片段规格</em> :<br />
      <code>block</code> | <code>expr</code> | <code>ident</code> | <code>item</code> | <code>lifetime</code> | <code>literal</code><br />
   | <code>meta</code> | <code>pat</code> | <code>pat_param</code> | <code>path</code> | <code>stmt</code> | <code>tt</code> | <code>ty</code> | <code>vis</code></p>
<p><em>宏表示分割</em> :<br />
   <a href="tokens.html"><em>Token</em></a><sub><em>除了 <a href="tokens.html#delimiters">分隔符</a> 和 宏表示操作符</em> 之外的任意 token_</sub></p>
<p><em>宏表示操作符</em> :<br />
   <code>*</code> | <code>+</code> | <code>?</code></p>
<p><em>宏转录器</em> :<br />
   <a href="macros.html"><em>定界Token树</em></a></p>
</blockquote>
<p><code>macro_rules</code> 允许用户以声明的方式定义语法扩展。
我们把这样的扩展称为 &quot;宏&quot; 或者 &quot;实例宏&quot; 。</p>
<p>每个宏定义都有一个名称和一个或多个 <em>规则</em> 。
每个规则都有两个部分：一个 <em>匹配器</em> ，用于描述它匹配的语法，以及一个 <em>转录器</em> ，用于描述成功匹配调用后将替换的语法。
匹配器和转录器都必须被包含在分隔符中。
宏可以扩展为表达式、语句、条目 (包括 trait 、实现和外部条目) 、类型或模式。</p>
<h2 id="转录"><a class="header" href="#转录">转录</a></h2>
<p>当宏被调用时，宏展开器通过名称查找宏调用，并依次尝试每个宏规则。
它会转录第一个成功的匹配；如果这导致错误，则不会尝试后续匹配。
在匹配时，不会进行前瞻；如果编译器不能逐个 Token 地明确定义如何解析宏调用，则会出错。
在下面的示例中，编译器不会向前查看标识符，不会查看下一个 Token 是否为 <code>)</code> ，尽管这能够更明确地解析调用:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! ambiguity {
    ($($i:ident)* $j:ident) =&gt; { };
}

ambiguity!(error); // Error: 局部歧义
<span class="boring">}</span></code></pre></pre>
<p>在匹配器和转录器中， <code>$</code> 符号用于从宏引擎中调用特殊行为 (在 <a href="macros-by-example.html#metavariables">元变量</a> 和 <a href="macros-by-example.html#repetitions">重复</a> 中描述)。
不属于这种调用的标记会被字面匹配和转录，除了一个例外。
该例外是匹配器的外部定界符将匹配任意一对定界符。
因此，例如，匹配器 <code>(())</code> 将匹配 <code>{()}</code> 但不匹配 <code>{{}}</code>。字符 <code>$</code> 不能按字面匹配或转录。</p>
<h3 id="转发匹配片段"><a class="header" href="#转发匹配片段">转发匹配片段</a></h3>
<p>在将匹配的片段转发到另一个实例宏时，第二个宏中的匹配器将看到片段类型的不透明 AST 。
第二个宏不能使用文本标记来匹配匹配器中的片段，只能使用相同类型的片段指定符。
<code>ident</code> 、 <code>lifetime</code> 和 <code>tt</code> 片段类型例外，可以用文本标记匹配。以下是这个限制的示例：</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
    ($l:expr) =&gt; { bar!($l); }
// ERROR:               ^^ 在宏调用中这个 token 没有预期的规则
}

macro_rules! bar {
    (3) =&gt; {}
}

foo!(3);
<span class="boring">}</span></code></pre></pre>
<p>以下是演示如何在匹配 <code>tt</code> 片段后直接匹配 Token 的示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// compiles OK
macro_rules! foo {
    ($l:tt) =&gt; { bar!($l); }
}

macro_rules! bar {
    (3) =&gt; {}
}

foo!(3);
<span class="boring">}</span></code></pre></pre>
<h2 id="元变量"><a class="header" href="#元变量">元变量</a></h2>
<p>在匹配器中， <code>$</code> <em>名称</em> <code>:</code> <em>片段规格</em> 用于匹配指定类型的 Rust 语法片段，并将其绑定到名为 <code>$</code><em>name</em> 的元变量中。有效的片段规格包括：</p>
<ul>
<li><code>item</code>: <a href="items.html"><em>条目</em></a> </li>
<li><code>block</code>: <a href="expressions/block-expr.html"><em>块表达式</em></a> </li>
<li><code>stmt</code>: <a href="statements.html"><em>语句</em></a> 不含尾部分号 (需要分号的条目语句除外)</li>
<li><code>pat_param</code>: <a href="patterns.html"><em>模式非顶层选项</em></a></li>
<li><code>pat</code>: 至少在任何 <a href="patterns.html"><em>模式非顶层选项</em></a>, 可能更多，取决于版本</li>
<li><code>expr</code>: <a href="expressions.html"><em>表达式</em></a> </li>
<li><code>ty</code>: <a href="types.html#type-expressions"><em>类型</em></a> </li>
<li><code>ident</code>: 一个 <a href="identifiers.html">标识符或关键字</a> 或 <a href="identifiers.html">原始标识符</a></li>
<li><code>path</code>: <a href="paths.html#paths-in-types"><em>类型路径</em></a> </li>
<li><code>tt</code>: <a href="macros.html#macro-invocation"><em>Token树</em></a>  (简单 <a href="tokens.html">token</a> 或匹配在定界符号 <code>()</code> 、 <code>[]</code> 、 <code>{}</code> 中 token)</li>
<li><code>meta</code>: 一个 <a href="attributes.html"><em>Attr</em></a>, 属性的内容</li>
<li><code>lifetime</code>:  <a href="tokens.html#lifetimes-and-loop-labels">生命周期TOKEN</a></li>
<li><code>vis</code>: 一个可能是空的 <a href="visibility-and-privacy.html"><em>可见性</em></a> 限定词</li>
<li><code>literal</code>: 匹配的 <code>-</code><sup>?</sup><a href="expressions/literal-expr.html"><em>字面值表达式</em></a></li>
</ul>
<p>在转录器中，可以通过 <code>$</code><em>名称</em> 的形式引用元变量，因为片段类型已经在匹配器中被指定了。
元变量被替换为匹配到的语法元素。
关键字元变量 <code>$crate</code> 可以用于引用当前的 crate。可以将元变量多次或不进行转录。
参见下面的 <a href="macros-by-example.html#hygiene">卫生性</a> .</p>
<p>出于向后兼容的原因，虽然 <code>_</code> <a href="expressions/underscore-expr.html">也是一个表达式</a>，但单独的下划线不会被 <code>expr</code> 片段匹配。但是，当它出现为子表达式时，<code>_</code> 将被 <code>expr</code> 片段匹配。</p>
<blockquote>
<p><strong>版次差异</strong>: 从 2021 版本开始，<code>pat</code> 片段匹配符匹配顶层或模式 (即它们接受 [模式][Pattern]) 。</p>
<p>在 2021 版本之前，它们完全匹配与 <code>pat_param</code> 相同的片段 (即它们接受 <a href="patterns.html"><em>模式非顶层选项</em></a> ) 。</p>
<p>相关版本指 <code>macro_rules!</code> 定义生效的版本。</p>
</blockquote>
<h2 id="重复"><a class="header" href="#重复">重复</a></h2>
<p>在匹配器和转录器中，重复的标志是通过将要重复的标记放在 <code>$(</code>…<code>)</code> 中，后跟重复运算符，可选地包括分隔符标记。
分隔符标记可以是任何标记，除了定界符或重复运算符，但常用的是 <code>;</code> 和 <code>,</code> 。
例如，<code>$( $i:ident ),*</code> 表示由逗号分隔的任意数量的标识符。允许嵌套重复。</p>
<p>重复运算符是:</p>
<ul>
<li><code>*</code> — 表示任何数量的重复。</li>
<li><code>+</code> — 表示任何数字，但至少是 1 。</li>
<li><code>?</code> — 表示有 0 或 1 个出现的可选片段。</li>
</ul>
<p>由于 <code>?</code> 表示最多出现一次，所以它不能与分隔符一起使用。</p>
<p>重复的片段同时匹配和转换成指定数量的该片段，由分隔符隔开。
元变量将匹配到其对应片段的每个重复。例如，上面的 <code>$( $i:ident ),*</code> 示例将 <code>$i</code> 匹配到列表中的所有标识符。</p>
<p>在转录过程中，重复操作受到额外的限制，以便编译器知道如何正确地展开它们：</p>
<ol>
<li>一个匹配器中的一个重复子串，必须在转录器中以完全相同的数量、种类和嵌套顺序出现。
因此，对于匹配器 <code>$( $i:ident ),*</code>，转录器 <code>=&gt; { $i }</code>、<code>=&gt; { $( $( $i)* )* }</code> 和 <code>=&gt; { $( $i )+ }</code> 都是不合法的，
但是 <code>=&gt; { $( $i );* }</code> 是正确的，并将由逗号分隔的标识符列表替换为由分号分隔的列表。</li>
<li>在转录器中，每个重复部分必须至少包含一个元变量，以决定扩展它的次数。
如果同一个重复部分中出现了多个元变量，它们必须绑定相同数量的片段。
例如，<code>( $( $i:ident ),* ; $( $j:ident ),* ) =&gt; (( $( ($i,$j) ),* ))</code> 必须绑定与 <code>$i</code> 片段相同数量的 <code>$j</code> 片段。
这意味着，使用 <code>(a, b, c; d, e, f)</code> 调用宏是合法的，并扩展为 <code>((a,d), (b,e), (c,f))</code> ，但 <code>(a, b, c; d, e)</code> 是不合法的，因为它们的数量不同。这个要求适用于每个嵌套重复层。</li>
</ol>
<h2 id="作用域导出和导入"><a class="header" href="#作用域导出和导入">作用域、导出和导入</a></h2>
<p>由于历史原因，实例宏的作用域并不完全像条目那样工作。
宏有两种作用域形式：文本作用域和基于路径的作用域。
文本作用域是基于事物在源文件中的顺序，甚至跨越多个文件，并且是默认作用域。下面将进一步解释它。
基于路径的作用域与条目的作用域完全相同。宏的作用域、导出和导入主要由属性控制。</p>
<p>当宏被未限定的标识符 (不是多部分路径的一部分) 调用时，它首先在文本作用域中查找。
如果这没有产生任何结果，那么它将在基于路径的作用域中查找。
如果宏的名称带有路径限定符，则仅在基于路径的作用域中查找。</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">use lazy_static::lazy_static; // 基于路径导入。

macro_rules! lazy_static { // 文本定义。
    (lazy) =&gt; {};
}

lazy_static!{lazy} // 文本查找首先找到我们的宏。
self::lazy_static!{} // 基于路径的查找忽略我们的宏，找到导入的宏。</code></pre>
<h3 id="文本作用域"><a class="header" href="#文本作用域">文本作用域</a></h3>
<p>文本作用域在很大程度上基于事物在源文件中出现的顺序，类似于使用 <code>let</code> 声明的局部变量的作用域，但也适用于模块级别。
当使用 <code>macro_rules!</code> 定义宏时，宏在定义后进入作用域 (请注意，由于名称是从调用位置查找的，因此仍然可以递归使用) 。
在其周围的作用域 (通常是模块) 关闭之前，它可以进入子模块，甚至跨越多个文件：</p>
<!-- ignore: requires external modules -->
<pre><code class="language-rust ignore">//// src/lib.rs
mod has_macro {
    // m!{} // Error: m 不在作用域内。

    macro_rules! m {
        () =&gt; {};
    }
    m!{} // OK: 出现在 m 的声明之后。

    mod uses_macro;
}

// m!{} // Error: m 不在作用域内。

//// src/has_macro/uses_macro.rs

m!{} // OK: 在 src/lib.rs 中出现在 m 的声明之后。</code></pre>
<p>宏被多次定义不会出错；最近的声明会隐藏先前的声明，除非它已经超出作用域。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    (1) =&gt; {};
}

m!(1);

mod inner {
    m!(1);

    macro_rules! m {
        (2) =&gt; {};
    }
    // m!(1); // Error: 没有规则匹配 '1'
    m!(2);

    macro_rules! m {
        (3) =&gt; {};
    }
    m!(3);
}

m!(1);
<span class="boring">}</span></code></pre></pre>
<p>宏也可以在函数内部声明和使用，并且工作方式类似：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    // m!(); // Error: m 不在作用域内。
    macro_rules! m {
        () =&gt; {};
    }
    m!();
}


// m!(); // Error: m 不在作用域内。
<span class="boring">}</span></code></pre></pre>
<h3 id="macro_use-属性"><a class="header" href="#macro_use-属性"><code>macro_use</code> 属性</a></h3>
<p><em><code>macro_use</code> 属性</em> 有两个目的。首先，它可用于使模块的宏作用域在模块关闭后不结束，通过将其应用于一个模块：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
mod inner {
    macro_rules! m {
        () =&gt; {};
    }
}

m!();
<span class="boring">}</span></code></pre></pre>
<p>第二个作用是将它应用于出现在 crate 的根模块中的 <code>extern crate</code> 声明，从而从另一个 crate 导入宏。
以这种方式导入的宏被导入到 <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> 预定义</a> ，而不是文本上导入，这意味着它们可以被任何其他名称隐藏。
虽然 <code>#[macro_use]</code> 导入的宏可以在导入语句之前使用，但在冲突的情况下，最后导入的宏优先。
可选地，可以使用 [MetaListIdents] 语法指定要导入的宏列表；当将 <code>#[macro_use]</code> 应用于模块时，不支持此功能。</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">#[macro_use(lazy_static)] // 或 #[macro_use] 导入所有宏。
extern crate lazy_static;

lazy_static!{}
// self::lazy_static!{} // Error: lazy_static 在 `self` 未定义。</code></pre>
<p>使用 <code>#[macro_use]</code> 导入的宏必须使用 <code>#[macro_export]</code> 导出，下面将对此进行描述。</p>
<h3 id="基于路径作用域"><a class="header" href="#基于路径作用域">基于路径作用域</a></h3>
<p>默认情况，宏没有基于路径的作用域。然而，如果它有 <code>#[macro_export]</code> 属性，那么它就被声明在 crate 根作用域内，并可正常引用:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self::m!();
m!(); // OK: 基于路径的查找在当前模块中查找 m 。

mod inner {
    super::m!();
    crate::m!();
}

mod mac {
    #[macro_export]
    macro_rules! m {
        () =&gt; {};
    }
}
<span class="boring">}</span></code></pre></pre>
<p>标有 <code>#[macro_export]</code> 的宏总是 <code>pub</code> 的，可以通过路径或像上面描述的 <code>#[macro_use]</code> 在其他 crate 中引用。</p>
<h2 id="卫生性"><a class="header" href="#卫生性">卫生性</a></h2>
<p>默认情况下，在宏中引用的所有标识符都会按原样扩展，并在宏调用的地方查找。
如果宏引用了在调用位置不在作用域内的条目或宏，则可能会出现问题。
为了缓解这个问题，可以在路径的开头使用 <code>$crate</code> 元变量，以强制在定义宏的 crate 内部进行查找。</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">//// 定义在 `helper_macro` crate 中。
#[macro_export]
macro_rules! helped {
    // () =&gt; { helper!() } // 由于 'helper' 不在作用域中，这可能会导致错误。
    () =&gt; { $crate::helper!() }
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}

//// 在另一个 crate 里使用。
// 请注意，没有导入 `helper_macro::helper` !
use helper_macro::helped;

fn unit() {
    helped!();
}</code></pre>
<p>注意，因为 <code>$crate</code> 指的是当前的 crate ，所以当引用非宏条目时，必须使用完全限定的模块路径。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod inner {
    #[macro_export]
    macro_rules! call_foo {
        () =&gt; { $crate::inner::foo() };
    }

    pub fn foo() {}
}
<span class="boring">}</span></code></pre></pre>
<p>此外，尽管 <code>$crate</code> 允许宏在展开时引用其所在 crate 内的条目，但它对可见性没有影响。
被引用的条目或宏仍必须从调用点可见。在下面的示例中，从 crate 外部尝试调用 <code>call_foo!()</code> 将失败，因为 <code>foo()</code> 不是公开的。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! call_foo {
    () =&gt; { $crate::foo() };
}

fn foo() {}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>在 Rust 1.30 之前， <code>$crate</code> 和 <code>local_inner_macros</code>  (下面会描述) 是不支持的。
它们与基于路径导入宏的引入一起添加，以确保辅助宏不需要由宏导出 crate 的用户手动导入。
使用辅助宏的早期 Rust 版本编写的 crate 需要修改以使用 <code>$crate</code> 或 <code>local_inner_macros</code> 以便与基于路径导入一起使用。</p>
</blockquote>
<p>当一个宏被导出时，可以在 <code>#[macro_export]</code> 属性中添加 <code>local_inner_macros</code> 关键字，以自动在所有包含的宏调用中添加 <code>$crate::</code> 前缀。
这主要是为了迁移在 <code>$crate</code> 添加到语言之前编写的代码，使其能够与 Rust 2018 的基于路径的宏导入一起使用。不建议在新代码中使用此功能。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export(local_inner_macros)]
macro_rules! helped {
    () =&gt; { helper!() } // 自动转换为 $crate::helper!() 。
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="后继符冲突限制"><a class="header" href="#后继符冲突限制">后继符冲突限制</a></h2>
<p>宏系统使用的解析器相当强大，但出于防止当前或未来版本的语言存在歧义的考虑，它是有限制的。
特别是，除了有关模糊扩展的规则之外，由元变量匹配的非终端符号必须后跟一个已决定可以安全地在该类型的匹配之后使用的标记。</p>
<p>作为一个例子，像 <code>$i:expr [ , ]</code> 这样的宏匹配器在 Rust 中在理论上是可以被接受的，因为 <code>[,]</code> 不能成为合法表达式的一部分，因此解析总是不会存在歧义。
但是，由于 <code>[</code> 可以作为尾随表达式的开始，因此 <code>[</code> 不是一个可以安全地在表达式之后排除的字符。
如果在以后的 Rust 版本中接受了 <code>[,]</code> ，这个匹配器就会变成有歧义或者解析错误，从而破坏工作中的代码。
然而，像 <code>$i:expr,</code> 或 <code>$i:expr;</code> 这样的匹配器是合法的，因为 <code>,</code> 和 <code>;</code> 是合法的表达式分隔符。具体的规则如下：</p>
<ul>
<li><code>expr</code> 和 <code>stmt</code> 后面只能跟着一个: <code>=&gt;</code> 、 <code>,</code>、 <code>;</code> 。</li>
<li><code>pat_param</code> 后面只能跟着一个: <code>=&gt;</code> 、 <code>,</code> 、 <code>=</code> 、 <code>|</code> 、 <code>if</code> 、 <code>in</code> 。</li>
<li><code>pat</code> 后面只能跟着一个: <code>=&gt;</code> 、 <code>,</code> 、 <code>=</code> 、 <code>if</code> 、 <code>in</code> 。</li>
<li><code>path</code> 和 <code>ty</code> 后面只能跟着一个: <code>=&gt;</code> 、 <code>,</code> 、 <code>=</code> 、 <code>|</code> 、 <code>;</code> 、 <code>:</code> 、 <code>&gt;</code> 、 <code>&gt;&gt;</code> 、 <code>[</code> 、 <code>{</code> 、 <code>as</code> 、 <code>where</code> ， 或 <code>block</code> 片段指定符的宏变量 。</li>
<li><code>vis</code> 后面只能跟着一个: <code>,</code>, 一个非原始的 <code>priv</code> 以外的标识符，任何可以开始一个类型的标记，或者一个带有 <code>ident</code> 、 <code>ty</code> 或 <code>path</code> 片段指定符的元变量。</li>
<li>对所有其他片段指定符没有限制。</li>
</ul>
<blockquote>
<p><strong>版次差异</strong>: 在 2021 版之前， <code>pat</code> 后面还可以加上 <code>|</code>。</p>
</blockquote>
<p>当涉及到重复时，规则适用于每次可能的扩展，同时要考虑分隔符。这意味着：</p>
<ul>
<li>如果重复包括一个分隔符，则该分隔符必须能够跟在重复内容之后。</li>
<li>如果重复可以重复多次 (<code>*</code> 或 <code>+</code>) ，则其内容必须能够跟随它们自身。</li>
<li>重复的内容必须能够跟随之前的任何内容，而跟随重复内容的任何内容后面都必须能够跟随。</li>
<li>如果重复可以匹配零次 (<code>*</code> 或 <code>?</code>) ，则后面必须能够跟随前面。</li>
</ul>
<p>更多细节，见形式说明 <a href="macro-ambiguity.html">formal specification</a> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="过程宏"><a class="header" href="#过程宏">过程宏</a></h2>
<p><em>过程宏</em> 允许创建语法扩展，作为函数执行。
过程宏有三种添加形式:</p>
<ul>
<li>[函数宏] - <code>custom!(...)</code> </li>
<li>[衍生宏] - <code>#[derive(CustomDerive)]</code> </li>
<li>[属性宏] - <code>#[CustomAttribute]</code> </li>
</ul>
<p>过程宏允许你在编译时运行代码，对 Rust 句法进行操作，既消耗并产生 Rust 句法。
你可以把过程宏想象成从一个 AST 到另一个 AST 的函数。</p>
<p>过程宏必须定义在一个 <a href="linkage.html">crate 类型</a> 为 <code>proc-macro</code> 的 crate 中。</p>
<blockquote>
<p><strong>注意</strong>: 在使用 Cargo 时，过程宏 crate 是用配置清单中的 <code>proc-macro</code> 键来定义的。</p>
<pre><code class="language-toml">[lib]
proc-macro = true
</code></pre>
</blockquote>
<p>作为函数，其必须要么返回句法，要么恐慌，要么无休止地循环。
返回的句法要么替换要么增加句法，这取决于过程宏的种类。
编译器会捕获恐慌，并变成编译器错误。
编译器不会捕获无休止循环，从而会挂起编译器。</p>
<p>过程宏在编译过程中运行，由此拥有与编译器相同的资源。
例如，标准输入、错误和输出与编译器所能访问的相同。
同样地，文件访问也是一样的。因为如此，过程宏与 <a href="../cargo/reference/build-scripts.html">Cargo 构建脚本</a> 有同样的安全问题。</p>
<p>过程宏有两种报告错误的方式。第一种是恐慌。
第二种是触发 <a href="../std/macro.compile_error.html"><code>compile_error</code></a> 宏调用。</p>
<h3 id="the-proc_macro-crate"><a class="header" href="#the-proc_macro-crate">The <code>proc_macro</code> crate</a></h3>
<p>过程宏 crate 几乎总是链接编译器提供的 <a href="../proc_macro/index.html"><code>proc_macro</code> crate</a> 。
<code>proc_macro</code> crate 提供了编写过程宏所需的类型和功能，使其更加容易。</p>
<p>这个 crate 主要包含一个 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> 类型。
过程宏在 <em>token streams</em> 流上操作，而不是 AST 节点，这对编译器和过程宏来说是更稳定的接口。
<em>token streams</em> 大致相当于 <code>Vec&lt;TokenTree&gt;</code> ，其中 <code>TokenTree</code> 可以大致认为是词法 Token 。
例如 <code>foo</code> 是 <code>Ident</code> 标记， <code>.</code> 是 <code>Punct</code> 标记，而 <code>1.2</code> 是 <code>Literal</code> 标记。与 <code>Vec&lt;TokenTree&gt;</code> 不同，<code>TokenStream</code> 类型克隆更轻便。</p>
<p>所有 Token 都有一个相关的 <code>Span</code> 。
<code>Span</code> 是一个不透明的值，不能被修改，但可以被制造。
<code>Span</code> 表示程序中源码的一个作用域，主要用于错误报告。
虽然你不能修改 <code>Span</code> 本身，但总是可以改变与任何 Token <em>相关</em> 的 <code>Span</code> ，比如通过从另一个 Token 获得 <code>Span</code> 。</p>
<h3 id="过程宏卫生性"><a class="header" href="#过程宏卫生性">过程宏卫生性</a></h3>
<p>过程宏是 <em>unhygienic</em> &quot;非卫生&quot; 的，行为简单，像是直接把输出 Token 流写入到其旁边的代码中一样。
意味着，它会受到外部条目的影响，也会影响到外部导入。</p>
<p>因为有这个限制，宏作者需要非常小心，以确保宏能在更多情况下工作。
这通常包括: 使用库中条目的绝对路径 (例如 <code>::std::option::Option</code> 而不是 <code>Option</code> ) ，
或者确保生成的函数名称不太可能与其他函数冲突 (例如 <code>__internal_foo</code> 而不是 <code>foo</code> ) 。</p>
<h3 id="函数式过程宏"><a class="header" href="#函数式过程宏">函数式过程宏</a></h3>
<p><em>函数式过程宏</em> 使用宏调用操作符 (<code>!</code>) 来调用。</p>
<p>这些宏是由一个具有 <code>proc_macro</code> <a href="attributes.html">attribute</a> 和 <code>(TokenStream) -&gt; TokenStream</code> 签名的 <a href="visibility-and-privacy.html">public</a> <a href="items/functions.html">function</a> 定义的。
输入 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> 是宏调用式的定界符号内的内容，输出 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> 则是整个宏调用式的内容。</p>
<p>例如，下面的宏定义忽略其输入，并将一个函数 <code>answer</code> 输出到它的作用域。</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type = &quot;proc-macro&quot;]
</span>extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro]
pub fn make_answer(_item: TokenStream) -&gt; TokenStream {
    &quot;fn answer() -&gt; u32 { 42 }&quot;.parse().unwrap()
}</code></pre>
<p>然后我们在二进制 crate 中使用它来打印 &quot;42&quot; 到标准输出。</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">extern crate proc_macro_examples;
use proc_macro_examples::make_answer;

make_answer!();

fn main() {
    println!(&quot;{}&quot;, answer());
}</code></pre>
<p>函数式过程宏可以在任何宏调用式位置被调用，其中包括 <a href="statements.html">语句</a> 、 <a href="expressions.html">表达式</a> 、 <a href="patterns.html">模式</a> 、 <a href="types.html#type-expressions">类型表达式</a> 、 <a href="items.html">条目</a> ，
包括 <a href="items/external-blocks.html"><code>extern</code> blocks</a> 中的条目，内部 和 trait <a href="items/implementations.html">实现</a> ，以及 <a href="items/traits.html">trait 定义</a> 。</p>
<h3 id="衍生宏"><a class="header" href="#衍生宏">衍生宏</a></h3>
<p><em>衍生宏</em> 为 <a href="attributes/derive.html"><code>derive</code> 属笥</a> 定义新输入。
这些宏可以根据 <a href="items/structs.html">struct</a> 、 <a href="items/enumerations.html">enum</a> 或 <a href="items/unions.html">union</a> 的 token 流创建新的 <a href="items.html">条目</a> 。
它们也可以定义 <a href="procedural-macros.html#derive-macro-helper-attributes">衍生宏辅助属性</a> 。</p>
<p>自定义衍生宏是由一个 <a href="visibility-and-privacy.html">public</a> <a href="items/functions.html">function</a> 定义的，其属性为 <code>proc_macro_derive</code> ，签名为 <code>(TokenStream) -&gt; TokenStream</code> 。</p>
<p>输入 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> 是具有 <code>derive</code> 属性条目的 token 流。
输出 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> 必须是一组条目，然后附加到输入 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> 的条目所在的 <a href="items/modules.html">module</a> 或 <a href="expressions/block-expr.html">block</a> 。</p>
<p>下面是一个衍生宏的例子。它没有对其输入做任何有用的事情，而只是附加了一个函数 <code>answer</code> 。</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type = &quot;proc-macro&quot;]
</span>extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro_derive(AnswerFn)]
pub fn derive_answer_fn(_item: TokenStream) -&gt; TokenStream {
    &quot;fn answer() -&gt; u32 { 42 }&quot;.parse().unwrap()
}</code></pre>
<p>然后使用所述的衍生宏:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">extern crate proc_macro_examples;
use proc_macro_examples::AnswerFn;

#[derive(AnswerFn)]
struct Struct;

fn main() {
    assert_eq!(42, answer());
}</code></pre>
<h4 id="衍生宏辅助属性"><a class="header" href="#衍生宏辅助属性">衍生宏辅助属性</a></h4>
<p>衍生宏可以在它们所在的 <a href="items.html">条目</a> 的作用域内添加额外的 <a href="attributes.html">属性</a> 。
这些属性被称为 <em>衍生宏辅助属性</em> 。
这些属性是 <a href="attributes.html#active-and-inert-attributes">惰性的</a> ，其唯一目的是嵌入到定义它们的衍生宏中。
也就是说，让所有的宏可以看到它们。</p>
<p>定义辅助属性的方法是在 <code>proc_macro_derive</code> 宏中置入一个 <code>attributes</code> 键，用逗号分隔的标识符列表，即辅助属性的名称。</p>
<p>例如，下面这个衍生宏定义了一个辅助属性 <code>helper</code> ，但最终没有对它做任何事情。</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type=&quot;proc-macro&quot;]
</span><span class="boring">extern crate proc_macro;
</span><span class="boring">use proc_macro::TokenStream;
</span>
#[proc_macro_derive(HelperAttr, attributes(helper))]
pub fn derive_helper_attr(_item: TokenStream) -&gt; TokenStream {
    TokenStream::new()
}</code></pre>
<p>然后在结构体上使用衍生宏:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">#[derive(HelperAttr)]
struct Struct {
    #[helper] field: ()
}</code></pre>
<h3 id="属性宏"><a class="header" href="#属性宏">属性宏</a></h3>
<p><em>属性宏</em> 定义了新的 <a href="attributes.html">外围属性</a> ，可以附加到 <a href="items.html">条目</a> 上，
包括 <a href="items/external-blocks.html"><code>extern</code> blocks</a> 外部块中的条目，内部 和 trait的 <a href="items/implementations.html">实现</a> ，以及 <a href="items/traits.html">trait 定义</a> 。</p>
<p>属性宏是由带有 <code>proc_macro_attribute</code> <a href="attributes.html">attribute</a> 的 <a href="visibility-and-privacy.html">public</a> <a href="items/functions.html">function</a> 定义的，其签名为 <code>(TokenStream, TokenStream) -&gt; TokenStream</code> 。
第一个 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> 是属性名称后面的分隔的 token 树，不包括外部分隔符号。
如果属性被写成裸属性名，则属性 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> 是空的。
第二个 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> 是 <a href="items.html">条目</a> 的其他部分，包括 <a href="items.html">条目</a> 上的其他 <a href="attributes.html">属笥</a> 。
返回的 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> 用任意数量的 <a href="items.html">条目</a> 替换 <a href="items.html">条目</a> 。</p>
<p>例如，这个属性宏接收输入流并按原样返回，实际上是对于属性的空操作。</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type = &quot;proc-macro&quot;]
</span><span class="boring">extern crate proc_macro;
</span><span class="boring">use proc_macro::TokenStream;
</span>
#[proc_macro_attribute]
pub fn return_as_is(_attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    item
}</code></pre>
<p>下面这个例子显示了属性宏得到的字符串化的 <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code>s</a> 。
该输出将其显示在编译器的输出中。输出内容显示在以 &quot;out:&quot; 为前缀的函数后的注释中。</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore">// my-macro/src/lib.rs
<span class="boring">extern crate proc_macro;
</span><span class="boring">use proc_macro::TokenStream;
</span>
#[proc_macro_attribute]
pub fn show_streams(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    println!(&quot;attr: \&quot;{}\&quot;&quot;, attr.to_string());
    println!(&quot;item: \&quot;{}\&quot;&quot;, item.to_string());
    item
}</code></pre>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// src/lib.rs
extern crate my_macro;

use my_macro::show_streams;

// Example: Basic function
#[show_streams]
fn invoke1() {}
// out: attr: &quot;&quot;
// out: item: &quot;fn invoke1() { }&quot;

// Example: Attribute with input
#[show_streams(bar)]
fn invoke2() {}
// out: attr: &quot;bar&quot;
// out: item: &quot;fn invoke2() {}&quot;

// Example: Multiple tokens in the input
#[show_streams(multiple =&gt; tokens)]
fn invoke3() {}
// out: attr: &quot;multiple =&gt; tokens&quot;
// out: item: &quot;fn invoke3() {}&quot;

// Example:
#[show_streams { delimiters }]
fn invoke4() {}
// out: attr: &quot;delimiters&quot;
// out: item: &quot;fn invoke4() {}&quot;</code></pre>
<h3 id="声明宏-token-和过程宏-token"><a class="header" href="#声明宏-token-和过程宏-token">声明宏 Token 和过程宏 Token</a></h3>
<p>声明 <code>macro_rules</code> 宏和过程宏使用是类似的，但是不同的 Token (或者说 [`TokenTree's] ) 定义。</p>
<p>在 <code>macro_rules</code> 中的 Token 树 (对应于 <code>tt</code> matcher) 被定义为</p>
<ul>
<li>限定的组 (<code>(...)</code>, <code>{...}</code>, 等) 。</li>
<li>语言支持的所有运算符，包括单字符和多字符的运算符 (<code>+</code>, <code>+=</code>) 。
<ul>
<li>请注意，这个集合不包括单引号 <code>'</code> 。</li>
</ul>
</li>
<li>字面值 (<code>&quot;string&quot;</code>, <code>1</code>, 等) 。
<ul>
<li>请注意，负 (如 <code>-1</code>) 从来不是这种字面值 Token 的一部分，而是单独的操作符 Token 。</li>
</ul>
</li>
<li>标识符，包括关键字 (<code>ident</code>, <code>r#ident</code>, <code>fn</code>)</li>
<li>生命周期 (<code>'ident</code>)</li>
<li>在 <code>macro_rules</code> 中元变量替换 (如 <code>$my_expr</code> 在 <code>macro_rules! mac { ($my_expr: expr) =&gt; { $my_expr } }</code> 在 <code>mac</code> 的展开之后，无论传递的表达式是什么，都会被认为是单一的 Token 树 )</li>
</ul>
<p>过程宏中的 Token 树被定义为</p>
<ul>
<li>限定的组 (<code>(...)</code>, <code>{...}</code>, 等)</li>
<li>语言支持的运算符中使用的所有标点符号 (<code>+</code> ，但不是 <code>+=</code>)，还有单引号 <code>'</code> 字符 (通常用在生命周期上，关于生命周期的分割和连接行为见下文)</li>
<li>字面值 (<code>&quot;string&quot;</code>, <code>1</code>, 等)
<ul>
<li>支持负 (如<code>-1</code> ) 作为整数和浮点数字的一部分。</li>
</ul>
</li>
<li>标识符，包括关键字 (<code>ident</code>, <code>r#ident</code>, <code>fn</code>)</li>
</ul>
<p>当 Token 流被传递到过程宏时，会考虑这两个定义之间不匹配的情况。
请注意，下面的转换可能会产生惰性，所以如果没有实际检验 Token ，就可能不会发生。</p>
<p>传递给过程宏时</p>
<ul>
<li>所有的多字符运算符都分解成单字符。</li>
<li>生命周期分解成一个 <code>'</code> 字符和一个标识符。</li>
<li>所有元变量的替换都表示为它们实际的 Token 流。
<ul>
<li>当需要保留语法分析的优先级时，这样的 Token 流可以被包装成带有隐含限定符号 ([Delimiter::None]) 的限定组 ([Group]) 。</li>
<li><code>tt</code> 和 <code>ident</code> 的替换从来不会被包裹在这样的组中，而总是作为它们的实际的 Token 树来表示。</li>
</ul>
</li>
</ul>
<p>当从过程宏触发时</p>
<ul>
<li>在适用的情况下，标点符号被粘接在多字符运算符中。</li>
<li>与标识符连接的单引号 <code>'</code> 被粘接在生命周期中。</li>
<li>负字面值被转换为两个标记 ( <code>-</code> 和字面值 )，当需要保留语法分析的优先级时，可能会被包裹在一个带限定符号的组 (<a href="../proc_macro/struct.Group.html"><code>Group</code></a>) 中，并带有隐式限定符 (<a href="../proc_macro/enum.Delimiter.html#variant.None"><code>Delimiter::None</code></a>) 。</li>
</ul>
<p>请注意，无论是声明性的还是过程性的宏都不支持 doc 注释标记 (例如 <code>/// Doc</code> ) ，当其传递给宏时，总是转换为表示其等价的 <code>#[doc = r&quot;str&quot;]</code> 属性的 Token 流。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crate和源码文件"><a class="header" href="#crate和源码文件">Crate和源码文件</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>Crate</em> :<br />
   UTF8BOM<sup>?</sup><br />
   执行注解<sup>?</sup><br />
   <a href="attributes.html"><em>内部属性</em></a><sup>*</sup><br />
   <a href="items.html"><em>条目</em></a><sup>*</sup></p>
</blockquote>
<blockquote>
<p><strong><sup>词法</sup></strong><br />
UTF8BOM : <code>\uFEFF</code><br />
执行注解 : <code>#!</code> ~<code>\n</code><sup>+</sup><a href="crates-and-source-files.html#shebang">†</a></p>
</blockquote>
<blockquote>
<p>注意：尽管 Rust 和其他语言一样，可以被解释器实现，但是现有的唯一实现是编译器，
并且这门语言一直被设计为编译型语言。因此，本节假设使用的是编译器。</p>
</blockquote>
<p>Rust 的语义遵循编译时和运行时之间的阶段区别。
<sup class="footnote-reference"><a href="#phase-distinction">1</a></sup> 有一个 <em>静态解释</em> 的语义规则来决定编译的成功或失败，而有一个 <em>动态解释</em> 的语义规则来决定程序在运行时的行为。</p>
<p>编译模型以名为 <em>crate</em> 的构件为中心。
每个编译过程处理单个源代码形式的 crate，如果成功，将生成单个二进制形式的 crate ，生成可执行文件或某种类型的库。<sup class="footnote-reference"><a href="#cratesourcefile">2</a></sup></p>
<p>一个 <em>crate</em> 是编译、链接、版本控制、分发和运行时加载的基本单位。
一个 crate 包含了一个嵌套的 <a href="items/modules.html">模块</a> 作用域 <em>树</em> 。
这个树的最高层是一个匿名模块，任何 crate 中的条目都有一个规范的 <a href="paths.html">模块路径</a> 来表示它在 crate 的模块树中的位置。</p>
<p>Rust 编译器总是使用单个源文件作为输入，并始终产生单个输出 crate 。
处理该源文件可能会导致其他源文件作为模块被加载。源文件的扩展名为<code>.rs</code>。</p>
<p>一个 Rust 的源文件描述了一个模块，它的名称和位置是在源文件之外定义的，即通过引用源文件中的 <a href="items/modules.html">Module</a> 条目，或者通过 crate 自身的名称。
每个源文件都是一个模块，但不是每个模块都需要自己的源文件：<a href="items/modules.html">模块定义</a> 可以在一个文件中嵌套。</p>
<p>每个源文件包含零个或多个 <a href="items.html"><em>条目</em></a> 定义，可以选择地以任意数量的 <a href="attributes.html">属性</a> 开头，这些属性适用于包含的模块，大多数属性都会影响编译器的行为。
匿名的 crate 模块可以有适用于整个 crate 的附加属性。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 指定 crate 名称。
#![crate_name = &quot;projx&quot;]

// 指定输出制品的类型。
#![crate_type = &quot;lib&quot;]

// 开启警告。
// 这可以在任何模块中，而不仅是匿名的 crate 模块。
#![warn(non_camel_case_types)]
<span class="boring">}</span></code></pre></pre>
<h2 id="字节顺序标记"><a class="header" href="#字节顺序标记">字节顺序标记</a></h2>
<p>可选的 <a href="https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8">UTF8 字节顺序标记</a> (UTF8BOM 产生式) 表示该文件使用 UTF8 编码。它只能出现在文件开头，并且被编译器忽略。</p>
<h2 id="执行注解"><a class="header" href="#执行注解">执行注解</a></h2>
<p>源码文件可以包含 <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)"><em>shebang</em></a> (执行注解) ，它指示操作系统要使用哪个程序来执行此文件。
它基本上将源文件视为可执行脚本。执行注解只能出现在文件开头 (但在可选的 <em>UTF8BOM</em> 之后) 。
它会被编译器忽略。例如:</p>
<!-- ignore: tests don't like shebang -->
<pre><code class="language-rust ignore">#!/usr/bin/env rustx

fn main() {
    println!(&quot;Hello!&quot;);
}</code></pre>
<p>对于执行注解语法，存在限制以避免与 <a href="attributes.html">属性</a> 混淆。
<code>#!</code> 字符后面不能跟着 <code>[</code> 标记，忽略其中的注释或 <a href="whitespace.html">空白</a> 。
如果此限制失败，则它不会被视为执行注解，而是被视为属性的开始。</p>
<h2 id="预定义-和-no_std"><a class="header" href="#预定义-和-no_std">预定义 和 <code>no_std</code></a></h2>
<p>本节已移至 <a href="names/preludes.html">预定义章节</a> 。</p>
<!-- this is to appease the linkchecker, will remove once other books are updated -->
<h2 id="main-函数"><a class="header" href="#main-函数">Main 函数</a></h2>
<p>如果一个 crate 包含一个 <code>main</code> <a href="items/functions.html">函数</a>，它可以被编译成可执行文件。
如果存在一个 <code>main</code> 函数，则它不应接受任何参数，不应声明任何 <a href="trait-bounds.html">trait 或生命周期约束</a>，也不应该有任何 <code>where</code> 子句，而且它的返回类型必须实现 <a href="../std/process/trait.Termination.html"><code>Termination</code></a> trait。</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() -&gt; ! {
    std::process::exit(0);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() -&gt; impl std::process::Termination {
    std::process::ExitCode::SUCCESS
}</code></pre></pre>
<blockquote>
<p><strong>注意</strong>: 标准库中具有 <a href="../std/process/trait.Termination.html"><code>Termination</code></a> 实现的类型包括:</p>
<ul>
<li><code>()</code></li>
<li><a href="types/never.html"><code>!</code></a></li>
<li><a href="../std/convert/enum.Infallible.html"><code>Infallible</code></a></li>
<li><a href="../std/process/struct.ExitCode.html"><code>ExitCode</code></a></li>
<li><code>Result&lt;T, E&gt; where T: Termination, E: Debug</code></li>
</ul>
</blockquote>
<!-- If the previous section needs updating (from "must take no arguments"
  onwards, also update it in the testing.md file -->
<h3 id="no_main-属性"><a class="header" href="#no_main-属性"><code>no_main</code> 属性</a></h3>
<p><code>no_main</code> 属性可以应用于 crate 级别，用于禁用可执行二进制文件的 <code>main</code> 符号的输出。
这在被链接到某个定义了 <code>main</code> 的其他对象时非常有用。</p>
<h2 id="crate_name-属性"><a class="header" href="#crate_name-属性"><code>crate_name</code> 属性</a></h2>
<p><code>crate_name</code> 属性可以应用于 crate 层级，使用 <a href="attributes.html#meta-item-attribute-syntax"><em>元名称值字符串</em></a> 语法指定 crate 名称。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>#![crate_name = &quot;mycrate&quot;]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p>crate 的名称不能为空，只能包含 <a href="../std/primitive.char.html#method.is_alphanumeric">Unicode 字母数字</a> 或 <code>_</code> (U+005F) 字符。</p>
<div class="footnote-definition" id="phase-distinction"><sup class="footnote-definition-label">1</sup>
<p>在一个解释器中，这种区别也会存在。无论何时执行程序，静态检查，例如语法分析、类型检查和 lints 应该先发生，然后才执行程序。</p>
</div>
<div class="footnote-definition" id="cratesourcefile"><sup class="footnote-definition-label">2</sup>
<p>一个 crate 在某种程度上类似于 ECMA-335 CLI 模型中的 <em>assembly</em> ， SML/NJ 编译管理器中的 <em>library</em> ，Owens 和 Flatt 模块系统中的 <em>unit</em>，或 Mesa 中的 <em>configuration</em> 。</p>
</div>
<script>
(function() {
    var fragments = {
        "#preludes-and-no_std": "names/preludes.html",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="条件编译"><a class="header" href="#条件编译">条件编译</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>配置断言</em> :<br />
      <em>配置选项</em><br />
   | <em>配置All</em><br />
   | <em>配置Any</em><br />
   | <em>配置Not</em></p>
<p><em>配置选项</em> :<br />
   <a href="identifiers.html">IDENTIFIER</a> (<code>=</code> (<a href="tokens.html#string-literals">STRING_LITERAL</a> | <a href="tokens.html#raw-string-literals">RAW_STRING_LITERAL</a>))<sup>?</sup></p>
<p><em>配置All</em><br />
   <code>all</code> <code>(</code> <em>配置断言列表</em><sup>?</sup> <code>)</code></p>
<p><em>配置Any</em><br />
   <code>any</code> <code>(</code> <em>配置断言列表</em><sup>?</sup> <code>)</code></p>
<p><em>配置Not</em><br />
   <code>not</code> <code>(</code> <em>配置断言</em> <code>)</code></p>
<p><em>配置断言列表</em><br />
   <em>配置断言</em> (<code>,</code> <em>配置断言</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<p><em>条件编译源代码</em> 是指根据某些条件来确定是否将其部分源代码不作为或者作为源代码的一部分。</p>
<!-- This definition is sort of vacuous --> 
<p>可以使用 <a href="attributes.html">attributes</a> <a href="conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a> 和 <a href="conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a> 以及内置的 <a href="conditional-compilation.html#the-cfg-macro"><code>cfg</code> 宏</a> 条件编译源代码。
这些条件是基于编译的 crate 的目标架构、传递给编译器的任意值和其他一些细节进行确定的，下面将对其进行详细描述。</p>
<p>每种形式的条件编译都需要有配置断言，该断言评估为 true 或 false。断言有以下几种形式：</p>
<ul>
<li>配置选项。如果选项设置为 true ，则为真，否则为假。</li>
<li><code>all()</code>，带有逗号分隔的配置断言列表。如果至少有一个断言为 false ，则结果为 false 。如果没有断言，则为 true 。</li>
<li><code>any()</code>，带有逗号分隔的配置断言列表。如果至少有一个断言为 true ，则结果为 true 。如果没有断言，则为 false 。</li>
<li><code>not()</code>，带有一个配置断言。如果其断言为 false ，则为 true ，如果其断言为 true ，则为 false 。</li>
</ul>
<p><em>配置选项</em> 是一些名称和键值对，可以被设置或不设置。
名称被写成单个标识符，例如 <code>unix</code> 。
键值对被写成一个标识符，后跟一个字符串 。
例如， <code>target_arch = &quot;x86_64&quot;</code> 就是一个配置选项。</p>
<blockquote>
<p><strong>注意</strong>: 等号周围的空白将被忽略。 <code>foo=&quot;bar&quot;</code> 和 <code>foo = &quot;bar&quot;</code> 是等价的配置选项。</p>
</blockquote>
<p>键在键值配置选项的集合中不是唯一的。例如，同时可以设置 <code>feature = &quot;std&quot;</code> 和 <code>feature = &quot;serde&quot;</code> 。</p>
<h2 id="设置配置选项"><a class="header" href="#设置配置选项">设置配置选项</a></h2>
<p>编译期间确定哪些配置选项被设置。某些选项是由编译数据设置的，称为编译器设置。
其他选项是任意设置的，基于在代码之外传递给编译器的输入设置。
无法为正在编译的 crate 的源代码设置配置选项。</p>
<blockquote>
<p><strong>注意</strong>: 对于 <code>rustc</code>，任意设置的配置选项可以使用 <a href="../rustc/command-line-arguments.html#--cfg-configure-the-compilation-environment"><code>--cfg</code></a> 标志设置。</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>: 键为 <code>feature</code> 的配置选项是 <a href="../cargo/reference/features.html">Cargo</a> 用于指定编译时选项和可选依赖的惯例。</p>
</blockquote>
<div class="warning">
<p>警告：任意设置的配置选项可能与编译器设置的配置选项具有相同的值。
例如，可能会在编译为 Windows 目标时执行 <code>rustc --cfg &quot;unix&quot; program.rs</code>，并同时设置 <code>unix</code> 和 <code>windows</code> 配置选项。
实际上这样做是不明智的。</p>
</div>
<h3 id="target_arch"><a class="header" href="#target_arch"><code>target_arch</code></a></h3>
<p>目标 CPU 架构与一组键值选项设置一起。该值类似于平台目标三元组的第一个元素，但并非完全相同。</p>
<p>示例值:</p>
<ul>
<li><code>&quot;x86&quot;</code></li>
<li><code>&quot;x86_64&quot;</code></li>
<li><code>&quot;mips&quot;</code></li>
<li><code>&quot;powerpc&quot;</code></li>
<li><code>&quot;powerpc64&quot;</code></li>
<li><code>&quot;arm&quot;</code></li>
<li><code>&quot;aarch64&quot;</code></li>
</ul>
<h3 id="target_feature"><a class="header" href="#target_feature"><code>target_feature</code></a></h3>
<p>为当前编译目标提供的每个平台特性设置键值选项。</p>
<p>示例值:</p>
<ul>
<li><code>&quot;avx&quot;</code></li>
<li><code>&quot;avx2&quot;</code></li>
<li><code>&quot;crt-static&quot;</code></li>
<li><code>&quot;rdrand&quot;</code></li>
<li><code>&quot;sse&quot;</code></li>
<li><code>&quot;sse2&quot;</code></li>
<li><code>&quot;sse4.1&quot;</code></li>
</ul>
<p>详见 <a href="attributes/codegen.html#the-target_feature-attribute"><code>target_feature</code> 属性</a> 获取有关可用特性的更多详细信息。
<code>target_feature</code> 选项的另一个特性是 <code>crt-static</code> ，它指示可用 <a href="linkage.html#static-and-dynamic-c-runtimes">静态 C 运行时库</a> 。</p>
<h3 id="target_os"><a class="header" href="#target_os"><code>target_os</code></a></h3>
<p>该选项是针对编译目标操作系统的键值选项，仅设定一次。该值类似于平台目标三元组的第二个和第三个元素。</p>
<p>示例值:</p>
<ul>
<li><code>&quot;windows&quot;</code></li>
<li><code>&quot;macos&quot;</code></li>
<li><code>&quot;ios&quot;</code></li>
<li><code>&quot;linux&quot;</code></li>
<li><code>&quot;android&quot;</code></li>
<li><code>&quot;freebsd&quot;</code></li>
<li><code>&quot;dragonfly&quot;</code></li>
<li><code>&quot;openbsd&quot;</code></li>
<li><code>&quot;netbsd&quot;</code></li>
</ul>
<h3 id="target_family"><a class="header" href="#target_family"><code>target_family</code></a></h3>
<p><code>target_family</code> 是提供关于目标平台更一般描述的键值选项，例如目标平台通常属于的操作系统或体系结构系列。可以设置任意数量的 <code>target_family</code> 键值对。</p>
<p>示例值:</p>
<ul>
<li><code>&quot;unix&quot;</code></li>
<li><code>&quot;windows&quot;</code></li>
<li><code>&quot;wasm&quot;</code></li>
</ul>
<h3 id="unix-和-windows"><a class="header" href="#unix-和-windows"><code>unix</code> 和 <code>windows</code></a></h3>
<p>如果设置了 <code>target_family = &quot;unix&quot;</code>，则会设置 <code>unix</code> ，如果设置了 <code>target_family = &quot;windows&quot;</code>，则会设置 <code>windows</code> 。</p>
<h3 id="target_env"><a class="header" href="#target_env"><code>target_env</code></a></h3>
<p>键值选项为目标平台提供进一步的区分信息，例如有关所使用的 ABI 或 <code>libc</code> 的信息。
由于历史原因，只有在实际需要区分时，此值才会被定义为非空字符串。
因此，例如，在许多 GNU 平台上，此值将为空。此值类似于平台目标三元组的第四个元素。
一个不同之处是，像 <code>gnueabihf</code> 这样的嵌入式 ABI 将简单地将 <code>target_env</code> 定义为 <code>&quot;gnu&quot;</code>。</p>
<p>示例值:</p>
<ul>
<li><code>&quot;&quot;</code></li>
<li><code>&quot;gnu&quot;</code></li>
<li><code>&quot;msvc&quot;</code></li>
<li><code>&quot;musl&quot;</code></li>
<li><code>&quot;sgx&quot;</code></li>
</ul>
<h3 id="target_endian"><a class="header" href="#target_endian"><code>target_endian</code></a></h3>
<p>键值选项，用于描述目标的字节序，取值为 &quot;little&quot; 或 &quot;big&quot; ，根据目标机器的 CPU 决定。</p>
<h3 id="target_pointer_width"><a class="header" href="#target_pointer_width"><code>target_pointer_width</code></a></h3>
<p>键值选项只设置一次，其值为目标的指针宽度 (以位为单位) 。</p>
<p>示例值:</p>
<ul>
<li><code>&quot;16&quot;</code></li>
<li><code>&quot;32&quot;</code></li>
<li><code>&quot;64&quot;</code></li>
</ul>
<h3 id="target_vendor"><a class="header" href="#target_vendor"><code>target_vendor</code></a></h3>
<p>键值选项设置一次，其键是目标的供应商 (vendor) 。</p>
<p>示例值:</p>
<ul>
<li><code>&quot;apple&quot;</code></li>
<li><code>&quot;fortanix&quot;</code></li>
<li><code>&quot;pc&quot;</code></li>
<li><code>&quot;unknown&quot;</code></li>
</ul>
<h3 id="target_has_atomic"><a class="header" href="#target_has_atomic"><code>target_has_atomic</code></a></h3>
<p>每个比特宽度支持原子加载、存储和比较交换操作的目标都设置了一个键值选项。</p>
<p>当这个 cfg 存在时，所有适用于相关原子宽度的稳定的 <a href="../core/sync/atomic/index.html"><code>core::sync::atomic</code></a> API 可用。</p>
<p>可能值:</p>
<ul>
<li><code>&quot;8&quot;</code></li>
<li><code>&quot;16&quot;</code></li>
<li><code>&quot;32&quot;</code></li>
<li><code>&quot;64&quot;</code></li>
<li><code>&quot;128&quot;</code></li>
<li><code>&quot;ptr&quot;</code></li>
</ul>
<h3 id="test"><a class="header" href="#test"><code>test</code></a></h3>
<p>该选项在编译测试套件时启用，可以通过在使用 <code>rustc</code> 时加上 <a href="../rustc/command-line-arguments.html#--test-build-a-test-harness"><code>--test</code></a> 标志来实现。
有关测试支持的更多信息，请参见 <a href="attributes/testing.html">Testing</a> 。</p>
<h3 id="debug_assertions"><a class="header" href="#debug_assertions"><code>debug_assertions</code></a></h3>
<p>在没有开启优化的情况下，默认启用。
这可以在开发时启用额外的调试代码，但不用于生产。
例如，它控制标准库中的 <a href="../std/macro.debug_assert.html"><code>debug_assert!</code></a> 宏的行为。</p>
<h3 id="proc_macro"><a class="header" href="#proc_macro"><code>proc_macro</code></a></h3>
<p>当编译的 crate 使用 <code>proc_macro</code> <a href="linkage.html">crate type</a> 时被设置。</p>
<h3 id="panic"><a class="header" href="#panic"><code>panic</code></a></h3>
<p>键值选项，根据 panic 策略设置而定。请注意，将来可能会添加更多值。</p>
<p>示例值:</p>
<ul>
<li><code>&quot;abort&quot;</code></li>
<li><code>&quot;unwind&quot;</code></li>
</ul>
<h2 id="条件编译的形式"><a class="header" href="#条件编译的形式">条件编译的形式</a></h2>
<h3 id="cfg-属性"><a class="header" href="#cfg-属性"><code>cfg</code> 属性</a></h3>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>CfgAttr属性</em> :<br />
   <code>cfg</code> <code>(</code> <em>配置断言</em> <code>)</code></p>
</blockquote>
<!-- should we say they're active attributes here? -->
<p><code>cfg</code> 属性是一个条件包含器，根据一系列配置判断来决定是否包含它所附着的目标。</p>
<p>它的语法是 <code>cfg</code>  <code>(</code> 配置断言语句 <code>)</code> 。</p>
<p>如果断言为 true，则将该条件附加到的条目重新编写，不再具有 <code>cfg</code> 属性。
如果断言为 false，则该条目将从源代码中删除。</p>
<p>一些关于功能的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 该函数仅在为 macOS 编译时包含在构建中。
#[cfg(target_os = &quot;macos&quot;)]
fn macos_only() {
  // ...
}

// 只有在定义了 foo 或 bar 的情况下，才会包含这个函数
#[cfg(any(foo, bar))]
fn needs_foo_or_bar() {
  // ...
}

// 这个函数只在为 32 位架构的 unixish 操作系统编译时包含。
#[cfg(all(unix, target_pointer_width = &quot;32&quot;))]
fn on_32bit_unix() {
  // ...
}

// 只有在没有定义 foo 的情况下才包含这个函数
#[cfg(not(foo))]
fn needs_not_foo() {
  // ...
}

// 该函数仅在恐慌策略被设置为 unwind 时包含。
#[cfg(panic = &quot;unwind&quot;)]
fn when_unwinding() {
  // ...
}

<span class="boring">}</span></code></pre></pre>
<p><code>cfg</code> 属性允许在任何允许属性的位置使用。</p>
<h3 id="cfg_attr-属性"><a class="header" href="#cfg_attr-属性"><code>cfg_attr</code> 属性</a></h3>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>CfgAttr属性</em> :<br />
   <code>cfg_attr</code> <code>(</code> _配置断言 <code>,</code> <em>CfgAttr组</em><sup>?</sup> <code>)</code></p>
<p><em>CfgAttr组</em> :<br />
   <a href="attributes.html"><em>Attr</em></a> (<code>,</code> <a href="attributes.html"><em>Attr</em></a>)<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<p><code>cfg_attr</code> 属性会根据条件断言来选择性地包含其他属性。</p>
<p>当配置断言为真时，此属性将展开为断言后列出的属性。
例如，以下模块将基于目标平台在 <code>linux.rs</code> 或 <code>windows.rs</code> 中找到：</p>
<!-- ignore: `mod` needs multiple files -->
<pre><code class="language-rust ignore">#[cfg_attr(target_os = &quot;linux&quot;, path = &quot;linux.rs&quot;)]
#[cfg_attr(windows, path = &quot;windows.rs&quot;)]
mod os;</code></pre>
<p>可以列出零个、一个或多个属性。多个属性将会分别展开为单独的属性。比如:</p>
<!-- ignore: fake attributes -->
<pre><code class="language-rust ignore">#[cfg_attr(feature = &quot;magic&quot;, sparkles, crackles)]
fn bewitched() {}

// 当 `magic` 特性标志启用时，上述内容将展开为:
#[sparkles]
#[crackles]
fn bewitched() {}</code></pre>
<blockquote>
<p><strong>注意</strong>: <code>cfg_attr</code> 可以扩展为另一个 <code>cfg_attr</code> 。
比如, <code>#[cfg_attr(target_os = &quot;linux&quot;, cfg_attr(feature = &quot;multithreaded&quot;, some_other_attribute))]</code> 是有效的。
这个例子等价于 <code>#[cfg_attr(all(target_os = &quot;linux&quot;, feature =&quot;multithreaded&quot;), some_other_attribute)]</code> 。</p>
</blockquote>
<p><code>cfg_attr</code> 属性允许在任何允许其他属性的地方使用。</p>
<h3 id="cfg-宏"><a class="header" href="#cfg-宏"><code>cfg</code> 宏</a></h3>
<p>内置的 <code>cfg</code> 宏接收一个配置断言并在断言为真时求值为 <code>true</code> 字面值，在断言为假时求值为 <code>false</code> 字面值。</p>
<p>示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let machine_kind = if cfg!(unix) {
  &quot;unix&quot;
} else if cfg!(windows) {
  &quot;windows&quot;
} else {
  &quot;unknown&quot;
};

println!(&quot;I'm running on a {} machine!&quot;, machine_kind);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="条目"><a class="header" href="#条目">条目</a></h1>
<blockquote>
<p><strong><sup>语未能:<sup></strong><br />
<em>条目</em>:<br />
   <a href="attributes.html"><em>外部属性</em></a><sup>*</sup><br />
      <em>可见性条目</em><br />
   | <em>宏条目</em></p>
<p><em>可见性条目</em>:<br />
   <a href="visibility-and-privacy.html"><em>可见性</em></a><sup>?</sup><br />
   (<br />
          <a href="items/modules.html"><em>模块</em></a><br />
      | <a href="items/extern-crates.html"><em>外部Crate</em></a><br />
      | <a href="items/use-declarations.html"><em>Use声明</em></a><br />
      | <a href="items/functions.html"><em>函数</em></a><br />
      | <a href="items/type-aliases.html"><em>类型别名</em></a><br />
      | [<em>结构体</em>]<br />
      | <a href="items/structs.html"><em>枚举</em></a><br />
      | <a href="items/unions.html"><em>联合体</em></a><br />
      | <a href="items/constant-items.html"><em>常量条目</em></a><br />
      | <a href="items/static-items.html"><em>静态条目</em></a><br />
      | <a href="items/traits.html"><em>Trait</em></a><br />
      | <a href="items/implementations.html"><em>实现</em></a><br />
      | <a href="items/external-blocks.html"><em>外部块</em></a><br />
   )</p>
<p><em>宏条目</em>:<br />
      <a href="macros.html#macro-invocation"><em>宏调用语句</em></a><br />
   | <a href="macros-by-example.html"><em>宏规则定义</em></a></p>
</blockquote>
<p><em>条目</em> 是 crate 的组成部分。条目通过一组嵌套的 <a href="items/modules.html">模块</a> 组织在 crate 中。
每个 crate 都有一个 &quot;最外层&quot; 的匿名模块；crate 中的所有其他条目都在这个模块树中，有自己的 <a href="paths.html">路径</a>。</p>
<p>条目是在编译时完全确定，通常在执行期间保持不变，并可能驻留在只读内存中。</p>
<p>有以下几种类型的条目:</p>
<ul>
<li><a href="items/modules.html">模块</a></li>
<li><a href="items/extern-crates.html"><code>extern crate</code> 声明</a></li>
<li><a href="items/use-declarations.html"><code>use</code> 声明</a> </li>
<li><a href="items/functions.html">函数定义</a> </li>
<li><a href="items/type-aliases.html">类型定义</a> </li>
<li><a href="items/structs.html">结构定义</a> </li>
<li><a href="items/enumerations.html">枚举定义</a> </li>
<li><a href="items/unions.html">联合体定义</a> </li>
<li><a href="items/constant-items.html">常量条目</a> </li>
<li><a href="items/static-items.html">静态条目</a> </li>
<li><a href="items/traits.html">trait 定义</a> </li>
<li><a href="items/implementations.html">实现</a></li>
<li><a href="items/external-blocks.html"><code>extern</code> 块</a> </li>
</ul>
<p>某些条目为声明子条目形成了隐式作用域。
换句话说，在函数或模块内，条目的声明 (在许多情况下) 可以与语句、控制块和类似的结构混合在一起，
其含义与在作用域外部声明该条目的含义相同 — 它仍然是静态条目 — 除了该条目在模块命名空间内的 <em>路径名称</em> 由包围条目的名称限定，或者是对包围条目私有的 (在函数的情况下) 。
语法指定了子条目声明可能出现的确切位置。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块"><a class="header" href="#模块">模块</a></h1>
<blockquote>
<p><strong><sup>语法:</sup></strong><br />
<em>模块</em> :<br />
      <code>unsafe</code><sup>?</sup> <code>mod</code> <a href="items/../identifiers.html">标识符</a> <code>;</code><br />
   | <code>unsafe</code><sup>?</sup> <code>mod</code> <a href="items/../identifiers.html">标识符</a> <code>{</code><br />
        <a href="items/../attributes.html"><em>内部属性</em></a><sup>*</sup><br />
        <a href="items/../items.html"><em>条目</em></a><sup>*</sup><br />
      <code>}</code></p>
</blockquote>
<p>模块是包含零个或多个 <a href="items/../items.html">条目</a> 的容器。</p>
<p>一个 <em>模块条目</em> 是一个用花括号括起来的、以 <code>mod</code> 关键字为前缀的、命名的模块。
模块条目将一个新的命名模块引入到组成 crate 的模块树中。模块可以任意嵌套。</p>
<p>一个模块的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod math {
    type Complex = (f64, f64);
    fn sin(f: f64) -&gt; f64 {
        /* ... */
<span class="boring">      unimplemented!();
</span>    }
    fn cos(f: f64) -&gt; f64 {
        /* ... */
<span class="boring">      unimplemented!();
</span>    }
    fn tan(f: f64) -&gt; f64 {
        /* ... */
<span class="boring">      unimplemented!();
</span>    }
}
<span class="boring">}</span></code></pre></pre>
<p>模块和类型共享相同的命名空间。
在作用域中使用与模块同名的类型是被禁止的：也就是说，类型定义、trait、struct、enum、union、类型参数或 crate 不能隐藏作用域中模块的名称，反之亦然。使用 <code>use</code> 引入作用域的条目也有此限制。</p>
<p><code>unsafe</code> 关键字在 <code>mod</code> 关键字之前语法上是允许的，但在语义层面上被拒绝。
这允许宏消耗语法并使用 <code>unsafe</code> 关键字，然后从 token 流中删除它。</p>
<h2 id="模块源码文件名"><a class="header" href="#模块源码文件名">模块源码文件名</a></h2>
<p>一个没有主体的模块将从外部文件加载。
当模块没有 <code>path</code> 属性时，文件的路径与逻辑 <a href="items/../paths.html">模块路径</a> 相同。
祖先模块路径组件是目录，而模块的内容在一个名为该模块加上 <code>.rs</code> 扩展名的文件中。
例如，下面的模块结构可以有如下的文件系统结构：</p>
<div class="table-wrapper"><table><thead><tr><th>模块路径</th><th>文件系统路径</th><th>文件内容</th></tr></thead><tbody>
<tr><td><code>crate</code></td><td><code>lib.rs</code></td><td><code>mod util;</code></td></tr>
<tr><td><code>crate::util</code></td><td><code>util.rs</code></td><td><code>mod config;</code></td></tr>
<tr><td><code>crate::util::config</code></td><td><code>util/config.rs</code></td><td></td></tr>
</tbody></table>
</div>
<p>模块文件名也可以是模块的名称作为目录，该目录中的内容在名为 <code>mod.rs</code> 的文件中。
上面的例子也可以使用名称为 <code>util/mod.rs</code> 的文件来表达 <code>crate::util</code> 的内容。
不允许同时存在 <code>util.rs</code> 和 <code>util/mod.rs</code>。</p>
<blockquote>
<p><strong>注意</strong>: 注意：在 Rust 1.30 之前，使用 <code>mod.rs</code> 文件是一种加载具有嵌套子项模块的方法。推荐使用新的命名约定，因为它更一致，并避免在项目中有许多名为 <code>mod.rs</code> 的文件。</p>
</blockquote>
<h3 id="path-属性"><a class="header" href="#path-属性"><code>path</code> 属性</a></h3>
<p><code>path</code> 属性可以影响加载外部文件模块时使用的目录和文件。</p>
<p>对于不在内联模块块中的模块上的 <code>path</code> 属性，文件路径相对于源文件所在的目录。
例如，以下代码片段会使用根据其位置而显示的路径:</p>
<!-- ignore: requires external files -->
<pre><code class="language-rust ignore">#[path = &quot;foo.rs&quot;]
mod c;</code></pre>
<div class="table-wrapper"><table><thead><tr><th>源代码文件</th><th><code>c</code> 的文件位置</th><th><code>c</code> 的模块路径</th></tr></thead><tbody>
<tr><td><code>src/a/b.rs</code></td><td><code>src/a/foo.rs</code></td><td><code>crate::a::b::c</code></td></tr>
<tr><td><code>src/a/mod.rs</code></td><td><code>src/a/foo.rs</code></td><td><code>crate::a::c</code></td></tr>
</tbody></table>
</div>
<p>对于嵌套在内联模块块中的 <code>path</code> 属性，文件路径的相对位置取决于 <code>path</code> 属性所在的源文件类型。
&quot;mod-rs&quot; 源文件是根模块 (例如 <code>lib.rs</code> 或 <code>main.rs</code> ) 以及文件名为 <code>mod.rs</code> 的模块。
&quot;non-mod-rs&quot; 源文件是所有其他模块文件。
在 mod-rs 文件中的内联模块块的 <code>path</code> 属性的路径是相对于 mod-rs 文件的目录，包括内联模块作为目录的组件。
对于非 mod-rs 文件，它是相同的，只是路径以非 mod-rs 模块的名称开头的目录。
例如，以下代码片段将根据其位置使用所示路径:</p>
<!-- ignore: requires external files -->
<pre><code class="language-rust ignore">mod inline {
    #[path = &quot;other.rs&quot;]
    mod inner;
}</code></pre>
<div class="table-wrapper"><table><thead><tr><th>源代码文件</th><th><code>inner</code> 的文件位置</th><th><code>inner</code> 的模块路径</th></tr></thead><tbody>
<tr><td><code>src/a/b.rs</code></td><td><code>src/a/b/inline/other.rs</code></td><td><code>crate::a::b::inline::inner</code></td></tr>
<tr><td><code>src/a/mod.rs</code></td><td><code>src/a/inline/other.rs</code></td><td><code>crate::a::inline::inner</code></td></tr>
</tbody></table>
</div>
<p>一个结合了内联模块以及其中嵌套模块的 <code>path</code> 属性的规则的示例 (适用于 mod-rs 和非 mod-rs 文件):</p>
<!-- ignore: requires external files -->
<pre><code class="language-rust ignore">#[path = &quot;thread_files&quot;]
mod thread {
    // 从 `thread_files/tls.rs` 中加载 `local_data` 模块，相对于这个源文件的目录。
    #[path = &quot;tls.rs&quot;]
    mod local_data;
}</code></pre>
<h2 id="模块的属性"><a class="header" href="#模块的属性">模块的属性</a></h2>
<p>模块和所有条目一样，可以接受外部属性 (outer attributes) ，同时也可以接受内部属性 (inner attributes) ，
内部属性可以出现在模块主体的左括号 <code>{</code> 之后，也可以出现在源文件的开头，在可选的 BOM 和 shebang 之后。</p>
<p>内置的对模块有意义的属性包括 <a href="items/../conditional-compilation.html"><code>cfg</code></a> 、 <a href="items/../attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a> 、 <a href="items/../../rustdoc/the-doc-attribute.html"><code>doc</code></a> 、 <a href="items/../attributes/diagnostics.html#lint-check-attributes">lint 检查属性</a> 、 <a href="items/modules.html#the-path-attribute"><code>path</code></a> 和 <a href="items/../names/preludes.html#the-no_implicit_prelude-attribute"><code>no_implicit_prelude</code></a> 。模块还接受宏属性。</p>
<script>
(function() {
    var fragments = {
        "#prelude-items": "../names/preludes.html",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="外部crate声明"><a class="header" href="#外部crate声明">外部crate声明</a></h1>
<blockquote>
<p><strong><sup>语法:<sup></strong><br />
<em>外部Crate</em> :<br />
   <code>extern</code> <code>crate</code> <em>Crate引用</em> <em>As子句</em><sup>?</sup> <code>;</code></p>
<p><em>Crate引用</em> :<br />
   <a href="items/../identifiers.html">标识符</a> | <code>self</code></p>
<p><em>As子句</em> :<br />
   <code>as</code> ( <a href="items/../identifiers.html">标识符</a> | <code>_</code> )</p>
</blockquote>
<p>一个 <em><code>extern crate</code> 声明</em> 指定了一个对外部 crate 的依赖。
外部 crate 然后被绑定到 <code>extern crate</code> 声明中提供的标识符中。
此外，如果 <code>extern crate</code> 出现在 crate 根中，则 crate 名称也会被添加到 <a href="items/../names/preludes.html#extern-prelude">extern 预定义</a> 中，在所有模块中自动处于作用域内。
可以使用 <code>as</code> 子句将导入的 crate 绑定到不同的名称。</p>
<p>编译时，外部 crate 会被解析为一个特定的 <code>soname</code>，并且对于该 <code>soname</code> 的运行时链接需求会在编译时传递给链接器进行加载。
编译时，编译器会扫描其库路径，并根据外部 crate 编译时声明的 <a href="items/../crates-and-source-files.html#the-crate_name-attribute"><code>crate_name</code> 属性</a> 与可选的 <code>crate_name</code> 进行匹配，以解析出 <code>soname</code>。
如果没有提供 <code>crate_name</code>，则会假定一个默认的 <code>name</code> 属性，等于 <code>extern crate</code> 声明中给出的 <a href="items/../identifiers.html">标识符</a>。</p>
<p><code>self</code> 可以被导入作为当前 crate 的绑定，此时必须使用 <code>as</code> 子句来指定绑定的名称。</p>
<p><code>extern crate</code> 声明的三个例子:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">extern crate pcre;

extern crate std; // 等价于: extern crate std as std;

extern crate std as ruststd; // 以另一个名字链接到 'std' 。</code></pre>
<p>在 Rust 中，crate 的命名不允许使用连字符。
然而，Cargo 包允许使用连字符。
如果在 <code>Cargo.toml</code> 中没有指定 crate 名称，则 Cargo 会自动将 <code>-</code> 替换为 <code>_</code>，这个行为详见 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md">RFC 940</a> 。</p>
<p>下面是一个例子:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// 导入Cargo package hello-world
extern crate hello_world; // 连字符替换为下划线</code></pre>
<h2 id="外部-prelude"><a class="header" href="#外部-prelude">外部 Prelude</a></h2>
<p>本节已移至 <a href="items/../names/preludes.html#extern-prelude">Preludes — Extern Prelude</a> 。</p>
<!-- this is to appease the linkchecker, will remove once other books are updated -->
<h2 id="下划线导入"><a class="header" href="#下划线导入">下划线导入</a></h2>
<p>使用 <code>extern crate foo as _</code> 的形式可以声明外部 crate 依赖，但不将其名称绑定到作用域中。
这对于只需要链接而从未被引用的 crate 可能很有用，避免它们被报告为未使用。</p>
<p><a href="items/../macros-by-example.html#the-macro_use-attribute"><code>macro_use</code> 属性</a> 按照惯例导入宏名到 <a href="items/../names/preludes.html#macro_use-prelude"><code>macro_use</code> 预导入</a>。</p>
<h2 id="no_link-属性"><a class="header" href="#no_link-属性"><code>no_link</code> 属性</a></h2>
<p><em><code>no_link</code> 属性</em> 可在 <code>extern crate</code> 条目上指定，以防止将 crate 链接到输出中。
这通常用于加载一个 crate 仅用于访问其宏。</p>
<script>
(function() {
    var fragments = {
        "#extern-prelude": "../names/preludes.html#extern-prelude",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-声明"><a class="header" href="#use-声明">Use 声明</a></h1>
<blockquote>
<p><strong><sup>语法:</sup></strong><br />
<em>Use声明</em> :<br />
   <code>use</code> <em>Use树</em> <code>;</code></p>
<p><em>Use树</em> :<br />
      (<a href="items/../paths.html#simple-paths"><em>简单路径</em></a><sup>?</sup> <code>::</code>)<sup>?</sup> <code>*</code><br />
   | (<a href="items/../paths.html#simple-paths"><em>简单路径</em></a><sup>?</sup> <code>::</code>)<sup>?</sup> <code>{</code> (<em>Use树</em> ( <code>,</code>  <em>Use树</em> )<sup>*</sup> <code>,</code><sup>?</sup>)<sup>?</sup> <code>}</code><br />
   | <a href="items/../paths.html#simple-paths"><em>简单路径</em></a> ( <code>as</code> ( <a href="items/../identifiers.html">标识符</a> | <code>_</code> ) )<sup>?</sup></p>
</blockquote>
<p><em>use 声明</em> 会创建一个或多个本地的名称绑定，和某个其他路径同义。
通常，<code>use</code> 声明用于缩短引用模块条目所需的路径。
这些声明通常出现在 <a href="items/modules.html">模块</a> 和 <a href="items/../expressions/block-expr.html">块</a> 中，通常在顶部。</p>
<p>Use 声明支持许多方便的快捷方式:</p>
<ul>
<li>使用类似通配符的花括号语法同时绑定具有相同前缀的路径列表，例如 <code>use a::b::{c, d, e::f, g::h::i};</code> 。</li>
<li>使用 <code>self</code> 关键字同时绑定具有相同前缀和共同父模块的路径列表，例如 <code>use a::b::{self, c, d::e};</code> 。</li>
<li>重新将目标名称绑定为新的本地名称，使用语法 <code>use p::q::r as x;</code> 。这也可以与前两个功能一起使用: <code>use a::b::{self as ab, c as abc}</code> 。</li>
<li>使用 星号通配符语法绑定与给定前缀匹配的所有路径，例如 <code>use a::b::*;</code> 。</li>
<li>多次嵌套前面的功能组合，例如 <code>use a::b::{self as ab, c, d::{*, e::f}};</code> 。</li>
</ul>
<p>以下关于 <code>use</code> 声明的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::hash_map::{self, HashMap};

fn foo&lt;T&gt;(_: T){}
fn bar(map1: HashMap&lt;String, usize&gt;, map2: hash_map::HashMap&lt;String, usize&gt;){}

fn main() {
    // use 声明也可以存在于函数中
    use std::option::Option::{Some, None};

    // 相当于 'foo(vec![std::option::Option::Some(1.0f64), std::option::Option::None]);'
    foo(vec![Some(1.0f64), None]);

    // `hash_map` 和 `HashMap` 都在作用域内。
    let map1 = HashMap::new();
    let map2 = hash_map::HashMap::new();
    bar(map1, map2);
}</code></pre></pre>
<h2 id="use-可见性"><a class="header" href="#use-可见性"><code>use</code> 可见性</a></h2>
<p>和条目一样，默认情况下， <code>use</code> 声明只在其所在的模块中可见。
同样地，如果在 <code>use</code> 声明前加上 <code>pub</code> 关键字，那么 <code>use</code> 声明就是公共的。
这样的 <code>use</code> 声明就可以用来 <em>重新导出</em> 一个名称。
因此，公共的 <code>use</code> 声明可以将某个公共名称重定向到一个不同的目标定义：甚至是定义在不同模块中的私有规范路径。
如果这样的重定向序列形成了一个循环或无法消除歧义，那么就会导致编译时错误。</p>
<p>一个重新导出的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021">mod quux {
    pub use self::foo::{bar, baz};
    pub mod foo {
        pub fn bar() {}
        pub fn baz() {}
    }
}

fn main() {
    quux::bar();
    quux::baz();
}</code></pre></pre>
<p>在这个例子中，模块 <code>quux</code> 重新导出了在 <code>foo</code> 中定义的两个公共名称。</p>
<h2 id="use-paths"><a class="header" href="#use-paths"><code>use</code> Paths</a></h2>
<blockquote>
<p><strong>注意</strong>: 本节内容不完整。</p>
</blockquote>
<p>以下是一些关于 <code>use</code> 声明能够和不能够正常工作的例子：</p>
<!-- Note: This example works as-is in either 2015 or 2018. -->
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused_imports)]
</span>use std::path::{self, Path, PathBuf};  // good: std 是 crate 名称
use crate::foo::baz::foobaz;    // good: Foo 位于 crate 的根

mod foo {

    pub mod example {
        pub mod iter {}
    }

    use crate::foo::example::iter; // good: foo 位于 crate 的根
//  use example::iter;      // bad 在 2015 版次: 相对路径不允许没有 `self` ; 2018 版good
    use self::baz::foobaz;  // good: Self 引用模块 'foo'
    use crate::foo::bar::foobar;   // good: foo 位于 crate 的根

    pub mod bar {
        pub fn foobar() { }
    }

    pub mod baz {
        use super::bar::foobar; // good: Super 指的是模块 foo
        pub fn foobaz() { }
    }
}

fn main() {}</code></pre></pre>
<blockquote>
<p><strong>版次差异</strong>: 在2015版本中， <code>use</code> 路径还允许访问 crate 根中的条目。使用上面的例子，以下 <code>use</code> 路径在2015版中可以使用但在2018版中无法使用:</p>
<pre><pre class="playground"><code class="language-rust edition2015"><span class="boring">mod foo {
</span><span class="boring">    pub mod example { pub mod iter {} }
</span><span class="boring">    pub mod baz { pub fn foobaz() {} }
</span><span class="boring">}
</span>use foo::example::iter;
use ::foo::baz::foobaz;
<span class="boring">fn main() {}</span></code></pre></pre>
<p>2015版不允许 <code>use</code> 声明引用 <a href="items/../names/preludes.html#extern-prelude">extern 预定义</a> 。因此，在2015中，仍需要使用 <a href="items/extern-crates.html"><code>extern crate</code></a> 声明来引用 <code>use</code> 声明中的外部 crate。从 2018 版开始， <code>use</code> 声明可以像 <code>extern crate</code> 一样指定一个外部 crate 依赖。</p>
<p>在 2018 版本中，如果在作用域内存在与外部 crate 相同的名称，则使用该 crate 名称需要在前面加上 <code>::</code> 以明确选择 crate 名称。这是为了保留与未来潜在更改的兼容性。</p>
<!-- uniform_paths future-proofing -->
<pre><pre class="playground"><code class="language-rust edition2021">// use std::fs; // Error, 有歧义
use ::std::fs;  // 从 std crate 导入，而不是下面的模块。
use self::std::fs as self_fs;  // 导入下面的模块。

mod std {
    pub mod fs {}
}
<span class="boring">fn main() {}</span></code></pre></pre>
</blockquote>
<h2 id="下划线导入-1"><a class="header" href="#下划线导入-1">下划线导入</a></h2>
<p>条目可以通过在路径前加一个下划线的形式 <code>use path as _</code> 导入，而不必绑定到一个名字。
这种方法特别适用于导入 trait ，以便可以使用它的方法而不必导入该 trait 的符号，例如，如果该 trait 的符号可能与另一个符号发生冲突。
另一个例子是链接一个外部 crate ，而不必导入它的名字。</p>
<p>在Rust语言中，使用通配符 (<code>*</code>) 导入的内容将会包括使用下划线 (<code>_</code>) 导入但未被命名的内容。
这些未命名的内容可以被视为一个占位符，它们存在于模块的作用域中，但没有一个明确的名称来引用它们。
如果你在导入模块时使用了下划线来导入某些条目，这些条目将被视为 &quot;无法命名的&quot; 条目，只有使用通配符才能导入它们。</p>
<pre><pre class="playground"><code class="language-rust edition2021">mod foo {
    pub trait Zoo {
        fn zoo(&amp;self) {}
    }

    impl&lt;T&gt; Zoo for T {}
}

use self::foo::Zoo as _;
struct Zoo;  // 下划线导入避免了与此条目的名称冲突。

fn main() {
    let z = Zoo;
    z.zoo();
}</code></pre></pre>
<p>独特的、无法命名的符号是在宏展开后创建的，这样宏就可以安全地发出对 <code>_</code> 导入的多个引用。例如，下面的代码不应该出错:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    ($item: item) =&gt; { $item $item }
}

m!(use std as _;);
// 展开为:
// use std as _;
// use std as _;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数"><a class="header" href="#函数">函数</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>函数</em> :<br />
   <em>函数修饰符组</em> <code>fn</code> <a href="items/../identifiers.html">标识符</a> <a href="items/generics.html"><em>泛型参数组</em></a><sup>?</sup><br />
      <code>(</code> <em>函数参数组</em><sup>?</sup> <code>)</code><br />
      <em>函数返回类型</em><sup>?</sup> <a href="items/generics.html#where-clauses"><em>Where子句</em></a><sup>?</sup><br />
      ( [<em>块表达式</em>] | <code>;</code> )</p>
<p><em>函数修饰符组</em> :<br />
   <code>const</code><sup>?</sup> <code>async</code><sup class="footnote-reference"><a href="#async-edition">1</a></sup><sup>?</sup> <code>unsafe</code><sup>?</sup> (<code>extern</code> <em>Abi</em><sup>?</sup>)<sup>?</sup></p>
<p><em>Abi</em> :<br />
   <a href="items/../tokens.html#string-literals">STRING_LITERAL</a> | <a href="items/../tokens.html#raw-string-literals">RAW_STRING_LITERAL</a></p>
<p><em>函数参数组</em> :<br />
      <em>Self参数</em> <code>,</code><sup>?</sup><br />
   | (<em>Self参数</em> <code>,</code>)<sup>?</sup> <em>函数数参数</em> (<code>,</code> <em>函数数参数</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>Self参数</em> :<br />
   <a href="items/../attributes.html"><em>OuterAttribute</em></a><sup>*</sup> ( <em>简写Self</em> | <em>类型化Self</em> )</p>
<p><em>简写Self</em> :<br />
    (<code>&amp;</code> | <code>&amp;</code> <a href="items/../trait-bounds.html"><em>生命周期</em></a>)<sup>?</sup> <code>mut</code><sup>?</sup> <code>self</code></p>
<p><em>类型化Self</em> :<br />
   <code>mut</code><sup>?</sup> <code>self</code> <code>:</code> <a href="items/../types.html#type-expressions"><em>类型</em></a></p>
<p><em>函数参数</em> :<br />
   <a href="items/../attributes.html"><em>外部属性</em></a><sup>*</sup> (
<em>函数参数模式</em> | <code>...</code> | <a href="items/../types.html#type-expressions"><em>模式</em></a> <sup class="footnote-reference"><a href="#fn-param-2015">2</a></sup>
)</p>
<p><em>函数参数模式</em> :<br />
   <a href="items/../patterns.html"><em>模式非顶层选项</em></a> <code>:</code> ( <a href="items/../types.html#type-expressions"><em>类型</em></a> | <code>...</code> )</p>
<p><em>函数返回类型</em> :<br />
   <code>-&gt;</code> <a href="items/../types.html#type-expressions"><em>类型</em></a></p>
<div class="footnote-definition" id="async-edition"><sup class="footnote-definition-label">1</sup>
<p>在 2015 版中不允许使用 <code>async</code> 限定词。</p>
</div>
<div class="footnote-definition" id="fn-param-2015"><sup class="footnote-definition-label">2</sup>
<p>在 2015 版中，只有在一个 <a href="items/traits.html">trait 条目</a> 的关联函数中才允许使用仅带有类型的函数参数。</p>
</div>
</blockquote>
<p>一个函数包括一个 <a href="items/../expressions/block-expr.html">代码块</a> ，以及一个名称、一组参数和一个输出类型。
除名称外，其他是可选的。函数是用关键字 <code>fn</code> 声明。
函数可以声明一组 <em>输入</em> <a href="items/../variables.html">变量</a> 作为参数，通过这些变量，调用者将参数传递给函数，并且函数的 <em>输出</em> 类型为函数完成时将返回给其调用者的 <a href="items/../types.html#type-expressions">类型</a> 。
如果未显式指定输出类型，则为 <a href="items/../types/tuple.html">单元类型</a> 。</p>
<p>当引用一个函数时，它会产生一个相应的零大小的 <a href="items/../types/function-item.html"><em>函数条目类型</em></a> 的一类 <em>值</em> ，当调用它时会直接调用该函数。</p>
<p>例如，这是一个简单的函数:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn answer_to_life_the_universe_and_everything() -&gt; i32 {
    return 42;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="函数参数"><a class="header" href="#函数参数">函数参数</a></h2>
<p>函数参数是不可拒绝的 <a href="items/../patterns.html">模式</a> ，因此任何在没有 else-less <code>let</code> 绑定中有效的模式在参数中也是有效的:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first((value, _): (i32, i32)) -&gt; i32 { value }
<span class="boring">}</span></code></pre></pre>
<p>如果第一个参数是 <em>Self参数</em> ，则表示该函数是一个 <a href="items/associated-items.html#methods">方法</a> 。
带有 <code>self</code> 参数的函数只能作为 <a href="items/traits.html">trait</a> 或 <a href="items/implementations.html">实现</a> 中的关联函数出现。</p>
<p>具有 <code>...</code> 符号的参数表示是一个 <a href="items/external-blocks.html#variadic-functions">可变参数函数</a> ，且只能作为 <a href="items/external-blocks.html">外部块函数</a> 的最后一个参数。
可变参数可以有一个可选的标识符，例如 <code>args: ...</code> 。</p>
<h2 id="函数体"><a class="header" href="#函数体">函数体</a></h2>
<p>函数的代码块在概念上被包装在一个块中，该块绑定了参数模式，然后 <code>return</code> 函数块的值。
这意味着，如果块的尾表达式被评估，则将返回到调用者。
如常规一样，如果在函数体内有显式的返回表达式，则会立即返回，如果到达该隐式返回，则会被短路。</p>
<p>例如，上面的函数的行为类似于以下写法:</p>
<!-- ignore: example expansion -->
<pre><code class="language-rust ignore">// argument_0是调用者实际传递的第一个参数。
let (value, _) = argument_0;
return {
    value
};</code></pre>
<p>函数没有函数体时以分号结束。这种形式只能出现在 <a href="items/traits.html">trait</a> 或 <a href="items/external-blocks.html">外部块</a> 中。</p>
<h2 id="泛型函数"><a class="header" href="#泛型函数">泛型函数</a></h2>
<p>一种 <em>泛型函数</em> 允许其签名中出现一个或多个 <em>参数化类型</em> 。
每个类型参数必须在一个尖括号包围的、由逗号分隔的列表中显式声明，在函数名之后。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// foo 中 A 和 B 是泛型

fn foo&lt;A, B&gt;(x: A, y: B) {
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>在函数签名和函数体内部，类型参数的名称可以用作类型名。
可以为类型参数指定 <a href="items/traits.html">Trait</a> 约束，以允许在该类型的值上调用该 Trait 的方法。可以使用 <code>where</code> 语法指定这个约束:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Debug;
</span>fn foo&lt;T&gt;(x: T) where T: Debug {
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>当泛型函数被引用时，它的类型根据引用的上下文进行实例化。例如，在这里调用 <code>foo</code> 函数:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;

fn foo&lt;T&gt;(x: &amp;[T]) where T: Debug {
    // details elided
}

foo(&amp;[1, 2]);
<span class="boring">}</span></code></pre></pre>
<p>将用 <code>i32</code> 实例化类型参数 <code>T</code> 。</p>
<p>函数的类型参数还可以在函数名后跟一个后缀 <a href="items/../paths.html">path</a> 组件来明确指定。
如果没有足够的上下文来确定类型参数，则可能需要这样做。例如，<code>mem::size_of::&lt;u32&gt;() == 4</code>。</p>
<h2 id="外部函数修饰"><a class="header" href="#外部函数修饰">外部函数修饰</a></h2>
<p><code>extern</code> 函数修饰符允许提供函数 <em>定义组</em> ，这些函数可以使用特定的 ABI 进行调用：</p>
<!-- ignore: fake ABI -->
<pre><code class="language-rust ignore">extern &quot;ABI&quot; fn foo() { /* ... */ }</code></pre>
<p>这些通常与 <a href="items/external-blocks.html">外部块</a> 条目结合使用，后者提供可以用来调用函数而不提供其定义的函数声明:</p>
<!-- ignore: fake ABI -->
<pre><code class="language-rust ignore">extern &quot;ABI&quot; {
  fn foo(); /* no body */
}
unsafe { foo() }</code></pre>
<p>当在函数条目中省略 <code>&quot;extern&quot; Abi?*</code> 时，ABI 被分配 <code>&quot;Rust&quot;</code> 。例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {}
<span class="boring">}</span></code></pre></pre>
<p>等价于:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;Rust&quot; fn foo() {}
<span class="boring">}</span></code></pre></pre>
<p>函数可以被外部代码调用，使用与 Rust 不同的 ABI 允许提供可以从其他编程语言 (如C) 调用的函数:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 用 &quot;C&quot; ABI声明函数
extern &quot;C&quot; fn new_i32() -&gt; i32 { 0 }

// 用 &quot;stdcall&quot; ABI声明函数
<span class="boring">#[cfg(target_arch = &quot;x86_64&quot;)]
</span>extern &quot;stdcall&quot; fn new_i32_stdcall() -&gt; i32 { 0 }
<span class="boring">}</span></code></pre></pre>
<p>与 <a href="items/external-blocks.html">external block</a> 类似，当使用 <code>extern</code> 关键字但省略了 <code>&quot;ABI&quot;</code> 时，使用的 ABI 默认为 <code>&quot;C&quot;</code> 。例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern fn new_i32() -&gt; i32 { 0 }
let fptr: extern fn() -&gt; i32 = new_i32;
<span class="boring">}</span></code></pre></pre>
<p>等价于:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; fn new_i32() -&gt; i32 { 0 }
let fptr: extern &quot;C&quot; fn() -&gt; i32 = new_i32;
<span class="boring">}</span></code></pre></pre>
<p>函数的 ABI (应用程序二进制接口) 和 Rust 不同的函数的 ABI 不能像 Rust 一样支持展开 (unwind) 方式，因此尝试在这些 ABI 中展开超过函数末尾的部分会导致进程中止。</p>
<blockquote>
<p><strong>注意</strong>: <code>rustc</code> 的 LLVM 后端通过执行非法指令来使进程中止。</p>
</blockquote>
<h2 id="const-函数"><a class="header" href="#const-函数">Const 函数</a></h2>
<p>被 <code>const</code> 修饰的函数是 <a href="items/../const_eval.html#const-functions">常量函数</a> ，同样的构造函数 <a href="items/structs.html">元组结构体</a> 和 <a href="items/enumerations.html">元组变体</a> 也是。 <em>常量函数</em> 可以在 <a href="items/../const_eval.html#const-context">常量上下文</a> 中被调用。</p>
<p><code>const</code> 函数可以使用 <a href="items/functions.html#extern-function-qualifier"><code>extern</code></a> 函数限定符，但是只能使用 <code>&quot;Rust&quot;</code> 和 <code>&quot;C&quot;</code> ABI。</p>
<p>Const 函数不允许是 <a href="items/functions.html#async-functions">async</a> 。</p>
<h2 id="异步函数"><a class="header" href="#异步函数">异步函数</a></h2>
<p>函数可以被标记为 async &quot;异步&quot; 的，这也可以与 <code>unsafe</code> 关键字组合使用。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn regular_example() { }
async unsafe fn unsafe_example() { }
<span class="boring">}</span></code></pre></pre>
<p>异步函数可以标记为 <code>async</code> 。在调用时，异步函数不会立即执行，而是将其参数捕获为一个 future 。当该 future 被轮询时，它会执行函数的主体。</p>
<p>一个 async 异步函数大致等同于一个返回 <a href="items/../types/impl-trait.html"><code>impl Future</code></a> 的函数，并且具有一个 <a href="items/../expressions/block-expr.html#async-blocks"><code>async move</code> 块</a>作为函数体:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Source
async fn example(x: &amp;str) -&gt; usize {
    x.len()
}
<span class="boring">}</span></code></pre></pre>
<p>大致等同于:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::future::Future;
</span>// 去除语法糖
fn example&lt;'a&gt;(x: &amp;'a str) -&gt; impl Future&lt;Output = usize&gt; + 'a {
    async move { x.len() }
}
<span class="boring">}</span></code></pre></pre>
<p>实际的脱糖更加复杂:</p>
<ul>
<li><code>async fn</code> 声明中的所有生命周期参数会被假定为被返回类型所包含。这在上面的展开示例中可以看到，显式地包含了 <code>'a</code> 生命周期。</li>
<li>函数体中的 <a href="items/../expressions/block-expr.html#async-blocks"><code>async move</code> 块</a> 捕获了所有函数参数，包括那些未使用或绑定到 <code>_</code> 模式的参数。
这确保了函数参数以与非异步函数相同的顺序被释放，除了释放操作在完全等待返回的 future 后发生。</li>
</ul>
<p>有关 <code>async</code> 的更多信息，请参见 <a href="items/../expressions/block-expr.html#async-blocks"><code>async</code> 块</a>。</p>
<blockquote>
<p><strong>版本差异</strong>: 异步函数仅在 Rust 2018 开始提供。</p>
</blockquote>
<h3 id="组合-async-和-unsafe"><a class="header" href="#组合-async-和-unsafe">组合 <code>async</code> 和 <code>unsafe</code></a></h3>
<p>在 Rust 中，声明既是 <code>async</code> 又是 <code>unsafe</code> 的函数是合法的。
这样产生的函数是不安全的，不能安全地调用，但它 (像任何异步函数一样) 返回一个 future。
这个 future 是普通的 future，因此在 &quot;await&quot; 它的时候不需要使用 <code>unsafe</code> 上下文。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 返回一个 future ，当被等待时，解除对 `x` 的引用。
//
// 必要条件： `x` 必须是安全的，在产生的 future 完成之前，可以取消引用。
async unsafe fn unsafe_example(x: *const i32) -&gt; i32 {
  *x
}

async fn safe_example() {
    // 初始需要一个 `unsafe` 块来调用这个函数:
    let p = 22;
    let future = unsafe { unsafe_example(&amp;p) };

    // 但这里不需要 `unsafe` 块。这将读取 `p` 的值:
    let q = future.await;
}
<span class="boring">}</span></code></pre></pre>
<p>注意，这个行为是由将函数展开为返回 <code>impl Future</code> 的行为所决定的。
在这个例子中，我们展开的函数是一个 <code>unsafe</code> 函数，但是返回值仍然是一样的。</p>
<p><code>unsafe</code> 关键字在异步函数中的使用方式与其在其他函数中的使用方式相同：它表示该函数对其调用者有一些额外的义务，以确保其安全性。
与任何其他不安全函数一样，这些条件可能会超出初始调用本身的范围。
例如，在上面的代码段中， <code>unsafe_example</code> 函数接受一个指针 <code>x</code> 作为参数，然后 (当等待时) 对该指针进行解引用。
这意味着 <code>x</code> 必须在 future 执行完成之前保持有效，并且调用者有责任确保这一点。</p>
<h2 id="函数的属性"><a class="header" href="#函数的属性">函数的属性</a></h2>
<p>函数可以使用 <a href="items/../attributes.html">外部属性</a> 。 <a href="items/../attributes.html">内部属性</a> 可以直接在函数的 <a href="items/../expressions/block-expr.html">block</a> 里的 <code>{</code> 后面使用。</p>
<p>以下示例展示了在函数中使用内部属性。该函数的文档注释只包含单词 &quot;Example&quot; 。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn documented() {
    #![doc = &quot;Example&quot;]
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>注意: 除了用于 lint ，通常仅在函数条目上使用外部属性是惯用的。</p>
</blockquote>
<p>函数可用的属性包括 <a href="items/../conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a> 、 <a href="items/../conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a> 、 <a href="items/../attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a> 、 <a href="items/../../rustdoc/the-doc-attribute.html"><code>doc</code></a> 、 <a href="items/../abi.html#the-export_name-attribute"><code>export_name</code></a> 、 <a href="items/../abi.html#the-link_section-attribute"><code>link_section</code></a> 、 <a href="items/../abi.html#the-no_mangle-attribute"><code>no_mangle</code></a> 、<a href="items/../attributes/diagnostics.html#lint-check-attributes">代码分析检查属性</a> 、 <a href="items/../attributes/diagnostics.html#the-must_use-attribute"><code>must_use</code></a> 、 <a href="items/../procedural-macros.html">过程宏属性</a> 、 <a href="items/../attributes/testing.html">测试属性</a> 和 <a href="items/../attributes/codegen.html#optimization-hints">优化提示属性</a> 。此外，函数还接受属性宏。</p>
<h2 id="函数参数的属性"><a class="header" href="#函数参数的属性">函数参数的属性</a></h2>
<p>函数参数上允许使用 <a href="items/../attributes.html">外部属性</a> ，其中允许使用的 <a href="items/../attributes.html#built-in-attributes-index">内置属性</a> 仅限于 <code>cfg</code> ， <code>cfg_attr</code> ， <code>allow</code> ， <code>warn</code> ， <code>deny</code> 和 <code>forbid</code>。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn len(
    #[cfg(windows)] slice: &amp;[u16],
    #[cfg(not(windows))] slice: &amp;[u8],
) -&gt; usize {
    slice.len()
}
<span class="boring">}</span></code></pre></pre>
<p>在应用于条目的过程宏属性中使用的惰性辅助属性也是允许的，但是请注意不要将这些惰性属性包含在最终的 <code>TokenStream</code> 中。</p>
<p>例如，以下代码定义了一个名为 <code>some_inert_attribute</code> 的惰性属性，它在任何地方都没有正式定义，
而 <code>some_proc_macro_attribute</code> 过程宏负责检测其是否存在，并将其从输出令牌流中删除。</p>
<!-- ignore: requires proc macro -->
<pre><code class="language-rust ignore">#[some_proc_macro_attribute]
fn foo_oof(#[some_inert_attribute] arg: u8) {
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型别名"><a class="header" href="#类型别名">类型别名</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>类型别名组</em> :<br />
   <code>type</code> <a href="items/../identifiers.html">标识符</a> <a href="items/generics.html"><em>泛型参数组</em></a><sup>?</sup>
( <code>:</code> <a href="items/../trait-bounds.html"><em>类型参数约束组</em></a> )<sup>?</sup>
<a href="items/generics.html#where-clauses"><em>Where子句</em></a><sup>?</sup> ( <code>=</code> <a href="items/../types.html#type-expressions"><em>类型</em></a> <a href="items/generics.html#where-clauses"><em>Where子句</em></a><sup>?</sup>)<sup>?</sup> <code>;</code></p>
</blockquote>
<p><em>类型别名</em> 为现有 <a href="items/../types.html">类型</a> 定义了一个新的名称。类型别名使用关键字 <code>type</code> 进行声明。
每个值都有一个特定的类型，但可以实现多个不同的 trait，或与多个不同的类型约束兼容。</p>
<p>例如，以下代码将类型 <code>Point</code> 定义为类型 <code>(u8, u8)</code> 的同义词，即由两个无符号 8 位整数组成的对应类型：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Point = (u8, u8);
let p: Point = (41, 68);
<span class="boring">}</span></code></pre></pre>
<p>类型别名无法用于限定元组结构体或单元结构体的构造函数。</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyStruct(u32);

use MyStruct as UseAlias;
type TypeAlias = MyStruct;

let _ = UseAlias(5); // OK
let _ = TypeAlias(5); // Doesn't work
<span class="boring">}</span></code></pre></pre>
<p>当类型别名不作为关联类型使用时，必须包含一个 <a href="items/../types.html#type-expressions"><em>类型</em></a> ，不能包含 <a href="items/../trait-bounds.html"><em>类型参数约束组</em></a> 。</p>
<p>在 <a href="items/traits.html">trait</a> 中使用作为 <a href="items/associated-items.html#associated-types">关联类型</a> 的类型别名，不应该包含类型本身的声明 <a href="items/../types.html#type-expressions"><em>类型</em></a> ，但是可以包含类型参数约束声明 <a href="items/../trait-bounds.html"><em>类型参数约束组</em></a> 。</p>
<p>类型别名在 <a href="items/implementations.html#trait-implementations">trait impl</a> 中作为 <a href="items/associated-items.html#associated-types">关联类型</a> 使用时，必须包括 <a href="items/../types.html#type-expressions"><em>类型</em></a> ，但不能包括 <a href="items/../trait-bounds.html"><em>类型参数约束组</em></a> 。</p>
<p>在 <a href="items/implementations.html#trait-implementations">trait impl</a> 中，位于类型别名等号之前的 where 从句 (例如 <code>type TypeAlias&lt;T&gt; where T: Foo = Bar&lt;T&gt;</code> ) 已经被弃用。
位于等号之后的 where 从句 (例如 <code>type TypeAlias&lt;T&gt; = Bar&lt;T&gt; where T: Foo</code> ) 是首选的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构"><a class="header" href="#结构">结构</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>结构体</em> :<br />
      <em>Struct结构体</em><br />
   | <em>元组结构体</em></p>
<p><em>Struct结构体</em> :<br />
   <code>struct</code>
<a href="items/../identifiers.html">标识符</a> 
<a href="items/generics.html"><em>泛型参数组</em></a><sup>?</sup>
<a href="items/generics.html#where-clauses"><em>Where子句</em></a><sup>?</sup>
( <code>{</code> <em>结构体字段组</em><sup>?</sup> <code>}</code> | <code>;</code> )</p>
<p><em>元组结构体</em> :<br />
   <code>struct</code>
<a href="items/../identifiers.html">标识符</a> 
<a href="items/generics.html"><em>泛型参数组</em></a><sup>?</sup>
<code>(</code> <em>元组字段组</em><sup>?</sup> <code>)</code>
<a href="items/generics.html#where-clauses"><em>Where子句</em></a><sup>?</sup>
<code>;</code></p>
<p><em>结构体字段组</em> :<br />
   <em>结构体字段</em> (<code>,</code> <em>结构体字段</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>结构体字段</em> :<br />
   <a href="items/../attributes.html"><em>外部属性</em></a><sup>*</sup><br />
   <a href="items/../visibility-and-privacy.html"><em>可见性</em></a><sup>?</sup><br />
   <a href="items/../identifiers.html">标识符</a> <code>:</code> <a href="items/../types.html#type-expressions"><em>类型</em></a></p>
<p><em>元组字段组</em> :<br />
   <em>元组字段</em> (<code>,</code> <em>元组字段</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>元组字段</em> :<br />
   <a href="items/../attributes.html"><em>外部属性</em></a><sup>*</sup><br />
   <a href="items/../visibility-and-privacy.html"><em>可见性</em></a><sup>?</sup><br />
   <a href="items/../types.html#type-expressions"><em>类型</em></a></p>
</blockquote>
<p><em>结构体</em> 是使用关键字 <code>struct</code> 定义命名的 <a href="items/../types/struct.html">结构体类型</a> 。</p>
<p>以下是 <code>struct</code> 类型的一个示例及其使用:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {x: i32, y: i32}
let p = Point {x: 10, y: 11};
let px: i32 = p.x;
<span class="boring">}</span></code></pre></pre>
<p><em>元组结构体</em> 是一种命名的 [元组类型] ，同样使用关键字 <code>struct</code> 定义。例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point(i32, i32);
let p = Point(10, 11);
let px: i32 = match p { Point(x, _) =&gt; x };
<span class="boring">}</span></code></pre></pre>
<p><em>单元结构体</em> 是一种没有任何字段的结构体，通过完全省略字段列表定义。这样的结构体隐式地定义了一个与其类型相同的常量名称。例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cookie;
let c = [Cookie, Cookie {}, Cookie, Cookie {}];
<span class="boring">}</span></code></pre></pre>
<p>相似于</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cookie {}
const Cookie: Cookie = Cookie {};
let c = [Cookie, Cookie {}, Cookie, Cookie {}];
<span class="boring">}</span></code></pre></pre>
<p>结构体没有精确指定内存布局。可以使用 <a href="items/../type-layout.html#representations"><code>repr</code> 属性</a> 指定特定的布局。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>枚举</em> :<br />
   <code>enum</code>
<a href="items/../identifiers.html">标识符</a> 
<a href="items/generics.html"><em>泛型参数组</em></a><sup>?</sup>
<a href="items/generics.html#where-clauses"><em>Where子句</em></a><sup>?</sup>
<code>{</code> <em>枚举条目组</em><sup>?</sup> <code>}</code></p>
<p><em>枚举条目组</em> :<br />
   <em>枚举条目</em> ( <code>,</code> <em>枚举条目</em> )<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>枚举条目</em> :<br />
   <em>外部属性</em><sup>*</sup> <a href="items/../visibility-and-privacy.html"><em>可见性</em></a><sup>?</sup><br />
   <a href="items/../identifiers.html">标识符</a> ( <em>枚举条目元组</em> | <em>枚举条目结构体</em> )<sup>?</sup>
<em>枚举条目判别式</em><sup>?</sup></p>
<p><em>枚举条目元组</em> :<br />
   <code>(</code> <a href="items/structs.html"><em>元组字段组</em></a><sup>?</sup> <code>)</code></p>
<p><em>枚举条目结构体</em> :<br />
   <code>{</code> [<em>结构体字段组</em>]<sup>?</sup> <code>}</code></p>
<p><em>枚举条目判别式</em> :<br />
   <code>=</code> <a href="items/../expressions.html"><em>表达式</em></a></p>
</blockquote>
<p>一个 <a href="items/../types/enum.html">枚举类型</a> ， 简称枚举 <em>enum</em> ，是一种同时定义了枚举类型和一组构造器 <em>constructors</em> 的命名类型。这些构造器可以用来创建或者匹配相应枚举类型的值。</p>
<p>枚举类型使用关键字 <code>enum</code> 进行声明。</p>
<p>下面是一个 <code>enum</code> 的使用示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Animal {
    Dog,
    Cat,
}

let mut a: Animal = Animal::Dog;
a = Animal::Cat;
<span class="boring">}</span></code></pre></pre>
<p>枚举构造器可以拥有命名的字段或者没有命名的字段:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Animal {
    Dog(String, f64),
    Cat { name: String, weight: f64 },
}

let mut a: Animal = Animal::Dog(&quot;Cocoa&quot;.to_string(), 37.2);
a = Animal::Cat { name: &quot;Spotty&quot;.to_string(), weight: 2.7 };
<span class="boring">}</span></code></pre></pre>
<p>在这个例子中， <code>Cat</code> 是一个 <em>类结构体枚举变体</em> ，而 <code>Dog</code> 则仅称为枚举变体。</p>
<p>没有构造器包含字段的枚举称为 <em><span id="field-less-enum">field-less enum</span></em> &quot;无字段枚举&quot; 。例如，以下是一个无字段枚举:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Fieldless {
    Tuple(),
    Struct{},
    Unit,
}
<span class="boring">}</span></code></pre></pre>
<p>如果一个不包含字段的枚举只包含单元枚举变体，则该枚举称为 <em><span id="unit-only-enum">unit-only enum</span></em> &quot;单元枚举&quot;。例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum {
    Foo = 3,
    Bar = 2,
    Baz = 1,
}
<span class="boring">}</span></code></pre></pre>
<p><span id="custom-discriminant-values-for-fieldless-enumerations"></span></p>
<h2 id="鉴别值"><a class="header" href="#鉴别值">鉴别值</a></h2>
<p>每个枚举实例都有一个 <em>鉴别值</em> ：一个逻辑上与之关联的整数，用来确定它持有的变体。</p>
<p>在 <a href="items/../type-layout.html#the-default-representation">默认表示</a> 下，鉴别值解释为 <code>isize</code> 值。
然而，编译器允许在实际内存布局中使用较小的类型 (或其他区分变体的方式) 。</p>
<h3 id="分配鉴别值"><a class="header" href="#分配鉴别值">分配鉴别值</a></h3>
<h4 id="显式鉴别值"><a class="header" href="#显式鉴别值">显式鉴别值</a></h4>
<p>在两种情况下，可以通过在变体名称后跟 <code>=</code> 和 <a href="items/../const_eval.html#constant-expressions">常量表达式</a> 来明确设置变体的判别式 :</p>
<ol>
<li>
<p>如果该枚举是 &quot;<a href="items/enumerations.html#unit-only-enum">unit-only</a>&quot; 单元枚举 。</p>
</li>
<li>
<p>如果使用 [原始表示] <a href="items/../type-layout.html#primitive-representations">primitive representation</a> 。例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u8)]
enum Enum {
    Unit = 3,
    Tuple(u16),
    Struct {
        a: u8,
        b: u16,
    } = 1,
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h4 id="隐式鉴别值"><a class="header" href="#隐式鉴别值">隐式鉴别值</a></h4>
<p>如果枚举变体的鉴别值没有指定，则它被设置为在声明中前一个变体的鉴别值加1。如果第一个变体的鉴别值未指定，则设置为零。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    Bar,            // 0        第一个未指定，则为0
    Baz = 123,      // 123
    Quux,           // 124      未指定，相比前一个加1
}

let baz_discriminant = Foo::Baz as u32;
assert_eq!(baz_discriminant, 123);
<span class="boring">}</span></code></pre></pre>
<h4 id="限制条件"><a class="header" href="#限制条件">限制条件</a></h4>
<p>当两个变体鉴别值相同时，是一个错误。</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SharedDiscriminantError {
    SharedA = 1,
    SharedB = 1
}

enum SharedDiscriminantError2 {
    Zero,       // 0
    One,        // 1
    OneToo = 1  // 1 (collision with previous!)
}
<span class="boring">}</span></code></pre></pre>
<p>如果先前枚举的鉴别值达到了其类型能够表示的最大值，那么下一个没有指定鉴别值的项将导致错误。</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u8)]
enum OverflowingDiscriminantError {
    Max = 255,
    MaxPlusOne // 将是256，但那会使枚举溢出。
}

#[repr(u8)]
enum OverflowingDiscriminantError2 {
    MaxMinusOne = 254, // 254
    Max,               // 255
    MaxPlusOne         // 将是256，但那会使枚举溢出。
}
<span class="boring">}</span></code></pre></pre>
<h3 id="访问鉴别值"><a class="header" href="#访问鉴别值">访问鉴别值</a></h3>
<h4 id="通过-memdiscriminant"><a class="header" href="#通过-memdiscriminant">通过 <code>mem::discriminant</code></a></h4>
<p><a href="items/../../std/mem/fn.discriminant.html"><code>mem::discriminant</code></a> 返回一个不透明的引用，指向枚举值的鉴别值，可以进行比较。但不能用于获取鉴别值。</p>
<h4 id="转换"><a class="header" href="#转换">转换</a></h4>
<p>如果一个枚举类型是 <a href="items/enumerations.html#unit-only-enum">unit-only</a>  (没有元组和结构的变体) ，那么它的鉴别值可以通过 <a href="items/../expressions/operator-expr.html#semantics">数字强制转换</a> 直接访问；比如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum {
    Foo,
    Bar,
    Baz,
}

assert_eq!(0, Enum::Foo as isize);
assert_eq!(1, Enum::Bar as isize);
assert_eq!(2, Enum::Baz as isize);
<span class="boring">}</span></code></pre></pre>
<p><a href="items/enumerations.html#field-less-enum">无成员的枚举</a> 可以被强制类型转换，如果它们没有显式的鉴别值，或者只有单元变体是显式的。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Fieldless {
    Tuple(),
    Struct{},
    Unit,
}

assert_eq!(0, Fieldless::Tuple() as isize);
assert_eq!(1, Fieldless::Struct{} as isize);
assert_eq!(2, Fieldless::Unit as isize);

#[repr(u8)]
enum FieldlessWithDiscrimants {
    First = 10,
    Tuple(),
    Second = 20,
    Struct{},
    Unit,
}

assert_eq!(10, FieldlessWithDiscrimants::First as u8);
assert_eq!(11, FieldlessWithDiscrimants::Tuple() as u8);
assert_eq!(20, FieldlessWithDiscrimants::Second as u8);
assert_eq!(21, FieldlessWithDiscrimants::Struct{} as u8);
assert_eq!(22, FieldlessWithDiscrimants::Unit as u8);
<span class="boring">}</span></code></pre></pre>
<h4 id="指针转换"><a class="header" href="#指针转换">指针转换</a></h4>
<p>如果枚举指定了 <a href="items/../type-layout.html#primitive-representations">原始表示</a> ，那么可以通过不安全的指针转换来可靠地访问鉴别值:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u8)]
enum Enum {
    Unit,
    Tuple(bool),
    Struct{a: bool},
}

impl Enum {
    fn discriminant(&amp;self) -&gt; u8 {
        unsafe { *(self as *const Self as *const u8) }
    }
}

let unit_like = Enum::Unit;
let tuple_like = Enum::Tuple(true);
let struct_like = Enum::Struct{a: false};

assert_eq!(0, unit_like.discriminant());
assert_eq!(1, tuple_like.discriminant());
assert_eq!(2, struct_like.discriminant());
<span class="boring">}</span></code></pre></pre>
<h2 id="零变体枚举"><a class="header" href="#零变体枚举">零变体枚举</a></h2>
<p>没有变体的枚举被称为 <em>零变体枚举</em> 。由于它们没有有效值，因此不能实例化。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum ZeroVariants {}
<span class="boring">}</span></code></pre></pre>
<p>零变体枚举被认为是 <a href="items/../types/never.html">永不类型</a> 的等效形式，但是它们不能被强制转换为其他类型。</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum ZeroVariants {}
</span>let x: ZeroVariants = panic!();
let y: u32 = x; // 类型不匹配的错误
<span class="boring">}</span></code></pre></pre>
<h2 id="变体可见性"><a class="header" href="#变体可见性">变体可见性</a></h2>
<p>枚举变体在语法上允许使用 <a href="items/../visibility-and-privacy.html"><em>可见性</em></a> 注释，但在验证枚举时，会被拒绝。
这使得可以在使用它们的不同上下文中使用统一的语法来解析条目。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! mac_variant {
    ($vis:vis $name:ident) =&gt; {
        enum $name {
            $vis Unit,

            $vis Tuple(u8, u16),

            $vis Struct { f: u8 },
        }
    }
}

// 空的 `vis` 是允许的。
mac_variant! { E }

// 这是允许的，因为它是在验证之前已删除。
#[cfg(FALSE)]
enum E {
    pub U,
    pub(crate) T(u8),
    pub(super) T { f: String }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="联合体"><a class="header" href="#联合体">联合体</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>联合体</em> :<br />
   <code>union</code> <a href="items/../identifiers.html">标识符</a> <a href="items/generics.html"><em>泛型参数组</em></a><sup>?</sup> <a href="items/generics.html#where-clauses"><em>Where子句</em></a><sup>?</sup>
<code>{</code><a href="items/structs.html"><em>结构体字段组</em></a> <code>}</code></p>
</blockquote>
<p>联合体与结构体声明使用相同的语法，只是将 <code>struct</code> 替换为 <code>union</code>。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
union MyUnion {
    f1: u32,
    f2: f32,
}
<span class="boring">}</span></code></pre></pre>
<p>联合体的关键特性是，所有的字段共享相同的存储空间。
因此，对联合体的一个字段的写操作可能会覆盖其它字段的值，而联合的大小则由其最大字段的大小决定。</p>
<p>联合体字段类型限制为以下类型的子集:</p>
<ul>
<li><code>Copy</code> 类型</li>
<li>引用 (<code>&amp;T</code> 和 <code>&amp;mut T</code> 为任意的 <code>T</code>)</li>
<li><code>ManuallyDrop&lt;T&gt;</code> (为任意的 <code>T</code>)</li>
<li>元组和数组仅允许包含联合体字段类型</li>
</ul>
<p>这个限制确保了联合体字段不需要被丢弃。
与结构体和枚举类似，也可以为联合体实现 <code>Drop</code> trait 来手动定义在释放时发生的行为。</p>
<h2 id="初始化联合体"><a class="header" href="#初始化联合体">初始化联合体</a></h2>
<p>联合体类型的值可以使用与结构体类型相同的语法创建，只不过必须指定一个字段:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span><span class="boring">
</span>let u = MyUnion { f1: 1 };
<span class="boring">}</span></code></pre></pre>
<p>这个表达式创建了一个类型为 <code>MyUnion</code> 的值，并使用字段 <code>f1</code> 初始化了存储。
可以使用与结构体字段相同的语法来访问联合字段。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span><span class="boring">
</span><span class="boring">let u = MyUnion { f1: 1 };
</span>let f = unsafe { u.f1 };
<span class="boring">}</span></code></pre></pre>
<h2 id="读取和写入联合体字段"><a class="header" href="#读取和写入联合体字段">读取和写入联合体字段</a></h2>
<p>联合体没有 &quot;活动字段&quot; 的概念。每次访问联合体时，只会解释用于访问的字段类型的存储。
读取联合体字段按位读取字段类型。
字段可能具有非零偏移量 (除非使用 <a href="items/../type-layout.html#reprc-unions">C表示法</a>) ；在这种情况下，从字段偏移处开始读取位。程序员有责任确保数据在字段类型上是有效的。
未能这样做会导致 <a href="items/../behavior-considered-undefined.html">未定义行为</a> 。例如，通过 <a href="items/../types/boolean.html">布尔类型</a> 字段读取值 <code>3</code> 是未定义行为。
实际上，使用 <a href="items/../type-layout.html#reprc-unions">C表示法</a> 写入并然后读取联合体类似于从用于写入的类型到用于读取的类型的 <a href="items/../../std/mem/fn.transmute.html"><code>transmute</code></a>  &quot;质变&quot;。</p>
<p>因此，所有对联合体字段的读取都必须放在 <code>unsafe</code> 块中:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span><span class="boring">let u = MyUnion { f1: 1 };
</span><span class="boring">
</span>unsafe {
    let f = u.f1;
}
<span class="boring">}</span></code></pre></pre>
<p>通常，使用联合体的代码会在不安全的联合体字段访问周围提供安全的包装器。</p>
<p>相比之下，写入联合体字段是安全的，因为它们只是覆盖任意数据，而不能导致未定义的行为。
(请注意，联合体字段类型永远不会具有粘联的丢弃 ，因此联合体字段写入永远不会隐式丢弃任何内容。)</p>
<h2 id="联合体模式匹配"><a class="header" href="#联合体模式匹配">联合体模式匹配</a></h2>
<p>另一种访问联合体字段的方式是使用模式匹配。
对于联合体字段的模式匹配与结构体模式匹配使用相同的语法，不同的是模式必须指定一个且仅一个字段。
由于模式匹配类似于使用特定字段读取联合体，因此它也必须放在 <code>unsafe</code> 块中。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span><span class="boring">
</span>fn f(u: MyUnion) {
    unsafe {
        match u {
            MyUnion { f1: 10 } =&gt; { println!(&quot;ten&quot;); }
            MyUnion { f2 } =&gt; { println!(&quot;{}&quot;, f2); }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>模式匹配可能将联合体作为更大结构体的字段进行匹配。
特别是在使用 Rust 联合体通过 FFI 实现 C 标记联合时，这允许同时匹配标记和相应字段:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u32)]
enum Tag { I, F }

#[repr(C)]
union U {
    i: i32,
    f: f32,
}

#[repr(C)]
struct Value {
    tag: Tag,
    u: U,
}

fn is_zero(v: Value) -&gt; bool {
    unsafe {
        match v {
            Value { tag: Tag::I, u: U { i: 0 } } =&gt; true,
            Value { tag: Tag::F, u: U { f: num } } if num == 0.0 =&gt; true,
            _ =&gt; false,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="联合体字段的引用"><a class="header" href="#联合体字段的引用">联合体字段的引用</a></h2>
<p>由于联合体字段共享存储空间，因此获得对联合体的一个字段的写访问权限可以给予对其所有其余字段的写访问权限。
借用检查规则必须调整以考虑这一点。
因此，如果联合体的一个字段被借用，则其所有其余字段在相同的生命周期内也被借用。</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span>// ERROR: 不能将 `u` (通过 `u.f2` ) 借为可变的，同一时间不能超过一次。
fn test() {
    let mut u = MyUnion { f1: 1 };
    unsafe {
        let b1 = &amp;mut u.f1;
//                    ---- 第一个可变借用发生在这里 (通过 `u.f1`)
        let b2 = &amp;mut u.f2;
//                    ^^^^ 第二个可变借用发生在这里 (通过 `u.f2`)
        *b1 = 5;
    }
//  -  第一个借用这里结束
    assert_eq!(unsafe { u.f1 }, 5);
}
<span class="boring">}</span></code></pre></pre>
<p>你所看到的是，在很多方面 (除了布局、安全性和所有权) 上，联合体和结构体表现得非常相似，这是由于从结构体继承了语法形式。
这在 Rust 语言的许多未提及方面也同样适用 (例如私有性、名称解析、类型推断、泛型、trait实现、内部实现、一致性、模式检查等等) 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常量条目"><a class="header" href="#常量条目">常量条目</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>常量条目</em> :<br />
   <code>const</code> ( <a href="items/../identifiers.html">标识符</a> | <code>_</code> ) <code>:</code> <a href="items/../types.html#type-expressions"><em>类型</em></a> ( <code>=</code> <a href="items/../expressions.html"><em>表达式</em></a> )<sup>?</sup> <code>;</code></p>
</blockquote>
<p><em>常量条目</em> 是一个可选名称的、不与程序中特定内存位置关联的 <em><a href="items/../const_eval.html#constant-expressions">常量值</a></em> 。
常量在使用时本质上是内联的，这意味着当它们在相关上下文中使用时，它们会被直接复制。
这包括使用来自外部 crate 的常量，以及 非-<a href="items/../special-types-and-traits.html#copy"><code>Copy</code></a> 类型。对同一常量的引用不能保证引用同一内存地址。</p>
<p>常量必须显式指定类型。该类型必须具有 <code>'static</code> 生命周期：初始化器中的任何引用都必须具有 <code>'static</code> 生命周期。</p>
<p>常量可以引用其他常量的地址，在这种情况下，地址将省略适用的生命周期，否则 (在大多数情况下) 默认为 <code>static</code>  生命周期 (请参见 <a href="items/../lifetime-elision.html#static-lifetime-elision">static lifetime elision</a> ) 。
但编译器仍然有自由将常量翻译为多个值，因此引用的地址可能不稳定。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const BIT1: u32 = 1 &lt;&lt; 0;
const BIT2: u32 = 1 &lt;&lt; 1;

const BITS: [u32; 2] = [BIT1, BIT2];
const STRING: &amp;'static str = &quot;bitstring&quot;;

struct BitsNStrings&lt;'a&gt; {
    mybits: [u32; 2],
    mystring: &amp;'a str,
}

const BITS_N_STRINGS: BitsNStrings&lt;'static&gt; = BitsNStrings {
    mybits: BITS,
    mystring: STRING,
};
<span class="boring">}</span></code></pre></pre>
<p>常量表达式只能在 <a href="items/traits.html">trait 定义</a> 中省略。</p>
<h2 id="常量析构函数"><a class="header" href="#常量析构函数">常量析构函数</a></h2>
<p>常量可以包含析构函数。当常量的值超出其作用域时，析构函数将被执行。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TypeWithDestructor(i32);

impl Drop for TypeWithDestructor {
    fn drop(&amp;mut self) {
        println!(&quot;Dropped. Held {}.&quot;, self.0);
    }
}

const ZERO_WITH_DESTRUCTOR: TypeWithDestructor = TypeWithDestructor(0);

fn create_and_drop_zero_with_destructor() {
    let x = ZERO_WITH_DESTRUCTOR;
    // x 在函数结束时丢弃，调用drop。
    // prints &quot;Dropped. Held 0.&quot;.
}
<span class="boring">}</span></code></pre></pre>
<h2 id="未命名常量"><a class="header" href="#未命名常量">未命名常量</a></h2>
<p>与 <a href="items/../items/associated-items.html#associated-constants">关联常量</a> 不同，可以使用下划线代替名称来表示 <a href="items/../glossary.html#free-item">自由</a> 常量无名称。例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const _: () =  { struct _SameNameTwice; };

// OK 虽然和上面的同名:
const _: () =  { struct _SameNameTwice; };
<span class="boring">}</span></code></pre></pre>
<p>与 <a href="items/use-declarations.html#underscore-imports">下划线导入</a> 类似，宏可以安全地在同一作用域内多次发送相同的未命名常量。例如，以下示例不应产生错误:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    ($item: item) =&gt; { $item $item }
}

m!(const _: () = (););
// 这扩展为:
// const _: () = ();
// const _: () = ();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="静态条目"><a class="header" href="#静态条目">静态条目</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>静态条目</em> :<br />
   <code>static</code> <code>mut</code><sup>?</sup> <a href="items/../identifiers.html">标识符</a> <code>:</code> <a href="items/../types.html#type-expressions"><em>类型</em></a>
( <code>=</code> <a href="items/../expressions.html"><em>表达式</em></a> )<sup>?</sup> <code>;</code></p>
</blockquote>
<p><em>静态条目</em> 与 <a href="items/constant-items.html">常量</a> 类似，不同之处在于它表示程序中精确的内存位置。
所有对静态条目的引用都指向同一内存位置。静态条目具有 <code>static</code> 生命周期，其生命周期超过 Rust 程序中的所有其他生命周期。静态条目在程序结束时不会调用 <a href="items/../destructors.html"><code>drop</code></a> 函数。</p>
<p>静态初始化器是一个在编译时计算的 <a href="items/../const_eval.html#constant-expressions">常量表达式</a> 。
静态初始化器可能会引用其他的静态。</p>
<p>非 <code>mut</code> 的静态条目，如果包含的类型不是 <a href="items/../interior-mutability.html">内部可变类型</a> ，则可以被放置在只读内存中。</p>
<p>所有对静态的访问都是安全的，但是对静态有一些限制:</p>
<ul>
<li>该类型必须有 <code>Sync</code> trait ，以允许线程安全的访问。</li>
<li>常量不能引用静态。</li>
</ul>
<p>在 <a href="items/external-blocks.html">外部块</a> 中必须省略静态条目的初始化表达式，并且必须为自由静态条目提供初始化表达式。</p>
<h2 id="静态--泛型"><a class="header" href="#静态--泛型">静态 &amp; 泛型</a></h2>
<p>在泛型作用域中定义的静态条目 (例如在一个泛型实现的默认实现中) 将恰好定义一个静态条目，就好像静态定义从当前作用域被提取到模块中一样。
不会为每个单态化生成一个静态条目。</p>
<p>代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::atomic::{AtomicUsize, Ordering};

trait Tr {
    fn default_impl() {
        static COUNTER: AtomicUsize = AtomicUsize::new(0);
        println!(&quot;default_impl: counter was {}&quot;, COUNTER.fetch_add(1, Ordering::Relaxed));
    }

    fn blanket_impl();
}

struct Ty1 {}
struct Ty2 {}

impl&lt;T&gt; Tr for T {
    fn blanket_impl() {
        static COUNTER: AtomicUsize = AtomicUsize::new(0);
        println!(&quot;blanket_impl: counter was {}&quot;, COUNTER.fetch_add(1, Ordering::Relaxed));
    }
}

fn main() {
    &lt;Ty1 as Tr&gt;::default_impl();
    &lt;Ty2 as Tr&gt;::default_impl();
    &lt;Ty1 as Tr&gt;::blanket_impl();
    &lt;Ty2 as Tr&gt;::blanket_impl();
}</code></pre></pre>
<p>打印</p>
<pre><code class="language-text">default_impl: counter was 0
default_impl: counter was 1
blanket_impl: counter was 0
blanket_impl: counter was 1
</code></pre>
<h2 id="可变静态"><a class="header" href="#可变静态">可变静态</a></h2>
<p>如果静态条目用 <code>mut</code> 关键字声明，那么就程序允许修改它。
Rust 的一个目标是难以出现并发错误，这显然是导致竞态条件或其他错误的一个很大源头。
因此，在读取或写入可变静态变量时，需要使用 <code>unsafe</code> 块。
应该注意确保对可变静态变量的修改，对与运行在同一进程中的其他线程方面是安全的。</p>
<p>可变静态变量仍然非常有用。它们可以与 C 语言库一起使用，并且还可以在 <code>extern</code> 块中绑定来自 C 语言的库。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn atomic_add(_: &amp;mut u32, _: u32) -&gt; u32 { 2 }
</span>
static mut LEVELS: u32 = 0;

// 这违反了没有共享状态的理念，而且这在内部也不能防止竞争，所以这个函数是 `unsafe` 的。
unsafe fn bump_levels_unsafe1() -&gt; u32 {
    let ret = LEVELS;
    LEVELS += 1;
    return ret;
}

// 假设我们有一个 atomic_add 函数，返回旧值，
// 这个函数是 &quot;safe&quot; ，但是返回值的含义可能不是调用者所期望的，所以它仍然被标记为 `unsafe` 。
unsafe fn bump_levels_unsafe2() -&gt; u32 {
    return atomic_add(&amp;mut LEVELS, 1);
}
<span class="boring">}</span></code></pre></pre>
<p>可变静态变量与普通静态变量具有相同的限制，只是类型不必实现 <code>Sync</code> trait。</p>
<h2 id="使用静态或常量"><a class="header" href="#使用静态或常量">使用静态或常量</a></h2>
<p>在选择使用常量条目或静态条目时可能会感到困惑。
通常情况下，应该优先使用常量而非静态条目，除非以下情况之一:</p>
<ul>
<li>需要存储大量的数据</li>
<li>需要静态的单地址特性。</li>
<li>需要内部可变性。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>Trait</em> :<br />
   <code>unsafe</code><sup>?</sup> <code>trait</code> <a href="items/../identifiers.html">标识符</a> 
<a href="items/generics.html"><em>泛型参数组</em></a><sup>?</sup>
( <code>:</code> <a href="items/../trait-bounds.html"><em>类型参数约束组</em></a><sup>?</sup> )<sup>?</sup>
<a href="items/generics.html#where-clauses"><em>Where子句</em></a><sup>?</sup> <code>{</code><br />
     <a href="items/../attributes.html"><em>内部属性</em></a><sup>*</sup><br />
     <a href="items/associated-items.html"><em>关联条目</em></a><sup>*</sup><br />
   <code>}</code></p>
</blockquote>
<p>一个 <em>trait</em> 描述了类型可以实现的抽象接口。这个接口由 <a href="items/associated-items.html">关联条目</a> 组成，包括以下三种类型：</p>
<ul>
<li><a href="items/associated-items.html#associated-functions-and-methods">functions</a> 函数</li>
<li><a href="items/associated-items.html#associated-types">types</a> 类型</li>
<li><a href="items/associated-items.html#associated-constants">constants</a> 常量</li>
</ul>
<p>所有 trait 都定义了一个隐式类型参数 <code>Self</code> ，它指代 &quot;正在实现此接口的类型&quot; 。
Trait 还可以包含其他类型参数。这些类型参数，包括 <code>Self</code> ， 像通常 <a href="items/generics.html">泛型</a> 一样可以受到其他 trait 的约束。</p>
<p>Trait 通过单独的 <a href="items/implementations.html">实现</a> 与具体的类型关联。</p>
<p>Trait 函数可以省略函数体，用分号代替。这表示实现必须定义该函数。
如果 trait 函数定义了函数体，则该定义作为任何未覆盖它的实现的默认值。
类似地，关联常量可以省略等号和表达式，以表示实现必须定义常量值。
关联类型绝不能定义类型，类型只能在实现中指定。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 有定义和无定义的关联trait条目的示例。
trait Example {
    const CONST_NO_DEFAULT: i32;
    const CONST_WITH_DEFAULT: i32 = 99;
    type TypeNoDefault;
    fn method_without_default(&amp;self);
    fn method_with_default(&amp;self) {}
}
<span class="boring">}</span></code></pre></pre>
<p>Trait 函数不允许为 <a href="items/functions.html#async-functions"><code>async</code></a> 或 <a href="items/functions.html#const-functions"><code>const</code></a> 。</p>
<h2 id="trait-约束"><a class="header" href="#trait-约束">Trait 约束</a></h2>
<p>泛型条目可以使用 trait 作为其类型参数的 <a href="items/../trait-bounds.html">约束</a> 。</p>
<h2 id="泛型-trait"><a class="header" href="#泛型-trait">泛型 Trait</a></h2>
<p>为了使 Trait 可以泛化，可以在 Trait 名称后指定类型参数。
这些参数使用与 <a href="items/functions.html#generic-functions">泛型函数</a> 相同的语法表示。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Seq&lt;T&gt; {
    fn len(&amp;self) -&gt; u32;
    fn elt_at(&amp;self, n: u32) -&gt; T;
    fn iter&lt;F&gt;(&amp;self, f: F) where F: Fn(T);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="对象安全"><a class="header" href="#对象安全">对象安全</a></h2>
<p>对象安全的 trait 可以是一个 <a href="items/../types/trait-object.html">trait对象</a> 的基础 trait 。
一个 trait 是 <em>对象安全</em> 的，如果它具有以下 trait (在<a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">RFC 255</a>中定义):</p>
<ul>
<li>所有的 <a href="items/traits.html#supertraits">supertraits</a> 也必须是对象安全的。</li>
<li><code>Sized</code> 不能是 <a href="items/traits.html#supertraits">超级trait</a> 。换句话说，必须不要求 <code>Self: Sized</code> 。</li>
<li>不能有任何关联常量。</li>
<li>不能有任何泛型关联类型。</li>
<li>所有关联函数必须是可从 trait 对象中可派发的，或者是明确不可派发的。
<ul>
<li>可派发函数要求:
<ul>
<li>没有任何类型参数 (允许生命周期参数),</li>
<li>是除接收者类型，不使用 <code>Self</code> 的 <a href="items/associated-items.html#methods">method</a> 。</li>
<li>有具有以下类型的接收器:
<ul>
<li><code>&amp;Self</code> (即 <code>&amp;self</code>)</li>
<li><code>&amp;mut Self</code> (即 <code>&amp;mut self</code>)</li>
<li><a href="items/../special-types-and-traits.html#boxt"><code>Box&lt;Self&gt;</code></a></li>
<li><a href="items/../special-types-and-traits.html#rct"><code>Rc&lt;Self&gt;</code></a></li>
<li><a href="items/../special-types-and-traits.html#arct"><code>Arc&lt;Self&gt;</code></a></li>
<li><a href="items/../special-types-and-traits.html#pinp"><code>Pin&lt;P&gt;</code></a> 其中 <code>P</code> 是上述类型之一</li>
</ul>
</li>
<li>没有 <code>where Self: Sized</code> 绑定 (接收器类型 <code>Self</code> (即 <code>self</code>) 暗指 this) 。</li>
</ul>
</li>
<li>显示不可派发函数要求:
<ul>
<li>有 <code>where Self: Sized</code> 绑定 (接收器类型 <code>Self</code> (即 <code>self</code>) 暗指 this) 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::pin::Pin;
</span>// 对象安全方法的示例。
trait TraitMethods {
    fn by_ref(self: &amp;Self) {}
    fn by_ref_mut(self: &amp;mut Self) {}
    fn by_box(self: Box&lt;Self&gt;) {}
    fn by_rc(self: Rc&lt;Self&gt;) {}
    fn by_arc(self: Arc&lt;Self&gt;) {}
    fn by_pin(self: Pin&lt;&amp;Self&gt;) {}
    fn with_lifetime&lt;'a&gt;(self: &amp;'a Self) {}
    fn nested_pin(self: Pin&lt;Arc&lt;Self&gt;&gt;) {}
}
<span class="boring">struct S;
</span><span class="boring">impl TraitMethods for S {}
</span><span class="boring">let t: Box&lt;dyn TraitMethods&gt; = Box::new(S);
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这个trait是对象安全的，但这些方法不能在 trait 对象上派发。
trait NonDispatchable {
    // 非方法，不能被派发。
    fn foo() where Self: Sized {}
    // Self类型只有在运行时才知道。
    fn returns(&amp;self) -&gt; Self where Self: Sized;
    // `other` 可能是接收者的不同的具体类型。
    fn param(&amp;self, other: Self) where Self: Sized {}
    // 泛型与虚表不兼容。
    fn typed&lt;T&gt;(&amp;self, x: T) where Self: Sized {}
}

struct S;
impl NonDispatchable for S {
    fn returns(&amp;self) -&gt; Self where Self: Sized { S }
}
let obj: Box&lt;dyn NonDispatchable&gt; = Box::new(S);
obj.returns(); // ERROR: 不能调用 Self 返回
obj.param(S);  // ERROR: 不能调用 Self 参数
obj.typed(1);  // ERROR: 不能调用泛型类型
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::rc::Rc;
</span>// 非对象安全 trait 的示例。
trait NotObjectSafe {
    const CONST: i32 = 1;  // ERROR: 不能有关联 const

    fn foo() {}  // ERROR: 关联函数没有 Sized
    fn returns(&amp;self) -&gt; Self; // ERROR: Self 在返回类型
    fn typed&lt;T&gt;(&amp;self, x: T) {} // ERROR: 有泛型类型参数
    fn nested(self: Rc&lt;Box&lt;Self&gt;&gt;) {} // ERROR: 尚不支持嵌套的接收器
}

struct S;
impl NotObjectSafe for S {
    fn returns(&amp;self) -&gt; Self { S }
}
let obj: Box&lt;dyn NotObjectSafe&gt; = Box::new(S); // ERROR
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Self: Sized traits 不是 object-safe.
trait TraitWithSize where Self: Sized {}

struct S;
impl TraitWithSize for S {}
let obj: Box&lt;dyn TraitWithSize&gt; = Box::new(S); // ERROR
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 如果 `Self` 是类型参数，则不是对象安全的。
trait Super&lt;A&gt; {}
trait WithSelf: Super&lt;Self&gt; where Self: Sized {}

struct S;
impl&lt;A&gt; Super&lt;A&gt; for S {}
impl WithSelf for S {}
let obj: Box&lt;dyn WithSelf&gt; = Box::new(S); // ERROR: 不能使用 `Self` 类型的参数
<span class="boring">}</span></code></pre></pre>
<h2 id="超级trait"><a class="header" href="#超级trait">超级trait</a></h2>
<p><strong>超级trait</strong> 是指在一个类型实现某个特定 trait 之前必须实现的一些 trait。
此外，在泛型或 trait 对象受到一个 trait 限定时，它可以访问其超级 trait 的关联条目。</p>
<p>超级 trait 可以通过在 trait 的 <code>Self</code> 类型上使用 trait 约束声明，而超级 trait 的 trait 约束将在其内部声明的 trait 的超级 trait 中传递。trait 不能是自己的超级 trait，这是一个错误。</p>
<p>具有超级 trait 的 trait 被称为其超级 trait 的 <strong>子trait</strong> 。</p>
<p>以下是将 <code>Shape</code> 声明为 <code>Circle</code> 的超级 trait 的示例。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Shape { fn area(&amp;self) -&gt; f64; }
trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
<span class="boring">}</span></code></pre></pre>
<p>以下是相同的示例， 但使用 <a href="items/generics.html#where-clauses">where 子句</a> 。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Shape { fn area(&amp;self) -&gt; f64; }
trait Circle where Self: Shape { fn radius(&amp;self) -&gt; f64; }
<span class="boring">}</span></code></pre></pre>
<p>下面的例子使用 <code>Shape</code> 中的 <code>area</code> 函数为 <code>radius</code> 提供了一个默认的实现。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Shape { fn area(&amp;self) -&gt; f64; }
</span>trait Circle where Self: Shape {
    fn radius(&amp;self) -&gt; f64 {
        // A = pi * r^2
        // 对于代数，
        // r = sqrt(A / pi)
        (self.area() /std::f64::consts::PI).sqrt()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这个例子展示了在一个泛型参数上调用超级 trait 方法。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Shape { fn area(&amp;self) -&gt; f64; }
</span><span class="boring">trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
</span>fn print_area_and_radius&lt;C: Circle&gt;(c: C) {
    // 这里从 `Circle` 的超级trait `Shape` 中调用 area 方法。
    println!(&quot;Area: {}&quot;, c.area());
    println!(&quot;Radius: {}&quot;, c.radius());
}
<span class="boring">}</span></code></pre></pre>
<p>类似地，以下是在 trait 对象上调用超级 trait 方法的示例。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Shape { fn area(&amp;self) -&gt; f64; }
</span><span class="boring">trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
</span><span class="boring">struct UnitCircle;
</span><span class="boring">impl Shape for UnitCircle { fn area(&amp;self) -&gt; f64 { std::f64::consts::PI } }
</span><span class="boring">impl Circle for UnitCircle { fn radius(&amp;self) -&gt; f64 { 1.0 } }
</span><span class="boring">let circle = UnitCircle;
</span>let circle = Box::new(circle) as Box&lt;dyn Circle&gt;;
let nonsense = circle.radius() * circle.area();
<span class="boring">}</span></code></pre></pre>
<h2 id="unsafe-traits"><a class="header" href="#unsafe-traits">Unsafe traits</a></h2>
<p>Trait 中以 <code>unsafe</code> 关键字开头的条目表示实现该 trait 可能是不安全的。
使用正确实现的不安全 trait 是安全的。相应的 <a href="items/implementations.html#trait-implementations">trait 实现</a> 也必须以 <code>unsafe</code> 关键字开头。</p>
<p><a href="items/../special-types-and-traits.html#sync"><code>Sync</code></a> 和 <a href="items/../special-types-and-traits.html#send"><code>Send</code></a> 是 unsafe trait 的示例。</p>
<h2 id="参数模式"><a class="header" href="#参数模式">参数模式</a></h2>
<p>未设置函数或方法的实现体只允许使用 <a href="items/../identifiers.html">标识符</a> 或者 <code>_</code> <a href="items/../patterns.html#wildcard-pattern">通配符模式</a>。
目前允许使用 <code>mut</code> <a href="items/../identifiers.html">标识符</a>，但是这种方式已经被弃用，并且将来会变成一个严格的错误。</p>
<!-- https://github.com/rust-lang/rust/issues/35203 -->
<p>在 2015 版中，trait 函数或方法参数的模式是可选的。</p>
<pre><pre class="playground"><code class="language-rust edition2015"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 2015 版
trait T {
    fn f(i32);  // 不需要参数标识符。
}
<span class="boring">}</span></code></pre></pre>
<p>函数或方法的参数模式种类被限制为以下之一:</p>
<ul>
<li><a href="items/../identifiers.html">标识符</a></li>
<li><code>mut</code> <a href="items/../identifiers.html">标识符</a></li>
<li><a href="items/../patterns.html#wildcard-pattern"><code>_</code></a></li>
<li><code>&amp;</code> <a href="items/../identifiers.html">标识符</a></li>
<li><code>&amp;&amp;</code> <a href="items/../identifiers.html">标识符</a></li>
</ul>
<p>从 2018 版开始，函数或方法参数模式不再是可选的。
此外，只要有函数体，所有不可反驳模式都是允许的。
如果没有函数体，则仍然受到上述限制。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T {
    fn f1((a, b): (i32, i32)) {}
    fn f2(_: (i32, i32));  // 不能使用没有主体的元组模式。
}
<span class="boring">}</span></code></pre></pre>
<h2 id="条目可见性"><a class="header" href="#条目可见性">条目可见性</a></h2>
<p>Trait中的条目在语法上允许添加 <a href="items/../visibility-and-privacy.html"><em>可见性</em></a> 注解，但是当验证该 trait 时，这些注解会被拒绝。
这使得在使用这些条目的不同上下文中，可以使用统一的语法进行解析。
例如，可以使用一个空的 <code>vis</code> 宏片段规格来表示 trait 条目，在其他允许使用可见性的情况下使用该宏规则。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! create_method {
    ($vis:vis $name:ident) =&gt; {
        $vis fn $name(&amp;self) {}
    };
}

trait T1 {
    // 允许使用空的 `vis` 。
    create_method! { method_of_t1 }
}

struct S;

impl S {
    // 这里允许可见性。
    create_method! { pub method_of_s }
}

impl T1 for S {}

fn main() {
    let s = S;
    s.method_of_t1();
    s.method_of_s();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实现"><a class="header" href="#实现">实现</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>实现</em> :<br />
   <em>内部实现</em> | <em>Trait实现</em></p>
<p><em>内部实现</em> :<br />
   <code>impl</code> <a href="items/generics.html"><em>泛型参数组</em></a><sup>?</sup> <a href="items/../types.html#type-expressions"><em>类型</em></a> <a href="items/generics.html#where-clauses"><em>Where子句</em></a><sup>?</sup> <code>{</code><br />
      <a href="items/../attributes.html"><em>内部属性</em></a><sup>*</sup><br />
      <a href="items/associated-items.html"><em>关联条目</em></a><sup>*</sup><br />
   <code>}</code></p>
<p><em>Trait实现</em> :<br />
   <code>unsafe</code><sup>?</sup> <code>impl</code> <a href="items/generics.html"><em>泛型参数组</em></a><sup>?</sup> <code>!</code><sup>?</sup>
<a href="items/../paths.html#paths-in-types"><em>类型路径</em></a> <code>for</code> <a href="items/../types.html#type-expressions"><em>类型</em></a><br />
   <a href="items/generics.html#where-clauses"><em>Where子句</em></a><sup>?</sup><br />
   <code>{</code><br />
      <a href="items/../attributes.html"><em>内部属性</em></a><sup>*</sup><br />
      <a href="items/associated-items.html"><em>关联条目</em></a><sup>*</sup><br />
   <code>}</code></p>
</blockquote>
<p>一个 <em>实现</em> 是将条目与 <em>实现类型</em> 相关联的一个条目。
实现是使用关键字 <code>impl</code> 定义的，并包含属于正在被实现的类型实例或静态类型的函数。</p>
<p>实现有两种类型:</p>
<ul>
<li>内部实现</li>
<li><a href="items/traits.html">trait</a> 实现</li>
</ul>
<h2 id="内部实现"><a class="header" href="#内部实现">内部实现</a></h2>
<p>一份内部实现被定义为以下几个部分的集合: <code>impl</code> 关键字、泛型类型声明、指向命名类型的路径、 where 子句，以及一组用括号包围的可关联条目。</p>
<p>命名类型被称为 <em>实现类型</em> ，可关联的条目是实现类型的 <em>关联条目</em> 。</p>
<p>内部实现将包含的条目与实现类型关联。内部实现可以包含关联函数(包括<a href="items/associated-items.html#methods">方法</a>)和<a href="items/associated-items.html#associated-constants">关联常量</a>。它们不能包含关联类型别名。</p>
<p>到关联条目的 <a href="items/../paths.html">路径</a> 是指到实现类型的任何路径，后面跟着关联条目的标识符作为最终路径组件。</p>
<p>一个类型也可以有多个内部实现。一个实现类型必须在与原始类型定义相同的 crate 中被定义。</p>
<pre><pre class="playground"><code class="language-rust edition2021">pub mod color {
    pub struct Color(pub u8, pub u8, pub u8);

    impl Color {
        pub const WHITE: Color = Color(255, 255, 255);
    }
}

mod values {
    use super::color::Color;
    impl Color {
        pub fn red() -&gt; Color {
            Color(255, 0, 0)
        }
    }
}

pub use self::color::Color;
fn main() {
    // 实现类型的真实路径和 impl 在同一模块。
    color::Color::WHITE;

    // 不同模块中的 Impl 块仍然是通过类型的路径来访问。
    color::Color::red();

    // 也可以将路径重新导出到实现类型。
    Color::red();

    // 不起作用，因为在 `values` 中没有使用 pub 。
    // values::Color::red();
}</code></pre></pre>
<h2 id="trait-实现"><a class="header" href="#trait-实现">Trait 实现</a></h2>
<p><em>trait实现</em> 和内部实现类似，只是可选的泛型类型声明后面是 <a href="items/traits.html">trait</a> ，再跟着 <code>for</code> 关键字，最后是指向命名类型的路径。</p>
<!-- To understand this, you have to back-reference to the previous section. :( -->
<p>该 trait 被称为 <em>实现 trait</em> 。实现类型实现了实现 trait 。</p>
<p>一个 trait 的实现必须定义实现的 trait 声明的所有非默认关联条目，可以重新定义实现的 trait 定义的默认关联条目，但不能定义任何其他条目。</p>
<p>与实现类型相关联的关联条目的路径是 <code>&lt;</code>，后跟到实现类型的路径，然后是 <code>as</code>，后跟到 trait 的路径，之后 <code>&gt;</code> 作为路径组件，然后是关联条目的路径组件。</p>
<p><a href="items/traits.html#unsafe-traits">Unsafe traits</a> 指的是需要在 trait 实现中使用 <code>unsafe</code> 关键字的 trait 。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Copy, Clone)]
</span><span class="boring">struct Point {x: f64, y: f64};
</span><span class="boring">type Surface = i32;
</span><span class="boring">struct BoundingBox {x: f64, y: f64, width: f64, height: f64};
</span><span class="boring">trait Shape { fn draw(&amp;self, s: Surface); fn bounding_box(&amp;self) -&gt; BoundingBox; }
</span><span class="boring">fn do_draw_circle(s: Surface, c: Circle) { }
</span>struct Circle {
    radius: f64,
    center: Point,
}

impl Copy for Circle {}

impl Clone for Circle {
    fn clone(&amp;self) -&gt; Circle { *self }
}

impl Shape for Circle {
    fn draw(&amp;self, s: Surface) { do_draw_circle(s, *self); }
    fn bounding_box(&amp;self) -&gt; BoundingBox {
        let r = self.radius;
        BoundingBox {
            x: self.center.x - r,
            y: self.center.y - r,
            width: 2.0 * r,
            height: 2.0 * r,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="trait-实现一致"><a class="header" href="#trait-实现一致">Trait 实现一致</a></h3>
<p>如果孤儿规则检查失败，存在重复的实现实例，则认为 Trait 实现不连贯的。</p>
<p>两个 trait 实现重叠当且仅当它们的 trait 集合存在非空交集，并且这两个 trait 实现都可以实例化为同一类型。</p>
<!-- This is probably wrong? Source: No two implementations can be instantiable with the same set of types for the input type parameters. -->
<h4 id="唯一性规则"><a class="header" href="#唯一性规则">唯一性规则</a></h4>
<p>规定 <code>impl&lt;P1..=Pn&gt; Trait&lt;T1..=Tn&gt; for T0</code> 只有当以下至少一项为真时， <code>impl</code> 才是有效:</p>
<ul>
<li><code>Trait</code> 是 <a href="items/../glossary.html#local-trait">局部trait</a></li>
<li>全部为
<ul>
<li><code>T0..=Tn</code> 中至少有一个类型必须是 <a href="items/../glossary.html#local-type">局部类型</a> 。让 <code>Ti</code> 成为第一个这样的类型。</li>
<li>在 <code>T0..Ti</code> (不包括 <code>Ti</code> ) 中不得出现 <a href="items/../glossary.html#uncovered-type">未覆盖类型</a> 参数 <code>P1..=Pn</code> 。</li>
</ul>
</li>
</ul>
<p>仅出现 <em>未覆盖</em> 类型参数是受限制的。需要注意的是，在一致性的目的下， <a href="items/../glossary.html#fundamental-type-constructors">基本类型</a> 是特殊的。
<code>Box&lt;T&gt;</code> 中的 <code>T</code> 不被视为被覆盖，而 <code>Box&lt;LocalType&gt;</code> 则被视为是局部类型。</p>
<h2 id="泛型实现"><a class="header" href="#泛型实现">泛型实现</a></h2>
<p>一个实现可以带有 <a href="items/generics.html">泛型参数</a> ，这些参数可以在实现的其余部分中使用。实现参数直接写在 <code>impl</code> 关键字之后。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Seq&lt;T&gt; { fn dummy(&amp;self, _: T) { } }
</span>impl&lt;T&gt; Seq&lt;T&gt; for Vec&lt;T&gt; {
    /* ... */
}
impl Seq&lt;bool&gt; for u32 {
    /* 将整数视为比特序列 */
}
<span class="boring">}</span></code></pre></pre>
<p>如果泛型参数至少在一种类型的关联条目中出现，则该泛型参数 <em>约束</em> 了实现:</p>
<ul>
<li>已实现的 trait ，如果有其一</li>
<li>实现类型</li>
<li>作为一个 <a href="items/associated-items.html#associated-types">关联类型</a> 的 <a href="items/../trait-bounds.html">约束</a> ，该类型包含约束实现的另一个参数</li>
</ul>
<p>类型和常量参数必须始终约束实现。如果在关联类型中使用生命周期，则生命周期必须约束实现。</p>
<p>约束示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait{}
</span><span class="boring">trait GenericTrait&lt;T&gt; {}
</span><span class="boring">trait HasAssocType { type Ty; }
</span><span class="boring">struct Struct;
</span><span class="boring">struct GenericStruct&lt;T&gt;(T);
</span><span class="boring">struct ConstGenericStruct&lt;const N: usize&gt;([(); N]);
</span>// T 通过作为 GenericTrait 的一个参数来约束。
impl&lt;T&gt; GenericTrait&lt;T&gt; for i32 { /* ... */ }

// T 通过作为 GenericTrait 的一个参数来约束。
impl&lt;T&gt; Trait for GenericStruct&lt;T&gt; { /* ... */ }

// 同样地， N 通过作为 ConstGenericStruct 的一个参数来约束
impl&lt;const N: usize&gt; Trait for ConstGenericStruct&lt;N&gt; { /* ... */ }

// T 通过在类型 `U` 的约束中的关联类型来约束，该类型本身是约束 trait 的一个泛型参数。
impl&lt;T, U&gt; GenericTrait&lt;U&gt; for u32 where U: HasAssocType&lt;Ty = T&gt; { /* ... */ }

// 和前面一样，除了类型是 `(U, isize)` 。 `U` 出现在包括 `T` 的类型里面，而不是类型本身。
impl&lt;T, U&gt; GenericStruct&lt;U&gt; where (U, isize): HasAssocType&lt;Ty = T&gt; { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>非约束性的示例:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 其余的都是错误，因为它们的类型或常量参数不受约束。

// T没有约束，因为它根本就没有出现。
impl&lt;T&gt; Struct { /* ... */ }

// 由于同样的原因，N并没有受到约束。
impl&lt;const N: usize&gt; Struct { /* ... */ }

// 在实现中使用 T 并不会约束 impl。
impl&lt;T&gt; Struct {
    fn uses_t(t: &amp;T) { /* ... */ }
}

// 在 U 的绑定中， T 用作关联类型，但 U 没有约束。
impl&lt;T, U&gt; Struct where U: HasAssocType&lt;Ty = T&gt; { /* ... */ }

// T 在绑定中使用，但不是作为一个关联类型，所以它不受约束。
impl&lt;T, U&gt; GenericTrait&lt;U&gt; for u32 where U: GenericTrait&lt;T&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>允许不受约束的生命周期参数的示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct;
</span>impl&lt;'a&gt; Struct {}
<span class="boring">}</span></code></pre></pre>
<p>不允许非约束性生命周期参数的示例:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct;
</span><span class="boring">trait HasAssocType { type Ty; }
</span>impl&lt;'a&gt; HasAssocType for Struct {
    type Ty = &amp;'a Struct;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="实现的属性"><a class="header" href="#实现的属性">实现的属性</a></h2>
<p>实现可以在 <code>impl</code> 关键字之前包含外部 <a href="items/../attributes.html">属性</a> ，在包含关联条目的括号内部包含内部 <a href="items/../attributes.html">属性</a> 。
内部属性必须在任何关联条目之前。在这里有意义的属性是 <a href="items/../conditional-compilation.html"><code>cfg</code></a> ， <a href="items/../attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a> ， <a href="items/../../rustdoc/the-doc-attribute.html"><code>doc</code></a> 和 [检查属性][lint check attributes] 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="外部块"><a class="header" href="#外部块">外部块</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>外部块</em> :<br />
   <code>unsafe</code><sup>?</sup> <code>extern</code> <a href="items/functions.html"><em>Abi</em></a><sup>?</sup> <code>{</code><br />
      <a href="items/../attributes.html"><em>内部属性</em></a><sup>*</sup><br />
      <em>外部条目</em><sup>*</sup><br />
   <code>}</code></p>
<p><em>外部条目</em> :<br />
   <a href="items/../attributes.html"><em>外部属性</em></a><sup>*</sup> (<br />
         <a href="items/../macros.html#macro-invocation"><em>宏调用语句</em></a><br />
      | ( <a href="items/../visibility-and-privacy.html"><em>可见性</em></a><sup>?</sup> ( <a href="items/static-items.html"><em>静态条目</em></a> | <a href="items/functions.html"><em>函数</em></a> ) )<br />
   )</p>
</blockquote>
<p>外部块提供了在当前 crate 中未定义的项的 <em>声明</em> ，并且是 Rust 实现外部函数接口 (FFI) 的基础。这类似于未经检查的导入。</p>
<p>在外部块中允许两种条目声明： <a href="items/functions.html">函数</a> 和 <a href="items/static-items.html">静态变量</a> 。
仅在 <code>unsafe</code> 上下文中才允许调用外部块中声明的函数或访问静态变量。</p>
<p><code>unsafe</code> 关键字在 <code>extern</code> 关键字之前语法上是被允许的，但是在语义层面上会被拒绝。
这使得宏可以消耗语法并使用 <code>unsafe</code> 关键字，然后从令牌流中删除。</p>
<h2 id="函数-1"><a class="header" href="#函数-1">函数</a></h2>
<p>在外部块中声明的函数与其他 Rust 函数的声明方式相同，但是它们不能有函数体，而是以分号结束。
参数中不允许使用模式，只能使用 <a href="items/../identifiers.html">标识符</a> 或 <code>_</code> 。不允许使用函数修饰符 (如 <code>const</code> 、 <code>async</code> 、 <code>unsafe</code> 和 <code>extern</code> )。</p>
<p>外部块中的函数可以像 rust 中定义的函数一样被 rust 代码调用。
Rust 编译器会自动在 Rust ABI 和外部 ABI 之间进行转换。</p>
<p>在外部块中声明的函数隐式地被认为是 <code>unsafe</code> 的。
当将其强转为函数指针时，外部块中声明的函数类型为 <code>unsafe extern &quot;abi&quot; for&lt;'l1, ..., 'lm&gt; fn(A1, ..., An) -&gt; R</code>，
其中 <code>'l1</code> , ... <code>'lm</code> 为它的生命周期参数， <code>A1</code> , ... , <code>An</code> 为它参数的声明类型，而 <code>R</code> 为它返回值的声明类型。</p>
<h2 id="statics"><a class="header" href="#statics">Statics</a></h2>
<p>在外部块中声明的静态变量的方式与 <a href="items/static-items.html">静态变量</a> 在外部块之外声明的方式相同，但它们没有表达式来初始化其值。
访问在外部块中声明的静态条目是不安全的，无论它是否可变，因为无法保证静态内存中的位模式是否有效，因为一些不确定的 (例如 C 语言) 代码负责初始化该静态。</p>
<p>就像 <a href="items/static-items.html">静态变量</a> 在外部块之外声明一样，外部静态变量可以是不可变的也可以是可变的。
在执行任何 Rust 代码之前， <em>必须</em> 先初始化不可变的静态。仅在 Rust 代码读取它之前，将其初始化是不够的。</p>
<h2 id="abi"><a class="header" href="#abi">ABI</a></h2>
<p>默认情况下，外部块假设它们正在调用的库在特定平台上使用标准 C ABI。
可以使用 <code>abi</code> 字符串指定其他 ABI，如下所示:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对于Windows API的接口
extern &quot;stdcall&quot; { }
<span class="boring">}</span></code></pre></pre>
<p>有三个跨平台的 ABI 字符串，保证所有编译器都支持:</p>
<ul>
<li><code>extern &quot;Rust&quot;</code> -- 在 Rust 代码中编写普通 <code>fn foo()</code> 时的默认 ABI。</li>
<li><code>extern &quot;C&quot;</code> -- 与 <code>extern fn foo()</code> 相同，使用你的 C 编译器支持的默认 ABI。</li>
<li><code>extern &quot;system&quot;</code> -- 通常与 <code>extern &quot;C&quot;</code> 相同，但在 Win32 上是 <code>&quot;stdcall&quot;</code> ，在链接到 Windows API 本身时应使用它。</li>
</ul>
<p>此外，还有一些特定于平台的 ABI 字符串:</p>
<ul>
<li><code>extern &quot;cdecl&quot;</code> -- x86_32 C 代码的默认 ABI。</li>
<li><code>extern &quot;stdcall&quot;</code> -- x86_32 上 Win32 API 的默认 ABI。</li>
<li><code>extern &quot;win64&quot;</code> -- x86_64 Windows 上 C 代码的默认 ABI。</li>
<li><code>extern &quot;sysv64&quot;</code> -- 非 Windows x86_64 上 C 代码的默认 ABI。</li>
<li><code>extern &quot;aapcs&quot;</code> -- ARM 的默认 ABI。</li>
<li><code>extern &quot;fastcall&quot;</code> -- <code>fastcall</code> ABI，对应于 MSVC 的 <code>__fastcall</code> 和 GCC 和 clang 的 <code>__attribute__((fastcall))</code> 。</li>
<li><code>extern &quot;vectorcall&quot;</code>-- <code>vectorcall</code> ABI，对应于 MSVC 的 <code>__vectorcall</code> 和 clang 的 <code>__attribute__((vectorcall))</code> 。</li>
</ul>
<h2 id="可变函数"><a class="header" href="#可变函数">可变函数</a></h2>
<p>在外部块中的函数可以通过将 <code>...</code> 指定最后一个参数为变参。
在变参之前必须至少有一个参数。可以使用标识符选择性地指定变量参数。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; {
    fn foo(x: i32, ...);
    fn with_name(format: *const u8, args: ...);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="外部块的属性"><a class="header" href="#外部块的属性">外部块的属性</a></h2>
<p>以下 <a href="items/../attributes.html">属性</a> 控制外部块的行为。</p>
<h3 id="link-属性"><a class="header" href="#link-属性"><code>link</code> 属性</a></h3>
<p><em><code>link</code> 属性</em> 指定编译器为 <code>extern</code> 块中的条目链接的本地库的名称。
它使用 <a href="items/../attributes.html#meta-item-attribute-syntax"><em>元列表名称值字符串</em></a> 语法来指定其输入。
<code>name</code> 键是要链接的本地库的名称。<code>kind</code> 键是可选值，用于指定以下可能值的库类型:</p>
<ul>
<li><code>dylib</code> - 表示动态库。如果未指定 <code>kind</code> ，则为默认值。</li>
<li><code>static</code> - 表示静态库。</li>
<li><code>framework</code> - 表示 macOS 框架。仅适用于 macOS 目标。</li>
<li><code>raw-dylib</code> - 表示动态库，其中编译器将生成要链接的导入库 (详情请参见 <a href="items/external-blocks.html#dylib-versus-raw-dylib"><code>dylib</code> versus <code>raw-dylib</code></a> )。仅适用于 Windows 目标。</li>
</ul>
<p>如果指定了 <code>kind</code> ，必须包括 <code>name</code> 键。</p>
<p>可选的 <code>modifiers</code> 参数是指定要链接的库的链接修饰符的一种方法。
修饰符以逗号分隔的字符串形式指定，每个修饰符前有 <code>+</code> 或 <code>-</code> 前缀，以表明该修饰符已启用或已禁用。
目前不支持在单个 <code>link</code> 属性中指定多个 <code>modifiers</code> 参数，或在同一 <code>modifiers</code> 参数中指定多个相同的修饰符。
例如: <code>#[link(name = &quot;mylib&quot;, kind = &quot;static&quot;, modifiers = &quot;+whole-archive&quot;)]</code> 。 </p>
<p>当从主机环境导入符号时，可以使用 <code>wasm_import_module</code> 键来指定 <code>extern</code> 块中条目的 <a href="https://webassembly.github.io/spec/core/syntax/modules.html">WebAssembly 模块</a> 名称。
如果未指定 <code>wasm_import_module</code> ，则默认模块名为 <code>env</code> 。</p>
<!-- ignore: requires extern linking -->
<pre><code class="language-rust ignore">#[link(name = &quot;crypto&quot;)]
extern {
    // …
}

#[link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)]
extern {
    // …
}

#[link(wasm_import_module = &quot;foo&quot;)]
extern {
    // …
}</code></pre>
<p>可以在空的外部块上添加 <code>link</code> 属性。
您可以使用它来满足代码中其他地方 (包括上游 crates) 的 extern 块的链接要求，而不是为每个 extern 块都添加属性。</p>
<h4 id="链接修饰符-bundle"><a class="header" href="#链接修饰符-bundle">链接修饰符: <code>bundle</code></a></h4>
<p>此修饰符仅与 <code>static</code> 链接类型兼容。使用任何其他类型都会导致编译器错误。</p>
<p>在构建 rlib 或 staticlib 时， <code>+bundle</code> 表示本地静态库将被打包到 rlib 或 staticlib 归档中，然后在链接最终二进制文件时从其中检索出来。</p>
<p>在构建 rlib 时， <code>-bundle</code> 表示本地静态库以名称的方式注册为该 rlib 的依赖项，并且其中的目标文件仅在链接最终二进制文件时包含，文件搜索也在最终链接期间按该名称执行。<br />
在构建 staticlib 时， <code>-bundle</code> 表示本地静态库不会被包含在档案中，某些更高级别的构建系统需要在链接最终二进制文件时稍后添加它。</p>
<p>当构建其他目标(如可执行文件或动态库)时，此修饰符不起作用。</p>
<p>修饰符的默认值是 <code>+bundle</code> 。</p>
<p>关于这个修饰符的更多实现细节可在 <a href="items/../../rustc/command-line-arguments.html#linking-modifiers-bundle">rustc 文档 <code>bundle</code></a> 找到 。</p>
<h4 id="链接修饰符-whole-archive"><a class="header" href="#链接修饰符-whole-archive">链接修饰符: <code>whole-archive</code></a></h4>
<p>此修饰符仅与 <code>static</code> 链接类型兼容。使用任何其他类型都会导致编译器错误。</p>
<p><code>+whole-archive</code> 表示静态库作为整个归档进行链接，而不会丢弃任何对象文件。</p>
<p>这个修饰符的默认值是 <code>-whole-archive</code> 。</p>
<p>关于这个修改器的更多实现细节可在 <a href="items/../../rustc/command-line-arguments.html#linking-modifiers-whole-archive">rustc 文档 <code>whole-archive</code></a> 中找到。</p>
<h3 id="链接修饰符-verbatim"><a class="header" href="#链接修饰符-verbatim">链接修饰符: <code>verbatim</code></a></h3>
<p>此修饰符与所有链接类型兼容。</p>
<p><code>+verbatim</code> 表示 rustc 本身不会为库名称添加任何目标指定的库前缀或后缀 (如 <code>lib</code> 或 <code>.a</code> ) ，并尝试尽可能要求链接器也是如此。</p>
<p><code>-verbatim</code> 表示 rustc 将在将库名称传递给链接器之前添加特定目标的前缀和后缀，且不会阻止链接器隐式添加它。</p>
<p>这个修饰符的默认值是 <code>-verbatim</code> 。</p>
<p>关于这个修饰符的更多实现细节可在 <a href="items/../../rustc/command-line-arguments.html#linking-modifiers-verbatim">rustc 文档 <code>verbatim</code></a> 中找到。</p>
<h4 id="dylib-相比-raw-dylib"><a class="header" href="#dylib-相比-raw-dylib"><code>dylib</code> 相比 <code>raw-dylib</code></a></h4>
<p>在 Windows 上，链接动态库需要向链接器提供导入库：这是一个特殊的静态库，以这样一种方式声明动态库导出的所有符号，使得链接器知道它们必须在运行时动态加载。</p>
<p>指定 <code>kind = &quot;dylib&quot;</code> 会指示 Rust 编译器基于 <code>name</code> 键链接导入库。
然后，链接器将使用其正常的库解析逻辑来找到该导入库。另外，指定 <code>kind = &quot;raw-dylib&quot;</code> 会指示编译器在编译期间生成一个导入库，并提供给链接器。</p>
<p>只有在 Windows 上才支持 <code>raw-dylib</code>，不支持 32 位 x86 ( <code>target_arch=&quot;x86&quot;</code> ) 。将其用于针对其他平台或 Windows 上的 x86 时将导致编译器错误。</p>
<h3 id="link_name-属性"><a class="header" href="#link_name-属性"><code>link_name</code> 属性</a></h3>
<p>在 <code>extern</code> 块内的声明上可以指定 <em><code>link_name</code> 属性</em> ，以指示要为给定函数或静态导入的符号。
使用 <a href="items/../attributes.html#meta-item-attribute-syntax"><em>元名称值字符串</em></a> 语法来指定符号的名称。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern {
    #[link_name = &quot;actual_symbol_name&quot;]
    fn name_in_rust();
}
<span class="boring">}</span></code></pre></pre>
<p>将此属性与 <code>link_ordinal</code> 属性一起使用会导致编译器错误。</p>
<h3 id="link_ordinal-属性"><a class="header" href="#link_ordinal-属性"><code>link_ordinal</code> 属性</a></h3>
<p>可以在 <code>extern</code> 块内的声明上应用 <em><code>link_ordinal</code> 属性</em>，以指示生成要链接的导入库时要使用的数字序数。 
在 Windows 上，每个动态库导出的符号都有一个唯一的编号，可以在加载库时使用该编号查找该符号，而不必通过名称查找它。</p>
<div class="warning">
<p>警告：<code>link_ordinal</code> 只应在符号的序数已知为稳定时使用：如果没有在构建其所在二进制文件时显式设置符号的序数，则将自动分配一个序数，而该分配的序数可能会在二进制文件的不同构建之间发生变化。</p>
</div>
<!-- ignore: Only works on x86 Windows -->
<pre><code class="language-rust ignore">#[link(name = &quot;exporter&quot;, kind = &quot;raw-dylib&quot;)]
extern &quot;stdcall&quot; {
    #[link_ordinal(15)]
    fn imported_function_stdcall(i: i32);
}</code></pre>
<p>此属性仅与 <code>raw-dylib</code> 链接类型一起使用。使用任何其他类型都会导致编译器错误。</p>
<p>将此属性与 <code>link_name</code> 属性一起使用将导致编译器错误。</p>
<h3 id="函数参数的属性-1"><a class="header" href="#函数参数的属性-1">函数参数的属性</a></h3>
<p>外部函数参数的属性遵循与 <a href="items/functions.html#attributes-on-function-parameters">常规函数参数</a> 相同的规则和限制。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型参数"><a class="header" href="#泛型参数">泛型参数</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>泛型参数组</em> :<br />
      <code>&lt;</code> <code>&gt;</code><br />
    | <code>&lt;</code> (<em>泛型参数</em> <code>,</code>)<sup>*</sup> <em>泛型参数</em> <code>,</code><sup>?</sup> <code>&gt;</code></p>
<p><em>泛型参数</em> :<br />
   <a href="items/../attributes.html"><em>外部属性</em></a><sup>*</sup> ( <em>生命周期参数</em> | <em>类型参数</em> | <em>常量参数</em> )</p>
<p><em>生命周期参数</em> :<br />
   <a href="items/../tokens.html#lifetimes-and-loop-labels">生命周期或标签</a> ( <code>:</code> <a href="items/../trait-bounds.html"><em>生命周期约束组</em></a> )<sup>?</sup></p>
<p><em>类型参数</em> :<br />
   <a href="items/../identifiers.html">标识符</a>( <code>:</code> <a href="items/../trait-bounds.html"><em>类型参数约束组</em></a><sup>?</sup> )<sup>?</sup> ( <code>=</code> <a href="items/../types.html#type-expressions"><em>类型</em></a> )<sup>?</sup></p>
<p><em>常量参数</em>:<br />
   <code>const</code> <a href="items/../identifiers.html">标识符</a> <code>:</code> <a href="items/../types.html#type-expressions"><em>类型</em></a> ( <code>=</code> <em><a href="items/../expressions/block-expr.html">块</a></em> | <a href="items/../identifiers.html">标识符</a> | -<sup>?</sup><a href="items/../expressions/literal-expr.html">字面值</a> )<sup>?</sup></p>
</blockquote>
<p><a href="items/functions.html">函数</a>、 <a href="items/type-aliases.html">类型别名</a> 、 <a href="items/structs.html">结构体</a> 、 <a href="items/enumerations.html">枚举</a> 、 <a href="items/unions.html">联合体</a> 、 <a href="items/traits.html">traits</a>和 <a href="items/implementations.html">实现</a> 可以通过类型、常量和生命周期参数 <em>泛型化</em> 。这些参数在尖括号 <span class="parenthetical"> (<code>&lt;...&gt;</code>) </span> 中列出，通常紧跟在条目名称之后，在其定义之前。对于没有名称的实现，它们直接在 <code>impl</code> 之后。泛型参数的顺序仅限于先生命周期参数，然后交替出现类型和常量参数。</p>
<p>一些带有类型、常量和生命周期参数的条目的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a, T&gt;() {}
trait A&lt;U&gt; {}
struct Ref&lt;'a, T&gt; where T: 'a { r: &amp;'a T }
struct InnerArray&lt;T, const N: usize&gt;([T; N]);
struct EitherOrderWorks&lt;const N: bool, U&gt;(U);
<span class="boring">}</span></code></pre></pre>
<p>泛型参数在它们声明的条目定义中是有效的。根据 <a href="items/../statements.html#item-declarations">条目声明</a> 所述，它们不在函数体中声明的条目作用域内。</p>
<p><a href="items/../types/pointer.html#shared-references-">引用</a> 、 <a href="items/../types/pointer.html#raw-pointers-const-and-mut">原始指针</a> 、 <a href="items/../types/array.html">数组</a> 、 <a href="items/../types/slice.html">切片</a> 、 <a href="items/../types/tuple.html">元组</a> ， 和 <a href="items/../types/function-pointer.html">函数指针</a> 也有生命周期或类型参数，但不是用路径语法来引用。</p>
<h3 id="常量泛型"><a class="header" href="#常量泛型">常量泛型</a></h3>
<p><em>常量泛型参数</em> 允许条目对常量值进行泛型。
const 标识符引入了常量参数的名称，并且必须使用给定类型的值来实例化所有条目实例。</p>
<!-- TODO: update above to say "introduces a name in the [value namespace]"
    once namespaces are added. -->
<p>仅允许的常量参数类型是 <code>u8</code> 、 <code>u16</code> 、 <code>u32</code> 、 <code>u64</code> 、 <code>u128</code> 、 <code>usize</code> 、<code>i8</code> 、 <code>i16</code> 、 <code>i32</code> 、 <code>i64</code> 、 <code>i128</code> 、 <code>isize</code> 、 <code>char</code> 、 <code>bool</code>.</p>
<p>常量参数可以在任何 <a href="items/constant-items.html">常量条目</a> 可用的地方使用，但是当它们用于 <a href="items/../types.html">类型</a> 或 <a href="items/../expressions/array-expr.html">数组重复表达式</a> 时，必须是独立的 (如下所述) 。也就是说，它们允许出现在以下位置:</p>
<ol>
<li>作为有关条目签名的一部分的任何类型应用 const 。</li>
<li>作为定义 <a href="items/associated-items.html#associated-constants">关联常量</a> 或作为 <a href="items/associated-items.html#associated-types">关联类型</a> 参数的常量表达式的一部分。</li>
<li>作为条目中任何函数体中运行时表达式中的值。</li>
<li>作为条目中任何函数体中使用的任何类型的参数。</li>
<li>作为条目字段类型的一部分。</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 可以使用常量泛型参数的例子。

// 用于条目本身签名。
fn foo&lt;const N: usize&gt;(arr: [i32; N]) {
    // 用作函数体中的类型。
    let x: [i32; N];
    // 用作表达式。
    println!(&quot;{}&quot;, N * 2);
}

// 用作结构的字段。
struct Foo&lt;const N: usize&gt;([i32; N]);

impl&lt;const N: usize&gt; Foo&lt;N&gt; {
    // 用作关联常量。
    const CONST: usize = N * 4;
}

trait Trait {
    type Output;
}

impl&lt;const N: usize&gt; Trait for Foo&lt;N&gt; {
    // 用作关联类型。
    type Output = [i32; N];
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不能使用常量泛型参数的例子。
fn foo&lt;const N: usize&gt;() {
    // 不能在函数体中的条目定义上使用。
    const BAD_CONST: [usize; N] = [1; N];
    static BAD_STATIC: [usize; N] = [1; N];
    fn inner(bad_arg: [usize; N]) {
        let bad_value = N * 2;
    }
    type BadAlias = [usize; N];
    struct BadStruct([usize; N]);
}
<span class="boring">}</span></code></pre></pre>
<p>作为进一步的限制，常量参数只能出现在 <a href="items/../types.html">类型</a> 或 <a href="items/../expressions/array-expr.html">数组重复表达式</a> 内部作为独立的参数。
在这些上下文中，它们只能用作单个段 <a href="items/../expressions/path-expr.html">路径表达式</a> ，可能包含在 <a href="items/../expressions/block-expr.html">块</a> 中 (如 <code>N</code> 或 <code>{N}</code> ) 。也就是说，它们不能与其他表达式结合使用。</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不可以使用常量参数的例子。

// 不允许在其他类型的表达式中组合，比如这里的返回类型中的算术表达式。
fn bad_function&lt;const N: usize&gt;() -&gt; [u8; {N + 1}] {
    // 同样不允许用于数组重复表达式。
    [1; {N + 1}]
}
<span class="boring">}</span></code></pre></pre>
<p><a href="items/../paths.html">路径</a> 中的常量参数指定用于该条目的常量值。
参数必须是为常量参数指定的类型的 <a href="items/../const_eval.html#constant-expressions">常量表达式</a> 。
除非它是单个路径段 (<a href="items/../identifiers.html">标识符</a>) 或 <a href="items/../expressions/literal-expr.html">字面值</a> (可能以 <code>-</code> 令牌开头) ，否则常量表达式必须是 <a href="items/../expressions/block-expr.html">块表达式</a> (用大括号括起来) 。</p>
<blockquote>
<p><strong>注意</strong>: 这种句法限制是必要的，以避免在解析类型内的表达式时需要无限前瞻。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn double&lt;const N: i32&gt;() {
    println!(&quot;doubled: {}&quot;, N * 2);
}

const SOME_CONST: i32 = 12;

fn example() {
    // const参数的使用示例。
    double::&lt;9&gt;();
    double::&lt;-123&gt;();
    double::&lt;{7 + 8}&gt;();
    double::&lt;SOME_CONST&gt;();
    double::&lt;{ SOME_CONST + 5 }&gt;();
}
<span class="boring">}</span></code></pre></pre>
<p>当一个泛型参数可以同时被解析为类型或常量参数时，它将总是被解析为类型参数。
将该参数放在块表达式中可以强制将其解释为常量参数。</p>
<!-- TODO: Rewrite the paragraph above to be in terms of namespaces, once
    namespaces are introduced, and it is clear which namespace each parameter
    lives in. -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type N = u32;
struct Foo&lt;const N: usize&gt;;
// 以下是一个错误，因为 `N` 被解释为类型别名 `N` 。
fn foo&lt;const N: usize&gt;() -&gt; Foo&lt;N&gt; { todo!() } // ERROR
// 可以用大括号包起来，强制解释为 `N` 常量参数。
fn bar&lt;const N: usize&gt;() -&gt; Foo&lt;{ N }&gt; { todo!() } // ok
<span class="boring">}</span></code></pre></pre>
<p>与类型和生命周期参数不同，常量参数可以在不在参数化条目内部使用的情况下声明，但在实现中除外，如 <a href="items/implementations.html#generic-implementations">泛型实现</a> 所述：</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ok
struct Foo&lt;const N: usize&gt;;
enum Bar&lt;const M: usize&gt; { A, B }

// ERROR: unused parameter
struct Baz&lt;T&gt;;
struct Biz&lt;'a&gt;;
struct Unconstrained;
impl&lt;const N: usize&gt; Unconstrained {}
<span class="boring">}</span></code></pre></pre>
<p>在解析 trait 约束职责时，在确定约束是否满足时，不考虑所有常量参数的实现是否穷尽。
例如，即使为 <code>bool</code> 类型实现了所有可能的常量值，但仍然会出错，因为 trait 约束未满足:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;const B: bool&gt;;
trait Bar {}
impl Bar for Foo&lt;true&gt; {}
impl Bar for Foo&lt;false&gt; {}

fn needs_bar(_: impl Bar) {}
fn generic&lt;const B: bool&gt;() {
    let v = Foo::&lt;B&gt;;
    needs_bar(v); // ERROR: trait 约束 `Foo&lt;B&gt;: Bar` 不满足
}
<span class="boring">}</span></code></pre></pre>
<h2 id="where-子句"><a class="header" href="#where-子句">Where 子句</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>Where子句</em> :<br />
   <code>where</code> ( <em>Where子句条目</em> <code>,</code> )<sup>*</sup> <em>Where子句条目</em> <sup>?</sup></p>
<p><em>Where子句条目</em> :<br />
      <em>生命周期Where子句条目</em><br />
   | <em>类型约束Where子句条目</em></p>
<p><em>生命周期Where子句条目</em> :<br />
   <a href="items/../trait-bounds.html"><em>生命周期</em></a> <code>:</code> <a href="items/../trait-bounds.html"><em>生命周期约束组</em></a></p>
<p><em>类型约束Where子句条目</em> :<br />
   [<em>对于生命周期组</em>]<sup>?</sup> <a href="items/../types.html#type-expressions"><em>类型</em></a> <code>:</code> <a href="items/../trait-bounds.html"><em>类型参数约束组</em></a><sup>?</sup></p>
</blockquote>
<p><em>where 子句</em> 提供了另一种方法来指定类型和生命周期参数的约束，以及指定非类型参数的类型约束的方法。</p>
<p><code>for</code> 关键字可用于引入 <a href="items/../trait-bounds.html#higher-ranked-trait-bounds">更高级的生命周期</a> 。它仅允许 <a href="items/generics.html#generic-parameters"><em>生命周期参数</em></a> 参数。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A&lt;T&gt;
where
    T: Iterator,            // 可以用 A&lt;T: Iterator&gt; 代替
    T::Item: Copy,          // 绑定在一个关联类型上
    String: PartialEq&lt;T&gt;,   // 绑定在 `String` 上，使用类型参数
    i32: Default,           // 允许的，但没有用
{
    f: T,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="属性"><a class="header" href="#属性">属性</a></h2>
<p>泛型生命周期和类型参数允许在它们上面使用 <a href="items/../attributes.html">属性</a> 。在这个位置上没有内置属性起作用，尽管自定义派生属性可能会赋予其意义。</p>
<p>此示例展示使用自定义衍生属性来修改泛型参数的含义。</p>
<!-- ignore: requires proc macro derive -->
<pre><code class="language-rust ignore">// 假设 MyFlexibleClone 衍生声明了 `my_flexible_clone` 作为它所理解的一个属性。
#[derive(MyFlexibleClone)]
struct Foo&lt;#[my_flexible_clone(unbounded)] H&gt; {
    a: *const H
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关联条目"><a class="header" href="#关联条目">关联条目</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>关联条目</em> :<br />
   <a href="items/../attributes.html"><em>外部属性</em></a><sup>*</sup> (<br />
         [<em>宏调用语句</em>]<br />
      | ( <a href="items/../visibility-and-privacy.html"><em>可见性</em></a><sup>?</sup> ( <a href="items/type-aliases.html"><em>类型别名</em></a> | <a href="items/constant-items.html"><em>常量条目</em></a> | <a href="items/functions.html"><em>函数</em></a> ) )<br />
   )</p>
</blockquote>
<p><em>关联条目</em> 是在 Rust 语言中通过 <a href="items/traits.html">traits</a> 或 <a href="items/implementations.html">实现</a> 中的类型定义的条目。
它们被称为关联条目，是因为它们是在关联类型上定义的。
关联条目是你可以在模块中声明的条目的子集，具体包括 <a href="items/associated-items.html#associated-functions-and-methods">关联函数</a> (包括方法)、 <a href="items/associated-items.html#associated-types">关联类型</a> 和 <a href="items/associated-items.html#associated-constants">关联常量</a>。</p>
<p>关联条目在关联类型中定义，通常是与关联类型有逻辑关系。
例如， <code>is_some</code> 方法与 <code>Option</code> 类型本身有密切的关系，因此应该定义为关联条目。</p>
<p>每个关联条目都有两种类型：定义和声明。定义包含实际的实现，而声明只声明定义的签名。</p>
<p>在 Rust 语言中，trait 的声明和在泛型类型上可用的内容构成了 trait 的约定。</p>
<h2 id="关联函数和方法"><a class="header" href="#关联函数和方法">关联函数和方法</a></h2>
<p><em>关联函数</em> 是与类型相关的 <a href="items/functions.html">函数</a> 。</p>
<p><em>关联函数声明</em> 声明了关联函数定义的签名。它采用函数条目的形式书写，但函数体被替换为 <code>;</code> 。</p>
<p>标识符是函数的名称。关联函数的泛型、参数列表、返回类型和 where 子句必须与关联函数声明相同。</p>
<p><em>关联函数定义</em> 是定义与另一种类型关联的函数。它的写法与 <a href="items/../types/function-item.html">函数条目</a> 相同。</p>
<p>一个常见的关联函数例子是 <code>new</code> 函数，它返回与关联函数关联的类型的值。</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Struct {
    field: i32
}

impl Struct {
    fn new() -&gt; Struct {
        Struct {
            field: 0i32
        }
    }
}

fn main () {
    let _struct = Struct::new();
}</code></pre></pre>
<p>当关联函数在 trait 中声明时，可以使用 <a href="items/../paths.html">路径</a> 调用该函数，该路径是附加 trait 名称的路径。
当发生这种情况时，它会替换为 <code>&lt;_ as Trait&gt;::function_name</code>。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Num {
    fn from_i32(n: i32) -&gt; Self;
}

impl Num for f64 {
    fn from_i32(n: i32) -&gt; f64 { n as f64 }
}

// 在这种情况下，这4个都是等价的。
let _: f64 = Num::from_i32(42);
let _: f64 = &lt;_ as Num&gt;::from_i32(42);
let _: f64 = &lt;f64 as Num&gt;::from_i32(42);
let _: f64 = f64::from_i32(42);
<span class="boring">}</span></code></pre></pre>
<h3 id="方法"><a class="header" href="#方法">方法</a></h3>
<p>第一个参数名为 <code>self</code> 的关联函数称为 <em>方法</em> ，可以使用 <a href="items/../expressions/method-call-expr.html">方法调用运算符</a> 例如 <code>x.foo()</code> ，以及通常的函数调用符号进行调用。</p>
<p>如果指定了 <code>self</code> 参数的类型，则限制解析为以下语法生成的类型之一 (其中 <code>'lt</code> 表示任意生命周期):</p>
<pre><code class="language-text">P = &amp;'lt S | &amp;'lt mut S | Box&lt;S&gt; | Rc&lt;S&gt; | Arc&lt;S&gt; | Pin&lt;P&gt;
S = Self | P
</code></pre>
<p>在这个语法中，<code>Self</code> 表示解析为实现类型的类型。
这也可以包括上下文类型别名 <code>Self </code>、其他类型别名或解析为实现类型的关联类型推导。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::pin::Pin;
</span>// 在结构 `Example` 上实现方法的例子。
struct Example;
type Alias = Example;
trait Trait { type Output; }
impl Trait for Example { type Output = Example; }
impl Example {
    fn by_value(self: Self) {}
    fn by_ref(self: &amp;Self) {}
    fn by_ref_mut(self: &amp;mut Self) {}
    fn by_box(self: Box&lt;Self&gt;) {}
    fn by_rc(self: Rc&lt;Self&gt;) {}
    fn by_arc(self: Arc&lt;Self&gt;) {}
    fn by_pin(self: Pin&lt;&amp;Self&gt;) {}
    fn explicit_type(self: Arc&lt;Example&gt;) {}
    fn with_lifetime&lt;'a&gt;(self: &amp;'a Self) {}
    fn nested&lt;'a&gt;(self: &amp;mut &amp;'a Arc&lt;Rc&lt;Box&lt;Alias&gt;&gt;&gt;) {}
    fn via_projection(self: &lt;Example as Trait&gt;::Output) {}
}
<span class="boring">}</span></code></pre></pre>
<p>可以使用不指定类型的简写语法，其等价于以下内容:</p>
<div class="table-wrapper"><table><thead><tr><th>简写</th><th>等同于</th></tr></thead><tbody>
<tr><td><code>self</code></td><td><code>self: Self</code></td></tr>
<tr><td><code>&amp;'lifetime self</code></td><td><code>self: &amp;'lifetime Self</code></td></tr>
<tr><td><code>&amp;'lifetime mut self</code></td><td><code>self: &amp;'lifetime mut Self</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>注意</strong>: 生命周期通常也可以用这种简写语法。</p>
</blockquote>
<p>如果 <code>self</code> 参数带有 <code>mut</code> 前缀，则它将变为可变变量，类似于使用 <code>mut</code> <a href="items/../patterns.html#identifier-patterns">标识符模式</a> 的常规参数。例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Changer: Sized {
    fn change(mut self) {}
    fn modify(mut self: Box&lt;Self&gt;) {}
}
<span class="boring">}</span></code></pre></pre>
<p>以下是关于 trait 上方法的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">type Surface = i32;
</span><span class="boring">type BoundingBox = i32;
</span>trait Shape {
    fn draw(&amp;self, surface: Surface);
    fn bounding_box(&amp;self) -&gt; BoundingBox;
}
<span class="boring">}</span></code></pre></pre>
<p>这个例子定义了一个具有两个方法的 trait 。只要在该 trait 作用域内的时候，所有 <a href="items/implementations.html">实现</a> 该 trait 的值都可以调用其 <code>draw</code> 和 <code>bounding_box</code> 方法。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">type Surface = i32;
</span><span class="boring">type BoundingBox = i32;
</span><span class="boring">trait Shape {
</span><span class="boring">    fn draw(&amp;self, surface: Surface);
</span><span class="boring">    fn bounding_box(&amp;self) -&gt; BoundingBox;
</span><span class="boring">}
</span><span class="boring">
</span>struct Circle {
    // ...
}

impl Shape for Circle {
    // ...
<span class="boring">  fn draw(&amp;self, _: Surface) {}
</span><span class="boring">  fn bounding_box(&amp;self) -&gt; BoundingBox { 0i32 }
</span>}

<span class="boring">impl Circle {
</span><span class="boring">    fn new() -&gt; Circle { Circle{} }
</span><span class="boring">}
</span><span class="boring">
</span>let circle_shape = Circle::new();
let bounding_box = circle_shape.bounding_box();
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>版本差异</strong>: 在 2015 版中，可以使用匿名参数 (例如 <code>fn foo(u8)</code> ) 声明 trait 方法。但在 2018 版中，这已被弃用并且会导致错误。所有参数必须有参数名。</p>
</blockquote>
<h4 id="方法参数的属性"><a class="header" href="#方法参数的属性">方法参数的属性</a></h4>
<p>方法参数上的属性遵循与 <a href="items/functions.html#attributes-on-function-parameters">常规函数参数</a> 相同的规则和限制。</p>
<h2 id="关联类型"><a class="header" href="#关联类型">关联类型</a></h2>
<p><em>关联类型</em> 是与另一个类型相关联的 <a href="items/type-aliases.html">类型别名</a> 。关联类型不能在 <a href="items/implementations.html#inherent-implementations">内部实现</a> 中定义，也不能在 trait 中给出默认实现。</p>
<p><em>关联类型声明</em> 声明了关联类型定义的签名。
它以以下一种形式书写，其中 <code>Assoc</code> 是关联类型的名称，<code>Params</code> 是由逗号分隔的类型、生命周期或常量参数列表，
<code>Bounds</code> 是关联类型必须满足的一组用加号分隔的 trait 约束列表， <code>WhereBounds</code> 是参数必须满足的一组用逗号分隔的约束列表:</p>
<!-- ignore: illustrative example forms -->
<pre><code class="language-rust ignore">type Assoc;
type Assoc: Bounds;
type Assoc&lt;Params&gt;;
type Assoc&lt;Params&gt;: Bounds;
type Assoc&lt;Params&gt; where WhereBounds;
type Assoc&lt;Params&gt;: Bounds where WhereBounds;</code></pre>
<p>该标识符是已声明的类型别名的名称。可选的 trait 约束必须由类型别名的实现满足。
关联类型存在一个隐式 <a href="items/../special-types-and-traits.html#sized"><code>Sized</code></a> 约束，可以使用特殊的 <code>?Sized</code> 约束放宽。</p>
<p><em>关联类型定义</em> 为类型别名，用于为类型上的 trait 实现定义类型。它们的书写方式与 <em>关联类型声明</em> 类似，但不能包含 <code>Bounds</code>，而是必须包含一个 <code>Type</code> :</p>
<!-- ignore: illustrative example forms -->
<pre><code class="language-rust ignore">type Assoc = Type;
type Assoc&lt;Params&gt; = Type; // 这里的 `Type` 可以引用 `Params` 
type Assoc&lt;Params&gt; = Type where WhereBounds;
type Assoc&lt;Params&gt; where WhereBounds = Type; // 已废弃，请选择上面的形式</code></pre>
<p>如果一个类型 <code>Item</code> 拥有一个从 trait <code>Trait</code> 中获取的关联类型 <code>Assoc</code>，那么 <code>&lt;Item as Trait&gt;::Assoc</code> 就是一个类型，它是关联类型定义中指定的类型的别名。此外，如果 <code>Item</code> 是一个类型参数，那么 <code>Item::Assoc</code> 可以在类型参数中使用。</p>
<p>关联类型可以包括 <a href="items/generics.html">泛型参数</a> 和 <a href="items/generics.html#where-clauses">where 约束</a> ；这些通常被称为 <em>泛型关联类型</em> 或 <em>GATs</em> 。
如果类型 <code>Thing</code> 从 trait <code>Trait</code> 中具有泛型 <code>&lt;'a&gt;</code> 的关联类型 <code>Item</code>，则该类型可以命名为 <code>&lt;Thing as Trait&gt;::Item&lt;'x&gt;</code>，其中 <code>'x</code> 是作用域内的某个生命周期。
在这种情况下，无论何时出现在 impl 上的关联类型定义中的 <code>'a</code> 都将使用 <code>'x</code> 。</p>
<p>关联类型可能包含 <a href="items/generics.html">泛型参数</a> 和 <a href="items/generics.html#where-clauses">where 约束</a> ；这些通常被称为 <em>泛型关联类型</em> 或 GAT。
如果类型 <code>Thing</code> 有一个来自 <code>Trait</code> 的关联类型 <code>Item</code> ，具有泛型 <code>&lt;'a&gt;</code> ，则可以像 <code>&lt;Thing as Trait&gt; ::Item&lt;'x&gt;</code> 这样命名该类型，其中 <code>'x</code> 是某个有效作用域内的生命周期。
在这种情况下，<code>'x</code> 将在实现中的关联类型定义中的 <code>'a</code> 处使用。</p>
<pre><pre class="playground"><code class="language-rust edition2021">trait AssociatedType {
    // 关联类型声明
    type Assoc;
}

struct Struct;

struct OtherStruct;

impl AssociatedType for Struct {
    // 关联类型定义
    type Assoc = OtherStruct;
}

impl OtherStruct {
    fn new() -&gt; OtherStruct {
        OtherStruct
    }
}

fn main() {
    // 用关联类型来指代 OtherStruct 为 &lt;Struct as AssociatedType&gt;::Assoc
    let _other_struct: OtherStruct = &lt;Struct as AssociatedType&gt;::Assoc::new();
}</code></pre></pre>
<p>带有泛型和 where子句 的关联类型的示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct ArrayLender&lt;'a, T&gt;(&amp;'a mut [T; 16]);

trait Lend {
    // 泛型关联类型声明
    type Lender&lt;'a&gt; where Self: 'a;
    fn lend&lt;'a&gt;(&amp;'a mut self) -&gt; Self::Lender&lt;'a&gt;;
}

impl&lt;T&gt; Lend for [T; 16] {
    // 泛型关联类型定义
    type Lender&lt;'a&gt; = ArrayLender&lt;'a, T&gt; where Self: 'a;

    fn lend&lt;'a&gt;(&amp;'a mut self) -&gt; Self::Lender&lt;'a&gt; {
        ArrayLender(self)
    }
}

fn borrow&lt;'a, T: Lend&gt;(array: &amp;'a mut T) -&gt; &lt;T as Lend&gt;::Lender&lt;'a&gt; {
    array.lend()
}


fn main() {
    let mut array = [0usize; 16];
    let lender = borrow(&amp;mut array);
}</code></pre></pre>
<h3 id="关联类型容器实例"><a class="header" href="#关联类型容器实例">关联类型容器实例</a></h3>
<p>考虑以下 <code>Container</code> trait 的示例。请注意，此类型可用于方法签名中:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Container {
    type E;
    fn empty() -&gt; Self;
    fn insert(&amp;mut self, elem: Self::E);
}
<span class="boring">}</span></code></pre></pre>
<p>为了使类型实现此 trait ，它不仅必须为每个方法提供实现，还必须指定类型 <code>E</code> 。这里是标准库类型 <code>Vec</code> 的 <code>Container</code> 的实现:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Container {
</span><span class="boring">    type E;
</span><span class="boring">    fn empty() -&gt; Self;
</span><span class="boring">    fn insert(&amp;mut self, elem: Self::E);
</span><span class="boring">}
</span>impl&lt;T&gt; Container for Vec&lt;T&gt; {
    type E = T;
    fn empty() -&gt; Vec&lt;T&gt; { Vec::new() }
    fn insert(&amp;mut self, x: T) { self.push(x); }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="bounds-和-wherebounds-之间的关系"><a class="header" href="#bounds-和-wherebounds-之间的关系"><code>Bounds</code> 和 <code>WhereBounds</code> 之间的关系</a></h3>
<p>In this example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Debug;
</span>trait Example {
    type Output&lt;T&gt;: Ord where T: Debug;
}
<span class="boring">}</span></code></pre></pre>
<p>给定对关联类型的引用，如 <code>&lt;X as Example&gt;::Output&lt;Y&gt;</code> ，则关联类型本身必须是 <code>Ord</code> ，而类型 <code>Y</code> 必须是 <code>Debug</code> 。</p>
<h3 id="要求在泛型关联类型上的where约束"><a class="header" href="#要求在泛型关联类型上的where约束">要求在泛型关联类型上的where约束</a></h3>
<p>trait 上的泛型关联类型声明当前可能需要一系列 where 子句 ，这取决于 trait 中的函数以及如何使用 GAT 。
未来这些规则可能会放宽;
更新内容可以在 <a href="https://rust-lang.github.io/generic-associated-types-initiative/explainer/required_bounds.html">泛型关联类型提案库</a> 中找到。</p>
<p>简而言之，这些 <code>where</code> 子句是必需的，以便最大限度允许在 impls 中定义关联类型的范围。
为了做到这一点，在任何出现 GAT 作为输入或输出的函数 (使用函数或trait的参数) 上，任何 <em>可以证明持有</em> 子句也必须写在 GAT 本身上。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait LendingIterator {
    type Item&lt;'x&gt; where Self: 'x;
    fn next&lt;'a&gt;(&amp;'a mut self) -&gt; Self::Item&lt;'a&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>在上面的例子中，在 <code>next</code> 函数中，我们可以证明 <code>Self: 'a</code>，因为我们从 <code>&amp;'a mut self</code> 推导出了这个隐含的限制。
因此，我们必须在 GAT 自身上写出等效的限制: <code>where Self: 'x</code> 。</p>
<p>当 trait 中有多个函数使用 GAT 时，会使用不同函数的边界的 <em>交集</em> ，而不是并集。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Check&lt;T&gt; {
    type Checker&lt;'x&gt;;
    fn create_checker&lt;'a&gt;(item: &amp;'a T) -&gt; Self::Checker&lt;'a&gt;;
    fn do_check(checker: Self::Checker&lt;'_&gt;);
}
<span class="boring">}</span></code></pre></pre>
<p>在这个例子中， <code>type Checker&lt;'a&gt;;</code> 不需要任何约束。虽然我们知道在 <code>create_checker</code> 函数中 <code>T: 'a</code> ，但是我们不知道在 <code>do_check</code> 函数中。
然而，如果将 <code>do_check</code> 函数注释掉，那么 <code>Checker</code> 就需要一个 <code>where T: 'x</code> 的约束。</p>
<p>关联类型上的约束也会传播所需的 where 子句。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterable {
    type Item&lt;'a&gt; where Self: 'a;
    type Iterator&lt;'a&gt;: Iterator&lt;Item = Self::Item&lt;'a&gt;&gt; where Self: 'a;
    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Self::Iterator&lt;'a&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>在这里，由于 <code>iter</code> ， <code>Item</code> 上需要 <code>where Self: 'a</code> 。但是，由于 <code>Iterator</code> 的约束中使用了 <code>Item</code> ，因此也需要在那里写出 <code>where Self: 'a</code> 子句。</p>
<p>最后，在 trait 中对 GAT 进行显式使用时的 <code>'static</code> 不计入所需的约束。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait StaticReturn {
    type Y&lt;'a&gt;;
    fn foo(&amp;self) -&gt; Self::Y&lt;'static&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="关联常量"><a class="header" href="#关联常量">关联常量</a></h2>
<p><em>关联常量</em> 是与类型相关联的 <a href="items/constant-items.html">常量</a> 。</p>
<p><em>关联常量声明</em> 声明了关联常量定义的签名。它写为 <code>const</code> ，然后是标识符，然后是 <code>:</code> ，然后是类型，最后以 <code>;</code> 结束。</p>
<p>标识符是路径中使用的常量的名称。类型是定义必须实现的类型。</p>
<p><em>关联常量定义</em> 定义了与类型相关联的常量。它的写法与 <a href="items/constant-items.html">常量条目</a> 相同。</p>
<p>关联常量定义仅在被引用时才会经过 <a href="items/../const_eval.html">常量求值</a> 。
此外，包括 <a href="items/generics.html">泛型参数</a> 的定义会在单态化后进行求值。</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">struct Struct;
struct GenericStruct&lt;const ID: i32&gt;;

impl Struct {
    // 定义没有立即评估
    const PANIC: () = panic!(&quot;compile-time panic&quot;);
}

impl&lt;const ID: i32&gt; GenericStruct&lt;ID&gt; {
    // 定义没有立即评估
    const NON_ZERO: () = if ID == 0 {
        panic!(&quot;contradiction&quot;)
    };
}

fn main() {
    // 引用 Struct::PANIC 会导致编译错误
    let _ = Struct::PANIC;

    // 可以, ID 不是 0
    let _ = GenericStruct::&lt;1&gt;::NON_ZERO;

    // 在 ID=0 的情况下评估 NON_ZERO 是编译错误
    let _ = GenericStruct::&lt;0&gt;::NON_ZERO;
}</code></pre></pre>
<h3 id="关联常量实例"><a class="header" href="#关联常量实例">关联常量实例</a></h3>
<p>A basic example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">trait ConstantId {
    const ID: i32;
}

struct Struct;

impl ConstantId for Struct {
    const ID: i32 = 1;
}

fn main() {
    assert_eq!(1, Struct::ID);
}</code></pre></pre>
<p>使用默认值:</p>
<pre><pre class="playground"><code class="language-rust edition2021">// 定义一个 trait `ConstantIdDefault`
trait ConstantIdDefault {
    // 声明一个常量 `ID`，默认值为 `1`
    const ID: i32 = 1;
}

// 定义结构体 `Struct`
struct Struct;
// 定义结构体 `OtherStruct`
struct OtherStruct;

// 为结构体 `Struct` 实现 `ConstantIdDefault` trait
impl ConstantIdDefault for Struct {}

// 为结构体 `OtherStruct` 实现 `ConstantIdDefault` trait，并重新定义 `ID` 常量的值为 `5`
impl ConstantIdDefault for OtherStruct {
    const ID: i32 = 5;
}

// 程序入口函数
fn main() {
    // 断言结构体 `Struct` 的 `ID` 常量值为 `1`
    assert_eq!(1, Struct::ID);
    // 断言结构体 `OtherStruct` 的 `ID` 常量值为 `5`
    assert_eq!(5, OtherStruct::ID);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><script>
(function() {
    var fragments = {
        "#cold-attribute": "attributes/codegen.html#the-cold-attribute",
        "#conditional-compilation": "conditional-compilation.html",
        "#deprecation": "attributes/diagnostics.html#the-deprecated-attribute",
        "#derive": "attributes/derive.html",
        "#documentation": "../rustdoc/the-doc-attribute.html",
        "#ffi-attributes": "attributes.html#built-in-attributes-index",
        "#inline-attribute": "attributes/codegen.html#the-inline-attribute",
        "#lint-check-attributes": "attributes/diagnostics.html#lint-check-attributes",
        "#macro-related-attributes": "attributes.html#built-in-attributes-index",
        "#miscellaneous-attributes": "attributes.html#built-in-attributes-index",
        "#must_use": "attributes/diagnostics.html#the-must_use-attribute",
        "#optimization-hints": "attributes/codegen.html#optimization-hints",
        "#path": "items/modules.html#the-path-attribute",
        "#preludes": "crates-and-source-files.html#preludes-and-no_std",
        "#testing": "attributes/testing.html",
        "#tool-lint-attributes": "attributes/diagnostics.html#tool-lint-attributes",
        "#crate-only-attributes": "attributes.html#built-in-attributes-index",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<h1 id="属性-1"><a class="header" href="#属性-1">属性</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>内部属性</em> :<br />
   <code>#</code> <code>!</code> <code>[</code> <em>属性</em> <code>]</code></p>
<p><em>外部属性</em> :<br />
   <code>#</code> <code>[</code> <em>属性</em> <code>]</code></p>
<p><em>属性</em> :<br />
   <a href="paths.html#simple-paths"><em>简单路径</em></a> <em>属性输入</em><sup>?</sup></p>
<p><em>属性输入</em> :<br />
      <a href="macros.html"><em>定界Token树</em></a><br />
   | <code>=</code> <a href="expressions.html"><em>表达式</em></a></p>
</blockquote>
<p><em>属性</em> 是通用的、自由形式的元数据，根据名称、约定、语言和编译器版本来解释。
属性以 <a href="https://www.ecma-international.org/publications/standards/Ecma-335.htm">ECMA-335</a> 中的 Attributes 为模型，其语法来自 <a href="https://www.ecma-international.org/publications/standards/Ecma-334.htm">ECMA-334</a> (C#) 。</p>
<p><em>内部属性</em> ，在井号 (<code>#</code>) 后跟一个叹号 (<code>!</code>)，应用于内部声明属性的条目。
<em>外部属性</em> ，在哈希值后不加叹号，应用于该属性随后的事物。</p>
<p>属性由一个路径和一个可选的被定界的令牌树组成，该令牌树的解释由属性定义。
除宏属性之外的属性还允许输入是一个等号 (<code>=</code>) 后跟一个表达式。更多细节请参见下面的 [元条目语法](meta item attribute syntax) 。</p>
<p>属性可分为以下几种。</p>
<ul>
<li><a href="attributes.html#built-in-attributes-index">内置属性</a></li>
<li><a href="procedural-macros.html#attribute-macros">宏属性</a></li>
<li><a href="procedural-macros.html#derive-macro-helper-attributes">衍生宏辅助属性</a></li>
<li><a href="attributes.html#tool-attributes">工具属性</a></li>
</ul>
<p>属性可以应用于语言中的许多内容:</p>
<ul>
<li>所有的 <a href="items.html">条目声明</a> 都接受外部属性，而 <a href="items/external-blocks.html">外部块</a> 、 <a href="items/functions.html">函数</a> 、 <a href="items/implementations.html">实现</a> 和 <a href="items/modules.html">模块</a> 接受内部属性。</li>
<li>大多数 <a href="statements.html">语句</a> 都接受外部属性 (关于表达式语句的限制，见 <a href="expressions.html#expression-attributes">表达式属性</a> ) 。</li>
<li><a href="expressions/block-expr.html">块表达式</a> 可以接受外部和内部属性，但是只有当它们是 <a href="statements.html#expression-statements">表达式语句</a> 的外部表达式或另一个块表达式的最终表达式时才能接受。</li>
<li><a href="items/enumerations.html">Enum</a> 变体和 <a href="items/structs.html">struct</a> 和 <a href="items/unions.html">union</a> 字段接受外部属性。</li>
<li><a href="expressions/match-expr.html">匹配表达式分支</a> 接受外部属性。</li>
<li><a href="items/generics.html">泛型生命周期或类型参数</a> 接受外部属性。</li>
<li>表达式在有限的情况下接受外部属性，详见 <a href="expressions.html#expression-attributes">表达式属性</a> 。</li>
<li><a href="items/functions.html">函数</a> 、 <a href="expressions/closure-expr.html">闭包</a> 和 <a href="types/function-pointer.html">函数指针</a> 参数接受外部属性。这包括在函数指针和 <a href="items/external-blocks.html#variadic-functions">外部块</a> 中用 <code>...</code> 表示的变量参数的属性。</li>
</ul>
<p>一些属性的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 应用于封闭模块或 crate 的通用 metadata 。
#![crate_type = &quot;lib&quot;]

// 标记为单元测试的函数
#[test]
fn test_foo() {
    /* ... */
}

// 条件编译模块
#[cfg(target_os = &quot;linux&quot;)]
mod bar {
    /* ... */
}

// 用于屏蔽警告/错误的 lint 属性
#[allow(non_camel_case_types)]
type int8_t = i8;

// 将内部属性应用于整个函数。
fn some_unused_variables() {
  #![allow(unused_variables)]

  let x = ();
  let y = ();
  let z = ();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="元条目属性语法"><a class="header" href="#元条目属性语法">元条目属性语法</a></h2>
<p>&quot;元条目&quot; 是大多数 <a href="attributes.html#built-in-attributes-index">内置属性</a> 中用于 <em>属性</em> 规则的语法，具体语法如下：</p>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>元条目</em> :<br />
      <a href="paths.html#simple-paths"><em>简单路径</em></a><br />
   | <a href="paths.html#simple-paths"><em>简单路径</em></a> <code>=</code> <a href="expressions.html"><em>表达式</em></a><br />
   | <a href="paths.html#simple-paths"><em>简单路径</em></a> <code>(</code> <em>元</em><sup>?</sup> <code>)</code></p>
<p><em>元</em> :<br />
   <em>元条目内部</em> ( <code>,</code> 元条目内部 )<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>元条目内部</em> :<br />
      <em>元条目</em><br />
   | <a href="expressions.html"><em>表达式</em></a></p>
</blockquote>
<p>元条目中的表达式必须宏展开为字面表达式，不得包含整数或浮点类型后缀。
不是字面值表达式的表达式将在语法分析后被拒绝，但可以传递给过程宏。</p>
<p>请注意，如果属性出现在另一个宏中，它将在该外部宏之后扩展。
例如，以下代码将首先扩展 <code>Serialize</code> 过程宏，该宏必须保留 <code>include_str!</code> 调用，以便它能够被扩展:</p>
<pre><code class="language-rust ignore">#[derive(Serialize)]
struct Foo {
    #[doc = include_str!(&quot;x.md&quot;)]
    x: u32
}</code></pre>
<p>此外，在应用于条目的所有其他属性之后，属性中的宏才会被展开:</p>
<pre><code class="language-rust ignore">#[macro_attr1] // 首先展开
#[doc = mac!()] // `mac!` 第4展开
#[macro_attr2] // 第二展开
#[derive(MacroDerive1, MacroDerive2)] // 第三展开
fn foo() {}</code></pre>
<p>各种内置属性使用不同的元条目语法子集来指定其输入。以下语法规则展示了一些常用形式:</p>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>元字</em>:<br />
   <a href="identifiers.html">标识符</a></p>
<p><em>元名称值字符串</em>:<br />
   <a href="identifiers.html">标识符</a> <code>=</code> (<a href="tokens.html#string-literals">STRING_LITERAL</a> | <a href="tokens.html#raw-string-literals">RAW_STRING_LITERAL</a>)</p>
<p><em>元列表路径</em>:<br />
   <a href="identifiers.html">标识符</a> <code>(</code> ( <a href="paths.html#simple-paths"><em>SimplePath</em></a> (<code>,</code> <a href="paths.html#simple-paths"><em>SimplePath</em></a>)* <code>,</code><sup>?</sup> )<sup>?</sup> <code>)</code></p>
<p><em>元列表ID组</em>:<br />
   <a href="identifiers.html">标识符</a> <code>(</code> ( <a href="identifiers.html">标识符</a> (<code>,</code> <a href="identifiers.html">标识符</a>)* <code>,</code><sup>?</sup> )<sup>?</sup> <code>)</code></p>
<p><em>元列表名称值字符串</em>:<br />
   <a href="identifiers.html">标识符</a> <code>(</code> ( <em>元名称值字符串</em> (<code>,</code> <em>元名称值字符串</em>)* <code>,</code><sup>?</sup> )<sup>?</sup> <code>)</code></p>
</blockquote>
<p>元条目的一些例子:</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>示例</th></tr></thead><tbody>
<tr><td><em>元字</em></td><td><code>no_std</code></td></tr>
<tr><td><em>元名称值字符串</em></td><td><code>doc = &quot;example&quot;</code></td></tr>
<tr><td><em>元列表路径</em></td><td><code>allow(unused, clippy::inline_always)</code></td></tr>
<tr><td><em>元列表ID组</em></td><td><code>macro_use(foo, bar)</code></td></tr>
<tr><td><em>元列表名称值字符串</em></td><td><code>link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)</code></td></tr>
</tbody></table>
</div>
<h2 id="活动和惰性属性"><a class="header" href="#活动和惰性属性">活动和惰性属性</a></h2>
<p>一个属性可以是活动的或惰性的。在属性处理过程中， <em>活动属性</em> 会从它们所在的元素中移除，而 <em>惰性属性</em> 则会保留。</p>
<p><a href="conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a> 和 <a href="conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a> 属性是活动属性。 <a href="attributes/testing.html#the-test-attribute"><code>test</code></a> 属性在测试编译时是惰性的，而在其他情况下是活动的。 <a href="procedural-macros.html#attribute-macros">属性宏</a> 是活动属性。所有其他属性都是惰性的。</p>
<h2 id="工具属性"><a class="header" href="#工具属性">工具属性</a></h2>
<p>编译器可以允许外部工具的属性，其中每个工具在自己的命名空间中。
属性路径的第一个部分是工具的名称，后面可能有一个或多个其他部分，其解释取决于工具本身。</p>
<p>当一个工具没有被使用时，该工具的属性会被接受而不会产生警告。
当该工具正在使用时，该工具需要负责处理和解释其属性。</p>
<p>工具属性在使用 <a href="names/preludes.html#the-no_implicit_prelude-attribute"><code>no_implicit_prelude</code></a> 属性时不可用。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 告知 rustfmt 工具不要格式化以下元素。
#[rustfmt::skip]
struct S {
}

// 控制 Clippy 工具的 &quot;cyclomatic complexity&quot; 阈值。
#[clippy::cyclomatic_complexity = &quot;100&quot;]
pub fn f() {}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>注意: <code>rustc</code> 目前可以识别工具 &quot;clippy&quot; 和 &quot;rustfmt&quot; 。</p>
</blockquote>
<h2 id="内置属性索引"><a class="header" href="#内置属性索引">内置属性索引</a></h2>
<p>以下是所有内置属性的索引。</p>
<ul>
<li>条件编译
<ul>
<li><a href="conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a> — 控制条件编译</li>
<li><a href="conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a> — 条件包含属性</li>
</ul>
</li>
<li>测试
<ul>
<li><a href="attributes/testing.html#the-test-attribute"><code>test</code></a> — 标记为测试函数</li>
<li><a href="attributes/testing.html#the-ignore-attribute"><code>ignore</code></a> — 禁用测试函数</li>
<li><a href="attributes/testing.html#the-should_panic-attribute"><code>should_panic</code></a> — 表示测试应产生恐慌</li>
</ul>
</li>
<li>衍生
<ul>
<li><a href="attributes/derive.html"><code>derive</code></a> — 自动 trait 实现</li>
<li><a href="attributes/derive.html#the-automatically_derived-attribute"><code>automatically_derived</code></a> — 由 <code>derive</code> 创建的实现的标记</li>
</ul>
</li>
<li>宏
<ul>
<li><a href="macros-by-example.html#path-based-scope"><code>macro_export</code></a> — 导出一个 <code>macro_rules</code> 宏，用于跨 crate 使用。</li>
<li><a href="macros-by-example.html#the-macro_use-attribute"><code>macro_use</code></a> — 展开宏的可见性，或从其他 crate 导入宏。</li>
<li><a href="procedural-macros.html#function-like-procedural-macros"><code>proc_macro</code></a> — 定义函数式宏。</li>
<li><a href="procedural-macros.html#derive-macros"><code>proc_macro_derive</code></a> — 定义衍生宏。</li>
<li><a href="procedural-macros.html#attribute-macros"><code>proc_macro_attribute</code></a> — 定义属性宏。</li>
</ul>
</li>
<li>诊断
<ul>
<li><a href="attributes/diagnostics.html#lint-check-attributes"><code>allow</code></a>, <a href="attributes/diagnostics.html#lint-check-attributes"><code>warn</code></a>, <a href="attributes/diagnostics.html#lint-check-attributes"><code>deny</code></a>, <a href="attributes/diagnostics.html#lint-check-attributes"><code>forbid</code></a> — 改变默认的 lint 级别。</li>
<li><a href="attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a> — 生成弃用通知</li>
<li><a href="attributes/diagnostics.html#the-must_use-attribute"><code>must_use</code></a> — 生成未使用值的 lint 。</li>
</ul>
</li>
<li>ABI, linking, symbols, and FFI
<ul>
<li><a href="items/external-blocks.html#the-link-attribute"><code>link</code></a> — 指定本地库，与 <code>extern</code> 块链接。</li>
<li><a href="items/external-blocks.html#the-link_name-attribute"><code>link_name</code></a> — 指定 <code>extern</code> 块中的函数或静态的符号名称。</li>
<li><a href="items/external-blocks.html#the-link_ordinal-attribute"><code>link_ordinal</code></a> — 指定 <code>extern</code> 块中的函数或静态符号的顺序。</li>
<li><a href="items/extern-crates.html#the-no_link-attribute"><code>no_link</code></a> — 防止链接外部 crate 。</li>
<li><a href="type-layout.html#representations"><code>repr</code></a> — 控制类型布局方式。</li>
<li><a href="linkage.html"><code>crate_type</code></a> — 指定 crate 的类型 (库、可执行文件等) 。</li>
<li><a href="crates-and-source-files.html#the-no_main-attribute"><code>no_main</code></a> — 禁止发送 <code>main</code> 符号。</li>
<li><a href="abi.html#the-export_name-attribute"><code>export_name</code></a> — 指定函数或静态的导出符号名称。</li>
<li><a href="abi.html#the-link_section-attribute"><code>link_section</code></a> — 指定一个对象文件的节，以用于函数或静态。</li>
<li><a href="abi.html#the-no_mangle-attribute"><code>no_mangle</code></a> — 禁用符号名称编码。</li>
<li><a href="abi.html#the-used-attribute"><code>used</code></a> — 强制编译器在输出对象文件中保留静态条目。</li>
<li><a href="crates-and-source-files.html#the-crate_name-attribute"><code>crate_name</code></a> — 指定 crate 名称。</li>
</ul>
</li>
<li>代码生成
<ul>
<li><a href="attributes/codegen.html#the-inline-attribute"><code>inline</code></a> — 提示内联代码。</li>
<li><a href="attributes/codegen.html#the-cold-attribute"><code>cold</code></a> — 提示函数不太可能被调用。</li>
<li><a href="attributes/codegen.html#the-no_builtins-attribute"><code>no_builtins</code></a> — 禁止使用某些内置函数。</li>
<li><a href="attributes/codegen.html#the-target_feature-attribute"><code>target_feature</code></a> — 配置特定平台的代码生成。</li>
<li><a href="attributes/codegen.html#the-track_caller-attribute"><code>track_caller</code></a> - 将父级调用位置传递给 <code>std::panic::Location::caller()</code>。</li>
<li><a href="attributes/codegen.html#the-instruction_set-attribute"><code>instruction_set</code></a> - 指定用于生成函数代码的指令集</li>
</ul>
</li>
<li>文档
<ul>
<li><code>doc</code> — 用于指定文档。请参见 <a href="../rustdoc/the-doc-attribute.html">Rustdoc 文档</a> 获取更多信息。 <a href="comments.html#doc-comments">文档注释</a> 会被转换为 <code>doc</code> 属性。</li>
</ul>
</li>
<li>预导入
<ul>
<li><a href="names/preludes.html#the-no_std-attribute"><code>no_std</code></a> — 从预导入中删除 std 。</li>
<li><a href="names/preludes.html#the-no_implicit_prelude-attribute"><code>no_implicit_prelude</code></a> — 禁用模块内的预导入查询。</li>
</ul>
</li>
<li>模块
<ul>
<li><a href="items/modules.html#the-path-attribute"><code>path</code></a> — 指定模块的文件名。</li>
</ul>
</li>
<li>范围
<ul>
<li><a href="attributes/limits.html#the-recursion_limit-attribute"><code>recursion_limit</code></a> — 设置某些编译时操作的最大递归限制。</li>
<li><a href="attributes/limits.html#the-type_length_limit-attribute"><code>type_length_limit</code></a> — 设置多态类型的最大规模。</li>
</ul>
</li>
<li>运行时
<ul>
<li><a href="runtime.html#the-panic_handler-attribute"><code>panic_handler</code></a> — 设定处理恐慌的函数。</li>
<li><a href="runtime.html#the-global_allocator-attribute"><code>global_allocator</code></a> — 设置全局内存分配器。</li>
<li><a href="runtime.html#the-windows_subsystem-attribute"><code>windows_subsystem</code></a> — 指定要链接的 windows 子系统。</li>
</ul>
</li>
<li>特性
<ul>
<li><code>feature</code> — 用于启用不稳定或实验性的编译器特性。有关 <code>rustc</code> 实现的特性，请参见 <a href="../unstable-book/index.html">未稳定性文档</a> 。</li>
</ul>
</li>
<li>类型系统
<ul>
<li><a href="attributes/type_system.html#the-non_exhaustive-attribute"><code>non_exhaustive</code></a> — 表示该类型在未来可能会添加更多的字段/变体。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试属性"><a class="header" href="#测试属性">测试属性</a></h1>
<p>以下 <a href="attributes/../attributes.html">属性</a> 用于指定用于执行测试的函数。
将 crate 编译为 &quot;test&quot; 模式将启用构建测试函数以及用于执行测试的测试工具。
启用测试模式还启用 <a href="attributes/../conditional-compilation.html#test"><code>test</code> 条件编译选项</a>。</p>
<h2 id="test-属性"><a class="header" href="#test-属性"><code>test</code> 属性</a></h2>
<p><em><code>test</code>属性</em> 用于标记一个函数作为测试用例执行。这些函数只在测试模式下编译。
测试函数必须是无参、单态函数，并且返回类型必须实现 <a href="attributes/../../std/process/trait.Termination.html"><code>Termination</code></a> trait ，例如:</p>
<ul>
<li><code>()</code></li>
<li><code>Result&lt;T, E&gt; where T: Termination, E: Debug</code></li>
<li><code>!</code></li>
</ul>
<!-- If the previous section needs updating (from "must take no arguments"
  onwards, also update it in the crates-and-source-files.md file -->
<blockquote>
<p>注意: 测试模式是通过向 <code>rustc</code> 传递 <code>--test</code> 参数或使用 <code>cargo test</code> 来启用的。</p>
</blockquote>
<p>测试框架将调用返回值的 <a href="attributes/../../std/process/trait.Termination.html#tymethod.report"><code>report</code></a> 方法，并根据 <a href="attributes/../../std/process/struct.ExitCode.html"><code>ExitCode</code></a> 代表的终止状态将测试分类为已通过或已失败。特别地:</p>
<ul>
<li>返回 <code>()</code> 的测试只要终止且未发生恐慌即为通过。</li>
<li>返回 <code>Result&lt;(), E&gt;</code> 的测试只要返回 <code>Ok(())</code> 即为通过。</li>
<li>返回 <code>ExitCode::SUCCESS</code> 的测试通过，返回 <code>ExitCode::FAILURE</code> 的测试失败。</li>
<li>无法终止的测试既不通过也不失败。</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io;
</span><span class="boring">fn setup_the_thing() -&gt; io::Result&lt;i32&gt; { Ok(1) }
</span><span class="boring">fn do_the_thing(s: &amp;i32) -&gt; io::Result&lt;()&gt; { Ok(()) }
</span>#[test]
fn test_the_thing() -&gt; io::Result&lt;()&gt; {
    let state = setup_the_thing()?; // expected to succeed
    do_the_thing(&amp;state)?;          // expected to succeed
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="ignore-属性"><a class="header" href="#ignore-属性"><code>ignore</code> 属性</a></h2>
<p>一个被标记为 <code>test</code> 的函数也可以被标记为 <code>ignore</code> 。
<em><code>ignore</code> 属性</em> 告知测试框架不要将该函数作为测试执行，但在测试模式下它仍会被编译。</p>
<p><code>ignore</code> 属性可以选择用 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>元名称值字符串</em></a> 语法编写，以具体说明测试被忽略的原因。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[ignore = &quot;not yet implemented&quot;]
fn mytest() {
    // …
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>注意</strong>: <code>rustc</code> 测试框架支持 <code>--include-ignored</code> 标志，以强制运行被忽略的测试。</p>
</blockquote>
<h2 id="should_panic-属性"><a class="header" href="#should_panic-属性"><code>should_panic</code> 属性</a></h2>
<p>带有 <code>test</code> 属性的返回类型为 <code>()</code> 的函数还可以带有 <code>should_panic</code> 属性。 <code>should_panic</code> 属性 表示仅当函数实际恐慌时，测试才会通过。</p>
<p><code>should_panic</code> 属性可以选择性地接受一个输入字符串，该字符串必须出现在恐慌消息中。
如果在消息中未找到该字符串，则测试将失败。可以使用 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>元名称值字符串</em></a> 语法或具有 <code>expected</code> 字段的 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>元列表名称值字符串</em></a> 语法传递该字符串。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[should_panic(expected = &quot;values don't match&quot;)]
fn mytest() {
    assert_eq!(1, 2, &quot;values don't match&quot;);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="衍生"><a class="header" href="#衍生">衍生</a></h1>
<p><em><code> derive</code> 属性</em> 允许自动生成数据结构的新 <a href="attributes/../items.html">条目</a> 。
它使用 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>元列表路径组</em></a> 语法来指定要实现的一组 trait 或要处理的 <a href="attributes/../procedural-macros.html#derive-macros">衍生宏</a> 的路径。</p>
<p>例如，以下代码将为 <code>Foo</code> 创建一个 <a href="attributes/../items/implementations.html"><code>impl</code> 条目</a> ，实现 <a href="attributes/../../std/cmp/trait.PartialEq.html"><code>PartialEq</code></a> 和 <a href="attributes/../../std/clone/trait.Clone.html"><code>Clone</code></a> 两个 trait ，
而类型参数 <code>T</code> 将被赋予相应 <code>impl</code> 中的 <code>PartialEq</code> 或 <code>Clone</code> 约束。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Clone)]
struct Foo&lt;T&gt; {
    a: i32,
    b: T,
}
<span class="boring">}</span></code></pre></pre>
<p>对于 <code>PartialEq</code> 所生成的 <code>impl</code> 等同于</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo&lt;T&gt; { a: i32, b: T }
</span>impl&lt;T: PartialEq&gt; PartialEq for Foo&lt;T&gt; {
    fn eq(&amp;self, other: &amp;Foo&lt;T&gt;) -&gt; bool {
        self.a == other.a &amp;&amp; self.b == other.b
    }
}
<span class="boring">}</span></code></pre></pre>
<p>你可以通过 <a href="attributes/../procedural-macros.html#derive-macros">过程宏</a> 为你自己的 trait 实现 <code>derive</code> 。</p>
<h2 id="automatically_derived-属性"><a class="header" href="#automatically_derived-属性"><code>automatically_derived</code> 属性</a></h2>
<p>自动生成的实现由 <code>derive</code> 属性自动添加了 <code>automatically_derived</code> 属性，它本身没有直接作用，但是可以被工具和诊断lint用来检测这些自动生成的实现。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="诊断属性"><a class="header" href="#诊断属性">诊断属性</a></h1>
<p>下面的 <a href="attributes/../attributes.html">属性</a> 用于在编译期间控制或生成诊断信息。</p>
<h2 id="代码分析检查属性"><a class="header" href="#代码分析检查属性">代码分析检查属性</a></h2>
<p>代码分析检查指的是一些可能存在不良编码模式的代码，例如不可到达的代码或省略的文档。
代码分析属性 <code>allow</code> 、 <code>warn</code> 、 <code>deny</code> 和 <code>forbid</code> 使用 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaListPaths</em></a> 语法指定要更改为应用属性的实体的代码分析级别列表。</p>
<p>对于任何代码分析检查 <code>C</code> ：</p>
<ul>
<li><code>allow(C)</code> 会覆盖 <code>C</code> 的检查，使违规不会被报告，</li>
<li><code>warn(C)</code> 警告有关 <code>C</code> 的违规，但继续编译。</li>
<li><code>deny(C)</code> 在遇到 <code>C</code> 的违规后发出错误信号，</li>
<li><code>forbid(C)</code> 与 <code>deny(C)</code> 相同，但还禁止以后更改代码分析级别。</li>
</ul>
<blockquote>
<p>注意: <code>rustc</code> 支持的代码分析检查可以通过 <code>rustc -W help</code> 找到，包括它们的默认设置，并在 <a href="attributes/../../rustc/lints/index.html">rustc 文档</a> 中有记录。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod m1 {
    // 忽略此处的缺失文档
    #[allow(missing_docs)]
    pub fn undocumented_one() -&gt; i32 { 1 }

    // 此处缺失文档会发出警告
    #[warn(missing_docs)]
    pub fn undocumented_too() -&gt; i32 { 2 }

    // 此处缺失文档会发出错误
    #[deny(missing_docs)]
    pub fn undocumented_end() -&gt; i32 { 3 }
}
<span class="boring">}</span></code></pre></pre>
<p>Lint属性可以覆盖先前属性中指定的级别，只要级别不会试图更改禁止的lint。
先前的属性来自语法树中更高级别的属性，或者是源代码中左到右的先前属性。</p>
<p>以下示例展示了如何使用 <code>allow</code> 和 <code>warn</code> 来打开和关闭特定检查:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[warn(missing_docs)]
pub mod m2 {
    #[allow(missing_docs)]
    pub mod nested {
        // 忽略这里缺失的文档
        pub fn undocumented_one() -&gt; i32 { 1 }

        // 这里缺失的文档会产生警告，
        // 即使之前有一个允许缺失文档的 #[allow(missing_docs)]
        #[warn(missing_docs)]
        pub fn undocumented_two() -&gt; i32 { 2 }
    }

    // 这里缺失的文档会产生警告
    pub fn undocumented_too() -&gt; i32 { 3 }
}
<span class="boring">}</span></code></pre></pre>
<p>这个例子展示了如何使用 <code>forbid</code> 禁止对某个 lint 检查使用 <code>allow</code> :</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[forbid(missing_docs)]
pub mod m3 {
    // 在这里尝试切换警告会导致错误
    #[allow(missing_docs)]
    /// Returns 2.
    pub fn undocumented_too() -&gt; i32 { 2 }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>注意：<code>rustc</code> 允许在 <a href="attributes/../../rustc/lints/levels.html#via-compiler-flag">命令行</a> 上设置代码分析级别，并支持在报告的代码分析上 <a href="attributes/../../rustc/lints/levels.html#capping-lints">设置限制</a> 。</p>
</blockquote>
<h3 id="代码分析组"><a class="header" href="#代码分析组">代码分析组</a></h3>
<p>代码分析可以被组织成具有名称的组，以便可以一起调整相关代码分析的级别。使用命名组相当于列出该组中的代码分析。</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这允许所有 &quot;unused&quot; 组中的 lint。
#[allow(unused)]
// 这将 &quot;unused&quot; 组中的 &quot;unused_must_use&quot; lint 改为了 &quot;deny&quot;。
#[deny(unused_must_use)]
fn example() {
    // 这不会生成警告，因为 &quot;unused_variables&quot; lint 在 &quot;unused&quot; 组中。
    let x = 1;
    // 这会生成一个错误，因为结果未使用且 &quot;unused_must_use&quot; 被标记为 &quot;deny&quot;。
    std::fs::remove_file(&quot;some_file&quot;); // ERROR: unused `Result` that must be used
}
<span class="boring">}</span></code></pre></pre>
<p>有一个特殊的名为 &quot;warnings&quot; 的分组，其中包括所有 &quot;warn&quot; 级别的代码分析。
&quot;warnings&quot; 分组忽略属性顺序，并适用于实体中所有会产生警告的代码分析。</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">unsafe fn an_unsafe_fn() {}
</span>// 这两个属性的顺序无关紧要。
#[deny(warnings)]
// unsafe_code lint 通常默认为 &quot;allow&quot;。
#[warn(unsafe_code)]
fn example_err() {
    // 这是一个错误，因为 `unsafe_code` 警告已经被提升到了 &quot;deny&quot;。
    unsafe { an_unsafe_fn() } // ERROR: usage of `unsafe` block
}
<span class="boring">}</span></code></pre></pre>
<h3 id="工具代码分析属性"><a class="header" href="#工具代码分析属性">工具代码分析属性</a></h3>
<p>'工具代码分析' 允许使用作用域 '代码分析' ，以允许、警告、禁止某些工具的代码分析。</p>
<p>只有在相关工具处于活动状态时才会检查工具代码分析。
如果像 <code>allow</code> 这样的代码分析属性引用了不存在的 '工具代码分析' ，则编译器在使用该工具之前不会警告不存在的代码分析。</p>
<p>否则，它们的工作方式与常规代码分析属性相同：</p>
<pre><pre class="playground"><code class="language-rust edition2021">// 将整个 pedantic clippy 代码分析组设置为警告
#![warn(clippy::pedantic)]
// 屏蔽 filter_map clippy 代码分析中的警告
#![allow(clippy::filter_map)]

fn main() {
// ...
}

// 仅针对该函数屏蔽 cmp_nan clippy 代码分析的警告
#[allow(clippy::cmp_nan)]
fn foo() {
// ...
}</code></pre></pre>
<blockquote>
<p>注意: 目前 <code>rustc</code> 只支持 &quot;<a href="https://github.com/rust-lang/rust-clippy">clippy</a>&quot; 和 &quot;<a href="attributes/../../rustdoc/lints.html">rustdoc</a>&quot; 的工具代码分析。</p>
</blockquote>
<h2 id="deprecated-属性"><a class="header" href="#deprecated-属性"><code>deprecated</code> 属性</a></h2>
<p><em><code>deprecated</code> 属性</em> 将一个条目标记为已弃用。<code>rustc</code> 在使用被 <code>#[deprecated]</code> 标记的条目时会发出警告。
<code>rustdoc</code> 将显示条目的弃用信息，包括 <code>since</code> 版本和 <code>note</code> (如果有) 。</p>
<p><code>deprecated</code> 属性有几种形式:</p>
<ul>
<li><code>deprecated</code> — 发出一条通用信息。</li>
<li><code>deprecated = &quot;message&quot;</code> — 在弃用消息中包含给定的字符串。</li>
<li><a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaListNameValueStr</em></a> 语法有两个可选字段:
<ul>
<li><code>since</code> — 指定条目被弃用的版本号。 <code>rustc</code> 目前不解释该字符串，但像 <a href="https://github.com/rust-lang/rust-clippy">Clippy</a> 这样的外部工具可能会检查值的有效性。</li>
<li><code>note</code> — 指定应在弃用消息中包含的字符串。通常用于提供有关弃用和首选替代方法的解释。</li>
</ul>
</li>
</ul>
<p><code>deprecated</code> 属性可应用于任何 <a href="attributes/../items.html">条目</a> 、 <a href="attributes/../items/traits.html">trait 条目</a> 、 <a href="attributes/../items/enumerations.html">enum 变体</a> 、 <a href="attributes/../items/structs.html">struct 字段</a> 、 <a href="attributes/../items/external-blocks.html">外部块条目</a> 或 <a href="attributes/../macros-by-example.html">宏定义</a>。
它不能应用于 <a href="attributes/../items/implementations.html#trait-implementations">trait 实现条目</a>。当应用于包含其他条目的条目 (例如 <a href="attributes/../items/modules.html">模块</a> 或 <a href="attributes/../items/implementations.html">实现</a> )时，所有子条目都继承弃用属性。</p>
<!-- NOTE: It is only rejected for trait impl items
(AnnotationKind::Prohibited). In all other locations, it is silently ignored.
Tuple struct fields are ignored.
-->
<p>以下一个例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(since = &quot;5.2.0&quot;, note = &quot;foo was rarely used. Users should instead use bar&quot;)]
pub fn foo() {}

pub fn bar() {}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/1270-deprecation.md">RFC</a> 包含了动机和更多细节。</p>
<h2 id="must_use-属性"><a class="header" href="#must_use-属性"><code>must_use</code> 属性</a></h2>
<p><em><code>must_use</code> 属性</em> 用于在值未被 &quot;使用&quot; 时发出诊断警告。它可以应用于用户定义的复合类型 ( [<code>struct</code>] 、 [<code>enum</code>] 和 [<code>union</code>] ) 、 [<code>functions</code>] 和 [<code>traits</code>] 。</p>
<p><code>must_use</code> 属性可以通过使用 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>元名称值字符串</em></a> 语法 (例如 <code>#[must_use = &quot;example message&quot;]</code> ) 包含一条消息。该消息将与警告一起给出。</p>
<p>当在用户定义的复合类型上使用时，如果 <a href="attributes/../expressions.html">表达式</a> 的 <a href="attributes/../statements.html#expression-statements">表达式语句</a> 具有该类型，则违反了 <code>unused_must_use</code> 代码分析。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
struct MustUse {
    // 一些字段
}

<span class="boring">impl MustUse {
</span><span class="boring">  fn new() -&gt; MustUse { MustUse {} }
</span><span class="boring">}
</span><span class="boring">
</span>// 违反了 `unused_must_use` lint.
MustUse::new();
<span class="boring">}</span></code></pre></pre>
<p>当应用于函数时，如果 <a href="attributes/../expressions.html">表达式</a> 是对该函数的 <a href="attributes/../expressions/call-expr.html">调用表达式</a>，那么将违反 <code>unused_must_use</code> 警告。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
fn five() -&gt; i32 { 5i32 }

// 违反了 `unused_must_use` lint.
five();
<span class="boring">}</span></code></pre></pre>
<p>当在 <a href="attributes/../items/traits.html">trait 声明</a> 上使用时，对该 trait 的 <a href="attributes/../types/impl-trait.html">impl trait</a> 或 <a href="attributes/../types/trait-object.html">dyn trait</a> 返回的函数的 <a href="attributes/../expressions/call-expr.html">调用表达式</a> 的 <a href="attributes/../statements.html#expression-statements">表达式语句</a> 违反了 <code>unused_must_use</code> 代码代析。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
trait Critical {}
impl Critical for i32 {}

fn get_critical() -&gt; impl Critical {
    4i32
}

// 违反了 `unused_must_use` lint.
get_critical();
<span class="boring">}</span></code></pre></pre>
<p>当在 trait 声明中的函数上使用时，当调用表达式是 trait 实现的函数时，该行为也适用。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    #[must_use]
    fn use_me(&amp;self) -&gt; i32;
}

impl Trait for i32 {
    fn use_me(&amp;self) -&gt; i32 { 0i32 }
}

// 违反了 `unused_must_use` lint.
5i32.use_me();
<span class="boring">}</span></code></pre></pre>
<p>当用于 trait 实现中的函数时，该属性无效。</p>
<blockquote>
<p>注意：包含该值的无关紧要的无操作表达式不会违反代码分析。
例如，将该值包装在未实现 <a href="attributes/../special-types-and-traits.html#drop"><code>Drop</code></a> 的类型中，然后不使用该类型，或者是块表达式的最终表达式，而不使用该表达式。</p>
</blockquote>
<blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
fn five() -&gt; i32 { 5i32 }

// 这些都不违反 unused_must_use lint 。
(five(),);
Some(five());
{ five() };
if true { five() } else { 0i32 };
match true {
    _ =&gt; five()
};
<span class="boring">}</span></code></pre></pre>
</blockquote>
<blockquote>
<p>注意：当有一个有意舍弃的必须使用的值时，使用带有 <code>_</code> 模式的 let 语句是惯用的写法。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
fn five() -&gt; i32 { 5i32 }

// 不违反 unused_must_use lint 。
let _ = five();
<span class="boring">}</span></code></pre></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码生成属性"><a class="header" href="#代码生成属性">代码生成属性</a></h1>
<p>下面的 <a href="attributes/../attributes.html">属性</a> 用于控制代码生成。</p>
<h2 id="优化提示"><a class="header" href="#优化提示">优化提示</a></h2>
<p><code>cold</code> 和 <code>inline</code> <a href="attributes/../attributes.html">属性</a> 给出一些建议，以便生成比没有提示更快的代码。
这些属性仅是提示，可能会被忽略。</p>
<p>这两个属性可以用于 <a href="attributes/../items/functions.html">函数</a> 。
当应用于 <a href="attributes/../items/traits.html">trait</a> 中的函数时，它们仅适用于该函数作为默认函数用于 trait 实现时，而不是所有 trait 实现。
这些属性对于没有函数体的 trait 函数没有影响。</p>
<h3 id="inline-属性"><a class="header" href="#inline-属性"><code>inline</code> 属性</a></h3>
<ul>
<li><code>inline</code> 属性* 建议将带有该属性的函数的副本放置在调用者中，而不是在定义的地方生成调用该函数的代码。</li>
</ul>
<blockquote>
<p><em><strong>注意</strong></em>: <code>rustc</code> 编译器基于内部启发式算法自动内联函数。不正确地内联函数可能会使程序变慢，因此应谨慎使用此属性。</p>
</blockquote>
<p>有三种使用 <code>inline</code> 属性的方法:</p>
<ul>
<li><code>#[inline]</code> <em>建议</em> 进行内联展开。</li>
<li><code>#[inline(always)]</code> <em>建议</em> 总是进行内联展开。</li>
<li><code>#[inline(never)]</code> <em>建议</em> 永远不进行内联展开。</li>
</ul>
<blockquote>
<p><em><strong>注意</strong></em>: 无论形式如何， <code>#[inline]</code> 都是一个提示，对于将带有该属性的函数的副本放置在调用者中没有任何 <em>强制</em> 。</p>
</blockquote>
<h3 id="cold-属性"><a class="header" href="#cold-属性"><code>cold</code> 属性</a></h3>
<p><em><code>cold</code> 属性</em> 表示带有该属性的函数不太可能被调用。</p>
<h2 id="no_builtins-属性"><a class="header" href="#no_builtins-属性"><code>no_builtins</code> 属性</a></h2>
<p><code>no_builtins</code> 属性可以用于禁用优化特定的代码模式以调用预期存在的库函数。该属性可以在 crate 级别应用。</p>
<h2 id="target_feature-属性"><a class="header" href="#target_feature-属性"><code>target_feature</code> 属性</a></h2>
<p><em><code>target_feature</code> 属性</em> 可以应用于函数，以启用为特定平台架构特性生成该函数的代码。
它使用带有单个 <code>enable</code> 键的 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>元列表名称值字符串</em></a> 语法，其值是逗号分隔的要启用的特性名称字符串。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_feature = &quot;avx2&quot;)]
</span>#[target_feature(enable = &quot;avx2&quot;)]
unsafe fn foo_avx2() {}
<span class="boring">}</span></code></pre></pre>
<p>每个 <a href="attributes/../conditional-compilation.html#target_arch">目标架构</a> 都有一组可启用的特性。
对于正在编译的 crate，如果指定了未被支持的目标架构的特性，则会出现错误。</p>
<p>对于使用不被当前平台支持的特性进行编译的函数进行调用是 <a href="attributes/../behavior-considered-undefined.html">未定义行为</a> ，除非平台明确说明这是安全的。</p>
<p>使用 <code>target_feature</code> 标注的函数不会被内联到不支持所给定特性的上下文中。
<code>#[inline(always)]</code> 属性不能与 <code>target_feature</code> 属性一起使用。</p>
<h3 id="可用特性"><a class="header" href="#可用特性">可用特性</a></h3>
<p>以下是可用的特性名称列表。</p>
<h4 id="x86-或-x86_64"><a class="header" href="#x86-或-x86_64"><code>x86</code> 或 <code>x86_64</code></a></h4>
<p>在此平台上执行不支持的特性是未定义的行为。
因此，该平台要求 <code>#[target_feature]</code> 仅应用于 <a href="attributes/../unsafe-keyword.html"><code>unsafe</code> 函数</a> 。</p>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>隐式启用</th><th>描述</th></tr></thead><tbody>
<tr><td><code>adx</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/Intel_ADX">ADX</a> — 多精度加进位指令扩展</td></tr>
<tr><td><code>aes</code></td><td><code>sse2</code></td><td><a href="https://en.wikipedia.org/wiki/AES_instruction_set">AES</a> — 高级加密标准</td></tr>
<tr><td><code>avx</code></td><td><code>sse4.2</code></td><td><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a> — 高级矢量扩展</td></tr>
<tr><td><code>avx2</code></td><td><code>avx</code></td><td><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#AVX2">AVX2</a> — 高级矢量扩展 2</td></tr>
<tr><td><code>bmi1</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets">BMI1</a> — 位操作指令集</td></tr>
<tr><td><code>bmi2</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets#BMI2">BMI2</a> — 位操作指令集 2</td></tr>
<tr><td><code>fma</code></td><td><code>avx</code></td><td><a href="https://en.wikipedia.org/wiki/FMA_instruction_set">FMA3</a> — 三操作数融合乘加</td></tr>
<tr><td><code>fxsr</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/fxsave"><code>fxsave</code></a> 和 <a href="https://www.felixcloutier.com/x86/fxrstor"><code>fxrstor</code></a> — 保存和恢复 x87 FPU、MMX 技术和 SSE 状态</td></tr>
<tr><td><code>lzcnt</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/lzcnt"><code>lzcnt</code></a> — 领先的零数目</td></tr>
<tr><td><code>pclmulqdq</code></td><td><code>sse2</code></td><td><a href="https://www.felixcloutier.com/x86/pclmulqdq"><code>pclmulqdq</code></a> — 打包无进位乘法的乘积四倍字</td></tr>
<tr><td><code>popcnt</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/popcnt"><code>popcnt</code></a> — 位值为 1 的位数</td></tr>
<tr><td><code>rdrand</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/RdRand"><code>rdrand</code></a> — 读取随机数</td></tr>
<tr><td><code>rdseed</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/RdRand"><code>rdseed</code></a> — 读取随机种子</td></tr>
<tr><td><code>sha</code></td><td><code>sse2</code></td><td><a href="https://en.wikipedia.org/wiki/Intel_SHA_extensions">SHA</a> — 安全哈希算法</td></tr>
<tr><td><code>sse</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a> — 流处理 SIMD 扩展</td></tr>
<tr><td><code>sse2</code></td><td><code>sse</code></td><td><a href="https://en.wikipedia.org/wiki/SSE2">SSE2</a> — 流处理 SIMD 扩展 2</td></tr>
<tr><td><code>sse3</code></td><td><code>sse2</code></td><td><a href="https://en.wikipedia.org/wiki/SSE3">SSE3</a> — 流处理 SIMD 扩展 3</td></tr>
<tr><td><code>sse4.1</code></td><td><code>ssse3</code></td><td><a href="https://en.wikipedia.org/wiki/SSE4#SSE4.1">SSE4.1</a> — 流处理 SIMD 扩展 4.1</td></tr>
<tr><td><code>sse4.2</code></td><td><code>sse4.1</code></td><td><a href="https://en.wikipedia.org/wiki/SSE4#SSE4.2">SSE4.2</a> — 流处理 SIMD 扩展 4.2</td></tr>
<tr><td><code>ssse3</code></td><td><code>sse3</code></td><td><a href="https://en.wikipedia.org/wiki/SSSE3">SSSE3</a> — 补充流处理 SIMD 扩展 3</td></tr>
<tr><td><code>xsave</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/xsave"><code>xsave</code></a> — 保存处理器扩展状态</td></tr>
<tr><td><code>xsavec</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/xsavec"><code>xsavec</code></a> — 保存带压缩的处理器扩展状态</td></tr>
<tr><td><code>xsaveopt</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/xsaveopt"><code>xsaveopt</code></a> — 优化保存处理器扩展状态</td></tr>
<tr><td><code>xsaves</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/xsaves"><code>xsaves</code></a> — 以管理模式保存处理器扩展状态</td></tr>
</tbody></table>
</div><!-- Keep links near each table to make it easier to move and update. -->
<h4 id="aarch64"><a class="header" href="#aarch64"><code>aarch64</code></a></h4>
<p>这个平台要求 <code>#[target_feature]</code> 仅能应用于 <a href="attributes/../unsafe-keyword.html"><code>unsafe</code>函数</a> 。</p>
<p>更多关于这些特性的文档可以在 [ARM 架构参考手册][ARM Architecture Reference Manual] 或 [developer.arm.com] 中找到。</p>
<blockquote>
<p><em><strong>注意</strong></em>: 如果使用以下特性对，应该一起标记为已启用或已禁用:
<code>paca</code> 和 <code>pacg</code> ，LLVM 当前将它们实现为一个特性。</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>隐式启用</th><th>特性名称</th></tr></thead><tbody>
<tr><td><code>aes</code></td><td><code>neon</code></td><td>FEAT_AES - 高级 <abbr title="Single Instruction Multiple Data">SIMD</abbr> AES 指令</td></tr>
<tr><td><code>bf16</code></td><td></td><td>FEAT_BF16 - BFloat16 指令</td></tr>
<tr><td><code>bti</code></td><td></td><td>FEAT_BTI - 分支目标识别</td></tr>
<tr><td><code>crc</code></td><td></td><td>FEAT_CRC - CRC32 校验和指令</td></tr>
<tr><td><code>dit</code></td><td></td><td>FEAT_DIT - 数据独立定时指令</td></tr>
<tr><td><code>dotprod</code></td><td></td><td>FEAT_DotProd - 高级 SIMD Int8 点乘指令</td></tr>
<tr><td><code>dpb</code></td><td></td><td>FEAT_DPB - 数据缓存清除到持久点</td></tr>
<tr><td><code>dpb2</code></td><td></td><td>FEAT_DPB2 - 数据缓存清除到深度持久点</td></tr>
<tr><td><code>f32mm</code></td><td><code>sve</code></td><td>FEAT_F32MM - SVE 单精度 FP 矩阵乘法指令</td></tr>
<tr><td><code>f64mm</code></td><td><code>sve</code></td><td>FEAT_F64MM - SVE 双精度 FP 矩阵乘法指令</td></tr>
<tr><td><code>fcma</code></td><td><code>neon</code></td><td>FEAT_FCMA - 浮点复数支持</td></tr>
<tr><td><code>fhm</code></td><td><code>fp16</code></td><td>FEAT_FHM - 半精度 FP FMLAL 指令</td></tr>
<tr><td><code>flagm</code></td><td></td><td>FEAT_FlagM - 条件标志位操作</td></tr>
<tr><td><code>fp16</code></td><td><code>neon</code></td><td>FEAT_FP16 - 半精度 FP 数据处理</td></tr>
<tr><td><code>frintts</code></td><td></td><td>FEAT_FRINTTS - 浮点到整数帮助指令</td></tr>
<tr><td><code>i8mm</code></td><td></td><td>FEAT_I8MM - Int8 矩阵乘法</td></tr>
<tr><td><code>jsconv</code></td><td><code>neon</code></td><td>FEAT_JSCVT - JavaScript 转换指令</td></tr>
<tr><td><code>lse</code></td><td></td><td>FEAT_LSE - 大系统扩展</td></tr>
<tr><td><code>lor</code></td><td></td><td>FEAT_LOR - 有限排序区域扩展</td></tr>
<tr><td><code>mte</code></td><td></td><td>FEAT_MTE - 内存标记扩展</td></tr>
<tr><td><code>neon</code></td><td></td><td>FEAT_FP 和 FEAT_AdvSIMD - 浮点数和高级 SIMD 扩展</td></tr>
<tr><td><code>pan</code></td><td></td><td>FEAT_PAN - 特权访问不允许扩展</td></tr>
<tr><td><code>paca</code></td><td></td><td>FEAT_PAuth - 指针认证（地址认证）</td></tr>
<tr><td><code>pacg</code></td><td></td><td>FEAT_PAuth - 指针认证（通用认证）</td></tr>
<tr><td><code>pmuv3</code></td><td></td><td>FEAT_PMUv3 - 性能监视器扩展（v3）</td></tr>
<tr><td><code>rand</code></td><td></td><td>FEAT_RNG - 随机数生成器</td></tr>
<tr><td><code>ras</code></td><td></td><td>FEAT_RAS - 可靠性、可用性和服务性扩展</td></tr>
<tr><td><code>rcpc</code></td><td></td><td>FEAT_LRCPC - 一致性处理器ARMv8.2 可以支持多种架构，其中一些可用特性如下所示：</td></tr>
<tr><td><code>rdm</code></td><td></td><td>FEAT_RDM - 双精度乘累加取整指令</td></tr>
<tr><td><code>sb</code></td><td></td><td>FEAT_SB - 推测屏障指令</td></tr>
<tr><td><code>sha2</code></td><td><code>neon</code></td><td>FEAT_SHA1 &amp; FEAT_SHA256 - 高级SIMD SHA指令</td></tr>
<tr><td><code>sha3</code></td><td><code>sha2</code></td><td>FEAT_SHA512 &amp; FEAT_SHA3 - 高级SIMD SHA指令</td></tr>
<tr><td><code>sm4</code></td><td><code>neon</code></td><td>FEAT_SM3 &amp; FEAT_SM4 - 高级SIMD SM3/4指令</td></tr>
<tr><td><code>spe</code></td><td></td><td>FEAT_SPE - 统计分析扩展指令</td></tr>
<tr><td><code>ssbs</code></td><td></td><td>FEAT_SSBS - 推测存储旁路安全指令</td></tr>
<tr><td><code>sve</code></td><td><code>fp16</code></td><td>FEAT_SVE - 可扩展向量扩展指令</td></tr>
<tr><td><code>sve2</code></td><td><code>sve</code></td><td>FEAT_SVE2 - 可扩展向量扩展2指令</td></tr>
<tr><td><code>sve2-aes</code></td><td><code>sve2</code>, <code>aes</code></td><td>FEAT_SVE_AES - SVE AES指令</td></tr>
<tr><td><code>sve2-sm4</code></td><td><code>sve2</code>, <code>sm4</code></td><td>FEAT_SVE_SM4 - SVE SM4指令</td></tr>
<tr><td><code>sve2-sha3</code></td><td><code>sve2</code>, <code>sha3</code></td><td>FEAT_SVE_SHA3 - SVE SHA3指令</td></tr>
<tr><td><code>sve2-bitperm</code></td><td><code>sve2</code></td><td>FEAT_SVE_BitPerm - SVE 位重排指令</td></tr>
<tr><td><code>tme</code></td><td></td><td>FEAT_TME - 事务内存扩展指令</td></tr>
<tr><td><code>vh</code></td><td></td><td>FEAT_VHE - 虚拟化主机扩展指令</td></tr>
</tbody></table>
</div>
<h4 id="wasm32-或-wasm64"><a class="header" href="#wasm32-或-wasm64"><code>wasm32</code> 或 <code>wasm64</code></a></h4>
<p><code>#[target_feature]</code> 可以在 Wasm 平台上用于安全函数和 <a href="attributes/../unsafe-keyword.html"><code>不安全函数</code></a> 。
在 Wasm 引擎不支持的指令下，尝试使用 <code>#[target_feature]</code> 属性将在加载时失败，不会有与编译器预期不同的解释风险，因此不可能引起未定义行为。</p>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody>
<tr><td><code>simd128</code></td><td><a href="https://github.com/webassembly/simd">WebAssembly simd proposal</a></td></tr>
</tbody></table>
</div>
<h3 id="附加信息"><a class="header" href="#附加信息">附加信息</a></h3>
<p><a href="attributes/../conditional-compilation.html#target_feature"><code>target_feature</code> 条件编译选项</a> 可用于根据编译时设置选择性地启用或禁用代码的编译。
请注意，该选项不受 <code>target_feature</code> 属性的影响，仅受整个 crate 启用的特性的驱动。</p>
<p>标准库中的 <a href="attributes/../../std/arch/macro.is_x86_feature_detected.html"><code>is_x86_feature_detected</code></a> 或 <a href="attributes/../../std/arch/macro.is_aarch64_feature_detected.html"><code>is_aarch64_feature_detected</code></a> 宏可用于在这些平台上进行运行时特性检测。</p>
<blockquote>
<p>注意: <code>rustc</code> 对于每个目标和 CPU 都有一组默认启用的特性。
可以使用 <a href="attributes/../../rustc/codegen-options/index.html#target-cpu"><code>-C target-cpu</code></a> 标志选择 CPU 。可以使用 <a href="attributes/../../rustc/codegen-options/index.html#target-feature"><code>-C target-feature</code></a> 标志为整个 crate 启用或禁用单个特性。</p>
</blockquote>
<h2 id="track_caller-属性"><a class="header" href="#track_caller-属性"><code>track_caller</code> 属性</a></h2>
<p><code>track_caller</code> 属性可以应用于任何使用 <a href="attributes/../items/external-blocks.html#abi"><code>&quot;Rust&quot;</code> ABI</a> 的函数，除了入口点 <code>fn main</code> 。
当应用于 trait 声明中的函数和方法时，该属性适用于所有实现。如果 trait 提供了带有该属性的默认实现，则该属性还适用于重写实现。</p>
<p>当应用于 <code>extern</code> 块中的函数时，该属性也必须应用于任何链接的实现，否则将导致未定义的行为。
当应用于提供给 <code>extern</code> 块的函数时，<code>extern</code> 块中的声明也必须具有该属性，否则将导致未定义的行为。</p>
<h3 id="行为"><a class="header" href="#行为">行为</a></h3>
<p>将此属性应用于函数 <code>f</code> ，允许 <code>f</code> 中的代码获取一个提示，即导致 <code>f</code> 调用的 &quot;顶级&quot; 跟踪调用的 <a href="attributes/../../core/panic/struct.Location.html"><code>Location</code></a> 。
在观察点，实现行为就好像它从 <code>f</code> 的帧向上遍历栈，查找 <em>未归属</em> 函数 <code>outer</code> 的最近帧，并返回 <code>outer</code> 中跟踪调用的 <a href="attributes/../../core/panic/struct.Location.html"><code>Location</code></a>。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[track_caller]
fn f() {
    println!(&quot;{}&quot;, std::panic::Location::caller());
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>注意: <code>core</code> 提供 <a href="attributes/../../core/panic/struct.Location.html#method.caller"><code>core::panic::Location::caller</code></a> 用于获取调用位置。它包装了 <code>rustc</code> 实现的 <a href="attributes/../../core/intrinsics/fn.caller_location.html"><code>core::intrinsics::caller_location</code></a> 内置函数。</p>
</blockquote>
<blockquote>
<p>注意: 由于产生的 <code>Location</code> 只是一个提示，实现可能会在遍历堆栈时提前停止。请参阅 <a href="attributes/codegen.html#limitations">限制</a> 以获取重要的注意事项。</p>
</blockquote>
<h4 id="示例-2"><a class="header" href="#示例-2">示例</a></h4>
<p>当 <code>f</code> 直接被 <code>calls_f</code> 调用时，<code>f</code> 中的代码会观察到它在 <code>calls_f</code> 中被调用的地方:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[track_caller]
</span><span class="boring">fn f() {
</span><span class="boring">    println!(&quot;{}&quot;, std::panic::Location::caller());
</span><span class="boring">}
</span>fn calls_f() {
    f(); // &lt;-- f() prints this location
}
<span class="boring">}</span></code></pre></pre>
<p>当函数 <code>f</code> 被另一个带有 <code>track_caller</code> 属性的函数 <code>g</code> 直接调用，而 <code>g</code> 又被 <code>calls_g</code> 调用时， <code>f</code> 和 <code>g</code> 中的代码都可以观察到 <code>calls_g</code> 中调用 <code>g</code> 的位置:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[track_caller]
</span><span class="boring">fn f() {
</span><span class="boring">    println!(&quot;{}&quot;, std::panic::Location::caller());
</span><span class="boring">}
</span>#[track_caller]
fn g() {
    println!(&quot;{}&quot;, std::panic::Location::caller());
    f();
}

fn calls_g() {
    g(); // &lt;-- g() prints this location twice, once itself and once from f()
}
<span class="boring">}</span></code></pre></pre>
<p>当函数 <code>g</code> 被另一个有 <code>track_caller</code> 属性的函数 <code>h</code> 直接或间接调用时 (例如 <code>h</code> 被 <code>calls_h</code> 调用) ，则 <code>f</code> 、 <code>g</code> 和 <code>h</code> 中的代码都会观察到 <code>calls_h</code> 中 <code>h</code> 的调用位置。
也就是说，调用链中最深的有 <code>track_caller</code> 属性的函数的调用位置会传递到所有下层函数:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[track_caller]
</span><span class="boring">fn f() {
</span><span class="boring">    println!(&quot;{}&quot;, std::panic::Location::caller());
</span><span class="boring">}
</span><span class="boring">#[track_caller]
</span><span class="boring">fn g() {
</span><span class="boring">    println!(&quot;{}&quot;, std::panic::Location::caller());
</span><span class="boring">    f();
</span><span class="boring">}
</span>#[track_caller]
fn h() {
    println!(&quot;{}&quot;, std::panic::Location::caller());
    g();
}

fn calls_h() {
    h(); // &lt;-- prints this location three times, once itself, once from g(), once from f()
}
<span class="boring">}</span></code></pre></pre>
<p>以次类推。</p>
<h3 id="限制"><a class="header" href="#限制">限制</a></h3>
<p>该信息是一个提示，实现不需要保留它。</p>
<p>特别地，将一个带有 <code>#[track_caller]</code> 的函数转换为函数指针会创建一个外壳函数，对于观察者来说，该外壳函数似乎是在函数定义的位置被调用的，从而在虚拟调用之间丢失了实际的调用者信息。
这种转换的常见例子是创建一个具有方法的 trait 对象，并将其进行标注。</p>
<blockquote>
<p>注意: 函数指针的上述外壳函数是必要的，因为 <code>rustc</code> 在代码生成上实现 <code>track_caller</code> 通过将一个隐式参数附加到函数 ABI 上，但是这对于间接调用是不安全的，
因为该参数不是函数类型的一部分，给定的函数指针类型可能引用一个没有该属性的函数或具有该属性的函数。创建外壳函数隐藏了函数指针调用者的隐式参数，从而保持了安全性。</p>
</blockquote>
<h2 id="instruction_set-属性"><a class="header" href="#instruction_set-属性"><code>instruction_set</code> 属性</a></h2>
<p>可以将 <code>instruction_set</code> 属性应用于函数，以启用针对目标体系结构支持的特定指令集的代码生成。
它使用 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaListPath</em></a> 语法和一个由架构和指令集组成的路径，指定如何为在单个程序中使用多个指令集的体系结构生成代码。</p>
<p>对于 <code>ARMv4</code> 和 <code>ARMv5te</code> 架构的目标，以下值可用:</p>
<ul>
<li><code>arm::a32</code> - 使用 ARM 编码.</li>
<li><code>arm::t32</code> - 使用 Thumb 编码.</li>
</ul>
<!-- ignore: arm-only -->
<pre><code class="language-rust ignore">#[instruction_set(arm::a32)]
fn foo_arm_code() {}

#[instruction_set(arm::t32)]
fn bar_thumb_code() {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="限制-1"><a class="header" href="#限制-1">限制</a></h1>
<p>下面的 <a href="attributes/../attributes.html">属性</a> 影响编译时的限制。</p>
<h2 id="recursion_limit-属性"><a class="header" href="#recursion_limit-属性"><code>recursion_limit</code> 属性</a></h2>
<p><em><code>recursion_limit</code> 属性</em> 可以在 <a href="attributes/../crates-and-source-files.html">crate</a> 级别上应用，以设置潜在的无限递归编译时操作 (如宏展开或自动解引用) 的最大深度。它使用 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>元名称值字符串</em></a> 语法来指定递归深度。</p>
<blockquote>
<p>注意：<code>rustc</code> 中的默认值是 128。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span>#![recursion_limit = &quot;4&quot;]

<span class="boring">fn main() {
</span>macro_rules! a {
    () =&gt; { a!(1); };
    (1) =&gt; { a!(2); };
    (2) =&gt; { a!(3); };
    (3) =&gt; { a!(4); };
    (4) =&gt; { };
}

// 这段代码无法扩展，因为它需要超过 4 的递归深度。
a!{}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span>#![recursion_limit = &quot;1&quot;]

<span class="boring">fn main() {
</span>// 这个失败是因为它需要进行两个递归步骤来自动解引用。
(|_: &amp;u8| {})(&amp;&amp;&amp;1);
<span class="boring">}</span></code></pre></pre>
<h2 id="type_length_limit-属性"><a class="header" href="#type_length_limit-属性"><code>type_length_limit</code> 属性</a></h2>
<p><code>type_length_limit</code> 属性限制了当进行单态化时，构建具体类型所做的最大类型替换数量。
它应用于 <a href="attributes/../crates-and-source-files.html">crate</a> 级别，使用 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>元名称值字符串</em></a> 语法设置限制，以基于类型替换数量设置限制。</p>
<blockquote>
<p>注意：<code>rustc</code> 中的默认值为 1048576。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span>#![type_length_limit = &quot;4&quot;]

<span class="boring">fn main() {
</span>fn f&lt;T&gt;(x: T) {}

// 编译失败，因为将 f::&lt;((((i32,), i32), i32), i32)&gt; 进行单态化需要超过 4 个类型元素。
f(((((1,), 2), 3), 4));
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型系统属性"><a class="header" href="#类型系统属性">类型系统属性</a></h1>
<p>以下属性用于更改类型的使用方式。</p>
<h2 id="non_exhaustive-属性"><a class="header" href="#non_exhaustive-属性"><code>non_exhaustive</code> 属性</a></h2>
<p><em><code>non_exhaustive</code> 属性</em> 表示类型或变体将来可能会添加更多的字段或变体。
它可以应用于 [<code>struct</code>] 、 [<code>enum</code>] 和 <code>enum</code> 变体。</p>
<p><code>non_exhaustive</code> 属性使用 <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>元字</em></a> 语法，因此不需要输入任何内容。</p>
<p>在定义的 crate 中，<code>non_exhaustive</code> 没有任何作用。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
pub struct Config {
    pub window_width: u16,
    pub window_height: u16,
}

#[non_exhaustive]
pub enum Error {
    Message(String),
    Other,
}

pub enum Message {
    #[non_exhaustive] Send { from: u32, to: u32, contents: String },
    #[non_exhaustive] Reaction(u32),
    #[non_exhaustive] Quit,
}

// 非穷尽结构体可以在定义的 crate 中像普通结构体一样构造。
let config = Config { window_width: 640, window_height: 480 };

// 非穷尽结构体可以在定义的 crate 中进行完全匹配。
if let Config { window_width, window_height } = config {
    // ...
}

let error = Error::Other;
let message = Message::Reaction(3);

// 非穷尽枚举可以在定义的 crate 中进行完全匹配。
match error {
    Error::Message(ref s) =&gt; { },
    Error::Other =&gt; { },
}

match message {
    // 非穷尽变体可以在定义的 crate 中进行完全匹配。
    Message::Send { from, to, contents } =&gt; { },
    Message::Reaction(id) =&gt; { },
    Message::Quit =&gt; { },
}
<span class="boring">}</span></code></pre></pre>
<p>在定义之外，使用 <code>non_exhaustive</code> 注解的类型有限制，以保持向后兼容性，当添加新字段或变量时。</p>
<p>不能在定义之外构造非穷尽类型:</p>
<ul>
<li>不能使用 [结构体表达式][StructExpression] (包括 <a href="attributes/../expressions/struct-expr.html#functional-update-syntax">函数更新语法</a>) 构造非穷尽变体 ( [<code>struct</code>] 或 [<code>enum</code> variant] ) 。</li>
<li>可以构造 [<code>enum</code>] 实例。</li>
</ul>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// `Config`，`Error` 和 `Message` 是在上游 crate 中定义并使用了 `#[non_exhaustive]` 标记的类型。
use upstream::{Config, Error, Message};

// 无法构造 `Config` 的实例，如果在新版本中添加了新的字段，则会导致编译失败，因此不允许。
let config = Config { window_width: 640, window_height: 480 };

// 可以构造 `Error` 的实例，如果新的变量被引入，也不会导致编译失败。
let error = Error::Message(&quot;foo&quot;.to_string());

// 无法构造 `Message::Send` 或 `Message::Reaction` 的实例，如果在新版本中添加了新的字段，则会导致编译失败，因此不允许。
let message = Message::Send { from: 0, to: 1, contents: &quot;foo&quot;.to_string(), };
let message = Message::Reaction(0);

// 无法构造 `Message::Quit` 的实例，如果将其转换为元组变量 `upstream`，则会导致编译失败。
let message = Message::Quit;</code></pre>
<p>在定义类型的 crate 之外，在匹配非穷尽类型时存在以下限制:</p>
<ul>
<li>当匹配非穷尽变体 (<a href="attributes/../items/structs.html"><code>struct</code></a> 或 <a href="attributes/../items/enumerations.html"><code>enum</code> variant</a>) 时，必须使用带有 <code>..</code> 的 <a href="attributes/../patterns.html#struct-patterns"><em>结构体模式</em></a> ，元组变体构造函数的可见性降为 <code>min($vis, pub(crate))</code> 。</li>
<li>当匹配非穷尽 <a href="attributes/../items/enumerations.html"><code>enum</code></a> 时，匹配一个变体不会导致分支的穷尽性。</li>
</ul>
<!-- ignore: requires external crates -->
<pre><code class="language-rust  ignore">// `Config` ， `Error` 和 `Message` 是在上游 crate 中定义的类型，已经被注释为 `#[non_exhaustive]`。
use upstream::{Config, Error, Message};

// 无法在非枚举穷尽(enum non-exhaustive)上进行匹配而不包括通配符分支。
match error {
Error::Message(ref s) =&gt; {},
Error::Other =&gt; {},
// 可以编译: `_ =&gt; {}，`
}

// 无法在非穷尽的结构体上进行匹配，除非使用通配符。
if let Ok(Config { window_width, window_height }) = config {
    // 可以编译: `..`
}

match message {
  // 无法在非穷尽的结构体上进行匹配，除非使用通配符。
  Message::Send { from, to, contents } =&gt; { },
  // 无法匹配非穷尽的元组或单元枚举变体。
  Message::Reaction(type) =&gt; { },
  Message::Quit =&gt; { },
}</code></pre>
<p>在外部的 crate 中，也不允许将非穷尽类型进行强制类型转换。</p>
<pre><code class="language-rust  ignore">use othercrate::NonExhaustiveEnum;

// 无法在其定义 crate 之外将非穷尽枚举转换为其他类型。
let _ = NonExhaustiveEnum::default() as u8;</code></pre>
<p>非穷尽类型在下游的 crate 中总是被视为是有 inhabitant(指代值或实例) 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语句和表达式"><a class="header" href="#语句和表达式">语句和表达式</a></h1>
<p>Rust <em>主要</em> 是一种表达式语言。这意味着大多数产生值或引起副作用的计算都由统一的语法类别——表达式指导。
每种表达式通常可以嵌套在其他表达式中，表达式的计算规则涉及指定表达式产生的值以及其子表达式本身的计算顺序。</p>
<p>语句则主要用于包含和显式地序列化表达式计算。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语句"><a class="header" href="#语句">语句</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>语句</em> :<br />
      <code>;</code><br />
   | <a href="items.html"><em>条目</em></a><br />
   | <a href="statements.html#let-statements"><em>Let语句</em></a><br />
   | <a href="statements.html#expression-statements"><em>表达式语句</em></a><br />
   | <a href="macros.html#macro-invocation"><em>宏调用语句</em></a></p>
</blockquote>
<p><em>语句</em> 是 <a href="expressions/block-expr.html">块</a> 的组成部分，而块又是之外 <a href="expressions.html">表达式</a> 或 <a href="items/functions.html">函数</a> 的组成部分。</p>
<p>Rust 有两种语句：<a href="statements.html#declaration-statements">声明语句</a> 和 [表达式语句](expression statements) 。</p>
<h2 id="声明语句"><a class="header" href="#声明语句">声明语句</a></h2>
<p><em>声明语句</em> 引入一个或多个 <em>名称</em> 到闭合语句块中。
声明的名称可能表示新变量或新 <a href="items.html">条目</a> 。</p>
<p>声明语句有两种类型: <code>let</code> 语句和条目声明。</p>
<h3 id="条目声明"><a class="header" href="#条目声明">条目声明</a></h3>
<p><em>条目声明语句</em> 的语法形式与 <a href="items/modules.html">模块</a> 中的 <a href="items.html">条目声明</a> 相同。
在语句块中声明一个条目，将其作用域限制为包含该语句的块。
该条目不会被赋予 <a href="paths.html#canonical-paths">规范路径</a> ，也不会声明任何子条目。
唯一的例外是通过 <a href="items/implementations.html">实现</a> 定义的关联条目，只要该条目和 (如果适用) trait 可访问，它们仍然可以在外部作用域中访问。
否则，它与在模块中声明该条目的含义相同。</p>
<p>不会隐式捕获包含函数的泛型参数、参数和局部变量。
例如， <code>inner</code> 无法访问 <code>outer_var</code> 。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn outer() {
  let outer_var = true;

  fn inner() { /* outer_var 在这里不在作用域内。 */ }

  inner();
}
<span class="boring">}</span></code></pre></pre>
<h3 id="let-语句"><a class="header" href="#let-语句"><code>let</code> 语句</a></h3>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>Let语句</em> :<br />
   <a href="attributes.html"><em>外部属性</em></a><sup>*</sup> <code>let</code> <a href="patterns.html"><em>模式非顶层选项</em></a>
( <code>:</code> <a href="types.html"><em>类型</em></a> )<sup>?</sup> (<code>=</code> <a href="expressions.html"><em>表达式</em></a> <a href="statements.html#let-else-restriction">†</a>
( <code>else</code> <a href="expressions/block-expr.html"><em>块表达式</em></a>) <sup>?</sup> ) <sup>?</sup> <code>;</code></p>
<p><span id="let-else-restriction">† 当指定了 <code>else</code> 块时，表达式不能是 <a href="expressions/operator-expr.html#lazy-boolean-operators"><em>惰性布尔表达式</em></a> ，也不能以 <code>}</code> 结尾。</span></p>
</blockquote>
<p><code>let</code> 语句引入了一组由 <a href="patterns.html">模式</a> 给定的新 <a href="variables.html">变量</a> 。模式可选地后跟一个类型注释，然后以初始化表达式结束，或者跟随可选的 <code>else</code> 块。
当没有给出类型注释时，编译器将推断类型，如果没有足够的类型信息进行明确推断，则会发出错误信号。
任何由变量声明引入的变量在声明点到包含块范围的结尾之间都可见，除非它们被另一个变量声明隐藏。</p>
<p>如果不存在 <code>else</code> 块，则模式必须是不可反驳的。
如果存在 <code>else</code> 块，则模式可以是可反驳的。
如果模式不匹配 (这需要它是可反驳的) ，则执行 <code>else</code> 块。
<code>else</code> 块必须始终发散 (求值为 <a href="types/never.html">永不类型</a> )。</p>
<p>译注：&quot;反驳&quot; (refutable) 和 &quot;不可反驳&quot; (irrefutable) 表示模式是否能够在任何情况下都成功匹配。
&quot;发散&quot; (diverge) 指的是一个表达式无法正常终止并返回值的情况。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (mut v, w) = (vec![1, 2, 3], 42); // 绑定可以是可变或常量
let Some(t) = v.pop() else { // 可反驳的模式需要一个 else 块
    panic!(); // else 块必须发散
};
let [u, v] = [v[0], v[1]] else { // 这个模式是不可反驳的，所以编译器会作为 else 块是冗余的进行 Lint 检查
    panic!();
};
<span class="boring">}</span></code></pre></pre>
<h2 id="表达式语句"><a class="header" href="#表达式语句">表达式语句</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>表达式语句</em> :<br />
      <a href="expressions.html"><em>无块表达式</em></a> <code>;</code><br />
   | <a href="expressions.html"><em>块表达式</em></a> <code>;</code><sup>?</sup></p>
</blockquote>
<p>一个表达式语句是指执行一个表达式并忽略其结果的语句。通常，表达式语句的目的是触发其表达式的副作用。</p>
<p>如果一个表达式只包含一个块表达式或控制流表达式，并且在允许语句的上下文中使用，它可以省略尾随的分号。
这会导致在将其解析为独立语句和作为另一个表达式的一部分之间产生歧义。在这种情况下，它会被解析为语句。
当作为语句使用时，<a href="expressions.html"><em>块表达式</em></a> 表达式的类型必须是单元类型。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3];
v.pop();          // 忽略 pop 返回的元素
if v.is_empty() {
    v.push(5);
} else {
    v.remove(0);
}                 // 分号可以省略。
[1];              // 独立的表达式语句，不是索引表达式。
<span class="boring">}</span></code></pre></pre>
<p>当省略了语句结尾的分号时，其结果必须是类型为 <code>()</code>。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 错误: 块表达式类型是 i32, 不是 ()
// Error: expected `()` because of default return type
// if true {
//   1
// }

// 成功: 块表达式类型是 i32
if true {
  1
} else {
  2
};
<span class="boring">}</span></code></pre></pre>
<h2 id="语句上的属性"><a class="header" href="#语句上的属性">语句上的属性</a></h2>
<p>语句可以接受 <a href="attributes.html">外部属性</a> 。
在语句上具有意义的属性包括 <a href="conditional-compilation.html"><code>cfg</code></a> 和 <a href="attributes/diagnostics.html#lint-check-attributes">lint 检查属性</a> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="表达式"><a class="header" href="#表达式">表达式</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>表达式</em> :<br />
      <em>无块表达式</em><br />
   | <em>块表达式</em></p>
<p><em>无块表达式</em> :<br />
   <a href="attributes.html"><em>外部属性</em></a><sup>*</sup><a href="expressions.html#expression-attributes">†</a><br />
   (<br />
         [<em>LiteralExpression</em>][<em>字面值表达式</em>]<br />
      | <a href="expressions/path-expr.html"><em>路径表达式</em></a><br />
      | <a href="expressions/operator-expr.html"><em>操作符表达式</em></a><br />
      | <a href="expressions/grouped-expr.html"><em>分组表达式</em></a><br />
      | <a href="expressions/array-expr.html"><em>数组表达式</em></a><br />
      | <a href="expressions/await-expr.html"><em>Await表达式</em></a><br />
      | <a href="expressions/array-expr.html#array-and-slice-indexing-expressions"><em>索引表达式</em></a><br />
      | <a href="expressions/tuple-expr.html"><em>元组表达式</em></a><br />
      | <a href="expressions/tuple-expr.html#tuple-indexing-expressions"><em>元组索引表达式</em></a><br />
      | <a href="expressions/struct-expr.html"><em>结构体表达式</em></a><br />
      | <a href="expressions/call-expr.html"><em>调用表达式</em></a><br />
      | <a href="expressions/method-call-expr.html"><em>方法调用表达式</em></a><br />
      | <a href="expressions/field-expr.html"><em>字段表达式</em></a><br />
      | <a href="expressions/closure-expr.html"><em>闭包表达式</em></a><br />
      | <a href="expressions/block-expr.html#async-blocks"><em>Async块表达式</em></a><br />
      | <a href="expressions/loop-expr.html#continue-expressions"><em>Continue表达式</em></a><br />
      | <a href="expressions/loop-expr.html#break-expressions"><em>Break表达式</em></a><br />
      | <a href="expressions/range-expr.html"><em>区间表达式</em></a><br />
      | <a href="expressions/return-expr.html"><em>Return表达式</em></a><br />
      | <a href="expressions/underscore-expr.html"><em>下划线表达式</em></a><br />
      | <a href="macros.html#macro-invocation"><em>宏调用表达式</em></a><br />
   )</p>
<p><em>块表达式</em> :<br />
   <a href="attributes.html"><em>外部属性</em></a><sup>*</sup><a href="expressions.html#expression-attributes">†</a><br />
   (<br />
         <a href="expressions/block-expr.html"><em>块表达式</em></a><br />
      | <a href="expressions/block-expr.html#unsafe-blocks"><em>Unsafe块表达式</em></a><br />
      | <a href="expressions/loop-expr.html"><em>Loop表达式</em></a><br />
      | <a href="expressions/if-expr.html#if-expressions"><em>If表达式</em></a><br />
      | <a href="expressions/if-expr.html#if-let-expressions"><em>IfLet表达式</em></a><br />
      | <a href="expressions/match-expr.html"><em>Match表达式</em></a><br />
   )</p>
</blockquote>
<p>表达式可能具有两个角色: 它总是产生一个值，并且它可能具有效果 (也称为 &quot;副作用&quot; )。
表达式计算为一个值，在计算期间具有副作用。
许多表达式包含子表达式，称为表达式的操作数。每种表达式的含义决定了几件事:</p>
<ul>
<li>在计算表达式时是否评估操作数</li>
<li>评估操作数的顺序</li>
<li>如何将操作数的值组合以获取表达式的值</li>
</ul>
<p>通过这种方式，表达式的结构决定了执行的结构。
块只是另一种表达式，因此块、语句、表达式和块可以递归地嵌套到任意深度。</p>
<blockquote>
<p><strong>注意</strong>: 我们给表达式的操作数命名以便于讨论，但这些名称未稳定，可能会更改。</p>
</blockquote>
<h2 id="表达式优先级"><a class="header" href="#表达式优先级">表达式优先级</a></h2>
<p>Rust 运算符和表达式的优先级按照以下顺序进行排列，从强到弱。
在相同优先级的二元运算符中，根据它们的结合性给出了它们的分组顺序。</p>
<div class="table-wrapper"><table><thead><tr><th>运算符/表达式</th><th>结合性</th></tr></thead><tbody>
<tr><td>路径</td><td></td></tr>
<tr><td>方法调用</td><td></td></tr>
<tr><td>字段表达式</td><td>从左到右</td></tr>
<tr><td>函数调用、数组索引</td><td></td></tr>
<tr><td><code>?</code></td><td></td></tr>
<tr><td>一元 <code>-</code> <code>*</code> <code>!</code> <code>&amp;</code> <code>&amp;mut</code></td><td></td></tr>
<tr><td><code>as</code></td><td>从左到右</td></tr>
<tr><td><code>*</code> <code>/</code> <code>%</code></td><td>从左到右</td></tr>
<tr><td><code>+</code> <code>-</code></td><td>从左到右</td></tr>
<tr><td><code>&lt;&lt;</code> <code>&gt;&gt;</code></td><td>从左到右</td></tr>
<tr><td><code>&amp;</code></td><td>从左到右</td></tr>
<tr><td><code>^</code></td><td>从左到右</td></tr>
<tr><td><code>|</code></td><td>从左到右</td></tr>
<tr><td><code>==</code> <code>!=</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code></td><td>需要括号</td></tr>
<tr><td><code>&amp;&amp;</code></td><td>从左到右</td></tr>
<tr><td><code>||</code></td><td>从左到右</td></tr>
<tr><td><code>..</code> <code>..=</code></td><td>需要括号</td></tr>
<tr><td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <br> <code>&amp;=</code> <code>|=</code> <code>^=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code></td><td>从右到左</td></tr>
<tr><td><code>return</code> <code>break</code> 闭包</td><td></td></tr>
</tbody></table>
</div>
<h2 id="操作数的求值顺序"><a class="header" href="#操作数的求值顺序">操作数的求值顺序</a></h2>
<p>以下表达式列表的所有表达式都以相同的方式对其操作数进行评估，如在列表后面所述。
其他表达式要么不需要操作数，要么根据其各自的页面上描述的条件进行有条件的评估。</p>
<ul>
<li>解引用表达式</li>
<li>错误传导表达式</li>
<li>取反表达式</li>
<li>算术和逻辑二元运算符</li>
<li>比较运算符</li>
<li>类型转换表达式</li>
<li>分组表达式</li>
<li>数组表达式</li>
<li><code>await</code> 表达式</li>
<li>索引表达式</li>
<li>元组表达式</li>
<li>元组索引表达式</li>
<li>结构体表达式</li>
<li>函数调用表达式</li>
<li>方法调用表达式</li>
<li>字段表达式</li>
<li><code>break</code> 表达式</li>
<li>范围表达式</li>
<li><code>return</code> 表达式</li>
</ul>
<p>这些表达式的操作数在应用表达式的效果之前进行求值。
取多个操作数的表达式按照源代码中从左到右的顺序进行求值。</p>
<blockquote>
<p><strong>注意</strong>: 哪些子表达式是一个表达式的操作数由前面的 &quot;表达式优先级&quot; 部分决定。</p>
</blockquote>
<p>例如，两个 <code>next</code> 方法调用总是按照它们在代码中出现的顺序被调用:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// 在这个例子中使用 `Vec` 而不是数组是为了避免引用，因为在编写此示例时没有稳定的拥有数组迭代器。
</span>let mut one_two = vec![1, 2].into_iter();
assert_eq!(
    (1, 2),
    (one_two.next().unwrap(), one_two.next().unwrap())
);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>注意</strong>: 由于这个规则是递归应用的，所以这些表达式也是从内到外依次求值的，直到没有更深层次的子表达式。在这个过程中会忽略同级的表达式。</p>
</blockquote>
<h2 id="占位表达式和值表达式"><a class="header" href="#占位表达式和值表达式">占位表达式和值表达式</a></h2>
<p>表达式分为两个主要类别：占位表达式和值表达式；
还有第三个次要的表达式类别称为可赋值表达式。
在每个表达式中，操作数也可以出现在占位上下文或值上下文中。
表达式的评估取决于它自己的类别和它所在的上下文。</p>
<p><em>占位表达式</em> 是表示内存占位的表达式。这些表达式是 <a href="expressions/path-expr.html">路径</a> ，它们引用局部变量、 <a href="items/static-items.html">静态变量</a> 、 <a href="expressions/operator-expr.html#the-dereference-operator">解引用</a> 、 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">数组索引</a> 表达式 ( <code>expr[expr]</code> ) 、 <a href="expressions/field-expr.html">字段</a> 引用 (<code>expr.f</code>) 和带括号的占位表达式。所有其他表达式都是值表达式。</p>
<p><em>值表达式</em> 是表示实际值的表达式。</p>
<p>以下为占位表达式上下文:</p>
<ul>
<li><a href="expressions/operator-expr.html#compound-assignment-expressions">复合赋值</a> 表达式的左操作数。</li>
<li>单目 <a href="expressions/operator-expr.html#borrow-operators">借用</a> 、 <a href="expressions/operator-expr.html#raw-address-of-operators">取地址</a> 或 <a href="expressions/operator-expr.html#the-dereference-operator">解引用</a> 操作符的操作数。</li>
<li>字段表达式的操作数。</li>
<li>数组索引表达式的索引操作数。</li>
<li>任何 <a href="expressions.html#implicit-borrows">隐式借用</a> 的操作数。</li>
<li><a href="statements.html#let-statements">let 语句</a> 的初始化器。</li>
<li><a href="expressions/if-expr.html#if-let-expressions"><code>if let</code></a> 、 <a href="expressions/match-expr.html"><code>match</code></a> 或 <a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a> 表达式的 <a href="glossary.html#scrutinee">被匹配项</a> 。</li>
<li><a href="expressions/struct-expr.html#functional-update-syntax">结构体函数式更新</a>表达式的基础。</li>
</ul>
<blockquote>
<p>注意: 从历史上看，占位表达式称为左值，值表达式称为右值。</p>
</blockquote>
<p><em>可赋值表达式</em> 是指出现在 <a href="expressions/operator-expr.html#assignment-expressions">赋值</a> 表达式的左操作数的表达式。
明确地说，可赋值表达式表达式包括：</p>
<ul>
<li>占位表达式</li>
<li><a href="expressions/underscore-expr.html">下划线表达式</a>。</li>
<li>包含可赋值表达式的 <a href="expressions/tuple-expr.html">元组表达式</a>。</li>
<li>包含可赋值表达式的 <a href="expressions/array-expr.html">数组表达式</a>。</li>
<li>包含可赋值表达式的 <a href="expressions/struct-expr.html">元组结构体表达式</a>。</li>
<li>包含可赋值表达式的 <a href="expressions/struct-expr.html">结构体表达式</a> (可包含命名字段) 。</li>
<li><a href="expressions/struct-expr.html">单元结构体</a>。</li>
</ul>
<p>在可赋值表达式中允许任意括号化。</p>
<h3 id="移动和复制类型"><a class="header" href="#移动和复制类型">移动和复制类型</a></h3>
<p>当在值表达式上下文中评估一个占位表达式，或者通过值在模式中绑定一个占位表达式时，它表示该内存占位中保存的值。
如果该值的类型实现了 <a href="special-types-and-traits.html#copy"><code>Copy</code></a>，那么该值将被复制。
在其余情况下，如果该类型是 <a href="special-types-and-traits.html#sized"><code>Sized</code></a>，那么可能可以移动该值。
只有以下占位表达式可以移出：</p>
<ul>
<li><a href="variables.html">变量</a>，它们当前未被借用。</li>
<li><a href="expressions.html#temporaries">临时值</a>。</li>
<li>一个占位表达式的 <a href="expressions/field-expr.html">字段</a> 可以被移出，并且不实现 <a href="special-types-and-traits.html#drop"><code>Drop</code></a> 。</li>
<li>具有类型 <a href="../std/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> 的表达式的 <a href="expressions/operator-expr.html#the-dereference-operator">解引用</a> 结果也可以移出。</li>
</ul>
<p>从评估为本地变量的占位表达式中移动出后，该占位将被取消初始化，不能再读取该占位直到重新初始化它。
在所有其他情况下，尝试在值表达式上下文中使用一个占位表达式都是错误的。</p>
<h3 id="mutability"><a class="header" href="#mutability">Mutability</a></h3>
<p>要将一个占位表达式赋值、进行可变借用、进行隐式可变借用或绑定到包含 <code>ref mut</code> 的模式中，它必须是可变的。
我们称这些为可变占位表达式。相反，其他占位表达式被称为不可变占位表达式。</p>
<p>下面的表达式可以是可变占位表达式上下文：</p>
<ul>
<li>当前没有被借用的可变 <a href="variables.html">变量</a> 。</li>
<li><a href="items/static-items.html#mutable-statics">可变 <code>static</code> 条目</a> 。</li>
<li><a href="expressions.html#temporaries">临时值</a> 。</li>
<li><a href="expressions/field-expr.html">字段</a>: 这将在可变占位表达式上下文中求出子表达式。</li>
<li><code>*mut T</code> 指针的解引用 <a href="expressions/operator-expr.html#the-dereference-operator">dereference</a> 。</li>
<li>类型为 <code>&amp;mut T</code> 的变量或变量字段的解引用。注意：这是对下一条规则的例外情况。</li>
<li>实现 <code>DerefMut</code> 的类型的解引用: 这要求被解引用的值在可变占位表达式上下文中求值。</li>
<li>实现 <code>IndexMut</code> 的类型的 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">数组索引</a>: 这将在可变占位表达式上下文中求出被索引的值，但不包括索引。</li>
</ul>
<h3 id="临时值"><a class="header" href="#临时值">临时值</a></h3>
<p>在大多数占位表达式上下文中使用值表达式时，会创建一个临时的无名内存位置，并将其初始化为该值。
表达式评估为该位置，除非它被 <a href="destructors.html#constant-promotion">提升</a> 为 <code>static</code> 静态的。
临时值的 <a href="destructors.html#drop-scopes">丢弃作用域</a> 通常是封闭语句的末尾。</p>
<h3 id="隐式借用"><a class="header" href="#隐式借用">隐式借用</a></h3>
<p>某些表达式将会通过隐式借用将一个表达式视为一个占位表达式。
例如，可以直接比较两个非固定大小的 <a href="types/slice.html">切片</a> 是否相等，因为 <code>==</code> 运算符会隐式地借用它的操作数:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let c = [1, 2, 3];
</span><span class="boring">let d = vec![1, 2, 3];
</span>let a: &amp;[i32];
let b: &amp;[i32];
<span class="boring">a = &amp;c;
</span><span class="boring">b = &amp;d;
</span>// ...
*a == *b;
// 等价形式:
::std::cmp::PartialEq::eq(&amp;*a, &amp;*b);
<span class="boring">}</span></code></pre></pre>
<p>隐式借用可以出现在以下表达式中:</p>
<ul>
<li><a href="expressions/method-call-expr.html">方法调用</a> 表达式中的左操作数。</li>
<li><a href="expressions/field-expr.html">字段</a> 表达式中的左操作数。</li>
<li><a href="expressions/call-expr.html">函数调用</a> 表达式中的左操作数。</li>
<li><a href="expressions/array-expr.html#array-and-slice-indexing-expressions">数组索引</a> 表达式中的左操作数。</li>
<li><a href="expressions/operator-expr.html#the-dereference-operator">解引用操作符</a> (<code>*</code>)的操作数。</li>
<li><a href="expressions/operator-expr.html#comparison-operators">比较</a> 的操作数。</li>
<li><a href="expressions/operator-expr.html#compound-assignment-expressions">复合赋值</a> 的左操作数。</li>
</ul>
<h2 id="trait-重载"><a class="header" href="#trait-重载">trait 重载</a></h2>
<p>许多以下的运算符和表达式可以使用 <code>std::ops</code> 或 <code>std::cmp</code> 中的 trait 重载为其他类型所用。这些 trait 在 <code>core::ops</code> 和 <code>core::cmp</code> 中也有相同的名称。</p>
<h2 id="表达式属性"><a class="header" href="#表达式属性">表达式属性</a></h2>
<p>在表达式前面的 [外部属性][OuterAttribute] 只允许在以下几种情况下使用：</p>
<ul>
<li>用作 <a href="statements.html">语句</a> 的表达式之前。</li>
<li><a href="expressions/array-expr.html">数组表达式</a>，<a href="expressions/tuple-expr.html">元组表达式</a>，<a href="expressions/call-expr.html">调用表达式</a>和元组风格的 <a href="expressions/struct-expr.html">结构体</a> 表达式的元素。</li>
<li><a href="expressions/block-expr.html">块表达式</a> 的尾部表达式。</li>
</ul>
<!-- Keep list in sync with block-expr.md -->
<p>它们不允许在以下情况下使用:</p>
<ul>
<li>[范围][Range] 表达式。</li>
<li>二元运算符表达式 (<a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">算术或逻辑表达式</a>，<a href="expressions/operator-expr.html#comparison-operators">比较表达式</a>，<a href="expressions/operator-expr.html#lazy-boolean-operators">懒惰布尔表达式</a>，<a href="expressions/operator-expr.html#type-cast-expressions">类型转换表达式</a>，<a href="expressions/operator-expr.html#assignment-expressions">赋值表达式</a>，[复合赋值表达式][CompoundAssignmentExpression]) 。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字面值表达式"><a class="header" href="#字面值表达式">字面值表达式</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>字面值表达式</em> :<br />
      <a href="expressions/../tokens.html#character-literals">字符字面值</a><br />
   | <a href="expressions/../tokens.html#string-literals">字符串字面值</a><br />
   | <a href="expressions/../tokens.html#raw-string-literals">原始字符串字面值</a><br />
   | <a href="expressions/../tokens.html#byte-literals">字节字面值</a><br />
   | <a href="expressions/../tokens.html#byte-string-literals">字节字符串字面值</a><br />
   | <a href="expressions/../tokens.html#raw-byte-string-literals">原始字节字符串字面值</a><br />
   | <a href="expressions/../tokens.html#integer-literals">整数字面值</a><br />
   | <a href="expressions/../tokens.html#floating-point-literals">浮点数字面值</a><br />
   | <code>true</code> | <code>false</code></p>
</blockquote>
<p>字面值表达式，由一个单独的标记组成，而不是一系列标记，它直接指示其计算结果的值，而不是通过名称或其他计算规则引用它。
字面值是 [常量表达式] 的一种形式，因此主要在编译时计算。
每个先前描述的词法 <a href="expressions/../tokens.html#literals">字面值</a> 形式都可以组成一个字面表达式，关键字 <code>true</code> 和 <code>false</code> 也可以。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&quot;hello&quot;;   // 字符串类型
'5';       // 字符类型
5;         // 整数类型
<span class="boring">}</span></code></pre></pre>
<h2 id="字符字面量表达式"><a class="header" href="#字符字面量表达式">字符字面量表达式</a></h2>
<p>字符字面量表达式由一个 <a href="expressions/../tokens.html#character-literals">字符字面值</a> 令牌构成。</p>
<blockquote>
<p><strong>注意</strong>: 此部分内容不完整。</p>
</blockquote>
<h2 id="字符串字面量表达式"><a class="header" href="#字符串字面量表达式">字符串字面量表达式</a></h2>
<p>字符串字面量表达式由一个 <a href="expressions/../tokens.html#string-literals">字符串字面值</a> 或 <a href="expressions/../tokens.html#raw-string-literals">原始字符串字面值</a> 令牌构成。</p>
<blockquote>
<p><strong>注意</strong>: 此部分内容不完整。</p>
</blockquote>
<h2 id="字节字面量表达式"><a class="header" href="#字节字面量表达式">字节字面量表达式</a></h2>
<p>字节字面量表达式由一个 <a href="expressions/../tokens.html#byte-literals">字节字面值</a> 令牌构成。</p>
<blockquote>
<p><strong>注意</strong>: 此部分内容不完整。</p>
</blockquote>
<h2 id="字节字符串字面量表达式"><a class="header" href="#字节字符串字面量表达式">字节字符串字面量表达式</a></h2>
<p>字节字符串字面量表达式由一个 <a href="expressions/../tokens.html#byte-string-literals">字节字符串字面值</a> 或 <a href="expressions/../tokens.html#raw-byte-string-literals">原始字节字符串字面值</a> 令牌构成。</p>
<blockquote>
<p><strong>注意</strong>: 此部分内容不完整。</p>
</blockquote>
<h2 id="整型字面值表达式"><a class="header" href="#整型字面值表达式">整型字面值表达式</a></h2>
<p>整型字面值表达式由一个 <a href="expressions/../tokens.html#integer-literals">整数字面值</a> 令牌组成。</p>
<p>如果令牌有 <a href="expressions/../tokens.html#suffixes">后缀</a> ，则后缀必须是 <a href="expressions/../types/numeric.html">基本整数类型</a> 中的一个名称： <code>u8</code> 、 <code>i8</code> 、 <code>u16</code> 、 <code>i16</code> 、 <code>u32</code> 、 <code>i32</code> 、 <code>u64</code> 、 <code>i64</code> 、 <code>u128</code> 、 <code>i128</code> 、 <code>usize</code> 或 <code>isize</code> ，并且表达式具有该类型。</p>
<p>如果令牌没有后缀，则该表达式的类型由类型推断确定：</p>
<ul>
<li>
<p>如果整型类型可以从周围的程序上下文中确定，则表达式具有该类型。</p>
</li>
<li>
<p>如果程序上下文中的整型类型不足以确定类型，则默认为有符号的 32 位整型 <code>i32</code>。</p>
</li>
<li>
<p>如果程序上下文中的整型类型过多，则被视为静态类型错误。</p>
</li>
</ul>
<p>整型字面量表达式的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>123;                               // type i32
123i32;                            // type i32
123u32;                            // type u32
123_u32;                           // type u32
let a: u64 = 123;                  // type u64

0xff;                              // type i32
0xff_u8;                           // type u8

0o70;                              // type i32
0o70_i16;                          // type i16

0b1111_1111_1001_0000;             // type i32
0b1111_1111_1001_0000i64;          // type i64

0usize;                            // type usize
<span class="boring">}</span></code></pre></pre>
<p>该表达式的值根据令牌的字符串表示如下确定：</p>
<ul>
<li>
<p>通过检查字符串的前两个字符，选择整数基数，如下：</p>
<ul>
<li><code>0b</code> 表示基数为 2。</li>
<li><code>0o</code> 表示基数为 8。</li>
<li><code>0x</code> 表示基数为 16。</li>
<li>否则，基数为 10。</li>
</ul>
</li>
<li>
<p>如果基数不是 10，则从字符串中删除前两个字符。</p>
</li>
<li>
<p>从字符串中删除任何后缀。</p>
</li>
<li>
<p>从字符串中删除任何下划线。</p>
</li>
<li>
<p>将字符串转换为 <code>u128</code> 值，就像通过 <a href="expressions/../../core/primitive.u128.html#method.from_str_radix"><code>u128::from_str_radix</code></a> 选择的基数一样。如果值不适合 <code>u128</code>，则会出现编译器错误。</p>
</li>
<li>
<p>通过 <a href="expressions/operator-expr.html#numeric-cast">数字类型转换</a> 将 <code>u128</code> 值转换为表达式的类型。</p>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>: 如果该字面值的值超出了该类型的表示范围，最终转换将截断该字面值。 <code>rustc</code> 包括一个名为 <code>overflowing_literals</code> 的 <a href="expressions/../attributes/diagnostics.html#lint-check-attributes">lint check</a> ，默认为 <code>deny</code>，拒绝其中出现的表达式。</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>: 例如， <code>-1i8</code> 是对字面值表达式 <code>1i8</code> 应用了 <a href="expressions/operator-expr.html#negation-operators">取反运算符</a> ，而不是一个整数字面值表达式。有关表示有符号类型的最负值的注释，请参见 <a href="expressions/operator-expr.html#overflow">Overflow</a> 。</p>
</blockquote>
<h2 id="浮点数字面值表达式"><a class="header" href="#浮点数字面值表达式">浮点数字面值表达式</a></h2>
<p>浮点数字面值表达式具有以下两种形式:</p>
<ul>
<li>单个 <a href="expressions/../tokens.html#floating-point-literals">浮点数字面值</a> 标记</li>
<li>单个 <a href="expressions/../tokens.html#integer-literals">整数字面值</a> 标记，该标记具有后缀但没有基数指示符</li>
</ul>
<p>如果标记具有 <a href="expressions/../tokens.html#suffixes">后缀</a> ，则后缀必须是 <a href="expressions/../types/numeric.html#floating-point-types">原始浮点类型</a> 之一的名称： <code>f32</code> 或 <code>f64</code> ，并且表达式具有该类型。</p>
<p>如果标记没有后缀，则表达式的类型由类型推断确定：</p>
<ul>
<li>
<p>如果可以从周围的程序上下文中 <em>唯一</em> 确定浮点类型，则表达式具有该类型。</p>
</li>
<li>
<p>如果程序上下文不够确定类型，则默认为 <code>f64</code> 。</p>
</li>
<li>
<p>如果程序上下文过度约束类型，则被视为静态类型错误。</p>
</li>
</ul>
<p>浮点数字面值表达式的示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>123.0f64;        // type f64
0.1f64;          // type f64
0.1f32;          // type f32
12E+99_f64;      // type f64
5f32;            // type f32
let x: f64 = 2.; // type f64
<span class="boring">}</span></code></pre></pre>
<p>表达式的值根据令牌的字符串表示形式确定，具体如下:</p>
<ul>
<li>从字符串中删除任何后缀。</li>
<li>从字符串中删除任何下划线。</li>
<li>将字符串转换为表达式的类型，如同通过 <a href="expressions/../../core/primitive.f32.html#method.from_str"><code>f32::from_str</code></a> 或 <a href="expressions/../../core/primitive.f64.html#method.from_str"><code>f64::from_str</code></a> 。</li>
</ul>
<blockquote>
<p><strong>注意</strong>: 例如， <code>-1.0</code> 是对字面表达式 <code>1.0</code> 应用 <a href="expressions/operator-expr.html#negation-operators">取反运算符</a> ，而不是单个浮点字面值表达式。</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>: <code>inf</code> 和 <code>NaN</code> 不是字面值令牌。
可以使用 <a href="expressions/../../core/primitive.f32.html#associatedconstant.INFINITY"><code>f32::INFINITY</code></a> 、 <a href="expressions/../../core/primitive.f64.html#associatedconstant.INFINITY"><code>f64::INFINITY</code></a> 、 <a href="expressions/../../core/primitive.f32.html#associatedconstant.NAN"><code>f32::NAN</code></a> 和 <a href="expressions/../../core/primitive.f64.html#associatedconstant.NAN"><code>f64::NAN</code></a> 常量来代替字面值表达式。
在 <code>rustc</code> 中，被评估为无限大的字面值将触发 <code>overflowing_literals</code> lint 检查。</p>
</blockquote>
<h2 id="布尔字面值表达式"><a class="header" href="#布尔字面值表达式">布尔字面值表达式</a></h2>
<p>一个布尔字面值表达式由 <code>true</code> 或 <code>false</code> 中的一个关键字组成。</p>
<p>该表达式的类型为原始的 <a href="expressions/../types/boolean.html">布尔类型</a> ，其值是:</p>
<ul>
<li>如果关键字是 <code>true</code>，则为真</li>
<li>如果关键字是 <code>false</code>，则为假</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="路径表达式"><a class="header" href="#路径表达式">路径表达式</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>路径表达式</em> :<br />
      <a href="expressions/../paths.html#paths-in-expressions"><em>表达式中路径</em></a><br />
   | <a href="expressions/../paths.html#qualified-paths"><em>表达式中的限定路径</em></a></p>
</blockquote>
<p>在表达式上下文中使用的 <a href="expressions/../paths.html">路径</a> 表示一个局部变量或一个条目。
解析为局部变量或静态变量的路径表达式是 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">占位表达式</a>，其他路径是 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">值表达式</a>。
使用 <a href="expressions/../items/static-items.html#mutable-statics"><code>static mut</code></a> 变量需要一个 <a href="expressions/block-expr.html#unsafe-blocks"><code>unsafe</code> 块</a> 。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod globals {
</span><span class="boring">    pub static STATIC_VAR: i32 = 5;
</span><span class="boring">    pub static mut STATIC_MUT_VAR: i32 = 7;
</span><span class="boring">}
</span><span class="boring">let local_var = 3;
</span>local_var;
globals::STATIC_VAR;
unsafe { globals::STATIC_MUT_VAR };
let some_constructor = Some::&lt;i32&gt;;
let push_integer = Vec::&lt;i32&gt;::push;
let slice_reverse = &lt;[i32]&gt;::reverse;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="块表达式"><a class="header" href="#块表达式">块表达式</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>块表达式</em> :<br />
   <code>{</code><br />
      <a href="expressions/../attributes.html"><em>内部属性</em></a><sup>*</sup><br />
      <em>语句组</em><sup>?</sup><br />
   <code>}</code></p>
<p><em>语句组</em> :<br />
      <a href="expressions/../statements.html"><em>语句</em></a><sup>+</sup><br />
   | <a href="expressions/../statements.html"><em>语句</em></a><sup>+</sup> <a href="expressions/../expressions.html"><em>无块表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>无块表达式</em></a></p>
</blockquote>
<p><em>块表达式</em> 或 <em>块</em> 是一个控制流表达式和用于条目和变量声明的匿名命名空间作用域。
作为控制流表达式，块按顺序执行其组成的非条目声明语句，然后执行其最后的可选表达式。
作为匿名命名空间作用域，仅在块内部声明的条目声明在块本身中可用，而由 <code>let</code> 语句声明的变量从下一条语句开始在块结束之前处于作用域中。</p>
<p>块的语法是 <code>{</code> ，然后是任何 <a href="expressions/../attributes.html">内部属性</a> ，然后是任意数量的 <a href="expressions/../statements.html">语句</a> ，然后是一个可选的表达式，称为最后的操作数，最后是一个 <code>}</code> 。</p>
<p>语句通常需要在分号后面，有两个例外：</p>
<ol>
<li>条目声明语句不需要在分号后面。</li>
<li>表达式语句通常需要一个后续分号，除非其外部表达式是控制流表达式。</li>
</ol>
<p>此外，语句之间的额外分号是允许的，但是这些分号不影响语义。</p>
<p>在评估块表达式时，除条目声明语句外，每个语句都按顺序执行。
然后，如果给定了最后的操作数，则执行它。</p>
<p>块的类型是最后操作数的类型，如果省略了最后操作数，则为 <code>()</code> 。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn fn_call() {}
</span>let _: () = {
    fn_call();
};

let five: i32 = {
    fn_call();
    5
};

assert_eq!(5, five);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>注意: 作为控制流表达式，如果块表达式是表达式语句的外部表达式，期望的类型是 <code>()</code> ，除非它紧跟着一个分号。</p>
</blockquote>
<p>块始终是值表达式，并在值表达式上下文中评估最后一个操作数。</p>
<blockquote>
<p><strong>注意</strong>: 如果确实需要，这可以用于强制移动值。例如，以下示例在调用 <code>consume_self</code> 时失败，因为结构体已在块表达式中移出了 <code>s</code> 。</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Struct;

impl Struct {
    fn consume_self(self) {}
    fn borrow_self(&amp;self) {}
}

fn move_by_block_expression() {
    let s = Struct;

    // 在块表达式中将值从 `s` 移出。
    (&amp;{ s }).borrow_self();

    // 无法执行，因为 `s` 已经被移出了。
    s.consume_self();
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<h2 id="async-块"><a class="header" href="#async-块"><code>async</code> 块</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>Async块表达式</em> :<br />
   <code>async</code> <code>move</code><sup>?</sup> <em>块表达式</em></p>
</blockquote>
<p>异步块是块表达式的一种变体，它计算为一个 future。
块的最终表达式 (如果存在) 确定 future 的结果值。</p>
<p>执行异步块类似于执行闭包表达式: 它的立即效果是生成并返回一个匿名类型。
然而，闭包返回实现一个或多个 <a href="expressions/../../std/ops/trait.Fn.html"><code>std::ops::Fn</code></a> trait 的类型，异步块返回的类型实现了 <a href="expressions/../../std/future/trait.Future.html"><code>std::future::Future</code></a> trait。
这种类型的实际数据格式未指定。</p>
<blockquote>
<p><strong>注意:</strong> rustc 生成的 future 类型大致相当于具有每个 <code>await</code> 点一个变体的枚举类型，其中每个变体存储从其相应点恢复所需的数据。
<strong>版本差异</strong>: 异步块仅在Rust 2018及以后版本中可用。</p>
</blockquote>
<h3 id="捕获模式"><a class="header" href="#捕获模式">捕获模式</a></h3>
<p>异步块使用与闭包相同的 <a href="expressions/../types/closure.html#capture-modes">捕获模式</a> 从它们的环境中捕获变量。
与闭包一样，当写成 <code>async { .. }</code> 时，每个变量的捕获模式将从块的内容中推断出来。
然而， <code>async move { .. }</code> 块将移动所有被引用的变量到生成的 future 中。</p>
<h3 id="异步上下文"><a class="header" href="#异步上下文">异步上下文</a></h3>
<p>由于异步块构造了一个future，它们定义了一个 <strong>异步上下文</strong> ，这个上下文可以包含 <a href="expressions/await-expr.html"><code>await</code> 表达式</a> 。
异步上下文由异步块以及异步函数的函数体建立，后者的语义是以异步块为基础定义的。</p>
<h3 id="控制流运算符"><a class="header" href="#控制流运算符">控制流运算符</a></h3>
<p>异步块类似于函数约束，就像闭包一样。
因此， <code>?</code> 运算符和 <code>return</code> 表达式都会影响未来的输出，而不是封闭函数或其他上下文。
也就是说，从异步块中的 <code>return &lt;expr&gt;</code> 将返回 <code>&lt;expr&gt;</code> 的结果作为未来的输出。
同样，如果 <code>&lt;expr&gt;?</code> 传播错误，则该错误将作为未来的结果传播。</p>
<p>最后， <code>break</code> 和 <code>continue</code> 关键字不能用于从异步块中分支跳出。
因此以下代码是非法的:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    async move {
        break; // error[E0267]: `break` inside of an `async` block
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="unsafe-块"><a class="header" href="#unsafe-块"><code>unsafe</code> 块</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>Unsafe块表达式</em> :<br />
   <code>unsafe</code> <em>块表达式</em></p>
</blockquote>
<p>在需要进行 <a href="expressions/../unsafety.html">unsafe 操作</a> 时，可以在一段代码块前加上 <code>unsafe</code> 关键字。详见 <a href="expressions/../unsafe-blocks.html"><code>unsafe</code> block</a> 。
示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
    let b = [13u8, 17u8];
    let a = &amp;b[0] as *const u8;
    assert_eq!(*a, 13);
    assert_eq!(*a.offset(1), 17);
}

<span class="boring">unsafe fn an_unsafe_fn() -&gt; i32 { 10 }
</span>let a = unsafe { an_unsafe_fn() };
<span class="boring">}</span></code></pre></pre>
<h2 id="标记的块表达式"><a class="header" href="#标记的块表达式">标记的块表达式</a></h2>
<p>标记的块表达式在 <a href="expressions/loop-expr.html#labelled-block-expressions">循环和其他可中断表达式</a> 部分进行了说明。</p>
<h2 id="块表达式上的属性"><a class="header" href="#块表达式上的属性">块表达式上的属性</a></h2>
<p>在以下情况下，可以在块表达式的左括号之后直接使用 <a href="expressions/../attributes.html">内部属性</a> :</p>
<ul>
<li><a href="expressions/../items/functions.html">函数</a> 和 <a href="expressions/../items/associated-items.html#methods">方法</a> 体。</li>
<li>循环体 ( <a href="expressions/loop-expr.html#infinite-loops"><code>loop</code></a> 、 <a href="expressions/loop-expr.html#predicate-loops"><code>while</code></a> 、 <a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a> 和 <a href="expressions/loop-expr.html#iterator-loops"><code>for</code></a> )。</li>
<li>作为 <a href="expressions/../statements.html">语句</a> 使用的块表达式。</li>
<li>块表达式作为 <a href="expressions/array-expr.html">数组表达式</a> 、 <a href="expressions/tuple-expr.html">元组表达式</a> 、 <a href="expressions/call-expr.html">调用表达式</a> 和类似元组的 <a href="expressions/struct-expr.html">结构体</a> 表达式的元素。</li>
<li>另一个块表达式的尾表达式是块表达式。</li>
</ul>
<!-- Keep list in sync with expressions.md -->
<p>具有在块表达式上的含义的属性包括 <a href="expressions/../conditional-compilation.html"><code>cfg</code></a> 和 <a href="expressions/../attributes/diagnostics.html#lint-check-attributes">lint 检查属性</a> 。</p>
<p>例如，这个函数在 Unix 平台上返回 <code>true</code> ，在其他平台上返回 <code>false</code> 。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_unix_platform() -&gt; bool {
    #[cfg(unix)] { true }
    #[cfg(not(unix))] { false }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="运算符表达式"><a class="header" href="#运算符表达式">运算符表达式</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>OperatorExpression</em> :<br />
      <a href="expressions/operator-expr.html#borrow-operators"><em>借用表达式</em></a><br />
   | <a href="expressions/operator-expr.html#the-dereference-operator"><em>解引用表达式</em></a><br />
   | <a href="expressions/operator-expr.html#the-question-mark-operator"><em>错误传导表达式</em></a><br />
   | <a href="expressions/operator-expr.html#negation-operators"><em>取反表达式</em></a><br />
   | <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><em>算术或逻辑表达式</em></a><br />
   | <a href="expressions/operator-expr.html#comparison-operators"><em>比较表达式</em></a><br />
   | <a href="expressions/operator-expr.html#lazy-boolean-operators"><em>惰性布尔表达式</em></a><br />
   | <a href="expressions/operator-expr.html#type-cast-expressions"><em>类型转换表达式</em></a><br />
   | <a href="expressions/operator-expr.html#assignment-expressions"><em>赋值表达式</em></a><br />
   | <a href="expressions/operator-expr.html#compound-assignment-expressions"><em>复合赋值表达式</em></a></p>
</blockquote>
<p>在 Rust 语言中，内置类型的运算符已经被定义好了。
许多下面提到的运算符也可以通过 <code>std::ops</code> 或 <code>std::cmp</code> 中的 trait 进行重载。</p>
<h2 id="溢出"><a class="header" href="#溢出">溢出</a></h2>
<p>在调试模式下编译的整数运算符会在溢出时触发 panic。
可以使用 <code>-C debug-assertions</code> 和 <code>-C overflow-checks</code> 编译器标志来更直接地控制这个行为。下列情况被视为溢出：</p>
<ul>
<li>当 <code>+</code>、<code>*</code> 或二元 <code>-</code> 创建的值大于可以存储的最大值或小于最小值。</li>
<li>对任何有符号整数类型的最小值应用一元 <code>-</code> ，除非操作数是 <a href="expressions/literal-expr.html#integer-literal-expressions">字面值表达式</a>
(或在一个或多个 <a href="expressions/grouped-expr.html">分组表达式</a> 中单独使用的字面值表达式) 。</li>
<li>在左操作数是有符号整数类型的最小整数且右操作数是 <code>-1</code> 时，使用 <code>/</code> 或 <code>%</code> 。 出于兼容性原因，即使禁用了 <code>-C overflow-checks</code> ，这些检查也会发生。</li>
<li>在右操作数大于或等于左操作数类型的位数或为负时，使用 <code>&lt;&lt;</code> 或 <code>&gt;&gt;</code> 。</li>
</ul>
<blockquote>
<p><strong>注意</strong>: 对于一元 <code>-</code> 后面的字面值表达式，这意味着类似 <code>-128_i8</code> 或 <code>let j: i8 = -(128)</code> 的形式永远不会导致 panic，并且其期望值为 -128 。</p>
<p>在这些情况下，字面值表达式已经具有其类型的最小值 (例如， <code>128_i8</code> 的值为 -128) ，因为整数字面值按照 <a href="expressions/literal-expr.html#integer-literal-expressions">整数字面值表达式</a> 中的描述被截断为其类型。</p>
<p>这些最小值的否定不会改变值，因为采用了二进制补码的溢出约定。</p>
<p>在 <code>rustc</code> 中，这些最小值表达式也被 <code>overflowing_literals</code> 代码分析检查忽略。</p>
</blockquote>
<h2 id="借用运算符"><a class="header" href="#借用运算符">借用运算符</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>借用表达式</em> :<br />
      (<code>&amp;</code>|<code>&amp;&amp;</code>) <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | (<code>&amp;</code>|<code>&amp;&amp;</code>) <code>mut</code> <a href="expressions/../expressions.html"><em>表达式</em></a></p>
</blockquote>
<p><code>&amp;</code> (共享借用) 和 <code>&amp;mut</code> (可变借用) 运算符是一元前缀运算符。
当应用于一个 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">占位表达式</a> 时，该表达式产生一个指向该值引用的位置的引用 (指针) 。
在引用的持续时间内，该内存位置也被置于借用状态。对于共享借用 ( <code>&amp;</code> ) ，这意味着该位置可能不能被修改，但可以被读取或再次共享。
对于可变借用 ( <code>&amp;mut</code> ) ，在借用过期之前，该位置可能不能以任何方式访问。
<code>&amp;mut</code> 在可变位置表达式上下文中评估其操作数。如果 <code>&amp;</code> 或 <code>&amp;mut</code> 运算符应用于一个 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">值表达式</a> ，则将创建一个 <a href="expressions/../expressions.html#temporaries">临时值</a>。</p>
<p>这些运算符不能被重载。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    // 创建一个值为 7 的临时值，它只在当前作用域有效。
    let shared_reference = &amp;7;
}
let mut array = [-2, 3, 9];
{
    // 对 `array` 进行可变借用，这个作用域内 `array` 只能通过 `mutable_reference` 使用。
    let mutable_reference = &amp;mut array;
}
<span class="boring">}</span></code></pre></pre>
<p>即使 <code>&amp;&amp;</code> 是单个标记 (<a href="expressions/operator-expr.html#lazy-boolean-operators">惰性 'and' 运算符</a>) ，但在借用表达式的上下文中使用时，它的作用相当于两个借用:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// same meanings:
let a = &amp;&amp;  10;
let a = &amp; &amp; 10;

// same meanings:
let a = &amp;&amp;&amp;&amp;  mut 10;
let a = &amp;&amp; &amp;&amp; mut 10;
let a = &amp; &amp; &amp; &amp; mut 10;
<span class="boring">}</span></code></pre></pre>
<h3 id="原始地址运算符"><a class="header" href="#原始地址运算符">原始地址运算符</a></h3>
<p>与借用运算符相关的是 <em>原始地址运算符</em> ，它们没有一级语法，但通过宏 <a href="expressions/../../std/ptr/macro.addr_of.html"><code>ptr::addr_of!(expr)</code></a> 和 <a href="expressions/../../std/ptr/macro.addr_of_mut.html"><code>ptr::addr_of_mut!(expr)</code></a> 暴露出来。
表达式 <code>expr</code> 在占位表达式上下文中进行评估。
<code>ptr::addr_of!(expr)</code> 然后创建一个类型为 <code>*const T</code> 的常量原始指针指向给定的位置，而 <code>ptr::addr_of_mut!(expr)</code> 则创建一个类型为 <code>*mut T</code> 的可变原始指针。</p>
<p>必须使用原始地址运算符而不是借用运算符，每当占位表达式可以评估为未正确对齐或不存储有效值 (根据其类型确定) ，或者每当创建引用会引入不正确的别名假设时。
在这些情况下，使用借用运算符将通过创建无效引用导致 <a href="expressions/../behavior-considered-undefined.html">未定义行为</a> ，但仍可以使用地址运算符构造原始指针。</p>
<p>以下是通过 <code>packed</code> 结构创建指向未对齐位置的原始指针的示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ptr;

// 定义一个 packed 结构体
#[repr(packed)]
struct Packed {
    f1: u8,
    f2: u16,
}

// 创建一个 packed 实例
let packed = Packed { f1: 1, f2: 2 };
// `&amp;packed.f2` 会创建一个不对齐的引用，因此是未定义行为！
// 使用 `ptr::addr_of!` 创建一个指向 `packed.f2` 的不可变原始指针
let raw_f2 = ptr::addr_of!(packed.f2);
// 读取 `raw_f2` 指向的值，并断言其值等于2
assert_eq!(unsafe { raw_f2.read_unaligned() }, 2);
<span class="boring">}</span></code></pre></pre>
<p>以下是创建指向不包含有效值的位置的原始指针的示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{ptr, mem::MaybeUninit};

struct Demo {
    field: bool,
}

let mut uninit = MaybeUninit::&lt;Demo&gt;::uninit();
// &amp;uninit.as_mut().field将创建对未初始化的'bool'的引用，因此为Undefined Behavior!
let f1_ptr = unsafe { ptr::addr_of_mut!((*uninit.as_mut_ptr()).field) };
// 将'true'写入先前未初始化的字段。
unsafe { f1_ptr.write(true); }
// 因为'uninit'已在上面初始化，所以是安全的。
let init = unsafe { uninit.assume_init() };
<span class="boring">}</span></code></pre></pre>
<h2 id="解引用操作符"><a class="header" href="#解引用操作符">解引用操作符</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>解引用表达式</em> :<br />
   <code>*</code> <a href="expressions/../expressions.html"><em>表达式</em></a></p>
</blockquote>
<p>解引用运算符 <code>*</code> 也是一个一元前缀运算符。
当应用于 <a href="expressions/../types/pointer.html">指针</a> 时，表示指向的地址。
如果表达式的类型为 <code>&amp;mut T</code> 或 <code>*mut T</code>，并且是一个局部变量、局部变量的 (嵌套) 字段或可变的 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">占位表达式</a> ，则可以将结果的内存位置分配给其它变量。
对一个裸指针进行解引用需要使用 <code>unsafe</code> 。</p>
<p>对于非指针类型， <code>*x</code> 在不可变的 <a href="expressions/../expressions.html#mutability">占位表达式上下文</a> 中等同于 <code>*std::ops::Deref::deref(&amp;x)</code> ，在可变的占位表达式上下文中等同于 <code>*std::ops::DerefMut::deref_mut(&amp;mut x)</code>。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;7;
assert_eq!(*x, 7);
let y = &amp;mut 9;
*y = 11;
assert_eq!(*y, 11);
<span class="boring">}</span></code></pre></pre>
<h2 id="问号操作符"><a class="header" href="#问号操作符">问号操作符</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>错误传导表达式</em> :<br />
   <a href="expressions/../expressions.html"><em>表达式</em></a> <code>?</code></p>
</blockquote>
<p>问号运算符 (<code>?</code>) 可以展开有效的值或返回错误值，并将它们传播到调用函数中。
它是一个一元后缀运算符，只能应用于 <code>Result&lt;T, E&gt;</code> 和 <code>Option&lt;T&gt;</code> 类型。</p>
<p>当应用于 <code>Result&lt;T, E&gt;</code> 类型的值时，它会传播错误。
如果该值是 <code>Err(e)</code> ，则它将从包含的函数或闭包返回 <code>Err(From::from(e))</code> 。如果应用于 <code>Ok(x)</code> ，则它将展开该值以求值为 <code>x</code> 。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::num::ParseIntError;
</span>fn try_to_parse() -&gt; Result&lt;i32, ParseIntError&gt; {
    let x: i32 = &quot;123&quot;.parse()?; // x = 123
    let y: i32 = &quot;24a&quot;.parse()?; // 立即返回一个 Err()
    Ok(x + y)                    // 不会被执行
}

let res = try_to_parse();
println!(&quot;{:?}&quot;, res);
<span class="boring">assert!(res.is_err())
</span><span class="boring">}</span></code></pre></pre>
<p>当应用于类型为 <code>Option&lt;T&gt;</code> 的值时，它会传播 <code>None</code> 。如果值为 <code>None</code> ，则它将返回 <code>None</code> 。如果应用于 <code>Some(x)</code> ，则它将展开该值以求值为 <code>x</code> 。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn try_option_some() -&gt; Option&lt;u8&gt; {
    let val = Some(1)?;
    Some(val)
}
assert_eq!(try_option_some(), Some(1));

fn try_option_none() -&gt; Option&lt;u8&gt; {
    let val = None?;
    Some(val)
}
assert_eq!(try_option_none(), None);
<span class="boring">}</span></code></pre></pre>
<p><code>?</code> 不能被重载。</p>
<h2 id="取反运算符"><a class="header" href="#取反运算符">取反运算符</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>取反表达式</em> :<br />
      <code>-</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <code>!</code> <a href="expressions/../expressions.html"><em>表达式</em></a></p>
</blockquote>
<p>这是最后两个一元操作符。
这张表总结了它们在原始类型上的行为以及用于重载其他类型的这些操作符的 trait 。
请记住，有符号整数总是使用二进制补码表示。所有这些操作符的操作数都在 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">值表达式上下文</a> 中评估，因此它们会被移动或复制。</p>
<div class="table-wrapper"><table><thead><tr><th>符号</th><th>整数</th><th>布尔</th><th>浮点数</th><th>重载 Trait</th></tr></thead><tbody>
<tr><td><code>-</code></td><td>取反*</td><td></td><td>取反</td><td><code>std::ops::Neg</code></td></tr>
<tr><td><code>!</code></td><td>按位取反</td><td><a href="expressions/../types/boolean.html#logical-not">逻辑取反</a></td><td></td><td><code>std::ops::Not</code></td></tr>
</tbody></table>
</div>
<p>* 仅适用于有符号整数类型。</p>
<p>下面是这些运算符的一些示例</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 6;
assert_eq!(-x, -6);
assert_eq!(!x, -7);
assert_eq!(true, !false);
<span class="boring">}</span></code></pre></pre>
<h2 id="算术和逻辑二元操作符"><a class="header" href="#算术和逻辑二元操作符">算术和逻辑二元操作符</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>算术或逻辑表达式</em> :<br />
      <a href="expressions/../expressions.html"><em>表达式</em></a> <code>+</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>-</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>*</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>/</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>%</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>&amp;</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>|</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>^</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>&lt;&lt;</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>&gt;&gt;</code> <a href="expressions/../expressions.html"><em>表达式</em></a></p>
</blockquote>
<p>二元运算符表达式均以中缀表示。此表总结了原始类型上算术和逻辑二元运算符的行为，以及用于重载其他类型的这些运算符的特性。
请记住，有符号整数始终使用二进制补码表示。所有这些运算符的操作数都在 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">值表达式上下文</a> 中计算，因此会被移动或复制。</p>
<div class="table-wrapper"><table><thead><tr><th>符号</th><th>整数</th><th>布尔</th><th>浮点数</th><th>重载 Trait</th><th>重载复合赋值 Trait</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>加法</td><td></td><td>加法</td><td><code>std::ops::Add</code></td><td><code>std::ops::AddAssign</code></td></tr>
<tr><td><code>-</code></td><td>减法</td><td></td><td>减法</td><td><code>std::ops::Sub</code></td><td><code>std::ops::SubAssign</code></td></tr>
<tr><td><code>*</code></td><td>乘法</td><td></td><td>乘法</td><td><code>std::ops::Mul</code></td><td><code>std::ops::MulAssign</code></td></tr>
<tr><td><code>/</code></td><td>除法*</td><td></td><td>除法</td><td><code>std::ops::Div</code></td><td><code>std::ops::DivAssign</code></td></tr>
<tr><td><code>%</code></td><td>取余**</td><td></td><td>取余</td><td><code>std::ops::Rem</code></td><td><code>std::ops::RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td>按位与</td><td><a href="expressions/../types/boolean.html#logical-and">逻辑与</a></td><td></td><td><code>std::ops::BitAnd</code></td><td><code>std::ops::BitAndAssign</code></td></tr>
<tr><td><code>|</code></td><td>按位或</td><td><a href="expressions/../types/boolean.html#logical-or">逻辑或</a></td><td></td><td><code>std::ops::BitOr</code></td><td><code>std::ops::BitOrAssign</code></td></tr>
<tr><td><code>^</code></td><td>按位异或</td><td><a href="expressions/../types/boolean.html#logical-xor">逻辑异或</a></td><td></td><td><code>std::ops::BitXor</code></td><td><code>std::ops::BitXorAssign</code></td></tr>
<tr><td><code>&lt;&lt;</code></td><td>左移</td><td></td><td></td><td><code>std::ops::Shl</code></td><td><code>std::ops::ShlAssign</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td>右移***</td><td></td><td></td><td><code>std::ops::Shr</code></td><td><code>std::ops::ShrAssign</code></td></tr>
</tbody></table>
</div>
<p>* 整数除法向零取整。
** Rust使用的余数采用 <a href="https://en.wikipedia.org/wiki/Modulo_operation#Variants_of_the_definition">截断除法</a> 定义。
给定 <code>remainder = dividend % divisor</code> ，余数将与被除数具有相同的符号。
*** 在有符号整数类型上进行算术右移，无符号整数类型上进行逻辑右移。</p>
<p>以下是使用这些运算符的示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(3 + 6, 9);
assert_eq!(5.5 - 1.25, 4.25);
assert_eq!(-5 * 14, -70);
assert_eq!(14 / 3, 4);
assert_eq!(100 % 7, 2);
assert_eq!(0b1010 &amp; 0b1100, 0b1000);
assert_eq!(0b1010 | 0b1100, 0b1110);
assert_eq!(0b1010 ^ 0b1100, 0b110);
assert_eq!(13 &lt;&lt; 3, 104);
assert_eq!(-10 &gt;&gt; 2, -3);
<span class="boring">}</span></code></pre></pre>
<h2 id="比较运算符"><a class="header" href="#比较运算符">比较运算符</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>比较表达式</em> :<br />
      <a href="expressions/../expressions.html"><em>表达式</em></a> <code>==</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a><code>!=</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>&gt;</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>&lt;</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>&gt;=</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>&lt;=</code> <a href="expressions/../expressions.html"><em>表达式</em></a></p>
</blockquote>
<p>比较运算符也被定义在基本类型和标准库的许多类型上。当链接比较运算符时，需要使用括号。
例如，表达式 <code>a == b == c</code> 是无效的，可以写成 <code>(a == b) == c</code> 。</p>
<p>与算术和逻辑运算符不同，用于重载这些运算符的 trait 通常更普遍地用于表明类型如何进行比较，并且可能会被假定为函数定义实际比较的条件。
标准库中的许多函数和宏可以利用这个假设 (虽然不能确保安全性) 。
与上面的算术和逻辑运算符不同，这些运算符隐式地获取其操作数的共享借用，以 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">占位表达式上下文</a> 中的方式进行评估：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let a = 1;
</span><span class="boring">let b = 1;
</span>a == b;
// 等价于
::std::cmp::PartialEq::eq(&amp;a, &amp;b);
<span class="boring">}</span></code></pre></pre>
<p>这意味着操作数不必移动出去。</p>
<div class="table-wrapper"><table><thead><tr><th>符号</th><th>意义</th><th>重载方法</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>等于</td><td><code>std::cmp::PartialEq::eq</code></td></tr>
<tr><td><code>!=</code></td><td>不等于</td><td><code>std::cmp::PartialEq::ne</code></td></tr>
<tr><td><code>&gt;</code></td><td>大于</td><td><code>std::cmp::PartialOrd::gt</code></td></tr>
<tr><td><code>&lt;</code></td><td>小于</td><td><code>std::cmp::PartialOrd::lt</code></td></tr>
<tr><td><code>&gt;=</code></td><td>大于等于</td><td><code>std::cmp::PartialOrd::ge</code></td></tr>
<tr><td><code>&lt;=</code></td><td>小于等于</td><td><code>std::cmp::PartialOrd::le</code></td></tr>
</tbody></table>
</div>
<p>这里是使用比较运算符的示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert!(123 == 123);
assert!(23 != -12);
assert!(12.5 &gt; 12.2);
assert!([1, 2, 3] &lt; [1, 3, 4]);
assert!('A' &lt;= 'B');
assert!(&quot;World&quot; &gt;= &quot;Hello&quot;);
<span class="boring">}</span></code></pre></pre>
<h2 id="惰性布尔运算符"><a class="header" href="#惰性布尔运算符">惰性布尔运算符</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>惰性布尔表达式</em> :<br />
      <a href="expressions/../expressions.html"><em>表达式</em></a> <code>||</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>&amp;&amp;</code> <a href="expressions/../expressions.html"><em>表达式</em></a></p>
</blockquote>
<p>运算符 <code>||</code> 和 <code>&amp;&amp;</code> 可以用于布尔类型的操作数。 <code>||</code> 运算符表示逻辑或， <code>&amp;&amp;</code> 运算符表示逻辑与。
它们与 <code>|</code> 和 <code>&amp;</code> 的区别在于，只有当左操作数不能确定表达式结果时才会对右操作数进行求值。
也就是说，只有当左操作数求值结果为 <code>false</code> 时 <code>||</code> 才会对右操作数进行求值，只有当左操作数求值结果为 <code>true</code> 时 <code>&amp;&amp;</code> 才会对右操作数进行求值。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = false || true; // true
let y = false &amp;&amp; panic!(); // false 不会对右侧的操作数进行求值，因此 `panic!()` 表达式不会被执行。
<span class="boring">}</span></code></pre></pre>
<h2 id="类型转换表达式"><a class="header" href="#类型转换表达式">类型转换表达式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>类型转换表达式</em> :<br />
   <a href="expressions/../expressions.html"><em>表达式</em></a>  <code>as</code> [<em>无约束类型</em>]</p>
</blockquote>
<p>类型转换表达式使用二元运算符 <code>as</code> 表示。</p>
<p>执行一个 <code>as</code> 表达式会将左侧的值转换为右侧的类型。</p>
<p>以下是一个 <code>as</code> 表达式的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn sum(values: &amp;[f64]) -&gt; f64 { 0.0 }
</span><span class="boring">fn len(values: &amp;[f64]) -&gt; i32 { 0 }
</span>fn average(values: &amp;[f64]) -&gt; f64 {
    let sum: f64 = sum(values);
    let size: f64 = len(values) as f64;
    sum / size
}
<span class="boring">}</span></code></pre></pre>
<p><code>as</code> 可以用于显式执行 <a href="expressions/../type-coercions.html">coercions</a> ，以及以下附加转换。
任何不符合 coercion 规则或表中条目的转换都是编译器错误。
这里的 <code>*T</code> 表示 <code>*const T</code> 或 <code>*mut T</code>。
在引用类型中， <code>m</code> 表示可选的 <code>mut</code> ，在指针类型中表示 <code>mut</code> 或 <code>const</code> 。</p>
<div class="table-wrapper"><table><thead><tr><th><code>e</code> 的类型</th><th><code>U</code></th><th><code>e as U</code> 执行的类型转换</th></tr></thead><tbody>
<tr><td>整型或浮点型</td><td>整型或浮点型</td><td>数值类型转换</td></tr>
<tr><td>枚举类型</td><td>整型类型</td><td>枚举类型转换</td></tr>
<tr><td><code>bool</code> 或 <code>char</code> 类型</td><td>整型类型</td><td>基本类型到整型类型的转换</td></tr>
<tr><td><code>u8</code> 类型</td><td><code>char</code> 类型</td><td><code>u8</code> 类型到 <code>char</code> 类型的转换</td></tr>
<tr><td><code>*T</code> 类型</td><td><code>*V</code> where <code>V: Sized</code> *</td><td>指针类型到指针类型的转换</td></tr>
<tr><td><code>*T</code> where <code>T: Sized</code></td><td>整型类型</td><td>指针类型到地址类型的转换</td></tr>
<tr><td>整型类型</td><td><code>*V</code> where <code>V: Sized</code></td><td>地址类型到指针类型的转换</td></tr>
<tr><td><code>&amp;m₁ T</code> 类型</td><td><code>*m₂ T</code> **</td><td>引用类型到指针类型的转换</td></tr>
<tr><td><code>&amp;m₁ [T; n]</code> 类型</td><td><code>*m₂ T</code> **</td><td>数组类型到指针类型的转换</td></tr>
<tr><td><a href="expressions/../types/function-item.html">函数条目</a> 类型</td><td><a href="expressions/../types/function-pointer.html">函数指针</a> 类型</td><td>函数条目到函数指针类型的转换</td></tr>
<tr><td><a href="expressions/../types/function-item.html">函数条目</a> 类型</td><td><code>*V</code> where <code>V: Sized</code></td><td>函数条目到指针类型的转换</td></tr>
<tr><td><a href="expressions/../types/function-item.html">函数条目</a> 类型</td><td>整型类型</td><td>函数条目到地址类型的转换</td></tr>
<tr><td><a href="expressions/../types/function-pointer.html">函数指针</a> 类型</td><td><code>*V</code> where <code>V: Sized</code></td><td>函数指针到指针类型的转换</td></tr>
<tr><td><a href="expressions/../types/function-pointer.html">函数指针</a> 类型</td><td>整型类型</td><td>函数指针到地址类型的转换</td></tr>
<tr><td>闭包类型 ***</td><td>函数指针类型</td><td>闭包类型到函数指针类型的转换</td></tr>
</tbody></table>
</div>
<p>* 当 <code>T</code> 和 <code>V</code> 都是不定大小类型但类型相同时，例如都是切片类型，它们之间是兼容的。
** 当且仅当 <code>m₁</code> 为 <code>mut</code> 或 <code>m₂</code> 为 <code>const</code> 时。允许将 <code>mut</code> 引用转换为 <code>const</code> 指针。
*** 仅适用于没有捕获 (关闭) 任何局部变量的闭包。</p>
<h3 id="语义"><a class="header" href="#语义">语义</a></h3>
<h4 id="数值转换"><a class="header" href="#数值转换">数值转换</a></h4>
<ul>
<li>两个大小相同的整数之间的转换 (例如 i32 -&gt; u32) 是无操作的 (Rust 对于固定整数的负值使用 2 的补码) </li>
<li>从较大的整数转换为较小的整数 (例如 u32 -&gt; u8) 会截断</li>
<li>从较小的整数转换为较大的整数 (例如 u8 -&gt; u32) 将：
<ul>
<li>如果源是无符号的，则用零填充</li>
<li>如果源是有符号的，则使用符号扩展</li>
</ul>
</li>
<li>将浮点数转换为整数会将浮点数向零舍入 
<ul>
<li><code>NaN</code> 将返回 <code>0</code> </li>
<li>大于最大整数值的值，包括 <code>INFINITY</code> ，将饱和到整数类型的最大值。</li>
<li>小于最小整数值的值，包括 <code>NEG_INFINITY</code> ，将饱和到整数类型的最小值。</li>
</ul>
</li>
<li>将整数转换为浮点数将产生可能最接近的浮点数 *
<ul>
<li>如有必要，舍入按照 <code>roundTiesToEven</code> 模式进行  *** </li>
<li>溢出时，将生成无限大 (与输入相同的符号) </li>
<li>注意：对于当前的数字类型集，只有在 <code>u128 as f32</code> 的值大于或等于 <code>f32::MAX + (0.5 ULP)</code> 时才会发生溢出</li>
</ul>
</li>
<li>从 f32 转换为 f64 是完美的和无损的</li>
<li>从 f64 转换为 f32 将产生可能最接近的 f32 **
<ul>
<li>如有必要，舍入按照 <code>roundTiesToEven</code> 模式进行 *** </li>
<li>溢出时，将生成无限大 (与输入相同的符号) </li>
</ul>
</li>
</ul>
<p>* 如果硬件不支持此舍入模式和溢出行为的整数到浮点数的转换，则此类转换可能比预期的慢。</p>
<p>** 如果硬件不支持此舍入模式和溢出行为的 f64 到 f32 的转换，则此类转换可能比预期的慢。</p>
<p>*** 正如 IEEE 754-2008 §4.3.1: 中所定义的那样：选择最接近的浮点数，如果恰好介于两个浮点数之间，则优先选择带有偶数最低位数字的数字。</p>
<h4 id="枚举转换"><a class="header" href="#枚举转换">枚举转换</a></h4>
<p>将枚举转换为其判别式，然后根据需要使用数值转换。转换仅限于以下种类的枚举:</p>
<ul>
<li><a href="expressions/../items/enumerations.html#unit-only-enum">仅单元元素的枚举</a></li>
<li><a href="expressions/../items/enumerations.html#field-less-enum">没有字段的枚举</a> 且没有 <a href="expressions/../items/enumerations.html#explicit-discriminants">显式判别式</a> ，或者只有单元元素有显式判别式</li>
</ul>
<h4 id="原始类型到整数的转换"><a class="header" href="#原始类型到整数的转换">原始类型到整数的转换</a></h4>
<ul>
<li><code>false</code> 转换为 <code>0</code> ， <code>true</code> 转换为 <code>1</code></li>
<li><code>char</code> 转换为其码点值，然后如果需要则使用数字转换。</li>
</ul>
<h4 id="u8-到-char-的类型转换"><a class="header" href="#u8-到-char-的类型转换"><code>u8</code> 到 <code>char</code> 的类型转换</a></h4>
<p>将 <code>u8</code> 类型的值转换为相应的 Unicode 编码对应的字符类型 <code>char</code> 。</p>
<h4 id="指针到地址转换"><a class="header" href="#指针到地址转换">指针到地址转换</a></h4>
<p>将一个裸指针转换为整数类型会产生指向内存的机器地址。
如果整数类型比指针类型小，地址可能会被截断；使用 <code>usize</code> 可以避免这种情况。</p>
<h4 id="地址到指针的强制类型转换"><a class="header" href="#地址到指针的强制类型转换">地址到指针的强制类型转换</a></h4>
<p>将整数强制类型转换为原始指针会将该整数解释为内存地址，并产生一个指向该内存的指针。</p>
<div class="warning">
<p>警告:
这会与 Rust 内存模型产生交互，而该模型仍在开发中。
即使一个通过此类型转换获得的指针在比特位上等同于一个有效指针，它也可能受到额外的限制
。如果未遵循别名规则，则解引用此类指针可能会导致 <a href="expressions/../behavior-considered-undefined.html">未定义行为</a> 。</p>
</div>
<p>一些简单正确的地址解算的示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut values: [i32; 2] = [1, 2];
let p1: *mut i32 = values.as_mut_ptr();
let first_address = p1 as usize;
let second_address = first_address + 4; // 4 == size_of::&lt;i32&gt;()
let p2 = second_address as *mut i32;
unsafe {
    *p2 += 1;
}
assert_eq!(values[1], 3);
<span class="boring">}</span></code></pre></pre>
<h2 id="赋值表达式"><a class="header" href="#赋值表达式">赋值表达式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>赋值表达式</em> :<br />
   <a href="expressions/../expressions.html"><em>表达式</em></a> <code>=</code> <a href="expressions/../expressions.html"><em>表达式</em></a></p>
</blockquote>
<p>一个 <em>赋值表达式</em> 将一个值移动到一个指定的位置。</p>
<p>一个赋值表达式由一个 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">可变的</a> ，即 <em>赋值运算符</em> ，后面跟一个等于号 (<code>=</code>) 和一个 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">值表达式</a> ，即 <em>被赋的值操作数</em> 组成。
在最基本的形式中，一个赋值运算符是一个 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">占位表达式</a> ，我们首先讨论这种情况。
下面讨论更一般的解构赋值情况，但是这种情况总是分解为对占位表达式的顺序赋值，这可能被视为更基本的情况。</p>
<h3 id="基本赋值语句"><a class="header" href="#基本赋值语句">基本赋值语句</a></h3>
<p>对赋值表达式求值，需要先对操作数进行求值。先对被赋值操作数进行求值，然后是赋值操作数表达式。对于解构赋值，可赋值表达式的子表达式从左到右进行求值。</p>
<blockquote>
<p><strong>注意</strong>：与其他表达式不同的是，右操作数在左操作数之前进行求值。该表达式首先有一个效果：删除被赋值位置的值，除非被赋值的地方是未初始化的本地变量或本地变量的未初始化字段。然后将赋值的值复制或移动到被赋值的地方。</p>
</blockquote>
<p>赋值表达式总是生成 <a href="expressions/../types/tuple.html">单元值</a> 。</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 0;
let y = 0;
x = y;
<span class="boring">}</span></code></pre></pre>
<h3 id="解构赋值"><a class="header" href="#解构赋值">解构赋值</a></h3>
<p>解构赋值是变量声明解构模式匹配的一种对应物，允许对复杂的值进行赋值，例如元组或结构体。
例如，我们可以交换两个可变变量:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (mut a, mut b) = (0, 1);
// 使用解构赋值交换 `a` 和 `b`。
(b, a) = (a, b);
<span class="boring">}</span></code></pre></pre>
<p>与使用 <code>let</code> 进行解构声明不同，由于语法歧义，模式不能出现在赋值语句的左侧。
相反，一组对应模式的表达式被指定为 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">可赋值表达式</a> ，并允许出现在赋值语句的左侧。
然后，将赋值表达式展开为模式匹配，然后进行顺序赋值。
展开后的模式必须是不可反驳的：特别地，这意味着仅允许具有在编译时已知长度的切片模式以及简单的切片 <code>[..]</code> 用于解构赋值。</p>
<p>展开的方法很简单，最好通过示例来说明。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct { x: u32, y: u32 }
</span><span class="boring">let (mut a, mut b) = (0, 0);
</span>(a, b) = (3, 4);

[a, b] = [3, 4];

Struct { x: a, y: b } = Struct { x: 3, y: 4};

// desugars to:

{
    let (_a, _b) = (3, 4);
    a = _a;
    b = _b;
}

{
    let [_a, _b] = [3, 4];
    a = _a;
    b = _b;
}

{
    let Struct { x: _a, y: _b } = Struct { x: 3, y: 4};
    a = _a;
    b = _b;
}
<span class="boring">}</span></code></pre></pre>
<p>在单个可赋值表达式中，标识符不禁止被多次使用。</p>
<p><a href="expressions/./underscore-expr.html">下划线表达式</a> 和空 <a href="expressions/./range-expr.html">区间表达式</a> 可用于忽略某些值，而不将它们绑定到变量上。</p>
<p>注意，对于展开后的表达式，不适用默认绑定模式。</p>
<h2 id="复合赋值表达式"><a class="header" href="#复合赋值表达式">复合赋值表达式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>复合赋值表达式</em> :<br />
      <a href="expressions/../expressions.html"><em>表达式</em></a> <code>+=</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>-=</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>*=</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>/=</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>%=</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>&amp;=</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>|=</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>^=</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>&lt;&lt;=</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>&gt;&gt;=</code> <a href="expressions/../expressions.html"><em>表达式</em></a></p>
</blockquote>
<p><em>复合赋值表达式</em> 将算术和逻辑二元运算符与赋值表达式结合在一起。</p>
<p>例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 5;
x += 1;
assert!(x == 6);
<span class="boring">}</span></code></pre></pre>
<p>复合赋值语法是一个 <a href="expressions/../expressions.html#mutability">可变的</a> <a href="expressions/../expressions.html#place-expressions-and-value-expressions">占位表达式</a>，紧接着是 <em>被赋值的操作数</em> ，然后是其中一个运算符，后面跟着一个 <code>=</code> 符号 (无空格) ，最后是一个 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">值表达式</a> ，即 <em>修改操作数</em> 。</p>
<p>与其他占位操作数不同，被赋值的占位操作数必须是一个占位表达式。尝试使用值表达式会导致编译错误，而不是将其升级为临时值。</p>
<p>复合赋值表达式的求值取决于操作符的类型。</p>
<p>如果两个类型都是原始类型，则将先计算修改操作数，然后是被赋值的操作数。
然后它将使用执行该运算符操作的被赋值操作数和修改操作数的值来设置被赋值操作数的占位的值。</p>
<blockquote>
<p><strong>注意</strong>: 这与其他表达式不同，因为右操作数在左操作数之前被评估。</p>
</blockquote>
<p>否则，这个表达式是语法糖，用于调用运算符的重载复合赋值特性的函数 (参见本章前面的表格) 。
被赋值的操作数会自动被可变地借用。</p>
<p>例如，在 <code>example</code> 中，以下表达式语句是等价的：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Addable;
</span><span class="boring">use std::ops::AddAssign;
</span>
impl AddAssign&lt;Addable&gt; for Addable {
    /* */
<span class="boring">fn add_assign(&amp;mut self, other: Addable) {}
</span>}

fn example() {
<span class="boring">let (mut a1, a2) = (Addable, Addable);
</span>  a1 += a2;

<span class="boring">let (mut a1, a2) = (Addable, Addable);
</span>  AddAssign::add_assign(&amp;mut a1, a2);
}
<span class="boring">}</span></code></pre></pre>
<p>与赋值表达式一样，复合赋值表达式始终生成 <a href="expressions/../types/tuple.html">单元值</a> 。</p>
<div class="warning">
<p>警告：操作数的求值顺序根据操作数的类型而交换：对于原始类型，右操作数将首先得到评估，而对于非原始类型，左操作数将首先得到评估。
尽量不要编写依赖于复合赋值表达式中操作数的求值顺序的代码。参见 <a href="https://github.com/rust-lang/rust/blob/1.58.0/src/test/ui/expr/compound-assignment/eval-order.rs">这个测试</a> ，了解使用此依赖性的示例。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分组表达式"><a class="header" href="#分组表达式">分组表达式</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>分组表达式</em> :<br />
   <code>(</code> <a href="expressions/../expressions.html"><em>表达式</em></a> <code>)</code></p>
</blockquote>
<p><em>括号表达式</em> 将一个单独的表达式包裹起来，最终的结果是这个表达式的值。
括号表达式的语法是 <code>(</code> ，然后是一个表达式，称为 <em>内嵌操作数</em> ，最后是一个 <code>)</code> 。</p>
<p>括号表达式的值等同于内嵌操作数的值。与其他表达式不同的是，括号表达式既是 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">占位表达式</a> 也是值表达式。
当内嵌操作数是占位表达式时，括号表达式也是占位表达式；当内嵌操作数是值表达式时，括号表达式也是值表达式。</p>
<p>括号可以用于显式修改表达式中子表达式的优先级顺序。</p>
<p>以下是括号表达式的示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32 = 2 + 3 * 4;       // 未使用括号的表达式
let y: i32 = (2 + 3) * 4;     // 使用了括号的表达式
assert_eq!(x, 14);            // 验证 x 的值是否为 14
assert_eq!(y, 20);            // 验证 y 的值是否为 20
<span class="boring">}</span></code></pre></pre>
<p>必须使用括号的一个例子是调用结构体成员的函数指针:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct A {
</span><span class="boring">   f: fn() -&gt; &amp;'static str
</span><span class="boring">}
</span><span class="boring">impl A {
</span><span class="boring">   fn f(&amp;self) -&gt; &amp;'static str {
</span><span class="boring">       &quot;The method f&quot;
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let a = A{f: || &quot;The field f&quot;};
</span><span class="boring">
</span>assert_eq!( a.f (), &quot;The method f&quot;);
assert_eq!((a.f)(), &quot;The field f&quot;);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数组和数组索引表达式"><a class="header" href="#数组和数组索引表达式">数组和数组索引表达式</a></h1>
<h2 id="数组表达式"><a class="header" href="#数组表达式">数组表达式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>数组表达式</em> :<br />
   <code>[</code> <em>数组元素组</em><sup>?</sup> <code>]</code></p>
<p><em>数组元素组</em> :<br />
      <a href="expressions/../expressions.html"><em>表达式</em></a> ( <code>,</code> <a href="expressions/../expressions.html"><em>表达式</em></a> )<sup>*</sup> <code>,</code><sup>?</sup><br />
   | <a href="expressions/../expressions.html"><em>表达式</em></a> <code>;</code> <a href="expressions/../expressions.html"><em>表达式</em></a></p>
</blockquote>
<p><em>数组表达式</em> 构造 <a href="expressions/../types/array.html">数组</a> 。
数组表达式有两种形式。</p>
<p>第一种形式列出数组中的每个值。
这种形式的语法是将类型相同的表达式列表用逗号隔开并用方括号括起来。
这会产生一个包含按照书写顺序排列的这些值的数组。</p>
<p>第二种形式的语法是两个表达式之间用分号 (<code>;</code>) 隔开并用方括号括起来。
分号前的表达式称为 <em>重复操作数</em> 。
分号后的表达式称为 <em>长度操作数</em> 。
它必须是类型为 usize 的 <a href="expressions/../const_eval.html#constant-expressions">常量表达式</a> ，例如  <a href="expressions/../tokens.html#literals">字面值</a> 或 <a href="expressions/../items/constant-items.html">常量条目</a> 。
这种形式的数组表达式会创建一个长度为长度操作数的值的数组，每个元素都是重复操作数的副本。
也就是说，[a; b] 创建一个包含 b 个 a 值的副本的数组。
如果长度操作数的值大于 1 ，则要求重复操作数的类型是 <a href="expressions/../special-types-and-traits.html#copy"><code>Copy</code></a> ，或者必须是指向常量条目的 <a href="expressions/path-expr.html">路径</a> 。</p>
<p>当重复操作数是常量条目时，它会被计算长度操作数的值的次数。
如果该值为 0 ，则不会对常量条目进行计算。
对于不是常量条目的表达式，它会被计算一次，然后结果会被复制长度操作数值的次数。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[1, 2, 3, 4];
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];
[0; 128];              // 数组为 128 个 0 
[0u8, 0u8, 0u8, 0u8,];
[[1, 0, 0], [0, 1, 0], [0, 0, 1]]; // 二维数组
const EMPTY: Vec&lt;i32&gt; = Vec::new();
[EMPTY; 2];
<span class="boring">}</span></code></pre></pre>
<h2 id="数组和切片索引表达式"><a class="header" href="#数组和切片索引表达式">数组和切片索引表达式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>索引表达式</em> :<br />
   <a href="expressions/../expressions.html"><em>表达式</em></a> <code>[</code> <a href="expressions/../expressions.html"><em>表达式</em></a> <code>]</code></p>
</blockquote>
<p><a href="expressions/../types/array.html">数组</a> 和 <a href="expressions/../types/slice.html">切片</a> 类型的值可以通过在它们后面写一个类型为 <code>usize</code> 的方括号括起来的表达式进行索引。
当数组是可变的，其结果的 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">内存位置</a> 可以被赋值。</p>
<p>对于其他类型，索引表达式 <code>a[b]</code> 等价于 <code>*std::ops::Index::index(&amp;a, b)</code> ，或者在可变占位表达式的上下文中等价于 <code>*std::ops::IndexMut::index_mut(&amp;mut a, b)</code> 。就像方法一样， Rust 也会在 <code>a</code> 上插入解引用操作以找到实现。</p>
<p>数组和切片的索引是从零开始的。
数组访问是一个 <a href="expressions/../const_eval.html#constant-expressions">常量表达式</a> ，因此如果索引值是常量，编译时可以进行边界检查。
否则，运行时会进行检查，如果检查失败，会将线程置于 <em>恐慌状态</em>。</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 默认情况下 lint 为 deny。
#![warn(unconditional_panic)]

([1, 2, 3, 4])[2];        // 计算结果为 3

let b = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
b[1][2];                  // 多维数组索引

let x = ([&quot;a&quot;, &quot;b&quot;])[10]; // 警告：索引越界

let n = 10;
let y = ([&quot;a&quot;, &quot;b&quot;])[n];  // 引发 panic

let arr = [&quot;a&quot;, &quot;b&quot;];
arr[10];                  // 警告：索引越界
<span class="boring">}</span></code></pre></pre>
<p>数组索引表达式可以通过实现 <a href="expressions/../../std/ops/trait.Index.html">Index</a> 和 <a href="expressions/../../std/ops/trait.IndexMut.html">IndexMut</a> trait 来实现其他类型的索引。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元组和元组索引表达式"><a class="header" href="#元组和元组索引表达式">元组和元组索引表达式</a></h1>
<h2 id="元组达式"><a class="header" href="#元组达式">元组达式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>元组表达式</em> :<br />
   <code>(</code> <em>元组元素组</em><sup>?</sup> <code>)</code></p>
<p><em>元组元素组</em> :<br />
   ( <a href="expressions/../expressions.html"><em>表达式</em></a> <code>,</code> )<sup>+</sup> <a href="expressions/../expressions.html"><em>表达式</em></a><sup>?</sup></p>
</blockquote>
<p><em>元组表达式</em> 构造了 <a href="expressions/../types/tuple.html">元组值</a> 。</p>
<p>元组表达式的语法是括号包围的、用逗号分隔的表达式列表，称为 <em>元组初始化操作数</em> 。
一元组表达式需要在其元组初始化操作数后面加上逗号，以与 <a href="expressions/grouped-expr.html">圆括号表达式</a> 区分。</p>
<p>元组表达式是 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">值表达式</a> ，它的结果是一个新构造的元组类型的值。
元组初始化操作数的数量是构造的元组的元的数量。
没有元组初始化操作数的元组表达式会产生一个单元元组。
对于其他元组表达式，第一个写入的元组初始化操作数初始化字段 <code>0</code> ，随后的操作数初始化下一个最高的字段。
例如，在元组表达式 <code>('a', 'b', 'c')</code> 中， <code>'a'</code> 初始化字段 <code>0</code> 的值， <code>'b'</code> 初始化字段 <code>1</code> 的值， <code>'c'</code> 初始化字段 <code>2</code> 的值。</p>
<p>以下是一些元组表达式及其类型的示例:</p>
<div class="table-wrapper"><table><thead><tr><th>表达式</th><th>类型</th></tr></thead><tbody>
<tr><td><code>()</code></td><td><code>()</code> (单元)</td></tr>
<tr><td><code>(0.0, 4.5)</code></td><td><code>(f64, f64)</code></td></tr>
<tr><td><code>(&quot;x&quot;.to_string(), )</code></td><td><code>(String, )</code></td></tr>
<tr><td><code>(&quot;a&quot;, 4usize, true)</code></td><td><code>(&amp;'static str, usize, bool)</code></td></tr>
</tbody></table>
</div>
<h2 id="元组索引表达式"><a class="header" href="#元组索引表达式">元组索引表达式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>元组索引表达式</em> :<br />
   <a href="expressions/../expressions.html"><em>表达式</em></a> <code>.</code> <a href="expressions/../tokens.html#tuple-index">元组索引</a></p>
</blockquote>
<p><em>元组索引表达式</em> 用于访问 <a href="expressions/../types/tuple.html">元组</a> 和 <a href="expressions/../types/struct.html">元组结构体</a> 中的字段。</p>
<p>元组索引表达式的语法是一个表达式，即 <em>元组操作数</em> ，后跟一个点号 ( <code>.</code> ) ，最后是一个元组索引。
元组索引的语法是一个 <a href="expressions/../tokens.html#integer-literals">十进制字面值</a> ，没有前导零、下划线或后缀。
例如，<code>0</code> 和 <code>2</code> 是有效的元组索引，但  <code>01</code> 、 <code>0_</code> 和 <code>0i32</code> 不是。</p>
<p>元组操作数的类型必须是 <a href="expressions/../types/tuple.html">元组类型</a> 或 <a href="expressions/../types/struct.html">元组结构体</a> 的一种。
元组索引必须是元组操作数类型中与之同名的字段。</p>
<p>求值元组索引表达式除了求值其元组操作数之外没有任何副作用。
作为 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">占位表达式</a> ，它将求值元组操作数中与元组索引同名的字段的位置。</p>
<p>元组索引表达式的示例如下:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对元组进行检索
let pair = (&quot;a string&quot;, 2);
assert_eq!(pair.1, 2);

// 对元组结构体进行检索
<span class="boring">struct Point(f32, f32);
</span>let point = Point(1.0, 0.0);
assert_eq!(point.0, 1.0);
assert_eq!(point.1, 0.0);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>注意</strong>: 与字段访问表达式不同，元组索引表达式可以作为 <a href="expressions/./call-expr.html">调用表达式</a> 的函数操作数，因为它不能与方法调用混淆，因为方法名称不能是数字。</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>: 尽管数组和切片也有元素，但必须使用 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">数组或切片索引表达式</a> 或 <a href="expressions/../patterns.html#slice-patterns">切片模式</a> 来访问它们的元素。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体表达式"><a class="header" href="#结构体表达式">结构体表达式</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>结构体表达式</em> :<br />
      <em>结构体表达式结构体</em><br />
   | <em>结构体表达式元组</em><br />
   | <em>结构体表达式单元</em></p>
<p><em>结构体表达式结构体</em> :<br />
   <a href="expressions/../paths.html#paths-in-expressions"><em>表达式中路径</em></a> <code>{</code> (<em>结构体表达式字段组</em> | <em>结构体省略</em>)<sup>?</sup> <code>}</code></p>
<p><em>结构体表达式字段组</em> :<br />
   <em>结构体表达式字段</em> (<code>,</code> <em>结构体表达式字段</em>)<sup>*</sup> (<code>,</code> <em>结构体省略</em> | <code>,</code><sup>?</sup>)</p>
<p><em>结构体表达式字段</em> :<br />
   <a href="expressions/../attributes.html"><em>外部属性</em></a> <sup>*</sup><br />
   (<br />
         <a href="expressions/../identifiers.html">标识符</a><br />
      | (<a href="expressions/../identifiers.html">标识符</a> | <a href="expressions/../tokens.html#tuple-index">元组索引</a>) <code>:</code> <a href="expressions/../expressions.html"><em>表达式</em></a><br />
   )</p>
<p><em>结构体省略</em> :<br />
   <code>..</code> <a href="expressions/../expressions.html"><em>表达式</em></a></p>
<p><em>结构体表达式元组</em> :<br />
   <a href="expressions/../paths.html#paths-in-expressions"><em>表达式中路径</em></a> <code>(</code><br />
      ( <a href="expressions/../expressions.html"><em>表达式</em></a> (<code>,</code> <a href="expressions/../expressions.html"><em>表达式</em></a>)<sup>*</sup> <code>,</code><sup>?</sup> )<sup>?</sup><br />
   <code>)</code></p>
<p><em>结构体表达式单元</em> : <a href="expressions/../paths.html#paths-in-expressions"><em>表达式中路径</em></a></p>
</blockquote>
<p><em>结构体表达式</em> 用于创建结构体、枚举或联合体值。
它由指向 <a href="expressions/../items/structs.html">结构体</a> 、 <a href="expressions/../items/enumerations.html">枚举变体</a> 或 <a href="expressions/../items/unions.html">联合体</a> 条目的路径，以及该条目字段的值组成。结构体表达式有三种形式：结构体、元组和单元结构体。</p>
<p>以下是结构体表达式的示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point { x: f64, y: f64 }
</span><span class="boring">struct NothingInMe { }
</span><span class="boring">struct TuplePoint(f64, f64);
</span><span class="boring">mod game { pub struct User&lt;'a&gt; { pub name: &amp;'a str, pub age: u32, pub score: usize } }
</span><span class="boring">struct Cookie; fn some_fn&lt;T&gt;(t: T) {}
</span>Point {x: 10.0, y: 20.0};
NothingInMe {};
TuplePoint(10.0, 20.0);
TuplePoint { 0: 10.0, 1: 20.0 }; // 得到的结果与上一行相同
let u = game::User {name: &quot;Joe&quot;, age: 35, score: 100_000};
some_fn::&lt;Cookie&gt;(Cookie);
<span class="boring">}</span></code></pre></pre>
<h2 id="字段结构体表达式"><a class="header" href="#字段结构体表达式">字段结构体表达式</a></h2>
<p>带有花括号括起来的字段结构体表达式允许您以任何顺序指定每个单独字段的值。字段名称用冒号与其值分开。</p>
<p><a href="expressions/../items/unions.html">联合体</a> 类型的值只能使用此语法创建，并且必须指定一个字段。</p>
<h2 id="函数式更新语法"><a class="header" href="#函数式更新语法">函数式更新语法</a></h2>
<p>用于构造结构体类型值的结构体表达式可以以 <code>..</code> 语法结尾，后跟表达式，表示函数式更新。
<code>..</code> 后面的表达式（基表达式）必须与新结构体类型相同。</p>
<p>整个表达式使用给定值填充指定的字段，并将其余字段从基表达式中移动或复制。
与所有结构体表达式一样，结构体的所有字段都必须是 <a href="expressions/../visibility-and-privacy.html">可见的</a> ，即使未显式命名。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point3d { x: i32, y: i32, z: i32 }
</span>let mut base = Point3d {x: 1, y: 2, z: 3};
let y_ref = &amp;mut base.y;
Point3d {y: 0, z: 10, .. base}; // 成功, 仅 base.x 是被访问
drop(y_ref);
<span class="boring">}</span></code></pre></pre>
<p>结构体表达式使用花括号括起来的字段，可以在 <a href="expressions/loop-expr.html">loop</a> 或 <a href="expressions/if-expr.html#if-expressions">if</a> 表达式的头部， <a href="expressions/if-expr.html#if-let-expressions">if let</a> 或 <a href="expressions/match-expr.html">match</a> 表达式的 <a href="expressions/../glossary.html#scrutinee">被匹配项</a> 中不能直接使用。
但是，如果它们位于另一个表达式中，例如括号中，那么就可以在这些情况下使用结构体表达式。</p>
<p>字段名可以是十进制整数值，用于构造元组结构体的索引。这可以与基础结构体一起使用，以填充未指定的其余索引:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color(u8, u8, u8); // 定义一个名为Color的元组结构体
let c1 = Color(0, 0, 0); // 创建元组结构体实例的一般方式
let c2 = Color{0: 255, 1: 127, 2: 0}; // 按索引指定结构体字段的值
let c3 = Color{1: 0, ..c2}; // 使用基础结构体填充所有其他字段
<span class="boring">}</span></code></pre></pre>
<h3 id="结构体字段初始化的简写语法"><a class="header" href="#结构体字段初始化的简写语法">结构体字段初始化的简写语法</a></h3>
<p>在初始化具有命名 (但不是编号) 字段的数据结构 (struct、enum、union) 时，可以使用 <code>fieldname</code> 的写法代替 <code>fieldname: fieldname</code> 的完整写法。
这样可以使用更简洁的语法来避免重复。
例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point3d { x: i32, y: i32, z: i32 }
</span><span class="boring">let x = 0;
</span><span class="boring">let y_value = 0;
</span><span class="boring">let z = 0;
</span>Point3d { x: x, y: y_value, z: z };
Point3d { x, y: y_value, z };
<span class="boring">}</span></code></pre></pre>
<h2 id="元组结构体表达式"><a class="header" href="#元组结构体表达式">元组结构体表达式</a></h2>
<p>用括号括起来的字段的结构体表达式构造元组结构体。
虽然为了完整性而在此列出了它作为一个特定的表达式，但它等同于对元组结构体构造函数的 <a href="expressions/call-expr.html">调用表达式</a> 。
例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Position(i32, i32, i32);
Position(0, 0, 0);  // 典型的创建元组结构体的方式
let c = Position;  // `c` 是一个接受 3 个参数的函数
let pos = c(8, 6, 7);  // 创建一个 `Position` 值
<span class="boring">}</span></code></pre></pre>
<h2 id="单元结构体表达式"><a class="header" href="#单元结构体表达式">单元结构体表达式</a></h2>
<p>单元结构体表达式只是指向一个空结构体条目的路径。
这个路径指向该结构体的值的隐式常量。
单元结构体的值也可以用一个没有字段的结构体表达式构造。例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Gamma;
let a = Gamma;  // Gamma 单元值。
let b = Gamma{};  // 与 `a` 完全相同的值。
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调用表达式"><a class="header" href="#调用表达式">调用表达式</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>调用语法</em> :<br />
   <a href="expressions/../expressions.html"><em>表达式</em></a> <code>(</code> <em>调用参数组</em><sup>?</sup> <code>)</code></p>
<p><em>调用参数组</em> :<br />
   <a href="expressions/../expressions.html"><em>表达式</em></a> ( <code>,</code> <a href="expressions/../expressions.html"><em>表达式</em></a> )<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<p><em>调用表达式</em> 调用一个函数。
调用表达式的语法是一个表达式，称为 <em>函数操作数</em> ，后面跟着一个带括号的逗号分隔的表达式列表，称为 <em>参数操作数</em> 。
如果函数最终返回，则表达式完成。
对于 <a href="expressions/../types/function-item.html">非函数类型</a> ，表达式 <code>f(...)</code> 使用 <a href="expressions/../../std/ops/trait.Fn.html"><code>std::ops::Fn</code></a> 、 <a href="expressions/../../std/ops/trait.FnMut.html"><code>std::ops::FnMut</code></a> 或<a href="expressions/../../std/ops/trait.FnOnce.html"><code>std::ops::FnOnce</code></a> trait 中的方法，这些 trait 在是否通过引用、可变引用或取得所有权方面有所不同。
如果需要，将自动借用。函数操作数也将根据需要 <a href="expressions/field-expr.html#automatic-dereferencing">自动解引用</a> 。</p>
<p>以下是一些调用表达式的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn add(x: i32, y: i32) -&gt; i32 { 0 }
</span>let three: i32 = add(1i32, 2i32);
let name: &amp;'static str = (|| &quot;Rust&quot;)();
<span class="boring">}</span></code></pre></pre>
<h2 id="消除函数调用的歧义"><a class="header" href="#消除函数调用的歧义">消除函数调用的歧义</a></h2>
<p>所有函数调用都是 <a href="expressions/../paths.html#qualified-paths">完全限定语法</a> 的语法糖。
根据调用的歧义性以及作用域内的条目，函数调用可能需要完全限定。</p>
<blockquote>
<p><strong>注意</strong>：在过去，术语 &quot;无歧义函数调用语法&quot; 、 &quot;通用函数调用语法&quot; 或 &quot;UFCS&quot; 已被用于文档、问题、RFC和其他社区著作。
但是，这些术语缺乏描述能力，可能会让问题变得更加混乱。
我们在这里提到它们是为了便于搜索。</p>
</blockquote>
<p>有几种常见情况可能导致方法或关联函数调用的接收者或参照对象产生歧义。
这些情况可能包括:</p>
<ul>
<li>多个作用域内的 trait 为相同类型定义了同名方法</li>
<li>不希望自动解引用；例如，区分智能指针本身的方法和指针的参照对象的方法</li>
<li>不带参数的方法，例如 <a href="expressions/../../std/default/trait.Default.html#tymethod.default"><code>default()</code></a> ，返回类型的属性，例如 <a href="expressions/../../std/mem/fn.size_of.html"><code>size_of()</code></a></li>
</ul>
<p>为了解决歧义，程序员可以使用更具体的路径、类型或 trait 来指定他们想要的方法或函数。</p>
<p>例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">trait Pretty {
    fn print(&amp;self);
}

trait Ugly {
  fn print(&amp;self);
}

struct Foo;
impl Pretty for Foo {
    fn print(&amp;self) {}
}

struct Bar;
impl Pretty for Bar {
    fn print(&amp;self) {}
}
impl Ugly for Bar {
    fn print(&amp;self) {}
}

fn main() {
    let f = Foo;
    let b = Bar;

    // 我们可以这样做，因为只有一个叫做 `print` 的项适用于 `Foo`
    f.print();
    // 更明确的，而且在 `Foo` 的情况下并不必要
    Foo::print(&amp;f);
    // 如果你不喜欢简洁的语法
    &lt;Foo as Pretty&gt;::print(&amp;f);

    // b.print(); // 错误：发现多个 'print'
    // Bar::print(&amp;b); // 仍然是错误：发现多个 `print`

    // 由于作用域内的项目定义了 `print` ，因此这是必要的
    &lt;Bar as Pretty&gt;::print(&amp;b);
}</code></pre></pre>
<p>Refer to <a href="https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md">RFC 132</a> for further details and motivations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="方法调用表达式"><a class="header" href="#方法调用表达式">方法调用表达式</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>方法调用表达式</em> :<br />
   <a href="expressions/../expressions.html"><em>表达式</em></a> <code>.</code> <a href="expressions/../paths.html#paths-in-expressions"><em>路径表达式语句</em></a> <code>(</code>[<em>调用参数组</em>]<sup>?</sup> <code>)</code></p>
</blockquote>
<p>一个 <em>方法调用</em> 由一个表达式 (即 <em>接收者</em> ) 加上一个点 ( <code>.</code> ) 、一个表达式路径段和一个带括号的表达式列表组成。
方法调用会解析到特定 trait 上关联的方法，如果左侧表达式的确切 <code>self</code> 类型已知，则静态地调度到方法，否则，如果左侧表达式是一个间接的 trait 对象，则动态地调度。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pi: Result&lt;f32, _&gt; = &quot;3.14&quot;.parse();
let log_pi = pi.unwrap_or(1.0).log(2.72);
<span class="boring">assert!(1.14 &lt; log_pi &amp;&amp; log_pi &lt; 1.15)
</span><span class="boring">}</span></code></pre></pre>
<p>在查找方法调用时，为了调用方法，接收者可能会自动解引用或借用。与其他函数相比，这需要更复杂的查找过程，因为可能有许多可能要调用的方法。使用以下过程:</p>
<p>第一步是构建候选接收者类型列表。通过重复 <a href="expressions/operator-expr.html#the-dereference-operator">解引用</a> 接收者表达式的类型，将遇到的每种类型添加到列表中，然后在最后尝试 <a href="expressions/../type-coercions.html#unsized-coercions">不可缩放强制转换</a> ，如果成功，则添加结果类型。然后，对于每个候选项 <code>T</code> ，在 <code>T</code> 之后立即添加 <code>&amp;T</code> 和 <code>&amp;mut T</code> 。</p>
<p>例如，如果接收者的类型为 <code>Box&lt;[i32;2]&gt;</code> ，则候选类型将是 <code>Box&lt;[i32;2]&gt;</code> 、 <code>&amp;Box&lt;[i32;2]&gt;</code> 、 <code>&amp;mut Box&lt;[i32;2]&gt;</code> 、 <code>[i32;2]</code> (通过解引用) 、 <code>&amp;[i32;2]</code> 、<code>&amp;mut [i32;2]</code> 、 <code>[i32]</code> （通过不可缩放强制转换）、 <code>&amp;[i32]</code> 和最后的 <code>&amp;mut [i32]</code> 。</p>
<p>然后，对于每个候选类型 <code>T</code> ，在以下位置搜索具有该类型接收者的 <a href="expressions/../visibility-and-privacy.html">可见</a> 方法:</p>
<ol>
<li><code>T</code> 的内部方法 (直接在 <code>T</code> 上实现的方法)。</li>
<li>由 <code>T</code> 实现的 <a href="expressions/../visibility-and-privacy.html">可见</a> trait 提供的任何方法。如果 <code>T</code> 是类型参数，则首先查找 <code>T</code> 的 trait 约束提供的方法，然后查找所有剩余的作用域内方法。</li>
</ol>
<blockquote>
<p>注意: 查找是按顺序对每种类型进行的，这可能偶尔会导致令人惊讶的结果。
下面的代码将打印 &quot;In trait impl!&quot; ，因为 <code>&amp;self</code> 方法首先被查找，因此在找到结构体的 <code>&amp;mut self</code> 方法之前就找到了 trait 方法。</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Foo {}

trait Bar {
  fn bar(&amp;self);
}

impl Foo {
  fn bar(&amp;mut self) {
    println!(&quot;In struct impl!&quot;)
  }
}

impl Bar for Foo {
  fn bar(&amp;self) {
    println!(&quot;In trait impl!&quot;)
  }
}

fn main() {
  let mut f = Foo{};
  f.bar();
}</code></pre></pre>
</blockquote>
<p>如果这个过程导致有多个可能的候选方法，那么就会出现一个错误，接收者必须被转换为适当的接收者类型才能调用该方法。</p>
<p>这个过程不考虑接收者的可变性或生命周期，也不考虑方法是否是 <code>unsafe</code> 。一旦找到一个方法，如果出于其中一个或多个原因无法调用，结果就是编译器错误。</p>
<p>如果达到了一个步骤，其中有多个可能的方法，比如在考虑通用方法或 trait 时，那么这就是编译器错误。这些情况需要使用 <a href="expressions/call-expr.html#disambiguating-function-calls">消除歧义的函数调用语法</a> 来调用方法和函数。</p>
<blockquote>
<p><strong>版本差异</strong>: 在 2021 版本之前，寻找可见方法时，如果候选接收者类型是 <a href="expressions/../types/array.html">数组类型</a> ，则忽略标准库 <a href="expressions/../../std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a> trait 提供的方法。</p>
<p>用于此目的的版本由表示方法名称的令牌确定。</p>
<p>这种特殊情况可能会在将来被删除。</p>
</blockquote>
<div class="warning">
<p><em><strong>警告:</strong></em> 对于 <a href="expressions/../types/trait-object.html">trait对象</a> ，如果存在与 trait 方法同名的内部方法，在方法调用表达式中尝试调用该方法会导致编译器错误。相反，可以使用 <a href="expressions/call-expr.html#disambiguating-function-calls">消除歧义的函数调用语法</a> 来调用该方法，这样会调用 trait 方法而不是内部方法。没有方法可以调用内部方法。不要在具有与 trait 方法同名的内部方法的 trait 对象上定义内部方法，这样就不会出现问题。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字段访问表达式"><a class="header" href="#字段访问表达式">字段访问表达式</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>字段表达式</em> :<br />
   <a href="expressions/../expressions.html"><em>表达式</em></a> <code>.</code> <a href="expressions/../identifiers.html">标识符</a></p>
</blockquote>
<p><em>字段表达式</em> 是一个 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">占位表达式</a>  ，它求值为 <a href="expressions/../items/structs.html">结构体</a> 或 <a href="expressions/../items/unions.html">联合体</a> 的一个字段的位置。
当操作数是 <a href="expressions/../expressions.html#mutability">可变的</a> ，字段表达式也是可变的。
字段表达式的语法是一个表达式 (称为 <em>容器操作数</em> ) ，然后是一个 <code>.</code> ，最后是一个 <a href="expressions/../identifiers.html">标识符</a> 。
字段表达式不能后跟一个括号内的逗号分隔的表达式列表，因为那将被解析为 <a href="expressions/method-call-expr.html">方法调用表达式</a> 。
也就是说，它们不能作为 <a href="expressions/call-expr.html">调用表达式</a> 的函数操作数。</p>
<blockquote>
<p><strong>注意</strong>: 在调用表达式中使用字段表达式时，要将其包装在 <a href="expressions/grouped-expr.html">括号表达式</a> 中。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct HoldsCallable&lt;F: Fn()&gt; { callable: F }
</span>let holds_callable = HoldsCallable { callable: || () };

// 无效：被解析为调用 &quot;callable&quot; 方法
// holds_callable.callable();

// 有效
(holds_callable.callable)();
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>示例:</p>
<!-- ignore: needs lots of support code -->
<pre><code class="language-rust ignore">mystruct.myfield;
foo().x;
(Struct {a: 10, b: 20}).a;
(mystruct.function_field)() // 包含字段表达式的调用表达式</code></pre>
<h2 id="自动解引用"><a class="header" href="#自动解引用">自动解引用</a></h2>
<p>如果容器操作数的类型实现了 <a href="expressions/../special-types-and-traits.html#deref-and-derefmut"><code>Deref</code></a> 或 <a href="expressions/../special-types-and-traits.html#deref-and-derefmut"><code>DerefMut</code></a> (取决于操作数是否 <a href="expressions/../expressions.html#mutability">可变</a> )，
则会进行 <em>自动解引用</em> ，直到使字段访问成为可能为止。</p>
<h2 id="借用"><a class="header" href="#借用">借用</a></h2>
<p>在借用过程中，结构体的字段或结构体的引用被视为独立的实体。
如果结构体没有实现 <a href="expressions/../special-types-and-traits.html#drop"><code>Drop</code></a> 并且存储在局部变量中，则移动其每个字段时也适用于此规则。
但如果除了 <a href="expressions/../special-types-and-traits.html#boxt"><code>Box</code></a> 之外的用户定义类型进行自动解引用，则不适用此规则。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A { f1: String, f2: String, f3: String }
let mut x: A;
<span class="boring">x = A {
</span><span class="boring">    f1: &quot;f1&quot;.to_string(),
</span><span class="boring">    f2: &quot;f2&quot;.to_string(),
</span><span class="boring">    f3: &quot;f3&quot;.to_string()
</span><span class="boring">};
</span>let a: &amp;mut String = &amp;mut x.f1; // 可变地借用 x.f1
let b: &amp;String = &amp;x.f2;         // 不可变地借用 x.f2
let c: &amp;String = &amp;x.f2;         // 可以再次借用
let d: String = x.f3;           // 从 x.f3 中移动值
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="闭包表达式"><a class="header" href="#闭包表达式">闭包表达式</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>闭包表达式</em> :<br />
   <code>move</code><sup>?</sup><br />
   ( <code>||</code> | <code>|</code> <em>闭包参数组</em><sup>?</sup> <code>|</code> )<br />
   (<a href="expressions/../expressions.html"><em>表达式</em></a> | <code>-&gt;</code> <a href="expressions/../types.html#type-expressions"><em>无约束类型组</em></a> <a href="expressions/block-expr.html"><em>块表达式</em></a>)</p>
<p><em>闭包参数组</em> :<br />
   <em>闭包参数</em> (<code>,</code> <em>闭包参数</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>闭包参数</em> :<br />
   <a href="expressions/../attributes.html"><em>外部属性</em></a><sup>*</sup> <a href="expressions/../patterns.html"><em>模式无顶层选项</em></a> ( <code>:</code> [<em>Type</em>][<em>类型</em>] )<sup>?</sup></p>
</blockquote>
<p><em>闭包表达式</em> ，也称为 lambda 表达式或 lambda ，定义一个 <a href="expressions/../types/closure.html">闭包类型</a> 并求值为该类型的值。
闭包表达式的语法是一个可选的 <code>move</code> 关键字，然后是一个由管道符号分隔 (<code>|</code>) 的逗号分隔的 <a href="expressions/../patterns.html">模式</a> 列表，称为<em>闭包参数</em>，每个参数后面可选地跟随一个 <code>:</code> 和一个类型，然后是一个可选的 <code>-&gt;</code> 和类型，称为 <em>返回类型</em> ，然后是一个表达式，称为 <em>闭包体操作数</em> 。每个模式后面的可选类型是该模式的类型注解。如果存在返回类型，则闭包体必须是一个 <a href="expressions/block-expr.html">块</a> 。</p>
<p>闭包表达式表示一个函数，该函数将一系列参数映射到跟随参数的表达式。
就像 <a href="expressions/../statements.html#let-statements"><code>let</code> 绑定</a> 一样，闭包参数是无法反驳的 <a href="expressions/../patterns.html">模式</a> ，其类型注解是可选的，如果未给出，将从上下文中推断。
每个闭包表达式都具有一个唯一的、匿名的类型。</p>
<p>值得注意的是，闭包表达式 <em>捕获其环境</em> ，而普通的 <a href="expressions/../items/functions.html">函数定义</a> 不会。
如果没有 <code>move</code> 关键字，闭包表达式 <a href="expressions/../types/closure.html#capture-modes">推断它如何从其环境中捕获每个变量</a> ，优先通过共享引用来捕获，实际上借用闭包体内提到的所有外部变量。
如果需要，编译器将推断应该取而代之的是可变引用，或者应该从环境中移动或复制值 (取决于它们的类型) 。
通过在闭包前面加上 <code>move</code> 关键字，可以强制闭包通过复制或移动值来捕获其环境。
这通常用于确保闭包的生命周期为 <code>'static</code> 。</p>
<h2 id="闭包类型实现的-trait"><a class="header" href="#闭包类型实现的-trait">闭包类型实现的 trait</a></h2>
<p>闭包类型实现哪些 trait 取决于如何捕获变量和捕获的变量的类型。
请参考 <a href="expressions/../types/closure.html#call-traits-and-coercions">调用 trait 和强制转换</a> 章节了解闭包实现 <code>Fn</code> 、 <code>FnMut</code> 和 <code>FnOnce</code> 的情况和时间。
如果每个捕获的变量的类型也实现了 trait ，闭包类型实现 <a href="expressions/../special-types-and-traits.html#send"><code>Send</code></a> 和 <a href="expressions/../special-types-and-traits.html#sync"><code>Sync</code></a> 。</p>
<h2 id="示例-3"><a class="header" href="#示例-3">示例</a></h2>
<p>在这个例子中，我们定义了一个函数 <code>ten_times</code> ，它接受一个高阶函数参数，然后我们调用它并传入一个闭包表达式作为参数，接着传入一个从环境中移动值的闭包表达式。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ten_times&lt;F&gt;(f: F) where F: Fn(i32) {
    // 遍历 0..10，对每个值调用 f 函数
    for index in 0..10 {
        f(index);
    }
}

// 调用 ten_times 函数，并传入一个匿名函数作为参数，该匿名函数打印出 &quot;hello&quot; 和输入值
ten_times(|j| println!(&quot;hello, {}&quot;, j));
// 带有类型注解的调用方式，和上一行等价
ten_times(|j: i32| -&gt; () { println!(&quot;hello, {}&quot;, j) });

let word = &quot;konnichiwa&quot;.to_owned();
// 调用 ten_times 函数，并传入一个匿名函数作为参数，该匿名函数打印出 word 和输入值
// 由于匿名函数要使用外部变量 word，所以前面加上 move 关键字
ten_times(move |j| println!(&quot;{}, {}&quot;, word, j));
<span class="boring">}</span></code></pre></pre>
<h2 id="在闭包参数上的属性"><a class="header" href="#在闭包参数上的属性">在闭包参数上的属性</a></h2>
<p>在闭包参数上的属性遵循与 <a href="expressions/../items/functions.html#attributes-on-function-parameters">普通函数参数</a> 相同的规则和限制。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="循环和其他可中断的表达式"><a class="header" href="#循环和其他可中断的表达式">循环和其他可中断的表达式</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>循环表达式</em> :<br />
   <a href="expressions/loop-expr.html#loop-labels"><em>循环标签</em></a><sup>?</sup> (<br />
         <a href="expressions/loop-expr.html#infinite-loops"><em>无限循环表达式</em></a><br />
      | <a href="expressions/loop-expr.html#predicate-loops"><em>断言循环表达式</em></a><br />
      | <a href="expressions/loop-expr.html#predicate-pattern-loops"><em>断言模式循环表达式</em></a><br />
      | <a href="expressions/loop-expr.html#iterator-loops"><em>迭代循环表达式</em></a><br />
      | <a href="expressions/loop-expr.html#labelled-block-expressions"><em>标签块表达式</em></a><br />
   )</p>
</blockquote>
<p>Rust 支持五种循环表达式:</p>
<ul>
<li><a href="expressions/loop-expr.html#infinite-loops"><code>loop</code> 表达式</a> 表示无限循环。</li>
<li><a href="expressions/loop-expr.html#predicate-loops"><code>while</code> 表达式</a> 循环直到断言为 false。</li>
<li><a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code> 表达式</a> 测试模式。</li>
<li><a href="expressions/loop-expr.html#iterator-loops"><code>for</code> 表达式</a> 从迭代器中提取值，循环直到迭代器为空。</li>
<li><a href="expressions/loop-expr.html#labelled-block-expressions">带标签的块表达式</a> 只运行一次循环，但允许使用 <code>break</code> 提前退出循环。</li>
</ul>
<p>这五种类型的循环都支持 <a href="expressions/loop-expr.html#break-expressions"><code>break</code> 表达式</a> 和 <a href="expressions/loop-expr.html#loop-labels">标签</a> 。
除了带标签的块表达式外，所有类型的循环都支持 <a href="expressions/loop-expr.html#continue-expressions"><code>continue</code> 表达式</a> 。
只有 <code>loop</code> 和带标签的块表达式支持 <a href="expressions/loop-expr.html#break-and-loop-values">计算非平凡值</a> 。</p>
<h2 id="无限循环"><a class="header" href="#无限循环">无限循环</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>无限循环表达式</em> :<br />
   <code>loop</code> <a href="expressions/block-expr.html"><em>块表达式</em></a></p>
</blockquote>
<p><code>loop</code> 表达式不断重复执行其主体:
<code>loop { println!(&quot;I live.&quot;); }</code> 。</p>
<p>没有相关的 <code>break</code> 表达式的 <code>loop</code> 表达式是发散的，并且具有 <a href="expressions/../types/never.html"><code>!</code></a> 类型。
包含相关 <a href="expressions/loop-expr.html#break-expressions"><code>break</code> 表达式(s)</a> 的 <code>loop</code> 表达式可能会终止，并且必须具有与 <code>break</code> 表达式的值兼容的类型。</p>
<h2 id="断言循环"><a class="header" href="#断言循环">断言循环</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>断言循环表达式</em> :<br />
   <code>while</code> <a href="expressions/../expressions.html"><em>表达式</em></a><sub><em>不包括结构体表达式</em></sub> <a href="expressions/block-expr.html"><em>块表达式</em></a></p>
</blockquote>
<p><code>while</code> 循环首先会对布尔类型的循环条件进行求值。
如果循环条件为 <code>true</code> ，则会执行循环主体代码块，之后控制流会返回到循环条件，再次对其求值。
如果循环条件为 <code>false</code> ，则 <code>while</code> 循环终止执行。</p>
<p>一个例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut i = 0;

while i &lt; 10 {
    println!(&quot;hello&quot;);
    i = i + 1;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="断言模式循环"><a class="header" href="#断言模式循环">断言模式循环</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<a href="expressions/loop-expr.html#predicate-pattern-loops"><em>断言模式循环表达式</em></a> :<br />
   <code>while</code> <code>let</code> <a href="expressions/../patterns.html"><em>模式</em></a> <code>=</code> <a href="expressions/match-expr.html"><em>被匹配项</em></a><sub><em>不包括惰性布尔运算符表达式</em></sub>
<a href="expressions/block-expr.html"><em>块表达式</em></a></p>
</blockquote>
<p>一个 <code>while let</code> 循环在语义上类似于一个 <code>while</code> 循环，但是在条件表达式的位置，它需要关键字 <code>let</code> ，后面跟着一个模式、一个等号、一个 <a href="expressions/../glossary.html#scrutinee">被匹配项</a> 和一个代码块表达式。
如果被匹配的表达式的值与模式匹配，那么循环体代码块就会被执行，然后控制流会返回到匹配模式的语句处。
否则， <code>while</code> 表达式会结束。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = vec![1, 2, 3];

while let Some(y) = x.pop() {
    println!(&quot;y = {}&quot;, y);
}

while let _ = 5 {
    println!(&quot;Irrefutable patterns are always true&quot;);
    break;
}
<span class="boring">}</span></code></pre></pre>
<p>一个 <code>while let</code> 循环等同于一个包含 <a href="expressions/match-expr.html"><code>match</code> 表达式</a> 的 <code>loop</code> 表达式，如下所示。</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">'label: while let PATS = EXPR {
    /* loop body */
}</code></pre>
<p>等价于</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">'label: loop {
    match EXPR {
        PATS =&gt; { /* loop body */ },
        _ =&gt; break,
    }
}</code></pre>
<p>可以使用 <code>|</code> 运算符指定多个模式。
这与 <code>match</code> 表达式中的 <code>|</code> 具有相同的语义:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vals = vec![2, 3, 1, 2, 2];
while let Some(v @ 1) | Some(v @ 2) = vals.pop() {
    // Prints 2, 2, then 1
    println!(&quot;{}&quot;, v);
}
<span class="boring">}</span></code></pre></pre>
<p>与 <a href="expressions/if-expr.html#if-let-expressions"><code>if let</code> 表达式</a> 一样，被匹配项不能是 <a href="expressions/operator-expr.html#lazy-boolean-operators">惰性布尔运算符表达式</a> 。</p>
<h2 id="迭代器循环"><a class="header" href="#迭代器循环">迭代器循环</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>迭代器循环表达式</em> :<br />
   <code>for</code> <a href="expressions/../patterns.html"><em>模式</em></a> <code>in</code> <a href="expressions/../expressions.html"><em>表达式</em></a><sub><em>不包括结构体表达式</em></sub>
<a href="expressions/block-expr.html"><em>块表达式</em></a></p>
</blockquote>
<p><code>for</code> 表达式是一种语法结构，用于循环遍历 <code>std::iter::IntoIterator</code> 的实现提供的元素。
如果迭代器产生一个值，那么该值将与不可反驳的模式匹配，执行循环体，然后控制返回到 <code>for</code> 循环的开头。
如果迭代器为空，则 <code>for</code> 表达式完成。</p>
<p>一个对数组内容进行 <code>for</code> 循环的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = &amp;[&quot;apples&quot;, &quot;cake&quot;, &quot;coffee&quot;];

for text in v {
    println!(&quot;I like {}.&quot;, text);
}
<span class="boring">}</span></code></pre></pre>
<p>一个对一系列整数进行 <code>for</code> 循环的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut sum = 0;
for n in 1..11 {
    sum += n;
}
assert_eq!(sum, 55);
<span class="boring">}</span></code></pre></pre>
<p><code>for</code> 循环等价于一个包含 <a href="expressions/match-expr.html"><code>match</code> 表达式</a> 的 <code>loop</code> 表达式，如下所示:</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">'label: for PATTERN in iter_expr {
    /* loop body */
}</code></pre>
<p>等价于</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">{
    let result = match IntoIterator::into_iter(iter_expr) {
        mut iter =&gt; 'label: loop {
            let mut next;
            match Iterator::next(&amp;mut iter) {
                Option::Some(val) =&gt; next = val,
                Option::None =&gt; break,
            };
            let PATTERN = next;
            let () = { /* loop body */ };
        },
    };
    result
}</code></pre>
<p><code>IntoIterator</code> 、 <code>Iterator</code> 和 <code>Option</code> 总是标准库中的条目，而不是当前作用域中解析出来的条目。
变量名 <code>next</code> 、 <code>iter</code> 和 <code>val</code> 仅用于说明，实际上用户无法键入这些名称。</p>
<blockquote>
<p><strong>注意</strong>：外部 <code>match</code> 用于确保在循环完成之前，<code>iter_expr</code> 中的任何 <a href="expressions/../expressions.html#temporaries">临时值</a> 都不会被丢弃。
<code>next</code> 在分配之前被声明，因为这样通常可以更正确地推断类型。</p>
</blockquote>
<h2 id="循环标签"><a class="header" href="#循环标签">循环标签</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>循环标签</em> :<br />
   <a href="expressions/../tokens.html#lifetimes-and-loop-labels">生命周期或标签</a> <code>:</code></p>
</blockquote>
<p>循环表达式可以选择性地使用标签。
标签在循环表达式之前写入一个生命周期，例如 <code>'foo: loop { break 'foo; }</code> 、 <code>'bar: while false {}</code> 、 <code>'humbug: for _ in 0..0 {}</code> 。
如果存在标签，则嵌套在此循环中的带有标签的 <code>break</code> 和 <code>continue</code> 表达式可以退出该循环或将控制返回到其头部。
请参见 <a href="expressions/loop-expr.html#break-expressions">break 表达式</a> 和 <a href="expressions/loop-expr.html#continue-expressions">continue 表达式</a> 。</p>
<p>标签遵循本地变量的卫生和隐藏规则。例如，以下代码将打印 &quot;outer loop&quot; :</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'a: loop {
    'a: loop {
        break 'a;
    }
    print!(&quot;outer loop&quot;);
    break 'a;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="break-表达式"><a class="header" href="#break-表达式"><code>break</code> 表达式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>Break表达式</em> :<br />
   <code>break</code> <a href="expressions/../tokens.html#lifetimes-and-loop-labels">生命周期或标签</a><sup>?</sup> <a href="expressions/../expressions.html"><em>表达式</em></a><sup>?</sup></p>
</blockquote>
<p>当遇到 <code>break</code> 时，与之关联的循环体会立即终止执行，例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut last = 0;
for x in 1..100 {
    if x &gt; 12 {
        break;
    }
    last = x;
}
assert_eq!(last, 12);
<span class="boring">}</span></code></pre></pre>
<p><code>break</code> 表达式通常与包含它的最内层 <code>loop</code> 、 <code>for</code> 或 <code>while</code> 循环相关联，但可以使用 <a href="expressions/loop-expr.html#loop-labels">标签</a> 来指定受影响的封闭循环。
例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'outer: loop {
    while true {
        break 'outer;
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>break</code> 表达式仅允许在循环体中使用，并且有以下形式之一: <code>break</code> 、 <code>break 'label</code> 或者
(<a href="expressions/loop-expr.html#break-and-loop-values">见下文</a>) <code>break EXPR</code> 或 <code>break 'label EXPR</code> 。</p>
<h2 id="标签块表达式"><a class="header" href="#标签块表达式">标签块表达式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>标签块表达式</em> :<br />
   <a href="expressions/block-expr.html"><em>块表达式</em></a></p>
</blockquote>
<p>带标签的块表达式与普通块表达式完全相同，只不过它们允许在块内使用 <code>break</code> 表达式。
与其他循环不同，带标签的块表达式中的 <code>break</code> 表达式 <em>必须</em> 有一个标签 (即标签不是可选的) 。
此外，与其他循环不同，带标签的块表达式 <em>必须</em> 以标签开始。</p>
<h2 id="continue-表达式"><a class="header" href="#continue-表达式"><code>continue</code> 表达式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>Continue 表达式</em> :<br />
   <code>continue</code> <a href="expressions/../tokens.html#lifetimes-and-loop-labels">生命周期或标签</a><sup>?</sup></p>
</blockquote>
<p>当遇到 <code>continue</code> 关键字时，与其相关联的循环体的当前迭代会立即终止，控制权返回到循环 <em>头</em> 。
在 <code>while</code> 循环中，头是控制循环的条件表达式。在 <code>for</code> 循环中，头是控制循环的调用表达式。</p>
<p>与 <code>break</code> 类似，<code>continue</code> 通常与最内层的封闭循环相关联，但可以使用 <code>continue 'label</code> 指定受影响的循环。
<code>continue</code> 表达式只允许出现在循环体中。</p>
<h2 id="break-和循环值"><a class="header" href="#break-和循环值"><code>break</code> 和循环值</a></h2>
<p>在Rust中，当与 <code>loop</code> 关键字相关联时，可以使用 <code>break</code> 表达式通过 <code>break EXPR</code> 或 <code>break 'label EXPR</code> 的形式从循环中返回一个值，其中 <code>EXPR</code> 是返回给 <code>loop</code> 的表达式结果。
例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (mut a, mut b) = (1, 1); // 初始化a和b为1
let result = loop { // 进入循环
    if b &gt; 10 { // 如果b大于10
        break b; // 跳出循环并返回b的值
    }
    let c = a + b; // 计算c
    a = b; // 将a赋值为上一个b的值
    b = c; // 将b赋值为上一个c的值
};
// 斐波那契数列中第一个大于10的数是13:
assert_eq!(result, 13);
<span class="boring">}</span></code></pre></pre>
<p>在 <code>loop</code> 语句中，如果有关联的 <code>break</code> 语句，它就不被视为发散，而且 <code>loop</code> 语句必须与每个 <code>break</code> 表达式兼容的类型。
如果没有表达式的 <code>break</code> 语句被视为与表达式为 <code>()</code> 的 <code>break</code> 语句相同。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="范围表达式"><a class="header" href="#范围表达式">范围表达式</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>区间表达式</em> :<br />
      <em>区间式</em><br />
   | <em>区间From表达式</em><br />
   | <em>区间To表达式</em><br />
   | <em>区间Full表达式</em><br />
   | <em>区间包含表达式</em><br />
   | <em>区间To包含表达式</em></p>
<p><em>区间式</em> :<br />
   <a href="expressions/../expressions.html"><em>表达式</em></a> <code>..</code> <a href="expressions/../expressions.html"><em>表达式</em></a></p>
<p><em>区间From表达式</em> :<br />
   <a href="expressions/../expressions.html"><em>表达式</em></a> <code>..</code></p>
<p><em>区间To表达式</em> :<br />
   <code>..</code> <a href="expressions/../expressions.html"><em>表达式</em></a></p>
<p><em>区间Full表达式</em> :<br />
   <code>..</code></p>
<p><em>区间包含表达式</em> :<br />
   <a href="expressions/../expressions.html"><em>表达式</em></a> <code>..=</code> <a href="expressions/../expressions.html"><em>表达式</em></a></p>
<p><em>区间To包含表达式</em> :<br />
   <code>..=</code> <a href="expressions/../expressions.html"><em>表达式</em></a></p>
</blockquote>
<p><code>..</code> 和 <code>..=</code> 运算符会根据下面的表格构造出一个 <code>std::ops::Range</code> (或 <code>core::ops::Range</code> ) 的变体:</p>
<div class="table-wrapper"><table><thead><tr><th>生产</th><th>语法</th><th>类型</th><th>区间</th></tr></thead><tbody>
<tr><td><em>区间式</em></td><td>头<code>..</code>尾</td><td><a href="https://doc.rust-lang.org/std/ops/struct.Range.html">std::ops::Range</a></td><td>头 ≤ x &lt; 尾</td></tr>
<tr><td><em>区间From表达式</em></td><td>头<code>..</code></td><td><a href="https://doc.rust-lang.org/std/ops/struct.RangeFrom.html">std::ops::RangeFrom</a></td><td>头 ≤ x</td></tr>
<tr><td><em>区间To表达式</em></td><td><code>..</code>尾</td><td><a href="https://doc.rust-lang.org/std/ops/struct.RangeTo.html">std::ops::RangeTo</a></td><td>x &lt; 尾</td></tr>
<tr><td><em>区间Full表达式</em></td><td><code>..</code></td><td><a href="https://doc.rust-lang.org/std/ops/struct.RangeFull.html">std::ops::RangeFull</a></td><td>-</td></tr>
<tr><td><em>区间包含表达式</em></td><td>头<code>..=</code>尾</td><td><a href="https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html">std::ops::RangeInclusive</a></td><td>头 ≤ x ≤ 尾</td></tr>
<tr><td><em>区间To包含表达式</em></td><td><code>..=</code>尾</td><td><a href="https://doc.rust-lang.org/std/ops/struct.RangeToInclusive.html">std::ops::RangeToInclusive</a></td><td>x ≤ 尾</td></tr>
</tbody></table>
</div>
<p>示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>1..2;   // std::ops::Range
3..;    // std::ops::RangeFrom
..4;    // std::ops::RangeTo
..;     // std::ops::RangeFull
5..=6;  // std::ops::RangeInclusive
..=7;   // std::ops::RangeToInclusive
<span class="boring">}</span></code></pre></pre>
<p>以下表达式是等价的。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = std::ops::Range {start: 0, end: 10};
let y = 0..10;

assert_eq!(x, y);
<span class="boring">}</span></code></pre></pre>
<p>Ranges可以在 <code>for</code> 循环中使用:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 1..11 {
    println!(&quot;{}&quot;, i);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-和-if-let-表达式"><a class="header" href="#if-和-if-let-表达式"><code>if</code> 和 <code>if let</code> 表达式</a></h1>
<h2 id="if-表达式"><a class="header" href="#if-表达式"><code>if</code> 表达式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>If表达式</em> :<br />
   <code>if</code> <a href="expressions/../expressions.html"><em>表达式</em></a><sub><em>不包括结构体表达式</em></sub> <a href="expressions/block-expr.html"><em>块表达式</em></a><br />
   (<code>else</code> (
<a href="expressions/block-expr.html"><em>块表达式</em></a>
| <em>If表达式</em>
| <em>IfLet表达式</em> ) )<sup>?</sup></p>
</blockquote>
<p><code>if</code> 表达式是程序控制流中的条件分支。
<code>if</code> 表达式的语法是一个条件操作数，后面跟着一个结果块，任意数量的 <code>else if</code> 条件和块，以及一个可选的末尾 <code>else</code> 块。条件操作数必须具有 <a href="expressions/../types/boolean.html">布尔类型</a> 。
如果条件操作数计算结果为 <code>true</code> ，则执行结果块，跳过任何后续的 <code>else if</code> 或 <code>else</code> 块。
如果条件操作数计算结果为 <code>false</code> ，则跳过结果块，评估任何后续的 <code>else if</code> 条件。
如果所有 <code>if</code> 和 <code>else if</code> 条件都计算结果为 <code>false</code> ，则执行任何 <code>else</code> 块。
<code>if</code> 表达式的计算结果与执行的块相同，如果没有执行块，则为 <code>()</code> 。
<code>if</code> 表达式在所有情况下必须具有相同的类型。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let x = 3;
</span>if x == 4 {
    println!(&quot;x is four&quot;);
} else if x == 3 {
    println!(&quot;x is three&quot;);
} else {
    println!(&quot;x is something else&quot;);
}

let y = if 12 * 15 &gt; 150 {
    &quot;Bigger&quot;
} else {
    &quot;Smaller&quot;
};
assert_eq!(y, &quot;Bigger&quot;);
<span class="boring">}</span></code></pre></pre>
<h2 id="if-let-表达式"><a class="header" href="#if-let-表达式"><code>if let</code> 表达式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>IfLet表达式</em> :<br />
   <code>if</code> <code>let</code> <a href="expressions/../patterns.html"><em>模式</em></a> <code>=</code> <a href="expressions/match-expr.html"><em>被匹配项</em></a><sub><em>包括惰性布尔运算符表达式</em></sub>
<a href="expressions/block-expr.html"><em>块表达式</em></a><br />
   (<code>else</code> (
<a href="expressions/block-expr.html"><em>块表达式</em></a>
| <em>If表达式</em>
| <em>IfLet表达式</em> ) )<sup>?</sup></p>
</blockquote>
<p><code>if let</code> 表达式在语义上类似于 <code>if</code> 表达式，但是在条件操作数的位置上，它期望关键字 <code>let</code> 后跟一个模式、一个等号和一个<a href="expressions/../glossary.html#scrutinee">被匹配项</a> 。如果被检查的操作数的值匹配模式，则执行相应的代码块。
否则，如果存在 <code>else</code> 块，则流程将继续执行该块。
与 <code>if</code> 表达式类似， <code>if let</code> 表达式具有由执行的代码块确定的值。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dish = (&quot;Ham&quot;, &quot;Eggs&quot;); // 定义一个元组dish，包含两个字符串&quot;Ham&quot;和&quot;Eggs&quot;

// 由于模式不匹配，这个代码块将被跳过
if let (&quot;Bacon&quot;, b) = dish { // 在dish上应用模式匹配，如果dish与(&quot;Bacon&quot;, b)相同，则执行代码块
    println!(&quot;Bacon is served with {}&quot;, b);
} else { 
    // 否则执行这个代码块
    println!(&quot;No bacon will be served&quot;); // 打印&quot;No bacon will be served&quot;
}

// 由于模式匹配，这个代码块将被执行
if let (&quot;Ham&quot;, b) = dish { // 在dish上应用模式匹配，如果dish与(&quot;Ham&quot;, b)相同，则执行代码块
    println!(&quot;Ham is served with {}&quot;, b); // 打印&quot;Ham is served with Eggs&quot;
}

if let _ = 5 { // 对5应用不可反驳的模式，始终为真，执行代码块
    println!(&quot;Irrefutable patterns are always true&quot;); // 打印&quot;Irrefutable patterns are always true&quot;
}
<span class="boring">}</span></code></pre></pre>
<p><code>if</code> 和 <code>if let</code> 表达式可以混合使用:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(3);
let a = if let Some(1) = x {
    1
} else if x == Some(2) {
    2
} else if let Some(y) = x {
    y
} else {
    -1
};
assert_eq!(a, 3);
<span class="boring">}</span></code></pre></pre>
<p>一个 <code>if let</code> 表达式等价于一个如下所示的 <a href="expressions/match-expr.html"><code>match</code> 表达式</a> :</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">if let PATS = EXPR {
    /* body */
} else {
    /*else */
}</code></pre>
<p>等价于</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">match EXPR {
    PATS =&gt; { /* body */ },
    _ =&gt; { /* else */ },    // () if there is no else
}</code></pre>
<p>可以使用 <code>|</code> 运算符指定多个模式。这与 <code>match</code> 表达式中的 <code>|</code> 运算符具有相同的语义:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum E {
    X(u8),
    Y(u8),
    Z(u8),
}
let v = E::Y(12);
if let E::X(n) | E::Y(n) = v {
    assert_eq!(n, 12);
}
<span class="boring">}</span></code></pre></pre>
<p>该表达式不能是一个 <a href="expressions/operator-expr.html#lazy-boolean-operators">惰性布尔运算符表达式</a>。
使用惰性布尔运算符会与语言计划更改的特性产生歧义 (即 if-let 链的实现 - 请参见 <a href="https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018">eRFC 2947</a> )。
当需要惰性布尔运算符表达式时，可以通过如下方式使用括号来实现：</p>
<!-- ignore: pseudo code -->
<pre><code class="language-rust ignore">// 之前...
if let PAT = EXPR &amp;&amp; EXPR { .. } 

// 之后...
if let PAT = ( EXPR &amp;&amp; EXPR ) { .. } 

// 之前...
if let PAT = EXPR || EXPR { .. } 

// 之后...
if let PAT = ( EXPR || EXPR ) { .. } </code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-表达式"><a class="header" href="#match-表达式"><code>match</code> 表达式</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>Match表达式</em> :<br />
   <code>match</code> <em>被匹配项</em> <code>{</code><br />
      <a href="expressions/../attributes.html"><em>内部属性</em></a><sup>*</sup><br />
      <em>Match分支组</em><sup>?</sup><br />
   <code>}</code></p>
<p><em>被匹配项</em> :<br />
   <a href="expressions/../expressions.html"><em>表达式</em></a><sub><em>不包括结构体表达式</em></sub></p>
<p><em>Match分支组</em> :<br />
   ( <em>Match分支</em> <code>=&gt;</code>
( <a href="expressions/../expressions.html"><em>无块表达式</em></a> <code>,</code>
| <a href="expressions/../expressions.html"><em>块表达式</em></a> <code>,</code><sup>?</sup> )
)<sup>*</sup><br />
   <em>Match分支</em> <code>=&gt;</code> <a href="expressions/../expressions.html"><em>表达式</em></a> <code>,</code><sup>?</sup></p>
<p><em>Match分支</em> :<br />
   <a href="expressions/../attributes.html"><em>外部属性</em></a><sup>*</sup> <a href="expressions/../patterns.html"><em>模式</em></a> <em>Match分支守卫</em><sup>?</sup></p>
<p><em>Match分支守卫</em> :<br />
   <code>if</code> <a href="expressions/../expressions.html"><em>表达式</em></a></p>
</blockquote>
<p>一个 <em><code>match</code> 表达式</em> 会根据一个模式进行分支。匹配所发生的确切形式取决于 <a href="expressions/../patterns.html">模式</a> 。
一个 <code>match</code> 表达式有一个 <em><a href="expressions/../glossary.html#scrutinee">被匹配项</a> 表达式</em>，它是要与模式进行比较的值。被匹配表达式和模式必须具有相同的类型。</p>
<p><code>match</code> 的行为取决于被匹配表达式是一个 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">占位表达式还是值表达式</a>。
如果被匹配表达式是一个 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">值表达式</a> ，它首先被求值到一个临时位置，然后将结果值按顺序与每个分支中的模式进行比较，直到找到匹配的模式。
第一个具有匹配模式的分支被选择作为 <code>match</code> 的分支目标，任何由模式绑定的变量都分配到分支的块中的本地变量中，并且控制进入块中。</p>
<p>当被匹配表达式是一个 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">占位表达式</a> 时，<code>match</code> 不会分配临时位置；但是，按值绑定可能会从内存位置复制或移动。
如果可能的话，最好匹配占位表达式，因为这些匹配的生命周期继承了占位表达式的生命周期，而不是被限制在 <code>match</code> 内部。</p>
<p>下面是一个 <code>match</code> 表达式的示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    4 =&gt; println!(&quot;four&quot;),
    5 =&gt; println!(&quot;five&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
<span class="boring">}</span></code></pre></pre>
<p>在模式中绑定的变量的作用域限定在 <code>match</code> 守卫及分支表达式中。<a href="expressions/../patterns.html#binding-modes">绑定模式</a> (移动、复制或引用) 取决于模式。</p>
<p>多个匹配模式可以用 <code>|</code> 运算符连接起来。每个模式将按照从左到右的顺序进行测试，直到找到成功匹配的模式为止。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 9;
let message = match x {
    0 | 1  =&gt; &quot;not many&quot;,     // 如果 x 是 0 或 1，将 &quot;not many&quot; 赋值给 message
    2 ..= 9 =&gt; &quot;a few&quot;,       // 如果 x 在 2 到 9 之间（包括 2 和 9），将 &quot;a few&quot; 赋值给 message
    _      =&gt; &quot;lots&quot;         // 否则将 &quot;lots&quot; 赋值给 message
};

assert_eq!(message, &quot;a few&quot;);

// 演示模式匹配的顺序。
struct S(i32, i32);

match S(1, 2) {
    S(z @ 1, _) | S(_, z @ 2) =&gt; assert_eq!(z, 1),  // 如果 S 的第一个元素是 1 或者第二个元素是 2，则将 z 绑定为 1，并且通过断言来检查 z 的值。
    _ =&gt; panic!(),                                 // 否则发生错误
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>注意: <code>2..=9</code> 是 <a href="expressions/../patterns.html#range-patterns">区间模式</a> ，不是 <a href="expressions/range-expr.html">区间表达式</a> 。因此，在匹配分支中只能使用由区间模式支持的这些类型的范围。</p>
</blockquote>
<p>每个 <code>|</code> 分隔的模式中的所有绑定都必须出现在分支的所有模式中。每个同名绑定必须具有相同的类型，并且具有相同的绑定模式。</p>
<h2 id="匹配守卫"><a class="header" href="#匹配守卫">匹配守卫</a></h2>
<p><code>match</code> 分支可以接受 <em>匹配守卫</em> 来进一步细化匹配条件。
模式守卫出现在模式之后，由 <code>if</code> 关键字后面的 <code>bool</code> 类型表达式组成。</p>
<p>当模式成功匹配时，模式守卫表达式会被执行。如果表达式的结果为 true，则模式成功匹配。
否则，将测试下一个模式，包括同一分支中使用 <code>|</code> 运算符的其他匹配。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let maybe_digit = Some(0);
</span><span class="boring">fn process_digit(i: i32) { }
</span><span class="boring">fn process_other(i: i32) { }
</span>let message = match maybe_digit {
    Some(x) if x &lt; 10 =&gt; process_digit(x),
    Some(x) =&gt; process_other(x),
    None =&gt; panic!(),
};
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>注意：使用 <code>|</code> 操作符的多个匹配项可能导致模式守卫及其所产生的副作用执行多次。
例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::cell::Cell;
</span>let i : Cell&lt;i32&gt; = Cell::new(0);
match 1 {
    1 | _ if { i.set(i.get() + 1); false } =&gt; {}
    _ =&gt; {}
}
assert_eq!(i.get(), 2);
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>模式守卫可以引用其所跟随的模式中绑定的变量。
在评估模式守卫之前，会对匹配变量的部分获取共享引用。
在评估模式守卫时，这个共享引用被用于访问该变量。
只有当模式守卫计算结果为 true 时，才会将值从待匹配项移动或复制到该变量中。
这允许在守卫中使用共享借用，如果守卫不匹配，则不会移出待匹配项。
此外，通过在评估守卫时保持共享引用，还可以防止在守卫内进行修改。</p>
<h2 id="匹配分支上的属性"><a class="header" href="#匹配分支上的属性">匹配分支上的属性</a></h2>
<p>可以在匹配分支上使用外部属性。
在匹配分支上具有意义的属性只有 <a href="expressions/../conditional-compilation.html"><code>cfg</code></a> 和 <a href="expressions/../attributes/diagnostics.html#lint-check-attributes">代码分析检查属性</a> 。
<a href="expressions/../attributes.html">内部属性</a> 可以直接放置在匹配表达式的左括号后面，在与 <a href="expressions/block-expr.html#attributes-on-block-expressions">块表达式上的属性</a> 相同的表达式上下文中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="return-表达式"><a class="header" href="#return-表达式"><code>return</code> 表达式</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>Return表达式</em> :<br />
   <code>return</code> <a href="expressions/../expressions.html"><em>表达式</em></a><sup>?</sup></p>
</blockquote>
<p><code>return</code> 表达式使用关键字 <code>return</code> 标识。
执行 <code>return</code> 表达式会将其参数移动到当前函数调用的指定输出位置，销毁当前函数激活帧，并将控制权转移到调用帧。</p>
<p><code>return</code> 表达式的一个例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn max(a: i32, b: i32) -&gt; i32 {
    if a &gt; b {
        return a;
    }
    return b;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="await-表达式"><a class="header" href="#await-表达式">Await 表达式</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>Await表达式</em> :<br />
   <a href="expressions/../expressions.html"><em>表达式</em></a> <code>.</code> <code>await</code></p>
</blockquote>
<p><code>await</code> 表达式是一个语法结构，用于暂停一个由实现了 <code>std::future::IntoFuture</code> 的计算，直到给定的 future 准备好产生一个值。
<code>await</code> 表达式的语法是一个实现了 <a href="expressions/../../std/future/trait.IntoFuture.html"><code>IntoFuture</code></a> trait 的表达式，称为 <em>future 操作数</em> ，后跟一个 <code>.</code> 和 <code>await</code> 关键字。
<code>await</code> 表达式只能在 <a href="expressions/../expressions/block-expr.html#async-context">async 上下文</a> 中使用，比如 <a href="expressions/../items/functions.html#async-functions"><code>async fn</code></a> 或 <a href="expressions/block-expr.html#async-blocks"><code>async</code> 块</a> 。更具体来说，<code>await</code> 表达式具有以下效果。</p>
<ol>
<li>通过在 future 操作数上调用 <a href="expressions/../../std/future/trait.IntoFuture.html#tymethod.into_future"><code>IntoFuture::into_future</code></a> 创建一个 future。</li>
<li>将 future 评估为一个 <a href="expressions/../../std/future/trait.Future.html">future</a> <code>tmp</code> ；</li>
<li>使用 <a href="expressions/../../std/pin/struct.Pin.html#method.new_unchecked"><code>Pin::new_unchecked</code></a> 固定 <code>tmp</code> ；</li>
<li>然后通过调用 <a href="expressions/../../std/future/trait.Future.html#tymethod.poll"><code>Future::poll</code></a> 方法并传递当前的 <a href="expressions/await-expr.html#task-context">任务上下文</a> 来对这个固定的 future 进行轮询；</li>
<li>如果对 <code>poll</code> 的调用返回 <a href="expressions/../../std/task/enum.Poll.html#variant.Pending"><code>Poll::Pending</code></a> ，那么 future 返回 <code>Poll::Pending</code> ，暂停它的状态，以便当包围的 async 上下文重新被轮询时，执行返回到步骤 3 ；</li>
<li>否则对 <code>poll</code> 的调用必须返回 <a href="expressions/../../std/task/enum.Poll.html#variant.Ready"><code>Poll::Ready</code></a> ，在这种情况下， <a href="expressions/../../std/task/enum.Poll.html#variant.Ready"><code>Poll::Ready</code></a> 变体中包含的值将被用作 <code>await</code> 表达式本身的结果。</li>
</ol>
<blockquote>
<p><strong>版本差异</strong>: <code>await</code> 表达式只从 Rust 2018 开始可用。</p>
</blockquote>
<h2 id="任务上下文"><a class="header" href="#任务上下文">任务上下文</a></h2>
<p>任务上下文指的是在当前 <a href="expressions/../expressions/block-expr.html#async-context">async 上下文</a> 被轮询时提供给它的 <a href="expressions/../../std/task/struct.Context.html"><code>Context</code></a>。
因为 <code>await</code> 表达式只能在 async 上下文中合法使用，所以必须有一些任务上下文可用。</p>
<h2 id="近似解糖"><a class="header" href="#近似解糖">近似解糖</a></h2>
<p>实际上，一个 await 表达式大致相当于以下非规范的解糖:</p>
<!-- ignore: example expansion -->
<pre><code class="language-rust ignore">match operand.into_future() {
    mut pinned =&gt; loop {
        let mut pin = unsafe { Pin::new_unchecked(&amp;mut pinned) };
        match Pin::future::poll(Pin::borrow(&amp;mut pin), &amp;mut current_context) {
            Poll::Ready(r) =&gt; break r,
            Poll::Pending =&gt; yield Poll::Pending,
        }
    }
}</code></pre>
<p>其中 <code>yield</code> 伪代码返回 <code>Poll::Pending</code>，并在重新调用时从该点恢复执行。
变量 <code>current_context</code> 指的是从异步环境中获取的上下文。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="_-表达式"><a class="header" href="#_-表达式"><code>_</code> 表达式</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>下划线表达式</em> :<br />
   <code>_</code></p>
</blockquote>
<p>下划线表达式，用符号 <code>_</code> 表示，在解构赋值中用作占位符。它们只能出现在赋值的左侧。</p>
<p>一个 <code>_</code> 表达式的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p = (1, 2);
let mut a = 0;
(_, a) = p;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式"><a class="header" href="#模式">模式</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>模式</em> :<br />
      <code>|</code><sup>?</sup> <em>模式非顶层选项</em>  ( <code>|</code> <em>模式非顶层选项</em> )<sup>*</sup></p>
<p><em>模式非顶层选项</em> :<br />
      <em>无区间模式</em><br />
   | <a href="patterns.html#range-patterns"><em>区间模式</em></a></p>
<p><em>无区间模式</em> :<br />
      <a href="patterns.html#literal-patterns"><em>字面值模式</em></a><br />
   | <a href="patterns.html#identifier-patterns"><em>标识符模式</em></a><br />
   | <a href="patterns.html#wildcard-pattern"><em>通配符模式</em></a><br />
   | <a href="patterns.html#rest-patterns"><em>剩余模式</em></a><br />
   | <a href="patterns.html#reference-patterns"><em>引用模式</em></a><br />
   | <a href="patterns.html#struct-patterns"><em>结构体模式</em></a><br />
   | <a href="patterns.html#tuple-struct-patterns"><em>元组结构体模式</em></a><br />
   | <a href="patterns.html#tuple-patterns"><em>元组模式</em></a><br />
   | <a href="patterns.html#grouped-patterns"><em>分组模式</em></a><br />
   | <a href="patterns.html#slice-patterns"><em>切片模式</em></a><br />
   | <a href="patterns.html#path-patterns"><em>路径模式</em></a><br />
   | <a href="macros.html#macro-invocation"><em>宏调用</em></a></p>
</blockquote>
<p>模式用于将值与结构进行匹配，并在这些结构内将变量绑定到值(可选)。
它们还用于函数和闭包的变量声明和参数。以下示例中的模式执行四个操作：</p>
<ul>
<li>检查 <code>person</code> 是否有填充了某些内容的 <code>car</code> 字段。</li>
<li>检查 <code>person</code> 的 <code>age</code> 字段是否在 13 到 19 之间，并将其值绑定到 <code>person_age</code> 变量。</li>
<li>将 <code>name</code> 字段的引用绑定到变量 <code>person_name</code> 。</li>
<li>忽略 <code>person</code> 的其余字段。剩余字段可以具有任何值，并且不会绑定到任何变量。</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Car;
</span><span class="boring">struct Computer;
</span><span class="boring">struct Person {
</span><span class="boring">    name: String,
</span><span class="boring">    car: Option&lt;Car&gt;,
</span><span class="boring">    computer: Option&lt;Computer&gt;,
</span><span class="boring">    age: u8,
</span><span class="boring">}
</span><span class="boring">let person = Person {
</span><span class="boring">    name: String::from(&quot;John&quot;),
</span><span class="boring">    car: Some(Car),
</span><span class="boring">    computer: None,
</span><span class="boring">    age: 15,
</span><span class="boring">};
</span>if let
    Person {
        car: Some(_),
        age: person_age @ 13..=19,
        name: ref person_name,
        ..
    } = person
{
    println!(&quot;{} has a car and is {} years old.&quot;, person_name, person_age);
}
<span class="boring">}</span></code></pre></pre>
<p>模式用于:</p>
<ul>
<li><a href="statements.html#let-statements"><code>let</code> 声明</a></li>
<li><a href="items/functions.html">函数</a> 和 <a href="expressions/closure-expr.html">闭包</a> 参数</li>
<li><a href="expressions/match-expr.html"><code>match</code> 表达式</a></li>
<li><a href="expressions/if-expr.html"><code>if let</code> 表达式</a></li>
<li><a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code> 表达式</a></li>
<li><a href="expressions/loop-expr.html#iterator-loops"><code>for</code> 表达式</a></li>
</ul>
<h2 id="解构"><a class="header" href="#解构">解构</a></h2>
<p>解构模式可以用于解构 <a href="items/structs.html">structs</a> 、 <a href="items/enumerations.html">enums</a> 和 <a href="types/tuple.html">tuples</a> 。解构将一个值分解成其组成部分。
使用的语法与创建这些值时几乎相同。在一个模式中，其 <a href="glossary.html#scrutinee">被匹配项</a> 表达式具有 <code>struct</code>、<code>enum</code> 或 <code>tuple</code> 类型，占位符 (<code>_</code>) 代表 <em>单个</em> 数据字段，而通配符 <code>..</code> 代表 <em>特定变体的所有</em> 其余字段。
当解构具有命名字段 (但未编号) 的数据结构时，允许将 <code>fieldname</code> 写成 <code>fieldname: fieldname</code> 的简写形式。
在 Rust 中，解构是一种方便的工具，可用于从结构化数据类型中提取所需数据。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Message {
</span><span class="boring">    Quit,
</span><span class="boring">    WriteString(String),
</span><span class="boring">    Move { x: i32, y: i32 },
</span><span class="boring">    ChangeColor(u8, u8, u8),
</span><span class="boring">}
</span><span class="boring">let message = Message::Quit;
</span>match message {
    Message::Quit =&gt; println!(&quot;Quit&quot;),
    Message::WriteString(write) =&gt; println!(&quot;{}&quot;, &amp;write),
    Message::Move{ x, y: 0 } =&gt; println!(&quot;move {} horizontally&quot;, x),
    Message::Move{ .. } =&gt; println!(&quot;other move&quot;),
    Message::ChangeColor { 0: red, 1: green, 2: _ } =&gt; {
        println!(&quot;color change, red: {}, green: {}&quot;, red, green);
    }
};
<span class="boring">}</span></code></pre></pre>
<h2 id="可反驳性"><a class="header" href="#可反驳性">可反驳性</a></h2>
<p>当模式可能无法匹配其所匹配的值时，该模式被称为 <em>可反驳的</em> 。相反， <em>不可反驳</em> 模式总是与其所匹配的值匹配。例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x, y) = (1, 2);               // &quot;(x, y)&quot; 是一个不可反驳的模式

if let (a, 3) = (1, 2) {           // &quot;(a, 3)&quot; 是可反驳的，将不匹配
    panic!(&quot;不应该到达这里&quot;);
} else if let (a, 4) = (3, 4) {    // &quot;(a, 4)&quot; 是可反驳的，并将匹配
    println!(&quot;匹配到 ({}, 4)&quot;, a);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="字面值模式"><a class="header" href="#字面值模式">字面值模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>字面值模式</em> :<br />
      <code>true</code> | <code>false</code><br />
   | <a href="tokens.html#character-literals">字符字面值</a><br />
   | <a href="tokens.html#byte-literals">字节字面值</a><br />
   | <a href="tokens.html#string-literals">字符串字面值</a><br />
   | <a href="tokens.html#raw-string-literals">原始字符串字面值</a><br />
   | <a href="tokens.html#byte-string-literals">字节字符串字面值</a><br />
   | <a href="tokens.html#raw-byte-string-literals">原始字节字符串字面值</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#integer-literals">整数字面值</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#floating-point-literals">浮点数字面值</a></p>
</blockquote>
<p><em>字面值模式</em> 正好匹配与字面值创建的值相同的值。
由于负数不是字面值，字面值模式也接受字面值前面的可选负号，其作用类似于否定运算符。</p>
<div class="warning">
<p>目前接受浮点型字面值，但由于比较复杂，未来的 Rust 版本中将禁止在字面值模式中使用它们 (参见<a href="https://github.com/rust-lang/rust/issues/41620">问题 #41620</a>)。</p>
</div>
<p>字面值模式总是可反驳的。</p>
<p>例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in -2..5 {
    match i {
        -1 =&gt; println!(&quot;It's minus one&quot;),
        1 =&gt; println!(&quot;It's a one&quot;),
        2|4 =&gt; println!(&quot;It's either a two or a four&quot;),
        _ =&gt; println!(&quot;Matched none of the arms&quot;),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="标识符模式"><a class="header" href="#标识符模式">标识符模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>标识符模式</em> :<br />
      <code>ref</code><sup>?</sup> <code>mut</code><sup>?</sup> <a href="identifiers.html">标识符</a> (<code>@</code> <a href="patterns.html#patterns"><em>模式非顶层选项</em></a> ) <sup>?</sup></p>
</blockquote>
<p>标识符模式将其匹配的值绑定到变量上。
标识符在模式中必须是唯一的。
该变量将隐藏作用域中具有相同名称的任何变量。
新绑定的作用域取决于模式用于何处的上下文 (例如 <code>let</code> 绑定或 <code>match</code> 分支) 。</p>
<p>仅由标识符组成的模式 (可能带有 <code>mut</code> ) 会匹配任何值并将其绑定到该标识符上。这是变量声明和函数及闭包参数中最常用的模式。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut variable = 10;
fn sum(x: i32, y: i32) -&gt; i32 {
<span class="boring">   x + y
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>要将模式的匹配值绑定到变量上，请使用语法 <code>variable @ subpattern</code> 。
例如，以下代码将值 2 绑定到 <code>e</code> (而不是整个区间：这里的区间是一个区间子模式) 。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;

match x {
    e @ 1 ..= 5 =&gt; println!(&quot;got a range element {}&quot;, e),
    _ =&gt; println!(&quot;anything&quot;),
}
<span class="boring">}</span></code></pre></pre>
<p>默认情况下，标识符模式将根据匹配的值是否实现了 <a href="special-types-and-traits.html#copy"><code>Copy</code></a> ，绑定一个变量到匹配值的复制或移动。
可以使用 <code>ref</code> 关键字将其更改为绑定到一个引用，或使用 <code>ref mut</code> 更改为可变引用。例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let a = Some(10);
</span>match a {
    None =&gt; (),
    Some(value) =&gt; (),
}

match a {
    None =&gt; (),
    Some(ref value) =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p>在第一个 match 表达式中，该值被复制 (或移动) 。在第二个 match 中，对同一内存位置的引用被绑定到变量值。
这种语法是必要的，因为在解构子模式中， <code>&amp;</code> 操作符不能应用于值的字段。
例如，以下是无效的:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let value = Person { name: String::from(&quot;John&quot;), age: 23 };
</span>if let Person { name: &amp;person_name, age: 18..=150 } = value { }
<span class="boring">}</span></code></pre></pre>
<p>要使其有效，请写如下代码:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let value = Person { name: String::from(&quot;John&quot;), age: 23 };
</span>if let Person {name: ref person_name, age: 18..=150 } = value { }
<span class="boring">}</span></code></pre></pre>
<p>因此， <code>ref</code> 不是被匹配的内容。
它的目的仅仅是将匹配的绑定作为引用而不是复制或移动匹配的内容。</p>
<p><a href="patterns.html#path-patterns">路径模式</a> 优先于标识符模式。如果指定了 <code>ref</code> 或 <code>ref mut</code> ，并且标识符遮蔽了一个常量，则会出现错误。</p>
<p>如果子模式是不可反驳的或未指定子模式，则标识符模式是不可反驳的。</p>
<h3 id="绑定模式"><a class="header" href="#绑定模式">绑定模式</a></h3>
<p>为了提供更好的人机交互，模式运行在不同的 <em>绑定模式</em> 中，以便更容易地将引用绑定到值。
当引用值被非引用模式匹配时，它会自动被视为 <code>ref</code> 或 <code>ref mut</code> 绑定。
例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: &amp;Option&lt;i32&gt; = &amp;Some(3);    // 创建一个类型为 &amp;Option&lt;i32&gt; 的引用 x，指向 Some(3)
if let Some(y) = x {               // 对 x 进行模式匹配
    // y 被转换成了 `ref y`，其类型为 &amp;i32
}
<span class="boring">}</span></code></pre></pre>
<p><em>非引用模式</em> 包括除绑定、 <a href="patterns.html#wildcard-pattern">通配符模式</a> (<code>_</code>)、引用类型的 <a href="patterns.html#path-patterns"><code>const</code> 模式</a> 和 <a href="patterns.html#reference-patterns">引用模式</a> 之外的所有模式。</p>
<p>如果一个绑定模式没有明确指定 <code>ref</code> 、 <code>ref mut</code> 或 <code>mut</code> ，则会使用 <em>默认绑定模式</em> 来确定变量如何被绑定。
默认绑定模式开始于 &quot;移动&quot; 模式，使用移动语义。
匹配模式时，编译器从外向内开始。
每次使用非引用模式匹配引用时，它将自动解引用该值并更新默认绑定模式。
引用将默认绑定模式设置为 <code>ref</code> 。
可变引用将模式设置为 <code>ref mut</code> ，除非模式已经是 <code>ref</code> ，否则它将保持为 <code>ref</code> 。
如果自动解引用的值仍然是引用，则解引用该值并重复此过程。</p>
<p>移动绑定和引用绑定可以混合在同一个模式中。
这样做将导致对象的部分移动绑定，并且之后无法再使用该对象。
如果类型不能复制，则适用此规则。</p>
<p>在下面的示例中， <code>name</code> 从 <code>person</code> 中移动出来。试图将 <code>person</code> 作为整体或 <code>person.name</code> 使用会导致错误，因为存在 <em>部分移动</em> 。</p>
<p>例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let person = Person{ name: String::from(&quot;John&quot;), age: 23 };
</span>// `name` 从 `person` 中被移动了，而 `age` 则被引用。
let Person { name, ref age } = person;
<span class="boring">}</span></code></pre></pre>
<h2 id="通配符模式"><a class="header" href="#通配符模式">通配符模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>通配符模式</em> :<br />
   <code>_</code></p>
</blockquote>
<p><em>通配符模式</em> (下划线符号) 匹配任何值。它用于在不重要时忽略值。
在其他模式内部，它匹配单个数据字段 (与 <code>..</code> 匹配剩余字段不同)。
与标识符模式不同，它不会复制、移动或借用它所匹配的值。</p>
<p>例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let x = 20;
</span>let (a, _) = (10, x);   // x总是被 _ 匹配
<span class="boring">assert_eq!(a, 10);
</span>
// 忽略函数/闭包的参数
let real_part = |a: f64, _: f64| { a };

// 忽略函数/闭包的参数
<span class="boring">struct RGBA {
</span><span class="boring">   r: f32,
</span><span class="boring">   g: f32,
</span><span class="boring">   b: f32,
</span><span class="boring">   a: f32,
</span><span class="boring">}
</span><span class="boring">let color = RGBA{r: 0.4, g: 0.1, b: 0.9, a: 0.5};
</span>let RGBA{r: red, g: green, b: blue, a: _} = color;
<span class="boring">assert_eq!(color.r, red);
</span><span class="boring">assert_eq!(color.g, green);
</span><span class="boring">assert_eq!(color.b, blue);
</span>
// 接受任何 Some，与任何值
<span class="boring">let x = Some(10);
</span>if let Some(_) = x {}
<span class="boring">}</span></code></pre></pre>
<p>通配符模式始终是不可反驳的。</p>
<h2 id="剩余模式"><a class="header" href="#剩余模式">剩余模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>剩余模式</em> :<br />
   <code>..</code></p>
</blockquote>
<p><em>剩余模式</em> (<code>..</code> 符号) 作为一个可变长度的模式，用于匹配在之前和之后尚未被匹配到的零个或多个元素。
它只能在 <a href="patterns.html#tuple-patterns">元组模式</a> 、 <a href="patterns.html#tuple-struct-patterns">元组结构体模式</a> 和 <a href="patterns.html#slice-patterns">切片模式</a> 中使用，并且只能出现一次作为这些模式中的一个元素。
在 <a href="patterns.html#slice-patterns">切片模式</a> 中，它也允许出现在 <a href="patterns.html#identifier-patterns">标识符模式</a> 中。</p>
<p>剩余模式始终是不可反驳的。</p>
<p>例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let words = vec![&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
</span><span class="boring">let slice = &amp;words[..];
</span>match slice {
    [] =&gt; println!(&quot;slice is empty&quot;),
    [one] =&gt; println!(&quot;single element {}&quot;, one),
    [head, tail @ ..] =&gt; println!(&quot;head={} tail={:?}&quot;, head, tail), // 匹配第一个元素和其余元素

}

match slice {
    [.., &quot;!&quot;] =&gt; println!(&quot;!!!&quot;), // 忽略除了最后一个元素之外的所有元素，最后一个元素必须是 &quot;!&quot; 
    [start @ .., &quot;z&quot;] =&gt; println!(&quot;starts with: {:?}&quot;, start), // `start` 是除了最后一个元素之外的所有元素，最后一个元素必须是 &quot;z&quot; 
    [&quot;a&quot;, end @ ..] =&gt; println!(&quot;ends with: {:?}&quot;, end), // `end` 是除了第一个元素之外的所有元素，第一个元素必须是&quot;a&quot;
    whole @ [.., last] =&gt; println!(&quot;the last element of {:?} is {}&quot;, whole, last), // 'whole' 是整个切片， `last` 是最后一个元素
    rest =&gt; println!(&quot;{:?}&quot;, rest),
}

if let [.., penultimate, _] = slice {
    println!(&quot;next to last is {}&quot;, penultimate); // 获取倒数第二个元素
}

<span class="boring">let tuple = (1, 2, 3, 4, 5);
</span>// 剩余模式也可以用于元组和元组结构体模式。
match tuple {
    (1, .., y, z) =&gt; println!(&quot;y={} z={}&quot;, y, z), // 匹配第一个元素和其余元素，但是只保留最后两个元素
    (.., 5) =&gt; println!(&quot;tail must be 5&quot;), // 必须以 5 结尾
    (..) =&gt; println!(&quot;matches everything else&quot;), // 匹配所有其他情况
}
<span class="boring">}</span></code></pre></pre>
<h2 id="区间模式"><a class="header" href="#区间模式">区间模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>区间模式</em> :<br />
      <em>包含区间模式</em><br />
   | <em>HalfOpenRangePattern</em><br />
   | <em>ObsoleteRangePattern</em></p>
<p><em>包含区间模式</em> :<br />
      <em>区间模式边界</em> <code>..=</code> <em>区间模式边界</em></p>
<p><em>半开区间模式</em> :<br />
      <em>区间模式边界</em> <code>..</code>
   | <code>..=</code> <em>区间模式边界</em></p>
<p><em>废弃区间模式</em> :<br />
   <em>区间模式边界</em> <code>...</code> <em>区间模式边界</em></p>
<p><em>区间模式边界</em> :<br />
      <a href="tokens.html#character-literals">CHAR_LITERAL</a><br />
   | <a href="tokens.html#byte-literals">BYTE_LITERAL</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#integer-literals">INTEGER_LITERAL</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#floating-point-literals">FLOAT_LITERAL</a><br />
   | <a href="expressions/path-expr.html"><em>PathExpression</em></a></p>
</blockquote>
<p><em>区间模式</em> 匹配在它的边界定义的标量值的区间。
在符号左侧的边界是一个 <em>下界</em> 。
右侧的边界是一个 <em>上界</em> 。
区间模式可以是闭合或半开的。</p>
<p>如果区间模式有下界和上界，那么它是 <em>闭合的</em> 区间模式。
唯一的闭合区间模式是包含区间模式。</p>
<p><em>包含区间模式</em> 匹配在它的边界之间和包括边界两侧的所有值。
它由其下界、跟着 <code>..=</code> 符号、以及它的上界组成。
它的类型是它的上界和下界的类型统一。</p>
<p>例如，模式 <code>'m'..='p'</code> 将只匹配值 <code>'m'</code>、<code>'n'</code>、<code>'o'</code> 和 <code>'p'</code>。</p>
<p>下边界不能大于上边界，即在 <code>a..=b</code> 中，必须满足 a ≤ b 。
例如，有一个区间模式 <code>10..=0</code> 是错误的。</p>
<p>当区间模式仅具有上限或下限时，它们是 <em>半开放的</em> 。
它们的类型与其上限或下限相同。</p>
<p>仅具有下限的半开放区间写为其下限后跟 <code>..</code> 。
这些区间模式将匹配大于或等于下限的任何值。
例如， <code>1..</code> 将匹配 1 、 9 或 9001 ，或 9007199254740991 (如果它是适当大小的) ，但不匹配 0，对于有符号整数不匹配负数。</p>
<p>边界可以是字面值或指向常量值的路径。仅具有上限的半开放区间写为 <code>..=</code> 后跟其上限。
这些区间模式将匹配小于或等于上限的任何值。
例如，<code>..=10</code> 将匹配 10、1、0，对于有符号整数类型还会匹配所有负值。</p>
<p>半开放的区间模式不能用作 <a href="patterns.html#slice-patterns">切片模式</a> 中子模式的顶层模式。</p>
<p>边界值可以写作以下其中之一:</p>
<ul>
<li>字符、字节、整数或浮点数字面值。</li>
<li><code>-</code> 后跟一个整数或浮点数字面值。</li>
<li><a href="expressions/path-expr.html">路径</a>。</li>
</ul>
<p>如果边界值是作为路径写的，在宏展开后，该路径必须解析为类型为 <code>char</code> 、整数类型或浮点类型的常量条目。</p>
<p>边界的类型和值取决于它的写法。如果边界是一个路径，则模式具有路径解析为的常量的类型和值。
如果是字面值，则它具有相应的字面表达式的类型和值。
如果是一个以 <code>-</code> 开头的字面值，则它具有与相应字面值表达式相同的类型，以及相应字面值表达式的值的 <a href="expressions/operator-expr.html#negation-operators">取反</a> 的值。</p>
<p>Examples:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let c = 'f';
</span>let valid_variable = match c {
    'a'..='z' =&gt; true,
    'A'..='Z' =&gt; true,
    'α'..='ω' =&gt; true,
    _ =&gt; false,
};

<span class="boring">let ph = 10;
</span>println!(&quot;{}&quot;, match ph {
    0..=6 =&gt; &quot;acid&quot;,
    7 =&gt; &quot;neutral&quot;,
    8..=14 =&gt; &quot;base&quot;,
    _ =&gt; unreachable!(),
});

<span class="boring">let uint: u32 = 5;
</span>match uint {
    0 =&gt; &quot;zero!&quot;,
    1.. =&gt; &quot;positive number!&quot;,
};

// using paths to constants:
<span class="boring">const TROPOSPHERE_MIN : u8 = 6;
</span><span class="boring">const TROPOSPHERE_MAX : u8 = 20;
</span><span class="boring">
</span><span class="boring">const STRATOSPHERE_MIN : u8 = TROPOSPHERE_MAX + 1;
</span><span class="boring">const STRATOSPHERE_MAX : u8 = 50;
</span><span class="boring">
</span><span class="boring">const MESOSPHERE_MIN : u8 = STRATOSPHERE_MAX + 1;
</span><span class="boring">const MESOSPHERE_MAX : u8 = 85;
</span><span class="boring">
</span><span class="boring">let altitude = 70;
</span><span class="boring">
</span>println!(&quot;{}&quot;, match altitude {
    TROPOSPHERE_MIN..=TROPOSPHERE_MAX =&gt; &quot;troposphere&quot;,
    STRATOSPHERE_MIN..=STRATOSPHERE_MAX =&gt; &quot;stratosphere&quot;,
    MESOSPHERE_MIN..=MESOSPHERE_MAX =&gt; &quot;mesosphere&quot;,
    _ =&gt; &quot;outer space, maybe&quot;,
});

<span class="boring">pub mod binary {
</span><span class="boring">    pub const MEGA : u64 = 1024*1024;
</span><span class="boring">    pub const GIGA : u64 = 1024*1024*1024;
</span><span class="boring">}
</span><span class="boring">let n_items = 20_832_425;
</span><span class="boring">let bytes_per_item = 12;
</span>if let size @ binary::MEGA..=binary::GIGA = n_items * bytes_per_item {
    println!(&quot;It fits and occupies {} bytes&quot;, size);
}

<span class="boring">trait MaxValue {
</span><span class="boring">    const MAX: u64;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u8 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 8) - 1;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u16 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 16) - 1;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u32 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 32) - 1;
</span><span class="boring">}
</span>// using qualified paths:
println!(&quot;{}&quot;, match 0xfacade {
    0 ..= &lt;u8 as MaxValue&gt;::MAX =&gt; &quot;fits in a u8&quot;,
    0 ..= &lt;u16 as MaxValue&gt;::MAX =&gt; &quot;fits in a u16&quot;,
    0 ..= &lt;u32 as MaxValue&gt;::MAX =&gt; &quot;fits in a u32&quot;,
    _ =&gt; &quot;too big&quot;,
});
<span class="boring">}</span></code></pre></pre>
<p>固定宽度整数类型和 <code>char</code> 类型的区间模式在它们跨越类型的所有可能值时是不可反驳的。
例如，<code>0u8..=255u8</code> 是不可反驳的。
整数类型的值区间是从最小值到最大值的闭合区间。
<code>char</code> 类型的值区间恰好包含所有 Unicode 标量值的区间：<code>'\U{0000}'..='\U{D7FF}'</code> 和 <code>'\U{E000}'..='\U{10FFFF}'</code>。</p>
<p>浮点数区间模式已被弃用，并可能在未来的 Rust 版本中被移除。有关更多信息，请参见 <a href="https://github.com/rust-lang/rust/issues/41620">问题 #41620</a>。</p>
<blockquote>
<p><strong>版次差异</strong>: 在 2021 版本之前，闭合区间模式也可以使用 <code>...</code> 作为 <code>..=</code> 的替代，具有相同的含义。</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：虽然区间模式使用与 <a href="https://doc.rust-lang.org/reference/expressions/range-expr.html">区间表达式</a> 相同的语法，但不存在独占区间模式。也就是说，<code>x .. y</code> 和 <code>.. x</code> 都不是有效的区间模式。</p>
</blockquote>
<h2 id="引用模式"><a class="header" href="#引用模式">引用模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>引用模式</em> :<br />
   (<code>&amp;</code>|<code>&amp;&amp;</code>) <code>mut</code><sup>?</sup> <a href="patterns.html#patterns"><em>无区间模式</em></a></p>
</blockquote>
<p>引用模式会对正在匹配的指针进行解引用，因此会将它们借用。</p>
<p>例如，以下两个对 <code>x: &amp;i32</code> 的匹配是等效的:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let int_reference = &amp;3;

let a = match *int_reference { 0 =&gt; &quot;zero&quot;, _ =&gt; &quot;some&quot; };
let b = match int_reference { &amp;0 =&gt; &quot;zero&quot;, _ =&gt; &quot;some&quot; };

assert_eq!(a, b);
<span class="boring">}</span></code></pre></pre>
<p>引用模式的语法规则必须匹配标记 <code>&amp;&amp;</code> 来匹配引用到引用，因为它本身是一个标记，不是两个 <code>&amp;</code> 标记。</p>
<p>添加 <code>mut</code> 关键字会对可变引用进行解引用。
可变性必须与引用的可变性相匹配。</p>
<p>引用模式始终是不可反驳的。</p>
<h2 id="结构体模式"><a class="header" href="#结构体模式">结构体模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>结构体模式</em> :<br />
   <a href="paths.html#paths-in-expressions"><em>表达式中路径</em></a> <code>{</code><br />
      <em>结构体模式组</em> <sup>?</sup><br />
   <code>}</code></p>
<p><em>结构体模式组</em> :<br />
      <em>结构体模式字段组</em> (<code>,</code> | <code>,</code> <em>结构体模式符加</em>)<sup>?</sup><br />
   | <em>结构体模式符加</em></p>
<p><em>结构体模式字段组</em> :<br />
   <em>结构体模式字段</em> (<code>,</code> <em>结构体模式字段</em>) <sup>*</sup></p>
<p><em>结构体模式字段</em> :<br />
   <a href="attributes.html"><em>外部属性</em></a> <sup>*</sup><br />
   (<br />
         <a href="tokens.html#tuple-index">元组索引</a> <code>:</code> <a href="patterns.html#patterns"><em>模式</em></a><br />
      | <a href="identifiers.html">标识符</a> <code>:</code> <a href="patterns.html#patterns"><em>模式</em></a><br />
      | <code>ref</code><sup>?</sup> <code>mut</code><sup>?</sup> <a href="identifiers.html">标识符</a><br />
   )</p>
<p><em>结构体模式符加</em> :<br />
   <a href="attributes.html"><em>外部属性</em></a> <sup>*</sup><br />
   <code>..</code></p>
</blockquote>
<p>结构体模式匹配满足其子模式定义的所有条件的结构体值。
它们还用于 <a href="patterns.html#destructuring">解构</a> 结构体。</p>
<p>在结构体模式中，可以通过名称、索引 (对于元组结构体) 引用字段，或通过使用 <code>..</code> 忽略字段：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point {
</span><span class="boring">    x: u32,
</span><span class="boring">    y: u32,
</span><span class="boring">}
</span><span class="boring">let s = Point {x: 1, y: 1};
</span><span class="boring">
</span>match s {
    Point {x: 10, y: 20} =&gt; (),
    Point {y: 10, x: 20} =&gt; (),    // order doesn't matter
    Point {x: 10, ..} =&gt; (),
    Point {..} =&gt; (),
}

<span class="boring">struct PointTuple (
</span><span class="boring">    u32,
</span><span class="boring">    u32,
</span><span class="boring">);
</span><span class="boring">let t = PointTuple(1, 2);
</span><span class="boring">
</span>match t {
    PointTuple {0: 10, 1: 20} =&gt; (),
    PointTuple {1: 10, 0: 20} =&gt; (),   // order doesn't matter
    PointTuple {0: 10, ..} =&gt; (),
    PointTuple {..} =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p>如果没有使用 <code>..</code> ，则需要匹配所有字段:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct {
</span><span class="boring">   a: i32,
</span><span class="boring">   b: char,
</span><span class="boring">   c: bool,
</span><span class="boring">}
</span><span class="boring">let mut struct_value = Struct{a: 10, b: 'X', c: false};
</span><span class="boring">
</span>match struct_value {
    Struct{a: 10, b: 'X', c: false} =&gt; (),
    Struct{a: 10, b: 'X', ref c} =&gt; (),
    Struct{a: 10, b: 'X', ref mut c} =&gt; (),
    Struct{a: 10, b: 'X', c: _} =&gt; (),
    Struct{a: _, b: _, c: _} =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p><code>ref</code> 和/或 <code>mut</code> <em>标识符</em> 语法匹配任何值，并将其绑定到与给定字段同名的变量。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct {
</span><span class="boring">   a: i32,
</span><span class="boring">   b: char,
</span><span class="boring">   c: bool,
</span><span class="boring">}
</span><span class="boring">let struct_value = Struct{a: 10, b: 'X', c: false};
</span><span class="boring">
</span>let Struct{a: x, b: y, c: z} = struct_value;          // destructure all fields
<span class="boring">}</span></code></pre></pre>
<p>当结构体模式的任何子模式都是可反驳的时，结构体模式就是可反驳的。</p>
<h2 id="元组结构模式"><a class="header" href="#元组结构模式">元组结构模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>元组结构模式</em> :<br />
   <a href="paths.html#paths-in-expressions"><em>表达式中路径</em></a> <code>(</code> <em>元组结构条目组</em><sup>?</sup> <code>)</code></p>
<p><em>元组结构条目组</em> :<br />
   <a href="patterns.html#patterns"><em>模式</em></a> ( <code>,</code> <a href="patterns.html#patterns"><em>模式</em></a> )<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<p>元组结构体模式匹配元组结构体和枚举值，匹配所有符合其子模式定义的条件。它们还可用于 <a href="patterns.html#destructuring">解构</a> 元组结构体或枚举值。</p>
<p>当子模式中有不可反驳模式时，元组结构体模式就是可反驳的。</p>
<h2 id="元组模式"><a class="header" href="#元组模式">元组模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>元组模式</em> :<br />
   <code>(</code> <em>元组模式条目组</em><sup>?</sup> <code>)</code></p>
<p><em>元组模式条目组</em> :<br />
      <a href="patterns.html#patterns"><em>模式</em></a> <code>,</code><br />
   | [<em>剩余模式</em>]<br />
   | <a href="patterns.html#patterns"><em>模式</em></a> (<code>,</code> <a href="patterns.html#patterns"><em>模式</em></a>)<sup>+</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<p>元组模式匹配满足其子模式定义的所有条件的元组值。它们也用于 <a href="patterns.html#destructuring">解构</a> 元组。
形式为 <code>(..)</code> 且具有单个 <a href="patterns.html#rest-patterns"><em>剩余模式</em></a> 的是一种特殊形式，它不需要逗号，可以匹配任意大小的元组。</p>
<p>当其子模式中有一个可反驳时，元组模式是可反驳的。</p>
<p>以下是使用元组模式的示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pair = (10, &quot;ten&quot;);
let (a, b) = pair;

assert_eq!(a, 10);
assert_eq!(b, &quot;ten&quot;);
<span class="boring">}</span></code></pre></pre>
<h2 id="分组模式"><a class="header" href="#分组模式">分组模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>分组模式</em> :<br />
   <code>(</code> <a href="patterns.html#patterns"><em>模式</em></a> <code>)</code></p>
</blockquote>
<p>将一个模式括在括号中可以用于显式地控制复合模式的优先级。
例如，一个引用模式紧贴着一个区间模式，如 <code>&amp;0..=5</code> 是有歧义的并且不被允许，但可以用括号来表示。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let int_reference = &amp;3;
match int_reference {
    &amp;(0..=5) =&gt; (),
    _ =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="切片模式"><a class="header" href="#切片模式">切片模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>切片模式</em> :<br />
   <code>[</code> <em>切片模式条目组</em><sup>?</sup> <code>]</code></p>
<p><em>切片模式条目组</em> :<br />
   <a href="patterns.html#patterns"><em>模式</em></a> (<code>,</code> <a href="patterns.html#patterns"><em>模式</em></a>)<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<p>切片模式可以匹配固定大小的数组和动态大小的切片。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fixed size
let arr = [1, 2, 3];
match arr {
    [1, _, _] =&gt; &quot;starts with one&quot;,
    [a, b, c] =&gt; &quot;starts with something else&quot;,
};
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 动态大小
let v = vec![1, 2, 3];
match v[..] {
    [a, b] =&gt; { /* 这个分支不会匹配，因为长度不匹配 */ }
    [a, b, c] =&gt; { /* 这个分支会匹配 */ }
    _ =&gt; { /* 这个通配符是必须的，因为长度不能在编译时确定 */ }
};
<span class="boring">}</span></code></pre></pre>
<p>切片模式在匹配数组时是不可反驳的，只要每个元素都是不可反驳的即可。
在匹配切片时，只有在使用单个 <code>..</code> <a href="patterns.html#rest-patterns">剩余模式</a> 或使用 <code>..</code> 剩余模式作为子模式的 <a href="patterns.html#identifier-patterns">标识符模式</a> 时才是不可反驳的。</p>
<p>在一个切片内，半开区间模式如 <code>a..</code> 必须用括号括起来，例如 <code>(a..)</code>，以明确其意图是匹配单个值。</p>
<h2 id="路径模式"><a class="header" href="#路径模式">路径模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>路径模式</em> :<br />
      <a href="expressions/path-expr.html"><em>路径表达式</em></a></p>
</blockquote>
<p><em>路径模式</em> 是指引用常量值或没有字段的结构体或枚举变体的模式。</p>
<p>未经修饰的路径模式可以引用：</p>
<ul>
<li>枚举变体</li>
<li>结构体</li>
<li>常量</li>
<li>关联常量</li>
</ul>
<p>修饰的路径模式只能引用关联常量。常量不能是联合类型。结构体和枚举常量必须有 <code>#[derive(PartialEq, Eq)]</code> (而不是仅实现) 。
当路径模式引用结构体或枚举变体并且枚举只有一个变体或类型为不可反驳类型的常量时，路径模式是不可反驳的。当路径模式引用可反驳的常量或具有多个变体的枚举变体时，它们是可反驳的。</p>
<h2 id="或模式"><a class="header" href="#或模式">或模式</a></h2>
<p><em>或模式</em> 是指可以匹配两个或更多子模式的模式 (例如 <code>A | B | C</code> )。它们可以任意嵌套。
从语法上讲，或模式可以在任何其他模式允许的地方使用 (由 <em>模式</em> 生成式表示)，但有一些例外情况，例如 <code>let</code> 绑定和函数和闭包参数 (由 <em>模式非顶层选项</em> 产生式表示) 。</p>
<h3 id="静态语义"><a class="header" href="#静态语义">静态语义</a></h3>
<ol>
<li>
<p>对于任意的模式 <code>p | q</code> ，其中 <code>p</code> 和 <code>q</code> 是任意模式，如果:</p>
<ul>
<li>推断出的 <code>p</code> 的类型不能与推断出的 <code>q</code> 的类型统一，或者</li>
<li>在 <code>p</code> 和 <code>q</code> 中没有引入相同的绑定，或者</li>
<li>在 <code>p</code> 和 <code>q</code> 中具有相同名称的绑定的类型或绑定模式不能相互统一，那么此模式将被视为非法。</li>
</ul>
<p>在上述所有情况中，类型统一都是确切的，且不应用隐式 <a href="type-coercions.html">类型强制转换</a> 。</p>
</li>
<li>
<p>在类型检查表达式 <code>match e_s { a_1 =&gt; e_1, ... a_n =&gt; e_n }</code> 时，对于每个包含形式为 <code>p_i | q_i</code> 的模式的匹配分支 <code>a_i</code> ，如果在其所处的深度 <code>d</code> 处，<code>e_s</code> 中的片段类型不能与 <code>p_i | q_i</code> 统一，则模式 <code>p_i | q_i</code> 被视为非法。</p>
</li>
<li>
<p>在考虑穷尽性时，将模式 <code>p | q</code> 视为同时匹配 <code>p</code> 和 <code>q</code> 。对于某个构造函数 <code>c(x, ..)</code>，分配律适用于 <code>c(p | q, ..rest)</code> 和 <code>c(p, ..rest) | c(q, ..rest)</code> 。递归应用此规则，直到不存在除顶层外的形式为 <code>p | q</code> 的嵌套模式为止。</p>
<p>请注意，<em>&quot;构造函数&quot;</em> 并不是指元组结构模式，而是指任何产品类型的模式。这包括枚举变体、元组结构、具有命名字段的结构体、数组、元组和切片。</p>
</li>
</ol>
<h3 id="动态语义"><a class="header" href="#动态语义">动态语义</a></h3>
<ol>
<li>在深度为 <code>d</code> 处使用模式 <code>c(p | q, ..rest)</code> 匹配被匹配表达式 <code>e_s</code> 的动态语义，其中 <code>c</code> 是某个构造函数，<code>p</code> 和 <code>q</code> 是任意模式，<code>rest</code> 可选地包含 <code>c</code> 中的其他因子，其定义与 <code>c(p, ..rest) | c(q, ..rest)</code> 相同。</li>
</ol>
<h3 id="与其他未限定模式的优先级"><a class="header" href="#与其他未限定模式的优先级">与其他未限定模式的优先级</a></h3>
<p>正如本章的其他地方所示，有几种语法上未限定的模式，包括标识符模式、引用模式和或模式。或模式始终具有最低的优先级。
这使我们可以为未来可能的类型注释功能保留语法空间，并减少歧义。
例如，<code>x @ A(..) | B(..)</code> 将导致错误，即 <code>x</code> 在所有模式中都未绑定。<code>&amp;A(x) | B(x)</code> 将导致在不同的子模式中 <code>x</code> 类型不匹配的错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-system"><a class="header" href="#type-system">Type system</a></h1>
<div style="break-before: page; page-break-before: always;"></div><script>
(function() {
    var fragments = {
        "#boolean-type": "types/boolean.html",
        "#numeric-types": "types/numeric.html",
        "#machine-types": "types/numeric.html",
        "#machine-dependent-integer-types": "types/numeric.html#machine-dependent-integer-types",
        "#textual-types": "types/textual.html",
        "#never-type": "types/never.html",
        "#tuple-types": "types/tuple.html",
        "#array-and-slice-types": "types/array.html",
        "#struct-types": "types/struct.html",
        "#enumerated-types": "types/enum.html",
        "#union-types": "types/union.html",
        "#pointer-types": "types/pointer.html",
        "#shared-references-": "types/pointer.html#shared-references-",
        "#mutable-references-": "types/pointer.html#mutable-references-mut",
        "#raw-pointers-const-and-mut": "types/pointer.html#raw-pointers-const-and-mut",
        "#smart-pointers": "types/pointer.html#smart-pointers",
        "#function-item-types": "types/function-item.html",
        "#function-pointer-types": "types/function-pointer.html",
        "#closure-types": "types/closure.html",
        "#capture-modes": "types/closure.html#capture-modes",
        "#unique-immutable-borrows-in-captures": "types/closure.html#unique-immutable-borrows-in-captures",
        "#call-traits-and-coercions": "types/closure.html#call-traits-and-coercions",
        "#other-traits": "types/closure.html#other-traits",
        "#trait-objects": "types/trait-object.html",
        "#trait-object-lifetime-bounds": "types/trait-object.html#trait-object-lifetime-bounds",
        "#impl-trait": "types/impl-trait.html",
        "#anonymous-type-parameters": "types/impl-trait.html#anonymous-type-parameters",
        "#abstract-return-types": "types/impl-trait.html#abstract-return-types",
        "#self-types": "paths.html#self-1",
        "#inferred-type": "types/inferred.html",
        "#type-parameters": "types/parameters.html",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<h1 id="类型"><a class="header" href="#类型">类型</a></h1>
<p>在 Rust 程序中，每个变量、条目和值都有一个类型。一个 <em>值</em> 的 <em>类型</em> 定义了其存储的内存的解释方式和可对该值执行的操作。</p>
<p>内置类型与语言紧密集成，以一种用户定义类型无法模拟的非平凡方式实现。用户定义类型则具有有限的功能。</p>
<p>Rust 的类型列表包括：</p>
<ul>
<li>原始类型:
<ul>
<li><a href="types/boolean.html">布尔类型</a> — <code>bool</code></li>
<li><a href="types/numeric.html">数值类型</a> — 整数和浮点数</li>
<li><a href="types/textual.html">文本类型</a> — char 和 str</li>
<li><a href="types/never.html">空类型</a> — <code>!</code> — 没有值的类型</li>
</ul>
</li>
<li>序列类型:
<ul>
<li><a href="types/tuple.html">元组类型</a></li>
<li><a href="types/array.html">数组类型</a></li>
<li><a href="types/slice.html">切片类型</a></li>
</ul>
</li>
<li>用户定义类型:
<ul>
<li><a href="types/struct.html">结构体类型</a></li>
<li><a href="types/enum.html">枚举类型</a></li>
<li><a href="types/union.html">联合类型</a></li>
</ul>
</li>
<li>函数类型：
<ul>
<li><a href="types/function-item.html">函数类型</a></li>
<li><a href="types/closure.html">闭包类型</a></li>
</ul>
</li>
<li>指针类型:
<ul>
<li><a href="types/pointer.html#shared-references-">引用类型</a></li>
<li><a href="types/pointer.html#raw-pointers-const-and-mut">原始指针类型</a></li>
<li><a href="types/function-pointer.html">函数指针类型</a></li>
</ul>
</li>
<li>Trait 类型:
<ul>
<li>[Trait 对象]</li>
<li><a href="types/impl-trait.html">Impl trait</a></li>
</ul>
</li>
</ul>
<h2 id="类型表达式"><a class="header" href="#类型表达式">类型表达式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>类型</em> :<br />
      <em>无约束类型组</em><br />
   | <a href="types/impl-trait.html"><em>ImplTrait类型</em></a><br />
   | <a href="types/trait-object.html"><em>Trait对象类型</em></a></p>
<p><em>无边界类型组</em> :<br />
      <a href="types.html#parenthesized-types"><em>括号类型</em></a><br />
   | [<em>ImplTrait类型1约束</em>]<em>ImplTraitTypeOneBound</em>]<br />
   | <a href="types/trait-object.html"><em>Trait对象类型1约束</em></a><br />
   | <a href="paths.html#paths-in-types"><em>类型路径</em></a><br />
   | <a href="types/tuple.html#tuple-types"><em>元组类型</em></a><br />
   | <a href="types/never.html"><em>空类型</em></a><br />
   | <a href="types/pointer.html#raw-pointers-const-and-mut"><em>原始指针类型</em></a><br />
   | <a href="types/pointer.html#shared-references-"><em>引用类型</em></a><br />
   | <a href="types/array.html"><em>数组类型</em></a><br />
   | <a href="types/slice.html"><em>切片类型</em></a><br />
   | <a href="types/inferred.html"><em>推断类型</em></a><br />
   | <a href="paths.html#qualified-paths"><em>限定路径类型</em></a><br />
   | <a href="types/function-pointer.html"><em>裸函数类型</em></a><br />
   | <a href="macros.html#macro-invocation"><em>宏调用</em></a></p>
</blockquote>
<p>在上面的 <em>类型</em> 语法规则中定义的 <em>类型表达式</em> 是指引用类型的语法。它可以引用以下内容：</p>
<ul>
<li>序列类型 ( <a href="types/tuple.html">tuple</a> <a href="types/array.html">array</a> <a href="types/slice.html">slice</a> ) 。</li>
<li><a href="paths.html#paths-in-types">类型路径</a> 可以引用：
<ul>
<li>原始类型 ( <a href="types/boolean.html">boolean</a> <a href="types/numeric.html">numeric</a> <a href="types/textual.html">textual</a> ) 。</li>
<li>对 <a href="items.html">条目</a> 的引用 ( <a href="types/struct.html">struct</a> <a href="types/enum.html">enum</a>  <a href="types/union.html">union</a> <a href="items/type-aliases.html">type alias</a>  <a href="types/trait-object.html">trait</a> ) 。</li>
<li>[Self 路径][Self path] ，其中 Self 是实现类型。</li>
<li>泛型 <a href="types/parameters.html">类型参数</a> 。</li>
</ul>
</li>
<li>指针类型 ( <a href="types/pointer.html#shared-references-">reference</a> <a href="types/pointer.html#raw-pointers-const-and-mut">raw pointer</a> <a href="types/function-pointer.html">function pointer</a> ) 。</li>
<li><a href="types/inferred.html">inferred type</a> ，请求编译器确定类型。</li>
<li>用于消除歧义的 <a href="types.html#parenthesized-types">Parentheses</a> 。</li>
<li>Trait 类型: <a href="types/trait-object.html">Trait objects</a> 和 <a href="types/impl-trait.html">impl trait</a> 。</li>
<li><a href="types/never.html">never</a> 类型。</li>
<li><a href="macros.html">Macros</a> ，它们展开为类型表达式。</li>
</ul>
<h3 id="括号类型"><a class="header" href="#括号类型">括号类型</a></h3>
<blockquote>
<p><em>括号类型</em> :<br />
   <code>(</code> <a href="types.html#type-expressions"><em>类型</em></a> <code>)</code></p>
</blockquote>
<p>在某些情况下，类型的组合可能是不明确的。在类型周围加上括号以避免歧义。
例如， [引用类型] 中的 <a href="trait-bounds.html">类型约束</a> 的 <code>+</code> 运算符不清楚边界适用的位置，因此需要使用括号。
需要此消除歧义的语法使用 <a href="types.html#type-expressions"><em>无约束类型组</em></a> 规则，而不是 <a href="types.html#type-expressions"><em>类型</em></a> 。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span>type T&lt;'a&gt; = &amp;'a (dyn Any + Send);
<span class="boring">}</span></code></pre></pre>
<h2 id="递归类型"><a class="header" href="#递归类型">递归类型</a></h2>
<p>名义类型 - <a href="types/struct.html">structs</a> 、 <a href="types/enum.html">enumerations</a> 和 <a href="types/union.html">unions</a> - 可以是递归的。
也就是说，每个 <code>enum</code> 变量或 <code>struct</code> 或 <code>union</code> 字段可以直接或间接地引用封闭的 <code>enum</code> 或 <code>struct</code> 类型本身。
这种递归有限制:</p>
<ul>
<li>
<p>递归类型必须包含在递归中的名义类型 (不是仅仅是 <a href="items/type-aliases.html">类型别名</a> ，或其他结构类型，例如 <a href="types/array.html">数组</a> 或 <a href="types/tuple.html">元组</a> ) 。因此， <code>type Rec = &amp;'static [Rec]</code> 是不允许的。</p>
</li>
<li>
<p>递归类型的大小必须是有限的；换句话说，类型的递归字段必须是 <a href="types/pointer.html">指针</a> 。</p>
</li>
</ul>
<p>以下是 <em>递归</em> 类型及其使用示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum List&lt;T&gt; {
    Nil,
    Cons(T, Box&lt;List&lt;T&gt;&gt;)
}

let a: List&lt;i32&gt; = List::Cons(7, Box::new(List::Cons(13, Box::new(List::Nil))));
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="布尔类型"><a class="header" href="#布尔类型">布尔类型</a></h1>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b: bool = true;
<span class="boring">}</span></code></pre></pre>
<p><em>布尔类型</em> 或 <em>bool</em> 是一种原始数据类型，可以取两个值之一，称为 <em>true</em> 和 <em>false</em> 。</p>
<p>可以使用关键字 <code>true</code> 和 <code>false</code> 创建此类型的值，通过 <a href="types/../expressions/literal-expr.html">字面值表达式</a> 生成。</p>
<p>此类型是 <a href="types/../names/preludes.html#language-prelude">language prelude</a> 的一部分，其 <a href="types/../names.html">name</a> 为 <code>bool</code> 。</p>
<p>具有布尔类型的对象每个都具有 <a href="types/../type-layout.html#size-and-alignment">大小和对齐方式</a> 1 。
值 false 的位模式为 <code>0x00</code> ，值 true 的位模式为 <code>0x01</code> 。
具有布尔类型的对象具有任何其他位模式是 <a href="types/../behavior-considered-undefined.html">未定义行为</a> 。</p>
<p>布尔类型是各种 <a href="types/../expressions.html">表达式</a> 中许多操作数的类型：</p>
<ul>
<li><a href="types/../expressions/if-expr.html#if-expressions">if 表达式</a> 和 <a href="types/../expressions/loop-expr.html#predicate-loops">while 表达式</a> 中的条件操作数</li>
<li><a href="types/../expressions/operator-expr.html#lazy-boolean-operators">惰性布尔运算符表达式</a> 中的操作数</li>
</ul>
<blockquote>
<p><strong>注意</strong>: 布尔类型类似于但不是 <a href="types/enum.html">可枚举类型</a> 。实际上，这主要意味着构造函数未与类型关联 (例如， <code>bool::true</code> ) 。</p>
</blockquote>
<p>与所有原始类型一样，布尔类型 <a href="types/../items/implementations.html">p-impl</a> 实现了 <a href="types/../items/traits.html">traits</a> <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a> ， <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a> ， <a href="types/../special-types-and-traits.html#sized"><code>Sized</code></a> ， <a href="types/../special-types-and-traits.html#send"><code>Send</code></a> 和 <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a> 。</p>
<blockquote>
<p><strong>注意</strong>: 请参阅 <a href="types/../../std/primitive.bool.html">标准库文档</a> 以获取库操作。</p>
</blockquote>
<h2 id="布尔值的操作"><a class="header" href="#布尔值的操作">布尔值的操作</a></h2>
<!-- This is washy wording --> 当使用特定的运算符表达式作为布尔类型的操作数时，它们会根据 [布尔逻辑][boolean logic] 的规则进行评估。
<h3 id="逻辑非"><a class="header" href="#逻辑非">逻辑非</a></h3>
<div class="table-wrapper"><table><thead><tr><th><code>b</code></th><th><a href="types/../expressions/operator-expr.html#negation-operators"><code>!b</code></a></th></tr></thead><tbody>
<tr><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td></tr>
</tbody></table>
</div>
<h3 id="逻辑或"><a class="header" href="#逻辑或">逻辑或</a></h3>
<div class="table-wrapper"><table><thead><tr><th><code>a</code></th><th><code>b</code></th><th><a href="types/../expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><code>a | b</code></a></th></tr></thead><tbody>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td><td><code>true</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>false</code></td></tr>
</tbody></table>
</div>
<h3 id="逻辑与"><a class="header" href="#逻辑与">逻辑与</a></h3>
<div class="table-wrapper"><table><thead><tr><th><code>a</code></th><th><code>b</code></th><th><a href="types/../expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><code>a &amp; b</code></a></th></tr></thead><tbody>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>false</code></td></tr>
</tbody></table>
</div>
<h3 id="逻辑异或"><a class="header" href="#逻辑异或">逻辑异或</a></h3>
<div class="table-wrapper"><table><thead><tr><th><code>a</code></th><th><code>b</code></th><th><a href="types/../expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><code>a ^ b</code></a></th></tr></thead><tbody>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td><td><code>true</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>false</code></td></tr>
</tbody></table>
</div>
<h3 id="比较"><a class="header" href="#比较">比较</a></h3>
<div class="table-wrapper"><table><thead><tr><th><code>a</code></th><th><code>b</code></th><th><a href="types/../expressions/operator-expr.html#comparison-operators"><code>a == b</code></a></th></tr></thead><tbody>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>true</code></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><code>a</code></th><th><code>b</code></th><th><a href="types/../expressions/operator-expr.html#comparison-operators"><code>a &gt; b</code></a></th></tr></thead><tbody>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td><td><code>true</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>false</code></td></tr>
</tbody></table>
</div>
<ul>
<li><code>a != b</code> 相同于 <code>!(a == b)</code></li>
<li><code>a &gt;= b</code> 相同于 <code>a == b | a &gt; b</code></li>
<li><code>a &lt; b</code> 相同于 <code>!(a &gt;= b)</code></li>
<li><code>a &lt;= b</code> 相同于 <code>a == b | a &lt; b</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数字类型"><a class="header" href="#数字类型">数字类型</a></h1>
<h2 id="整数类型"><a class="header" href="#整数类型">整数类型</a></h2>
<p>无符号整数类型包括:</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>最小值</th><th>最大值</th></tr></thead><tbody>
<tr><td><code>u8</code></td><td>0</td><td>2<sup>8</sup>-1</td></tr>
<tr><td><code>u16</code></td><td>0</td><td>2<sup>16</sup>-1</td></tr>
<tr><td><code>u32</code></td><td>0</td><td>2<sup>32</sup>-1</td></tr>
<tr><td><code>u64</code></td><td>0</td><td>2<sup>64</sup>-1</td></tr>
<tr><td><code>u128</code></td><td>0</td><td>2<sup>128</sup>-1</td></tr>
</tbody></table>
</div>
<p>有符号的二进制补码整数类型包括:</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>最小值</th><th>最大值</th></tr></thead><tbody>
<tr><td><code>i8</code></td><td>-(2<sup>7</sup>)</td><td>2<sup>7</sup>-1</td></tr>
<tr><td><code>i16</code></td><td>-(2<sup>15</sup>)</td><td>2<sup>15</sup>-1</td></tr>
<tr><td><code>i32</code></td><td>-(2<sup>31</sup>)</td><td>2<sup>31</sup>-1</td></tr>
<tr><td><code>i64</code></td><td>-(2<sup>63</sup>)</td><td>2<sup>63</sup>-1</td></tr>
<tr><td><code>i128</code></td><td>-(2<sup>127</sup>)</td><td>2<sup>127</sup>-1</td></tr>
</tbody></table>
</div>
<h2 id="浮点数类型"><a class="header" href="#浮点数类型">浮点数类型</a></h2>
<p>IEEE 754-2008 标准中的 &quot;binary32&quot; 和 &quot;binary64&quot; 浮点数类型分别为 <code>f32</code> 和 <code>f64</code> 。</p>
<h2 id="机器相关的整数类型"><a class="header" href="#机器相关的整数类型">机器相关的整数类型</a></h2>
<p><code>usize</code> 类型是一种无符号整数类型，其位数与平台的指针类型相同。它可以表示进程中的每个内存地址。</p>
<p><code>isize</code> 类型是一种带符号整数类型，其位数与平台的指针类型相同。对象和数组大小的理论上限是最大的 <code>isize</code> 值。
这确保了 <code>isize</code> 可用于计算指向对象或数组中的指针之间的差异，并且可以寻址对象内的每个字节以及超出末尾一个字节。</p>
<p><code>usize</code> 和 <code>isize</code> 至少有 16 位宽度。</p>
<blockquote>
<p>注意：许多 Rust 代码可能假设指针、 <code>usize</code> 和 <code>isize</code> 是 32 位或 64 位。
因此，对于 16 位指针的支持是有限的，可能需要库显式关注并确认其支持。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文本类型"><a class="header" href="#文本类型">文本类型</a></h1>
<p>类型 <code>char</code> 和 <code>str</code> 用于保存文本数据。</p>
<p><code>char</code> 类型的值是一个 <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode 标量值</a> (即不是代理项的代码点) ，表示为 32 位无符号整数，它位于范围 0x0000 到 0xD7FF 或 0xE000 到 0x10FFFF。
创建一个超出此范围的 <code>char</code> 是 <a href="types/../behavior-considered-undefined.html">未定义行为</a> 。 <code>[char]</code> 实际上是长度为 1 的 UCS-4 / UTF-32 字符串。</p>
<p><code>str</code> 类型的值与 <code>[u8]</code> 相同，它是 8 位无符号字节的切片。
但是，Rust 标准库对 <code>str</code> 做了一些额外的假设: 在 <code>str</code> 上工作的方法假定并确保其中的数据是有效的 UTF-8 。
使用非 UTF-8 缓冲区调用 <code>str</code> 方法可能导致 <a href="types/../behavior-considered-undefined.html">未定义行为</a> ，可能是现在，也可能是将来。</p>
<p>由于 <code>str</code> 是 <a href="types/../dynamically-sized-types.html">动态大小类型</a> ，因此只能通过指针类型 (例如 <code>&amp;str</code> ) 来实例化。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="永不类型"><a class="header" href="#永不类型">永不类型</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>永不类型</em> : <code>!</code></p>
</blockquote>
<p>永不类型 <code>!</code> 是一种没有值的类型，代表永远不会完成计算的结果。
类型为 <code>!</code> 的表达式可以强制转换为任何其他类型。</p>
<!-- ignore: unstable -->
<pre><code class="language-rust ignore">let x: ! = panic!();
// 可以强制转换为任何类型。
let y: u32 = x;</code></pre>
<p><strong>注意:</strong> 预计在 1.41 版本中稳定的永不类型，但由于最后时间发现了一些回归问题，因此稳定性被暂时撤销。
目前， <code>!</code> 类型只能出现在函数返回类型中。有关更多详细信息，请参见 <a href="https://github.com/rust-lang/rust/issues/35121">问题跟踪</a> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuple-types"><a class="header" href="#tuple-types">Tuple types</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TupleType</em> :<br />
      <code>(</code> <code>)</code><br />
   | <code>(</code> ( <a href="types/../types.html#type-expressions"><em>Type</em></a> <code>,</code> )<sup>+</sup> <a href="types/../types.html#type-expressions"><em>Type</em></a><sup>?</sup> <code>)</code></p>
</blockquote>
<p><em>Tuple types</em> are a family of structural types<sup class="footnote-reference"><a href="#1">1</a></sup> for heterogeneous lists of other types.</p>
<p>The syntax for a tuple type is a parenthesized, comma-separated list of types.
1-ary tuples require a comma after their element type to be disambiguated with a <a href="types/../types.html#parenthesized-types">parenthesized type</a>.</p>
<p>A tuple type has a number of fields equal to the length of the list of types.
This number of fields determines the <em>arity</em> of the tuple.
A tuple with <code>n</code> fields is called an <em>n-ary tuple</em>.
For example, a tuple with 2 fields is a 2-ary tuple.</p>
<p>Fields of tuples are named using increasing numeric names matching their position in the list of types.
The first field is <code>0</code>.
The second field is <code>1</code>.
And so on.
The type of each field is the type of the same position in the tuple's list of types.</p>
<p>For convenience and historical reasons, the tuple type with no fields (<code>()</code>) is often called <em>unit</em> or <em>the unit type</em>.
Its one value is also called <em>unit</em> or <em>the unit value</em>.</p>
<p>Some examples of tuple types:</p>
<ul>
<li><code>()</code> (unit)</li>
<li><code>(f64, f64)</code></li>
<li><code>(String, i32)</code></li>
<li><code>(i32, String)</code> (different type from the previous example)</li>
<li><code>(i32, f64, Vec&lt;String&gt;, Option&lt;bool&gt;)</code></li>
</ul>
<p>Values of this type are constructed using a <a href="types/../expressions/tuple-expr.html#tuple-expressions">tuple expression</a>.
Furthermore, various expressions will produce the unit value if there is no other meaningful value for it to evaluate to.
Tuple fields can be accessed by either a <a href="types/../expressions/tuple-expr.html#tuple-indexing-expressions">tuple index expression</a> or <a href="types/../patterns.html#tuple-patterns">pattern matching</a>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Structural types are always equivalent if their internal types are equivalent.
For a nominal version of tuples, see <a href="types/./struct.html">tuple structs</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数组类型"><a class="header" href="#数组类型">数组类型</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>数组类型</em> :<br />
   <code>[</code> <a href="types/../types.html#type-expressions"><em>Type</em></a> <code>;</code> <a href="types/../expressions.html"><em>表达式</em></a> <code>]</code></p>
</blockquote>
<p>数组是一种固定大小的类型为 <code>T</code> 的元素序列，数组类型的写法为 <code>[T; N]</code> 。
其大小是一个 <a href="types/../const_eval.html#constant-expressions">常量表达式</a> ，值应该是 <a href="types/numeric.html#machine-dependent-integer-types"><code>usize</code></a> 类型。</p>
<p>例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 一个栈上分配的数组
let array: [i32; 3] = [1, 2, 3];

// 一个堆上分配的数组，转换为一个切片类型
let boxed_array: Box&lt;[i32]&gt; = Box::new([1, 2, 3]);
<span class="boring">}</span></code></pre></pre>
<p>数组的所有元素都被初始化，且在安全方法和运算符中访问数组时始终进行边界检查。</p>
<blockquote>
<p>注意: 标准库类型 <a href="types/../../std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> 提供了一种在堆上分配的可调整大小的数组类型。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slice-types"><a class="header" href="#slice-types">Slice types</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>切片类型</em> :<br />
   <code>[</code> <a href="types/../types.html#type-expressions"><em>类型</em></a> <code>]</code></p>
</blockquote>
<p>切片是一个 <a href="types/../dynamically-sized-types.html">动态大小类型</a> ，表示对类型为 <code>T</code> 的元素序列的 '视图' 。切片类型的写法为 <code>[T]</code> 。</p>
<p>切片类型通常通过指针类型来使用。例如：</p>
<ul>
<li><code>&amp;[T]</code>：一个 '共享切片' ，通常称为 '切片' 。它不拥有它所指向的数据，而是借用它。</li>
<li><code>&amp;mut [T]</code>：一个 '可变切片' 。它可变地借用它所指向的数据。</li>
<li><code>Box&lt;[T]&gt;</code>：一个 '装箱切片' 。</li>
</ul>
<p>例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 将一个堆分配的数组转换成一个切片
let boxed_array: Box&lt;[i32]&gt; = Box::new([1, 2, 3]);

// 从一个数组中创建一个 (共享的) 切片
let slice: &amp;[i32] = &amp;boxed_array[..];
<span class="boring">}</span></code></pre></pre>
<p>所有切片元素都是始终被初始化的，而且在安全的方法和操作中，访问切片时总是会进行边界检查。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体类型"><a class="header" href="#结构体类型">结构体类型</a></h1>
<p><code>struct</code> <em>类型</em> 是其他类型的异构集合，称为类型的 <em>字段</em> 。<sup class="footnote-reference"><a href="#structtype">1</a></sup></p>
<p>使用 <a href="types/../expressions/struct-expr.html">结构体表达式</a> 可以构造 <code>struct</code> 的新实例。</p>
<p>默认情况下， <code>struct</code> 的内存布局是未定义的，以允许编译器进行优化，例如字段重新排序，但是可以通过 <a href="types/../type-layout.html#representations"><code>repr</code>属性</a> 来确定。
在任一情况下，相应的结构 <em>表达式</em> 中的字段可以按任何顺序给出；生成的 <code>struct</code> 值始终具有相同的内存布局。</p>
<p><code>struct</code> 的字段可以由 <a href="types/../visibility-and-privacy.html">可见性修饰符</a> 修饰，以允许在模块之外访问结构中的数据。</p>
<p><em>元组结构体</em> 类型与结构体类型相同，但字段是匿名的。</p>
<p><em>类单元结构体</em> 类型类似于结构体类型，但是它没有字段。
与关联的 <a href="types/../expressions/struct-expr.html">结构体表达式</a> 构造的一个值是唯一的该类型的值。</p>
<div class="footnote-definition" id="structtype"><sup class="footnote-definition-label">1</sup>
<p><code>struct</code> 类型类似于 C 中的 <code>struct</code> 类型， ML 系列的 <em>record</em> 类型或 Lisp 系列的 <em>struct</em> 类型。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举类型"><a class="header" href="#枚举类型">枚举类型</a></h1>
<p><em>枚举类型</em> 是一种命名的、异构的不相交联合类型，由一个 <a href="types/../items/enumerations.html"><code>enum</code> 条目</a> 的名称表示。<sup class="footnote-reference"><a href="#enumtype">1</a></sup></p>
<p><a href="types/../items/enumerations.html"><code>enum</code> 条目</a> 声明了类型以及若干个 <em>变体</em> ，每个变体都有独立的名称，语法类似于结构体、元组结构体或单元结构体。</p>
<p>可以使用 <a href="types/../expressions/struct-expr.html">结构体表达式</a> 来构造枚举的新实例。对于枚举类型，任何一个 <code>enum</code> 值消耗的内存都至少等于对应枚举类型中最大的变体的内存大小加上需要存储一个标识符的大小。</p>
<p>枚举类型无法通过类型来进行结构上的表示，而必须通过指向 <a href="types/../items/enumerations.html"><code>enum</code> 条目</a> 的命名引用来表示。</p>
<div class="footnote-definition" id="enumtype"><sup class="footnote-definition-label">1</sup>
<p><code>enum</code> 类型类似于 ML 中的 <code>data</code> 构造声明，或者 Limbo 中的 <em>pick ADT</em> 。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="union-types"><a class="header" href="#union-types">Union types</a></h1>
<p>A <em>union type</em> is a nominal, heterogeneous C-like union, denoted by the name of
a <a href="types/../items/unions.html"><code>union</code> item</a>.</p>
<p>Unions have no notion of an &quot;active field&quot;. Instead, every union access
transmutes parts of the content of the union to the type of the accessed field.
Since transmutes can cause unexpected or undefined behaviour, <code>unsafe</code> is
required to read from a union field. Union field types are also restricted to a
subset of types which ensures that they never need dropping. See the <a href="types/../items/unions.html">item</a>
documentation for further details.</p>
<p>The memory layout of a <code>union</code> is undefined by default (in particular, fields do
<em>not</em> have to be at offset 0), but the <code>#[repr(...)]</code> attribute can be used to
fix a layout.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数条目类型"><a class="header" href="#函数条目类型">函数条目类型</a></h1>
<p>引用函数条目或类似元组结构或枚举变量的构造函数时，它会生成其 <em>函数条目类型</em> 的大小为零的值。
该类型明确标识函数 - 其名称、类型参数和其提前绑定的生命周期参数 (但不包括其延迟绑定的生命周期参数，这些参数仅在调用函数时分配) - 因此该值不需要包含实际的函数指针，并且调用函数时不需要进行间接寻址。</p>
<p>没有直接引用函数条目类型的语法，但编译器在错误消息中将显示类型为类似于 <code>fn(u32) -&gt; i32 {fn_name}</code> 的类型。</p>
<p>因为函数条目类型明确标识函数，不同函数的条目类型 - 不同的条目，或者相同条目的不同泛型 - 是不同的，混合它们会产生类型错误:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0308 edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;() { }
let x = &amp;mut foo::&lt;i32&gt;;
*x = foo::&lt;u32&gt;; //~ ERROR 类型不匹配
<span class="boring">}</span></code></pre></pre>
<p>然而，从具有相同签名的函数条目到 <a href="types/function-pointer.html">函数指针</a> 存在 <a href="types/../type-coercions.html">强制转换</a> ，当期望直接使用函数指针时，它会被触发。
当在同一 <code>if</code> 或 <code>match</code> 的不同分支中遇到具有相同签名的不同函数条目类型时，也会触发这种转换:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let want_i32 = false;
</span><span class="boring">fn foo&lt;T&gt;() { }
</span>
// 在这里，`foo_ptr_1` 具有函数指针类型 `fn()`
let foo_ptr_1: fn() = foo::&lt;i32&gt;;

// ... `foo_ptr_2` 也具有相同的函数指针类型 - 这样类型检查通过了
let foo_ptr_2 = if want_i32 {
    foo::&lt;i32&gt;
} else {
    foo::&lt;u32&gt;
};
<span class="boring">}</span></code></pre></pre>
<p>所有的函数条目都实现了 <a href="types/../../std/ops/trait.Fn.html"><code>Fn</code></a> , <a href="types/../../std/ops/trait.FnMut.html"><code>FnMut</code></a> , <a href="types/../../std/ops/trait.FnOnce.html"><code>FnOnce</code></a> , <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a> , <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a> , <a href="types/../special-types-and-traits.html#send"><code>Send</code></a> 和 <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="闭包类型"><a class="header" href="#闭包类型">闭包类型</a></h1>
<p><a href="types/../expressions/closure-expr.html">闭包表达式</a> 生成一个闭包值，具有独特的匿名类型，无法显式书写。
闭包类型类似于包含捕获变量的结构体。例如，以下闭包:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;F : FnOnce() -&gt; String&gt; (g: F) {
    println!(&quot;{}&quot;, g());
}

let mut s = String::from(&quot;foo&quot;);
let t = String::from(&quot;bar&quot;);

f(|| {
    s += &amp;t;
    s
});
// Prints &quot;foobar&quot;.
<span class="boring">}</span></code></pre></pre>
<p>生成的闭包类型大致类似于以下结构体:</p>
<!-- ignore: simplified, requires unboxed_closures, fn_traits -->
<pre><code class="language-rust ignore">struct Closure&lt;'a&gt; {
    s : String,
    t : &amp;'a String,
}

impl&lt;'a&gt; FnOnce&lt;()&gt; for Closure&lt;'a&gt; {
    type Output = String;
    fn call_once(self) -&gt; String {
        self.s += &amp;*self.t;
        self.s
    }
}</code></pre>
<p>因此，对 <code>f</code> 的调用将像以下代码一样工作:</p>
<!-- ignore: continuation of above -->
<pre><code class="language-rust ignore">f(Closure{s: s, t: &amp;t});</code></pre>
<h2 id="捕获模式-1"><a class="header" href="#捕获模式-1">捕获模式</a></h2>
<p>编译器优先选择对闭合变量进行不可变借用，然后是唯一不可变借用 (参见下文) ，然后是可变借用，最后才是移动方式。
编译器将选择与在闭包体内使用捕获变量的方式兼容的这些选项中的第一个。编译器不考虑周围的代码，比如涉及变量的生命周期或闭包本身的生命周期。</p>
<p>如果使用了 <code>move</code> 关键字，则所有的捕获都是通过移动，或者对于 <code>Copy</code> 类型是通过复制，而不管是否可以使用借用。
通常， <code>move</code> 关键字用于允许闭包超出捕获值的生命周期，例如，如果闭包正在被返回或用于生成新线程。</p>
<p>结构体、元组和枚举等复合类型始终被整体捕获，而不是逐个字段捕获。为了捕获单个字段，可能需要借用到一个本地变量中：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">
</span>struct SetVec {
    set: HashSet&lt;u32&gt;,
    vec: Vec&lt;u32&gt;
}

impl SetVec {
    fn populate(&amp;mut self) {
        let vec = &amp;mut self.vec;
        self.set.iter().for_each(|&amp;n| {
            vec.push(n);
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>如果闭包直接使用 <code>self.vec</code> ，那么它将尝试通过可变引用来捕获 <code>self</code> 。
但是，由于 <code>self.set</code> 已经被借用以进行迭代，代码将无法编译。</p>
<h2 id="捕获中的唯一不可变借用"><a class="header" href="#捕获中的唯一不可变借用">捕获中的唯一不可变借用</a></h2>
<p>捕获可以通过一种称为唯一不可变借用的特殊借用方式发生，它无法在语言的任何其他地方使用，并且无法显式书写。
当修改可变引用的引用对象时，就会发生这种情况，例如以下示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut b = false;
let x = &amp;mut b;
{
    let mut c = || { *x = true; };
    // 下面这一行是错误的:
    // let y = &amp;x;
    c();
}
let z = &amp;x;
<span class="boring">}</span></code></pre></pre>
<p>在这种情况下，无法将 <code>x</code> 借为可变引用，因为 <code>x</code> 不是可变的。
但与此同时，借用 <code>x</code> 为不可变引用将使赋值操作非法，因为 <code>&amp; &amp;mut</code> 引用可能不是唯一的，因此不能安全地用于修改值。
因此，使用了一种独特的不可变借用：它以不可变方式借用 <code>x</code> ，但像可变借用一样，必须是唯一的。
在上面的示例中，取消注释 <code>y</code> 的声明将导致错误，因为它将违反闭包对 <code>x</code> 的借用的唯一性； <code>z</code> 的声明是有效的，因为闭包的生命周期在块的末尾已过期，释放了借用。</p>
<h2 id="调用trait和类型强制转换"><a class="header" href="#调用trait和类型强制转换">调用trait和类型强制转换</a></h2>
<p>闭包类型都实现了 <a href="types/../../std/ops/trait.FnOnce.html"><code>FnOnce</code></a> ，表示它们可以通过消费闭包所有权来被调用一次。此外，一些闭包还实现了更具体的调用 trait:</p>
<ul>
<li>一个不会移动任何捕获变量的闭包实现了 <a href="types/../../std/ops/trait.FnMut.html"><code>FnMut</code></a> ，表示它可以通过可变引用来调用。</li>
<li>一个不会修改或移动捕获变量的闭包实现了 <a href="types/../../std/ops/trait.Fn.html"><code>Fn</code></a> ，表示它可以通过共享引用来调用。</li>
</ul>
<blockquote>
<p>注意: <code>move</code> 闭包仍然可能实现 <a href="types/../../std/ops/trait.Fn.html"><code>Fn</code></a> 或 <a href="types/../../std/ops/trait.FnMut.html"><code>FnMut</code></a> ，即使它们通过移动捕获变量。
这是因为闭包类型实现的trait是由闭包对捕获值的操作方式决定的，而不是它们如何捕获它们。</p>
</blockquote>
<p><em>非捕获闭包</em> 是不从其环境捕获任何内容的闭包。它们可以强制转换为与匹配签名的函数指针 (例如, <code>fn()</code> ) 。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let add = |x, y| x + y;

let mut x = add(5,7);

type Binop = fn(i32, i32) -&gt; i32;
let bo: Binop = add;
x = bo(5,7);
<span class="boring">}</span></code></pre></pre>
<h2 id="其他-traits"><a class="header" href="#其他-traits">其他 traits</a></h2>
<p>所有闭包类型都实现了 <a href="types/../special-types-and-traits.html#sized"><code>Sized</code></a> 。此外，如果允许所存储的捕获类型这样做，则闭包类型会实现以下 traits：</p>
<ul>
<li><a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a></li>
<li><a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a></li>
<li><a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a></li>
<li><a href="types/../special-types-and-traits.html#send"><code>Send</code></a></li>
</ul>
<p><a href="types/../special-types-and-traits.html#send"><code>Send</code></a> 和 <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a> 的规则与普通结构体类型相同，而 <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a> 和 <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a> 的行为则类似于 <a href="https://doc.rust-lang.org/reference/items/derive.html">衍生</a> 。
对于 <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a> ，复制捕获变量的顺序未指定。</p>
<p>由于捕获通常是通过引用进行的，因此会出现以下一般规则:</p>
<ul>
<li>如果所有捕获的变量都是 <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a> ，则闭包是 <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a> 的。</li>
<li>如果所有非唯一不可变引用捕获的变量都是 <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a> ，并且所有唯一不可变或可变引用、复制或移动捕获的值都是 <a href="types/../special-types-and-traits.html#send"><code>Send</code></a> ，则闭包是 <a href="types/../special-types-and-traits.html#send"><code>Send</code></a> 的。</li>
<li>如果闭包未通过唯一不可变或可变引用捕获任何值，并且它通过复制或移动捕获的所有值都是 <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a> 或 <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a> 的，则闭包是 <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a> 或 <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a> 的。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="指针类型"><a class="header" href="#指针类型">指针类型</a></h1>
<p>所有指针都是显式的一等值。它们可以移动或复制，存储到数据结构中，并从函数返回。</p>
<h2 id="引用--和-mut"><a class="header" href="#引用--和-mut">引用 (<code>&amp;</code> 和 <code>&amp;mut</code>)</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>引用类型</em> :<br />
   <code>&amp;</code> <a href="types/../trait-bounds.html"><em>生命周期</em></a><sup>?</sup> <code>mut</code><sup>?</sup> <a href="types/../types.html#type-expressions"><em>无约束类型组</em></a></p>
</blockquote>
<h3 id="共享引用-"><a class="header" href="#共享引用-">共享引用 (<code>&amp;</code>)</a></h3>
<p>共享引用指向由某个其他值拥有的内存。创建一个值的共享引用时，它会防止直接修改该值。 <a href="types/../interior-mutability.html">内部可变性</a> 在某些情况下提供了一个例外。
顾名思义，可能存在对一个值的任意数量的共享引用。共享引用类型写作 <code>&amp;type</code> ，或者在需要指定显式生命周期时写作 <code>&amp;'a type</code> 。
复制引用是一个 &quot;浅层&quot; 操作：它只涉及到指针本身的复制，也就是说，指针是 <code>Copy</code> 的。
释放引用对它所指向的值没有影响，但引用 <a href="types/../expressions.html#temporaries">临时值</a> 将在引用本身的作用域中保持其活动状态。</p>
<h3 id="可变引用-mut"><a class="header" href="#可变引用-mut">可变引用 (<code>&amp;mut</code>)</a></h3>
<p>可变引用指向由某个其他值拥有的内存。可变引用类型写作 <code>&amp;mut type</code> 或 <code>&amp;'a mut type</code> 。可变引用 (未被借用的) 是访问它所指向的值的唯一方式，因此不是 <code>Copy</code> 。</p>
<h2 id="原始指针-const-and-mut"><a class="header" href="#原始指针-const-and-mut">原始指针 (<code>*const</code> and <code>*mut</code>)</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>原始指针类型</em> :<br />
   <code>*</code> ( <code>mut</code> | <code>const</code> ) <a href="types/../types.html#type-expressions"><em>无约束类型组</em></a></p>
</blockquote>
<p>原始指针是没有安全性或生存性保证的指针。原始指针写作 <code>*const T</code> 或 <code>*mut T</code> 。
例如， <code>*const i32</code> 意味着一个指向 32 位整数的原始指针。复制或丢弃原始指针不会对任何其他值的生命周期产生影响。
解引用原始指针是一个 <a href="types/../unsafety.html"><code>unsafe</code> 操作</a> 。这也可以用于通过重新借用它 (<code>&amp;*</code> 或 <code>&amp;mut *</code>) 将原始指针转换为引用。
通常不建议使用原始指针；其存在是为了支持与外部代码的互操作性，以及编写关键性能或低级别的函数。</p>
<p>当比较原始指针时，是通过它们的地址进行比较，而不是通过它们所指向的内容进行比较。当将原始指针与 <a href="types/../dynamically-sized-types.html">动态大小类型</a> 进行比较时，它们还会比较它们的附加数据。</p>
<p>可以使用 <a href="types/../../core/ptr/macro.addr_of.html"><code>core::ptr::addr_of!</code></a> 创建 <code>*const</code> 指针和 <a href="types/../../core/ptr/macro.addr_of_mut.html"><code>core::ptr::addr_of_mut!</code></a> 创建 <code>*mut</code> 指针来直接创建原始指针。</p>
<h2 id="智能指针"><a class="header" href="#智能指针">智能指针</a></h2>
<p>标准库包含除了引用和原始指针之外的其他 '智能指针' 类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数指针类型"><a class="header" href="#函数指针类型">函数指针类型</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>裸函数类型</em> :<br />
   <a href="types/../trait-bounds.html#higher-ranked-trait-bounds"><em>对于生命周期组</em></a><sup>?</sup> <em>函数类型限定符组</em> <code>fn</code><br />
       <code>(</code> <em>函数参数可能命名为可变参数</em><sup>?</sup> <code>)</code> <em>裸函数返回类型</em><sup>?</sup></p>
<p><em>函数类型限定符组</em>:<br />
   <code>unsafe</code><sup>?</sup> (<code>extern</code> <a href="types/../items/functions.html"><em>Abi</em></a><sup>?</sup>)<sup>?</sup></p>
<p><em>裸函数返回类型</em>:<br />
   <code>-&gt;</code> <a href="types/../types.html#type-expressions"><em>TypeNoBounds</em></a></p>
<p><em>函数参数可能命名为可变参数</em> :<br />
   <em>可能命名函数参数组</em> | <em>可能命名函数参数可变</em></p>
<p><em>可能命名函数参数组</em> :<br />
   <em>可能命名函数参数</em> ( <code>,</code> <em>可能命名函数参数</em> )<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>可能命名函数参数</em> :<br />
   <a href="types/../attributes.html"><em>外部属性</em></a><sup>*</sup> ( ( <a href="types/../identifiers.html">标识符</a> | <code>_</code> ) <code>:</code> )<sup>?</sup> <a href="types/../types.html#type-expressions"><em>类型</em></a></p>
<p><em>可能命名函数参数可变</em> :<br />
   ( <em>可能命名函数参数</em> <code>,</code> )<sup>*</sup> <em>可能命名函数参数</em> <code>,</code> <a href="types/../attributes.html"><em>外部属性</em></a><sup>*</sup> <code>...</code></p>
</blockquote>
<p>函数指针类型，用 <code>fn</code> 关键字表示，用来引用一个函数，该函数的身份不一定在编译时已知。
它们可以通过从 <a href="types/function-item.html">函数条目</a> 和无捕获的 <a href="types/closure.html">闭包</a> 进行强制转换来创建。</p>
<p><code>unsafe</code> 修饰符表示该类型的值是一个 <a href="types/../unsafe-keyword.html">不安全的函数</a> ，而 <code>extern</code> 修饰符表示它是一个 <a href="types/../items/functions.html#extern-function-qualifier">外部函数</a> 。</p>
<p>可变参数只能在使用了 <code>&quot;C&quot;</code> 或 <code>&quot;cdecl&quot;</code> 调用约定的 <a href="types/../items/external-blocks.html"><code>extern</code></a> 函数类型中指定。</p>
<p>下面是一个例子，其中 <code>Binop</code> 被定义为函数指针类型:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x: i32, y: i32) -&gt; i32 {
    x + y
}

let mut x = add(5,7);

type Binop = fn(i32, i32) -&gt; i32;
let bo: Binop = add;
x = bo(5,7);
<span class="boring">}</span></code></pre></pre>
<h2 id="函数指针参数上的属性"><a class="header" href="#函数指针参数上的属性">函数指针参数上的属性</a></h2>
<p>函数指针参数上的属性遵循与 <a href="types/../items/functions.html#attributes-on-function-parameters">常规函数参数</a> 相同的规则和限制。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-对象"><a class="header" href="#trait-对象">Trait 对象</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>Trait对象类型</em> :<br />
   <code>dyn</code><sup>?</sup> [<em>类型参数约束组</em>]</p>
<p><em>Trait对象类型1约束</em> :<br />
   <code>dyn</code><sup>?</sup> <a href="types/../trait-bounds.html"><em>Trait约束</em></a></p>
</blockquote>
<p>一个 <em>trait 对象</em> 是另一个类型的不透明值，该类型实现了一组 trait 。trait 集由一个 <a href="types/../items/traits.html#object-safety">object safe</a> 的 <em>base trait</em> 和任意数量的 [auto trait] 组成。</p>
<p>Trait 对象实现了 base trait ，它的 auto traits 以及 base trait 的任何 <a href="types/../items/traits.html#supertraits">超级 Trait</a> 。</p>
<p>Trait 对象写作关键字 <code>dyn</code> 后跟一组 trait 约束 ，但对 trait 约束有以下限制。
除了第一个 trait 之外的所有 trait 都必须是 auto trait ，不能有多个 lifetime ，并且不允许 opt-out bounds (例如 <code>?Sized</code> )。
此外，路径到 traits 可以括在括号中。</p>
<p>例如，给定 <code>Trait</code> ，以下都是 trait 对象:</p>
<ul>
<li><code>dyn Trait</code></li>
<li><code>dyn Trait + Send</code></li>
<li><code>dyn Trait + Send + Sync</code></li>
<li><code>dyn Trait + 'static</code></li>
<li><code>dyn Trait + Send + 'static</code></li>
<li><code>dyn Trait +</code></li>
<li><code>dyn 'static + Trait</code>.</li>
<li><code>dyn (Trait)</code></li>
</ul>
<blockquote>
<p><strong>版本差异</strong>: 在 2021 版之前，可以省略 <code>dyn</code> 关键字。</p>
<p>注意: 为了清晰起见，建议在您的 trait 对象上始终使用 <code>dyn</code> 关键字，除非您的代码库支持使用 Rust 1.26 或更低版本进行编译。</p>
</blockquote>
<blockquote>
<p><strong>版本差异</strong>: 在 2015 版中，如果 trait 对象的第一个限定是以 <code>::</code> 开头的路径，那么 <code>dyn</code> 将被视为路径的一部分。您可以将第一个路径放在括号中来解决这个问题。
因此，如果您想要一个带有 trait <code>::your_module::Trait</code> 的 trait 对象，您应该将其写为 <code>dyn (::your_module::Trait)</code> 。</p>
<p>从 2018 版开始， <code>dyn</code> 是一个真正的关键字，不允许在路径中使用，因此不需要括号。</p>
</blockquote>
<p>如果 base trait 相互为别名， auto trait 集相同且生命周期约束相同，则两个 trait 对象类型为别名。例如， <code>dyn Trait + Send + UnwindSafe</code> 与 <code>dyn Trait + UnwindSafe + Send</code> 是相同的。</p>
<p>由于值的具体类型的不透明性，trait对象是 [动态大小类型] 。与所有 <abbr title="dynamically sized types">DSTs</abbr> 一样，trait 对象在某种类型的指针后面使用，例如 <code>&amp;dyn SomeTrait</code> 或 <code>Box&lt;dyn SomeTrait&gt;</code> 。
指向 trait 对象的指针实例包括：</p>
<ul>
<li>指向实现 <code>SomeTrait</code> 的类型 <code>T</code> 的实例的指针</li>
<li>虚方法表 (通常简称为 <em>vtable</em> ) ，它包含对于 <code>T</code> 实现的每个方法及其 <a href="types/../items/traits.html#supertraits">超级 Trait</a> ，指向 <code>T</code> 的实现 (即函数指针) 的指针。</li>
</ul>
<p>Trait 对象的目的是允许方法的 &quot;晚期绑定&quot; 。在 Trait 对象上调用方法会导致运行时的虚拟调度：也就是说，函数指针从 Trait 对象的 vtable 中加载，并间接调用。每个 vtable 条目的实际实现可以在基于对象的基础上变化。</p>
<p>Trait 对象的一个例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021">trait Printable {
    fn stringify(&amp;self) -&gt; String;
}

impl Printable for i32 {
    fn stringify(&amp;self) -&gt; String { self.to_string() }
}

fn print(a: Box&lt;dyn Printable&gt;) {
    println!(&quot;{}&quot;, a.stringify());
}

fn main() {
    print(Box::new(10) as Box&lt;dyn Printable&gt;);
}</code></pre></pre>
<p>在这个例子中，trait <code>Printable</code> 出现在 <code>print</code> 函数的类型签名和 <code>main</code> 函数中的转换表达式中，表示它们都是 trait 对象。</p>
<h2 id="trait-对象的生命周期约束"><a class="header" href="#trait-对象的生命周期约束">Trait 对象的生命周期约束</a></h2>
<p>由于 Trait 对象可以包含引用，因此这些引用的生命周期需要作为 Trait 对象的一部分表示。这个生命周期的写法是 <code>Trait + 'a</code> 。有一些 <a href="types/../lifetime-elision.html#default-trait-object-lifetimes">默认值</a> 可以允许此生命周期通常被推断为一个合理的选择。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait"><a class="header" href="#impl-trait">Impl trait</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>ImplTrait类型</em> : <code>impl</code> <a href="types/../trait-bounds.html"><em>类型参数约束组</em></a></p>
<p><em>ImplTrait类型1约束</em> : <code>impl</code> <a href="types/../trait-bounds.html"><em>Trait约束</em></a></p>
</blockquote>
<p><code>impl Trait</code> 提供了一种方式来指定未命名但具体实现了特定 trait 的类型。
它可以出现在两种位置: 参数位置 (在这里它可以作为函数的匿名类型参数) ，以及返回位置 (在这里它可以作为抽象的返回类型) 。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}
<span class="boring">impl Trait for () {}
</span>
// 参数位置: 匿名类型参数
fn foo(arg: impl Trait) {
}

// 返回值位置: 抽象返回类型
fn bar() -&gt; impl Trait {
}
<span class="boring">}</span></code></pre></pre>
<h2 id="匿名类型参数"><a class="header" href="#匿名类型参数">匿名类型参数</a></h2>
<blockquote>
<p>注意: 这经常被称为 &quot;参数位置的impl Trait&quot;。 (这里更准确的术语是 &quot;参数&quot;，但 &quot;参数位置的impl Trait&quot; 是这个特性开发期间使用的措辞，而且它仍然在实现的某些部分中保留着。)</p>
</blockquote>
<p>函数可以使用 <code>impl</code> ，后面跟一组 trait bound，来声明一个参数为匿名类型。调用方必须提供一个满足匿名类型参数所声明的 trait bound 的类型，而函数只能使用匿名类型参数的 trait bound 可用的方法。</p>
<p>例如，以下这两种形式几乎是等价的:</p>
<pre><code class="language-rust ignore">trait Trait {}

// 泛型类型参数
fn foo&lt;T: Trait&gt;(arg: T) {
}

// impl Trait 作为函数参数的匿名类型参数
fn foo(arg: impl Trait) {
}</code></pre>
<p>换句话说， <code>impl Trait</code> 作为函数参数是一种语法糖，用于泛型类型参数 <code>&lt;T: Trait&gt;</code> ，只不过该类型是匿名的并且不出现在 <a href="types/../items/generics.html"><em>GenericParams</em></a> 列表中。</p>
<blockquote>
<p><strong>注意：</strong>
对于函数参数而言，泛型类型参数和 <code>impl Trait</code> 并不完全等效。
对于泛型参数如 <code>&lt;T: Trait&gt;</code> ，调用方可以在调用时使用 <a href="types/../paths.html#paths-in-expressions"><em>GenericArgs</em></a> 显式指定 <code>T</code> 的泛型参数，例如 <code>foo::&lt;usize&gt;(1)</code> 。
如果 <code>impl Trait</code> 是 <em>任何</em> 函数参数的类型，那么调用方在调用该函数时永远不能提供任何泛型参数。
这包括返回类型或任何常量泛型参数。</p>
<p>因此，从其中一个函数签名更改到另一个函数签名可能会对函数的调用方构成破坏性更改。</p>
</blockquote>
<h2 id="抽象返回类型"><a class="header" href="#抽象返回类型">抽象返回类型</a></h2>
<blockquote>
<p>注意: 这通常被称为 &quot;返回位置的 impl Trait&quot; 。</p>
</blockquote>
<p>函数可以使用 <code>impl Trait</code> 返回一个抽象返回类型。这些类型可以代表另一个具体类型，其中调用者只能使用指定 <code>Trait</code> 声明的方法。
函数的每个可能的返回值必须解析为相同的具体类型。返回位置的 <code>impl Trait</code> 允许函数返回未装箱的抽象类型。
这在处理 <a href="types/closure.html">闭包</a> 和 迭代器时特别有用。</p>
<p>例如，闭包具有独特的、无法重写的类型。以前，从函数返回闭包的唯一方法是使用 <a href="types/trait-object.html">trait 对象</a> ：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}</span></code></pre></pre>
<p>这可能会导致堆分配和动态分派的性能惩罚。
无法完全指定闭包的类型，只能使用 <code>Fn</code> trait。
这意味着 trait 对象是必需的。
但是，使用 <code>impl Trait</code> 可以更简单地编写此代码:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}
<span class="boring">}</span></code></pre></pre>
<p>这也避免了使用装箱 trait 对象的缺点。</p>
<p>同样，迭代器的具体类型可能变得非常复杂，包含了链中所有先前迭代器的类型。
返回 <code>impl Iterator</code> 意味着函数只公开 <code>Iterator</code> trait 作为其返回类型的限制，而不是明确指定涉及的所有其他迭代器类型。</p>
<h3 id="泛型和-impl-trait-在返回位置的差异"><a class="header" href="#泛型和-impl-trait-在返回位置的差异">泛型和 <code>impl Trait</code> 在返回位置的差异</a></h3>
<p>在参数位置上， <code>impl Trait</code> 在语义上与泛型类型参数非常相似。
然而，在返回位置上，两者之间存在显著的差异。
使用 <code>impl Trait</code> ，与泛型类型参数不同，函数选择返回类型，调用者无法选择返回类型。</p>
<p>该函数：</p>
<pre><code class="language-rust ignore">fn foo&lt;T: Trait&gt;() -&gt; T {</code></pre>
<p>允许调用者确定返回类型 <code>T</code> ，并且函数返回该类型。</p>
<p>该函数：</p>
<pre><code class="language-rust ignore">fn foo() -&gt; impl Trait {</code></pre>
<p>不允许调用者确定返回类型。相反，函数选择返回类型，但只承诺它将实现 <code>Trait</code> 。</p>
<h2 id="限制-2"><a class="header" href="#限制-2">限制</a></h2>
<p><code>impl Trait</code> 只能出现在自由函数或固有函数的参数或返回类型中。它不能出现在 trait 的实现内部，也不能是 let 绑定的类型或出现在类型别名中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型参数"><a class="header" href="#类型参数">类型参数</a></h1>
<p>在具有类型参数声明的条目的主体内部，其类型参数名称是类型:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 定义了一个泛型函数 to_vec，其类型参数为 A，它要求 A 类型实现了 Clone trait
fn to_vec&lt;A: Clone&gt;(xs: &amp;[A]) -&gt; Vec&lt;A&gt; {
    // 如果 xs 数组为空，则直接返回空的 Vec
    if xs.is_empty() {
        return vec![];
    }
    // 定义变量 first，它的类型是 A，它的值是 xs 数组的第一个元素的克隆
    let first: A = xs[0].clone();
    // 定义变量 rest，它的类型是 Vec&lt;A&gt;，它的值是调用 to_vec 函数得到的结果，
    // 参数是 xs 数组的第 2 个元素到最后一个元素组成的切片。
    let mut rest: Vec&lt;A&gt; = to_vec(&amp;xs[1..]);
    // 在 rest 的开头插入 first 元素
    rest.insert(0, first);
    // 返回更新后的 rest
    rest
}
<span class="boring">}</span></code></pre></pre>
<p>这里， <code>first</code> 的类型为 <code>A</code> ，它引用了 <code>to_vec</code> 的类型参数 <code>A</code> ; <code>rest</code> 的类型为 <code>Vec&lt;A&gt;</code> ，即元素类型为 <code>A</code> 的向量。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="推断类型"><a class="header" href="#推断类型">推断类型</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>推断类型</em> : <code>_</code></p>
</blockquote>
<p>推断类型是通过周围可用信息让编译器尽可能地推断类型。它不能用于条目签名中。通常在泛型参数中使用:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Vec&lt;_&gt; = (0..10).collect();
<span class="boring">}</span></code></pre></pre>
<!--
  What else should be said here?
  The only documentation I am aware of is https://rustc-dev-guide.rust-lang.org/type-inference.html
  There should be a broader discussion of type inference somewhere.
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="动态大小类型"><a class="header" href="#动态大小类型">动态大小类型</a></h1>
<p>大多数类型在编译时具有固定的大小并实现了 <a href="special-types-and-traits.html#sized"><code>Sized</code></a> trait。大小仅在运行时已知的类型称为 <em>动态大小类型</em> (<em>DST</em>) 或非大小类型 。
<a href="types/slice.html">切片</a> 和 <a href="types/trait-object.html">trait 对象</a> 是两个 <abbr title="动态大小类型">DSTs</abbr> 的例子。这样的类型只能在某些情况下使用：</p>
<ul>
<li>指向 <abbr title="动态大小类型">DSTs</abbr> 的指针类型是有大小的，但大小是指向大小类型的指针的两倍。
<ul>
<li>指向切片的指针还会存储切片的元素数量。</li>
<li>指向 trait 对象的指针还会存储指向虚表的指针。</li>
</ul>
</li>
<li>可以将 <abbr title="动态大小类型">DSTs</abbr> 作为类型参数提供给具有特殊 <code>?Sized</code> 绑定的泛型类型参数。当相应的关联类型声明具有 <code>?Sized</code> 绑定时，它们还可用于关联类型定义。默认情况下，除非使用 <code>?Sized</code> 来放宽，否则任何类型参数或关联类型都具有 <code>Sized</code> 绑定。</li>
<li>trait可以为 <abbr title="动态大小类型">DSTs</abbr> 实现。与泛型类型参数不同，在 trait 定义中，默认情况下 <code>Self: ?Sized</code> 。</li>
<li>结构体可能包含一个 <abbr title="动态大小类型">DST</abbr> 作为最后一个字段；这使得结构体本身成为了 <abbr title="动态大小类型">DST</abbr> 。</li>
</ul>
<blockquote>
<p><strong>注意</strong>: <a href="variables.html">变量</a> 、函数参数、<a href="items/constant-items.html">const</a> 条目和 <a href="items/static-items.html">static</a> 条目必须是 <code>Sized</code> 。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型布局"><a class="header" href="#类型布局">类型布局</a></h1>
<p>一个类型的布局包括其大小、对齐方式以及其字段的相对偏移量。
对于枚举类型，判别标志的布局和解释方式也是类型布局的一部分。
每次编译都可以更改类型布局。为了避免尝试记录确切的变化，我们只记录目前的可以保证的部分。</p>
<h2 id="大小和对齐"><a class="header" href="#大小和对齐">大小和对齐</a></h2>
<p>所有的值都有一个对齐和大小。</p>
<p>一个值的 <em>对齐</em> 决定了存储这个值的地址必须是什么样的，一个对齐值为 <code>n</code> 的值必须存储在地址是 <code>n</code> 的倍数的位置上。
例如，对齐值为 2 的值必须存储在偶数地址上，而对齐值为 1 的值可以存储在任何地址上。
对齐值以字节为单位衡量，必须至少为 1 ，而且始终是 2 的幂次方。可以使用 <a href="../std/mem/fn.align_of_val.html"><code>align_of_val</code></a> 函数检查一个值的对齐方式。</p>
<p>一个值的 <em>大小</em> 是数组中具有该条目类型的连续元素之间的字节偏移，包括对齐填充。一个值的大小始终是它的对齐值的倍数。
请注意，某些类型的大小为零； 0 被认为是任何对齐值的倍数 (例如，在某些平台上，类型 <code>[u16; 0]</code> 的大小为 0 ，对齐值为 2 )。可以使用 <a href="../std/mem/fn.size_of_val.html"><code>size_of_val</code></a> 函数检查一个值的大小。</p>
<p>所有值都具有相同大小和对齐的类型实现了 <a href="../std/marker/trait.Sized.html"><code>Sized</code></a> trait，并可以使用 <a href="../std/mem/fn.size_of.html"><code>size_of</code></a> 和 <a href="../std/mem/fn.align_of.html"><code>align_of</code></a> 函数进行检查。
那些不是 <a href="../std/marker/trait.Sized.html"><code>Sized</code></a> 的类型称为 <a href="dynamically-sized-types.html">动态大小类型</a> 。由于所有 <code>Sized</code> 类型的值都共享相同的大小和对齐，因此我们将这些共享值称为类型的大小和类型的对齐值。</p>
<h2 id="原始数据布局"><a class="header" href="#原始数据布局">原始数据布局</a></h2>
<p>这张表格给出了大多数原始类型的大小。</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th><code>size_of::&lt;Type&gt;()</code></th></tr></thead><tbody>
<tr><td><code>bool</code></td><td>1</td></tr>
<tr><td><code>u8</code> / <code>i8</code></td><td>1</td></tr>
<tr><td><code>u16</code> / <code>i16</code></td><td>2</td></tr>
<tr><td><code>u32</code> / <code>i32</code></td><td>4</td></tr>
<tr><td><code>u64</code> / <code>i64</code></td><td>8</td></tr>
<tr><td><code>u128</code> / <code>i128</code></td><td>16</td></tr>
<tr><td><code>f32</code></td><td>4</td></tr>
<tr><td><code>f64</code></td><td>8</td></tr>
<tr><td><code>char</code></td><td>4</td></tr>
</tbody></table>
</div>
<p><code>usize</code> 和 <code>isize</code> 的大小足以包含目标平台上的每个地址。例如，在 32 位目标平台上，它的大小为 4 个字节，在 64 位目标平台上，它的大小为 8 个字节。</p>
<p>大多数基本数据类型的对齐方式通常是按照它们的大小对齐的，尽管这是平台特定的行为。特别地，在 x86 架构下， <code>u64</code> 和 <code>f64</code> 仅按照 32 位对齐。</p>
<h2 id="指针和引用的布局"><a class="header" href="#指针和引用的布局">指针和引用的布局</a></h2>
<p>指针和引用具有相同的布局。指针或引用的可变性不会改变其布局。指向有大小的类型的指针与 <code>usize</code> 具有相同的大小和对齐方式。
指向无大小的类型的指针是有大小的。其大小和对齐方式保证至少等于一个指针的大小和对齐方式。</p>
<blockquote>
<p>注意: 虽然您不应该依赖此信息，但是所有指向动态大小类型的指针目前都是 <code>usize</code> 大小的两倍，并具有相同的对齐方式。</p>
</blockquote>
<h2 id="数组布局"><a class="header" href="#数组布局">数组布局</a></h2>
<p>一个 <code>[T; N]</code> 的数组大小为 <code>size_of::&lt;T&gt;() * N</code> ，并且具有与 <code>T</code> 相同的对齐方式。
数组的布局使得从零开始的第 <code>n</code> 个元素相对于数组的起始位置偏移了 <code>n * size_of::&lt;T&gt;()</code> 字节。</p>
<h2 id="切片布局"><a class="header" href="#切片布局">切片布局</a></h2>
<p>切片的布局与它们切片的数组部分相同。</p>
<blockquote>
<p>注意: 这是关于原始 <code>[T]</code> 类型的，而不是指向切片的指针 (<code>&amp;[T]</code> ， <code>Box&lt;[T]&gt;</code> 等) 。</p>
</blockquote>
<h2 id="str-的布局"><a class="header" href="#str-的布局"><code>str</code> 的布局</a></h2>
<p>字符串切片是字符的 UTF-8 表示，其布局与类型为 <code>[u8]</code> 的切片相同。</p>
<h2 id="元组布局"><a class="header" href="#元组布局">元组布局</a></h2>
<p>元组的布局遵循 <a href="type-layout.html#the-default-representation">默认表示</a> 。</p>
<p>例外情况是空元组 (<code>()</code>) ，它被保证作为零大小的类型，大小为 0 ，对齐为 1 。</p>
<h2 id="trait-object-布局"><a class="header" href="#trait-object-布局">Trait Object 布局</a></h2>
<p>Trait 对象的布局与其包含的值相同。</p>
<blockquote>
<p>注意: 这里是指原始的 Trait Object 类型，而不是指指针 (如 <code>&amp;dyn Trait</code> 、 <code>Box&lt;dyn Trait&gt;</code> 等) 到 Trait Object 的类型。</p>
</blockquote>
<h2 id="闭包的布局"><a class="header" href="#闭包的布局">闭包的布局</a></h2>
<p>闭包没有布局的保证。</p>
<h2 id="表示形式"><a class="header" href="#表示形式">表示形式</a></h2>
<p>所有用户定义的复合类型 ( <code>struct</code> 、 <code>enum</code> 和 <code>union</code> ) 都有一个 <em>表示形式</em> ，用于指定类型的布局。
类型的可能表示形式包括:</p>
<ul>
<li><a href="type-layout.html#the-default-representation">默认</a></li>
<li><a href="type-layout.html#the-c-representation"><code>C</code></a></li>
<li><a href="type-layout.html#primitive-representations">原始表示形式</a></li>
<li><a href="type-layout.html#the-transparent-representation"><code>transparent</code></a></li>
</ul>
<p>可以通过在类型上应用 <code>repr</code> 属性来更改类型的表示形式。以下示例显示具有 <code>C</code> 表示形式的结构体。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct ThreeInts {
    first: i16,
    second: i8,
    third: i32
}
<span class="boring">}</span></code></pre></pre>
<p>通过 <code>align</code> 和 <code>packed</code> 修饰符可以分别提高或降低对齐方式。
它们会修改属性中指定的表示方式。如果未指定表示方式，则修改默认表示方式。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 默认的表示，对齐方式被降低到 2。
#[repr(packed(2))]
struct PackedStruct {
    first: i16,
    second: i8,
    third: i32
}

// C 表示，对齐方式被提高到 8。
#[repr(C, align(8))]
struct AlignedStruct {
    first: i16,
    second: i8,
    third: i32
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>注意: 由于表示是条目的属性，表示不依赖于泛型参数。任何两个具有相同名称的类型都具有相同的表示。例如， <code>Foo&lt;Bar&gt;</code> 和 <code>Foo&lt;Baz&gt;</code> 都具有相同的表示。</p>
</blockquote>
<p>类型的表示可以改变字段之间的填充，但不会改变字段本身的布局。例如，具有 <code>C</code> 表示的结构体中包含具有默认表示的结构体 <code>Inner</code> ，不会改变 <code>Inner</code> 的布局。</p>
<h3 id="默认表示形式"><a class="header" href="#默认表示形式">默认表示形式</a></h3>
<p>没有 <code>repr</code> 属性的名义类型采用默认表示形式。非正式地说，这个表示形式也被称为 <code>rust</code> 表示形式。此表示形式所做的唯一数据布局保证是为了保持正确性。它们是:</p>
<ol>
<li>字段对齐正确。</li>
<li>字段不重叠。</li>
<li>类型的对齐方式至少是其字段的最大对齐方式。</li>
</ol>
<p>严格地说，第一个保证意味着任何字段的偏移量都是该字段的对齐方式的倍数。
第二个保证意味着可以对字段进行排序，使得任何字段的偏移量加上其大小小于或等于排序中下一个字段的偏移量。排序不必与在类型声明中指定字段的顺序相同。</p>
<p>请注意，第二个保证并不意味着字段具有不同的地址: 零大小类型可能与结构中其他字段具有相同的地址。</p>
<p>此表示形式没有其他数据布局保证。</p>
<h3 id="c-表示形式"><a class="header" href="#c-表示形式"><code>C</code> 表示形式</a></h3>
<p><code>C</code> 表示形式旨在实现两个目的。一个目的是创建可与 C 语言互操作的类型，另一个目的是创建可以对其执行依赖于数据布局的操作 (如将值重新解释为不同类型) 的类型。
由于这个双重目的，可以创建对于与 C 编程语言进行接口编程无用的类型。</p>
<p>这个表示形式可以应用于结构体、联合体和枚举。但是，<a href="items/enumerations.html#zero-variant-enums">空变体枚举</a> 不支持 <code>C</code> 表示。</p>
<h4 id="reprc-结构体"><a class="header" href="#reprc-结构体"><code>#[repr(C)]</code> 结构体</a></h4>
<p>结构体的对齐方式是其中对齐要求最高的字段的对齐方式。</p>
<p>字段的大小和偏移量由以下算法决定。</p>
<p>将当前偏移量初始化为 0 字节。</p>
<p>对于结构体中的每个字段，按照声明顺序，首先确定字段的大小和对齐方式。
如果当前偏移量不是字段对齐要求的倍数，则添加填充字节，直到当前偏移量是字段对齐要求的倍数。
字段的偏移量是当前偏移量。然后增加当前偏移量的大小。</p>
<p>最后，结构体的大小是将当前偏移量向上舍入到结构体对齐方式的最接近的倍数。</p>
<p>以下是这个算法的伪代码描述。</p>
<!-- ignore: pseudocode -->
<pre><code class="language-rust ignore">/// 返回在偏移 `offset` 之后需要的填充量，以确保以下地址将对齐到 `alignment`。
fn padding_needed_for(offset: usize, alignment: usize) -&gt; usize {
    let misalignment = offset % alignment;
    if misalignment &gt; 0 {
        // 向上舍入到下一个 `alignment` 的倍数
        alignment - misalignment
    } else {
        // 已经是 `alignment` 的倍数
        0
    }
}

// 计算结构体中最大字段的对齐方式，作为结构体自身的对齐方式
struct.alignment = struct.fields().map(|field| field.alignment).max();

let current_offset = 0;

for field in struct.fields_in_declaration_order() {
    // 增加当前偏移量，使其成为此字段的对齐方式的倍数。对于第一个字段，这将始终为零。
    // 被跳过的字节称为填充字节。
    current_offset += padding_needed_for(current_offset, field.alignment);

    struct[field].offset = current_offset;

    current_offset += field.size;
}

// 结构体的大小为当前偏移量加上在此处添加的填充量，以确保结构体整体对齐到 `alignment` 的倍数
struct.size = current_offset + padding_needed_for(current_offset, struct.alignment);</code></pre>
<div class="warning">
<p>警告：此伪代码使用一种简单算法，为了清晰起见忽略了溢出问题。为了在实际代码中执行内存布局计算，请使用 <a href="../std/alloc/struct.Layout.html"><code>Layout</code></a> 。</p>
</div>
<blockquote>
<p>注意: 此算法可能会产生大小为零的结构体。在 C 中，像 <code>struct Foo { }</code> 这样的空结构体声明是不合法的。
但是，gcc 和 clang 都支持启用这样的结构体，并将它们分配为大小为零。
相比之下，C++ 给空结构体赋予大小为 1 ，除非它们是从其他结构体继承而来的，或者它们是带有 <code>[[no_unique_address]]</code> 属性的字段，在这种情况下，它们不会增加结构体的整体大小。</p>
</blockquote>
<h4 id="reprc-联合体"><a class="header" href="#reprc-联合体"><code>#[repr(C)]</code> 联合体</a></h4>
<p>使用 <code>#[repr(C)]</code> 声明的联合体将与目标平台上等效的 C 语言联合体声明具有相同的大小和对齐方式。
该联合体的大小将是其所有字段的最大大小舍入为其对齐方式，其对齐方式将是其所有字段的最大对齐方式。这些最大值可以来自不同的字段。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
union Union {
    f1: u16,
    f2: [u8; 4],
}

assert_eq!(std::mem::size_of::&lt;Union&gt;(), 4);  // 来自 f2
assert_eq!(std::mem::align_of::&lt;Union&gt;(), 2); // 来自 f1

#[repr(C)]
union SizeRoundedUp {
   a: u32,
   b: [u16; 3],
}

assert_eq!(std::mem::size_of::&lt;SizeRoundedUp&gt;(), 8);  // 大小为 6，来自 b，舍入为 8，来自 a 的对齐
assert_eq!(std::mem::align_of::&lt;SizeRoundedUp&gt;(), 4); // 来自 a
<span class="boring">}</span></code></pre></pre>
<h4 id="reprc-无字段的枚举"><a class="header" href="#reprc-无字段的枚举"><code>#[repr(C)]</code> 无字段的枚举</a></h4>
<p>对于 <a href="items/enumerations.html#field-less-enum">无字段的枚举</a> ，其 <code>C</code> 表示具有目标平台 C ABI 的默认 <code>enum</code> 大小和对齐方式。</p>
<blockquote>
<p>注意：C 中的枚举表示是实现定义的，因此这只是一个 &quot;最佳猜测&quot; 。特别地，当所关注的 C 代码使用某些标志编译时，这可能是不正确的。</p>
</blockquote>
<div class="warning">
<p>警告：C 语言中的 <code>enum</code> 和 Rust 的 <a href="items/enumerations.html#field-less-enum">无字段的枚举</a> 在这种表示方式下存在关键差异。
在 C 中，<code>enum</code> 主要是一个 <code>typedef</code> 加上一些命名常量；换句话说， <code>enum</code> 类型的对象可以容纳任何整数值。
例如，在 <code>C</code> 中，这通常用于位标志。
相比之下，Rust 的 <a href="items/enumerations.html#field-less-enum">无字段的枚举</a> 只能合法地容纳判别值，其他一切都是 <a href="behavior-considered-undefined.html">未定义行为</a> 。
因此，在 FFI 中使用无字段的枚举来模拟 C <code>enum</code> 通常是错误的。</p>
</div>
<h4 id="reprc-枚举类型的字段"><a class="header" href="#reprc-枚举类型的字段"><code>#[repr(C)]</code> 枚举类型的字段</a></h4>
<p>使用 <code>#[repr(C)]</code> 声明的带有字段的枚举类型的表示形式是一个带有两个字段的 <code>repr(C)</code> 结构体，也称为 C 语言中的 &quot;带标签联合体&quot; ：</p>
<ul>
<li>一个去掉所有字段的 <code>repr(C)</code> 版本的枚举类型 (&quot;标签&quot;)</li>
<li>一个 <code>repr(C)</code> 联合体，其中包含每个有字段的变体的 <code>repr(C)</code> 结构体 (&quot;有效载荷&quot;)</li>
</ul>
<blockquote>
<p>注意: 由于 <code>repr(C)</code> 结构体和联合体的表示方式，如果一个变体只有一个字段，在联合体中直接放置该字段或将其包装在结构体中没有区别；
因此，任何希望操作这种 <code>enum</code> 表示形式的系统都可以使用对他们来说更方便或更一致的形式。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这个枚举与下面的结构体具有相同的表示方式
#[repr(C)]
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
 }

// ... 这个结构体
#[repr(C)]
struct MyEnumRepr {
    tag: MyEnumDiscriminant, // 枚举的判别值
    payload: MyEnumFields, // 枚举的数据部分
}

// 这是枚举的判别值枚举
#[repr(C)]
enum MyEnumDiscriminant { A, B, C, D }

// 这是变体的联合体
#[repr(C)]
union MyEnumFields {
    A: MyAFields,
    B: MyBFields,
    C: MyCFields,
    D: MyDFields,
}

#[repr(C)]
#[derive(Copy, Clone)]
struct MyAFields(u32);

#[repr(C)]
#[derive(Copy, Clone)]
struct MyBFields(f32, u64);

#[repr(C)]
#[derive(Copy, Clone)]
struct MyCFields { x: u32, y: u8 }

// 这个结构体可以省略 (它是零大小的类型) ，并且它必须在C/C++头文件中。
#[repr(C)]
#[derive(Copy, Clone)]
struct MyDFields;
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>注意: 带有非 <code>Copy</code> 字段的 <code>union</code> 是未稳定的，请参见 <a href="https://github.com/rust-lang/rust/issues/55149">55149</a>。</p>
</blockquote>
<h3 id="原始表示"><a class="header" href="#原始表示">原始表示</a></h3>
<p><em>原始表示</em> 是与原始整数类型具有相同名称的表示。
即：<code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code>、<code>usize</code>、<code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code>、<code>i128</code>和<code>isize</code>。</p>
<p>原始表示仅适用于枚举类型，并根据枚举是否有字段具有不同的行为。
对于 <a href="items/enumerations.html#zero-variant-enums">零变体枚举</a> 来说，使用原始表示是错误的。将两个原始表示结合在一起也是错误的。</p>
<h4 id="无字段枚举的原始表示"><a class="header" href="#无字段枚举的原始表示">无字段枚举的原始表示</a></h4>
<p>对于 <a href="items/enumerations.html#field-less-enum">无字段枚举</a> ，原始表示将大小和对齐方式设置为与同名的原始类型相同。
例如，具有 <code>u8</code> 表示的无字段枚举只能具有 0 到 255 之间 (包括 0 和 255 ) 的鉴别标志。</p>
<h4 id="具有字段的枚举的基本表示"><a class="header" href="#具有字段的枚举的基本表示">具有字段的枚举的基本表示</a></h4>
<p>具有字段的基本表示枚举的表示是 <code>repr(C)</code> 联合，其中包含每个变量的 <code>repr(C)</code> 结构。
联合中每个结构的第一个字段是去除所有字段的枚举的基本表示版本 (&quot;标签&quot;) ，剩余字段是该变量的字段。</p>
<blockquote>
<p>注意：如果标签在联合中有自己的成员，则该表示不会改变，这样可以更清晰地进行操作 (尽管为了遵循 C++ 标准，标签成员应该包装在一个 <code>struct</code> 中)。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这个枚举和...具有相同的表示形式
#[repr(u8)]
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
 }

// ... 这个联合体。
#[repr(C)]
union MyEnumRepr {
    A: MyVariantA,
    B: MyVariantB,
    C: MyVariantC,
    D: MyVariantD,
}

// 这是鉴别器枚举。
#[repr(u8)]
#[derive(Copy, Clone)]
enum MyEnumDiscriminant { A, B, C, D }

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantA(MyEnumDiscriminant, u32);

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantB(MyEnumDiscriminant, f32, u64);

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantC { tag: MyEnumDiscriminant, x: u32, y: u8 }

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantD(MyEnumDiscriminant);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>注意: 具有非 <code>Copy</code> 字段的联合体是未稳定的，请参见 <a href="https://github.com/rust-lang/rust/issues/55149">55149</a> 。</p>
</blockquote>
<h4 id="将带字段的枚举的原始表示与-reprc-结合使用"><a class="header" href="#将带字段的枚举的原始表示与-reprc-结合使用">将带字段的枚举的原始表示与 <code>#[repr(C)]</code> 结合使用</a></h4>
<p>对于带字段的枚举，还可以将 <code>repr(C)</code> 和原始表示 (例如 <code>repr(C, u8)</code>) 结合使用。这会修改 <a href="type-layout.html#reprc-enums-with-fields"><code>repr(C)</code></a> ，将鉴别器枚举的表示方式更改为所选择的原始表示。
因此，如果您选择了 <code>u8</code> 表示方式，则鉴别器枚举的大小和对齐方式将为 1 字节。来自 <a href="type-layout.html#reprc-enums-with-fields">之前</a> 示例的鉴别器枚举如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C, u8)] // 添加了 `u8`
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
 }

// ...

#[repr(u8)] // 所以这里使用了 `u8` 而不是 `C`
enum MyEnumDiscriminant { A, B, C, D }

// ...
<span class="boring">}</span></code></pre></pre>
<p>例如，对于一个 <code>repr(C, u8)</code> 枚举，不可能有 257 个唯一的鉴别器 (&quot;标签&quot;) ，而只有一个 <code>repr(C)</code> 属性的相同枚举将在没有任何问题的情况下编译。</p>
<p>在 <code>repr(C)</code> 之外使用原始表示方式可能会改变枚举的大小:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
enum EnumC {
    Variant0(u8),
    Variant1,
}

#[repr(C, u8)]
enum Enum8 {
    Variant0(u8),
    Variant1,
}

#[repr(C, u16)]
enum Enum16 {
    Variant0(u8),
    Variant1,
}

// C 表示方式的大小取决于平台
assert_eq!(std::mem::size_of::&lt;EnumC&gt;(), 8);
// Enum8::Variant0 中鉴别器和值各占 1 个字节
assert_eq!(std::mem::size_of::&lt;Enum8&gt;(), 2);
// Enum16::Variant0 中鉴别器和值各占 1 个字节，再加上 1 个字节的填充
assert_eq!(std::mem::size_of::&lt;Enum16&gt;(), 4);
<span class="boring">}</span></code></pre></pre>
<h3 id="对齐修饰符"><a class="header" href="#对齐修饰符">对齐修饰符</a></h3>
<p><code>align</code> 和 <code>packed</code> 修饰符可以用于分别提高或降低 <code>struct</code> 和 <code>union</code> 的对齐方式。
<code>packed</code> 也可以改变字段之间的填充 (但不会改变任何字段内部的填充) 。</p>
<p>对齐方式是以整数形式的参数指定的，形式为 <code>#[repr(align(x))]</code> 或 <code>#[repr(packed(x))]</code> 。
对齐值必须是从 1 到 2<sup>29</sup> 的 2 的幂。对于 <code>packed</code>，如果没有给出值，例如 <code>#[repr(packed)]</code>，那么该值为 1。
对于 <code>align</code>，如果指定的对齐方式小于没有 <code>align</code> 修饰符的类型的对齐方式，则对齐方式不受影响。</p>
<p>对于 <code>packed</code>，如果指定的对齐方式大于没有 <code>packed</code> 修饰符的类型的对齐方式，则对齐方式和布局不受影响。
对于定位字段的目的，每个字段的对齐方式是指定的对齐方式和字段类型的对齐方式中较小的一个。
确保字段间的填充是最小的，以满足每个字段的 (可能已更改的) 对齐方式 (尽管请注意，单独使用 <code>packed</code> 不能提供有关字段顺序的任何保证) 。
这些规则的一个重要后果是，具有 <code>#[repr(packed(1))]</code> (或 <code>#[repr(packed)]</code>) 的类型将没有字段间的填充。</p>
<p><code>align</code> 和 <code>packed</code> 修饰符不能应用于同一类型，<code>packed</code> 类型不能传递地包含另一个 <code>align</code>ed 类型。
<code>align</code> 和 <code>packed</code> 只能应用于 [默认] 和 <a href="type-layout.html#the-c-representation"><code>C</code></a> 表示。</p>
<p><code>align</code> 修饰符也可以应用于 <code>enum</code>。 
当这样做时，<code>enum</code> 的对齐方式的效果与如果将 <code>enum</code> 包装在具有相同 <code>align</code> 修饰符的新类型 <code>struct</code> 中相同。</p>
<div class="warning">
<p><em><strong>警告:</strong></em> 对未对齐的指针进行解引用是 <a href="behavior-considered-undefined.html">未定义行为</a> ，可以 <a href="https://github.com/rust-lang/rust/issues/27060">安全地创建指向 <code>packed</code> 字段的未对齐指针</a>。
与 Rust 中所有安全地创建未定义行为的方式一样，这是一个错误。</p>
</div>
<h3 id="transparent-表示"><a class="header" href="#transparent-表示"><code>transparent</code> 表示</a></h3>
<p><code>transparent</code> 表示只能用于具有以下特点的 <code>struct</code> 或 <code>enum</code> 中的单个变体:</p>
<ul>
<li>具有非零大小的单个字段，且</li>
<li>具有大小为 0 且对齐方式为 1 的任意数量的字段 (例如 <a href="special-types-and-traits.html#phantomdatat"><code>PhantomData&lt;T&gt;</code></a>) 。</li>
</ul>
<p>具有此表示的结构体和枚举具有与单个非零大小字段相同的布局和 ABI 。</p>
<p>这与 <code>C</code> 表示不同，因为具有 <code>C</code> 表示的结构体将始终具有 <code>C</code> <code>struct</code> 的 ABI，而例如具有基元字段的 <code>transparent</code> 表示的结构体将具有基元字段的 ABI 。</p>
<p>由于此表示将类型布局委托给另一种类型，因此无法与任何其他表示一起使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内部可变性"><a class="header" href="#内部可变性">内部可变性</a></h1>
<p>有时候一个类型需要在拥有多个别名的情况下进行改变。在 Rust 中，这可以通过一种称为 <em>内部可变性</em> 模式来实现。
如果一个类型的内部状态可以通过对它的 <a href="types/pointer.html#shared-references-">共享引用</a> 进行改变，那么它就具有内部可变性。
这与通常的 <a href="behavior-considered-undefined.html">要求</a> 相反，通常共享引用指向的值不会被改变。</p>
<p><a href="../std/cell/struct.UnsafeCell.html"><code>std::cell::UnsafeCell&lt;T&gt;</code></a> 类型是禁用这种要求的唯一方法。
当 <code>UnsafeCell&lt;T&gt;</code> 被不可变地别名化时，仍然可以安全地对其包含的 <code>T</code> 进行改变或获取可变引用。
与所有其他类型一样，拥有多个 <code>&amp;mut UnsafeCell&lt;T&gt;</code> 别名是未定义的行为。</p>
<p>通过将 <code>UnsafeCell&lt;T&gt;</code> 用作字段，可以创建其他具有内部可变性的类型。
标准库提供了各种类型，提供安全的内部可变性 API 。
例如， <a href="../std/cell/struct.RefCell.html"><code>std::cell::RefCell&lt;T&gt;</code></a> 使用运行时借用检查来确保多个引用延伸的通常规则。
<a href="../std/sync/atomic/index.html"><code>std::sync::atomic</code></a> 模块包含了一些类型，这些类型包装了只能通过原子操作访问的值，允许这个值在线程之间共享和改变。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="子类型和协变性"><a class="header" href="#子类型和协变性">子类型和协变性</a></h1>
<p>子类型是隐式的，并且可以在类型检查或推断的任意阶段产生。
子类型仅限于两种情况:
与生命周期相关的协变性和具有更高层生命周期的类型之间的协变性。
如果我们从类型中抹去生命周期，那么唯一的子类型就是由于类型相等而产生的。</p>
<p>考虑以下示例: 字符串字面值始终具有 <code>'static</code> 生命周期。尽管如此，我们可以将 <code>s</code> 分配给 <code>t</code> :</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar&lt;'a&gt;() {
    let s: &amp;'static str = &quot;hi&quot;;
    let t: &amp;'a str = s;
}
<span class="boring">}</span></code></pre></pre>
<p>由于 <code>'static</code> 寿命超过了生命周期参数 <code>'a</code>，因此 <code>&amp;'static str</code> 是 <code>&amp;'a str</code> 的子类型。</p>
<p><a href="../nomicon/hrtb.html">高阶</a> 函数指针和 <a href="types/trait-object.html">trait 对象</a> 具有另一种子类型关系。
它们是由更高层生命周期的替换所给出的类型的子类型。以下是一些例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这里将 'a 替换为 'static
let subtype: &amp;(for&lt;'a&gt; fn(&amp;'a i32) -&gt; &amp;'a i32) = &amp;((|x| x) as fn(&amp;_) -&gt; &amp;_);
let supertype: &amp;(fn(&amp;'static i32) -&gt; &amp;'static i32) = subtype;

// 这同样适用于 trait 对象
let subtype: &amp;(dyn for&lt;'a&gt; Fn(&amp;'a i32) -&gt; &amp;'a i32) = &amp;|x| x;
let supertype: &amp;(dyn Fn(&amp;'static i32) -&gt; &amp;'static i32) = subtype;

// 我们还可以将一个高层生命周期替换为另一个
let subtype: &amp;(for&lt;'a, 'b&gt; fn(&amp;'a i32, &amp;'b i32))= &amp;((|x, y| {}) as fn(&amp;_, &amp;_));
let supertype: &amp;for&lt;'c&gt; fn(&amp;'c i32, &amp;'c i32) = subtype;
<span class="boring">}</span></code></pre></pre>
<h2 id="协变性"><a class="header" href="#协变性">协变性</a></h2>
<p>协变性是泛型类型相对于其参数具有的属性。泛型类型在参数上的 <em>协变性</em> 是参数的子类型化如何影响类型的子类型化。</p>
<ul>
<li>如果 <code>T</code> 是 <code>U</code> 的子类型，那么 <code>F&lt;T&gt;</code> 是 <code>F&lt;U&gt;</code> 的子类型，<code>F&lt;T&gt;</code> 对 <code>T</code> 是 <em>协变的</em> (covariant) ( &quot;通过&quot; 子类型化)</li>
<li>如果 <code>T</code> 是 <code>U</code> 的子类型，那么 <code>F&lt;U&gt;</code> 是 <code>F&lt;T&gt;</code> 的子类型，<code>F&lt;T&gt;</code> 对 <code>T</code> 是 <em>逆变的</em> (contravariant)</li>
<li>否则，<code>F&lt;T&gt;</code> 对 <code>T</code> 是 <em>不变的</em> (invariant) (不能推导出子类型关系)</li>
</ul>
<p>类型的协变性是按以下方式自动确定的:</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th><code>'a</code> 的变化</th><th><code>T</code> 的变化</th></tr></thead><tbody>
<tr><td><code>&amp;'a T</code></td><td>协变</td><td>协变</td></tr>
<tr><td><code>&amp;'a mut T</code></td><td>协变</td><td>不变</td></tr>
<tr><td><code>*const T</code></td><td></td><td>协变</td></tr>
<tr><td><code>*mut T</code></td><td></td><td>不变</td></tr>
<tr><td><code>[T]</code> 和 <code>[T; n]</code></td><td></td><td>协变</td></tr>
<tr><td><code>fn() -&gt; T</code></td><td></td><td>协变</td></tr>
<tr><td><code>fn(T) -&gt; ()</code></td><td></td><td>逆变</td></tr>
<tr><td><code>std::cell::UnsafeCell&lt;T&gt;</code></td><td></td><td>不变</td></tr>
<tr><td><code>std::marker::PhantomData&lt;T&gt;</code></td><td></td><td>协变</td></tr>
<tr><td><code>dyn Trait&lt;T&gt; + 'a</code></td><td>协变</td><td>不变</td></tr>
</tbody></table>
</div>
<p>其他的 <code>struct</code> ， <code>enum</code> 和 <code>union</code> 类型的协变性由它们字段的类型的协变性来决定。
如果参数在不同协变性的位置被使用，则参数是不变的。例如，以下的 <code>struct</code> 在 <code>'a</code> 和 <code>T</code> 上是协变的，在 <code>'b</code> ， <code>'c</code> 和 <code>U</code> 上是不变的。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::UnsafeCell;
struct Variance&lt;'a, 'b, 'c, T, U: 'a&gt; {
    x: &amp;'a U,               // 这使得 'a 上的 `Variance` 逆变，也使 U 上的 `Variance` 逆变，但是 U 在后面被使用了，所以它的 `Variance` 是不确定的。
    y: *const T,            // T 上的 `Variance` 是协变的
    z: UnsafeCell&lt;&amp;'b f64&gt;, // 'b 上的 `Variance` 是不变的
    w: *mut U,              // U 上的 `Variance` 是不变的，使整个结构体是不变的。

    f: fn(&amp;'c ()) -&gt; &amp;'c () // 在协变和逆变方向上都是的，使得 'c 在结构体中是不变的。
}
<span class="boring">}</span></code></pre></pre>
<p>当在 <code>struct</code>  <code>enum</code> 或 <code>union</code> 之外使用参数时，每个位置的参数的协变性是单独检查的。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::cell::UnsafeCell;
</span>fn generic_tuple&lt;'short, 'long: 'short&gt;(
    // `'long` 在元组中同时用于协变和不变位置。
    x: (&amp;'long u32, UnsafeCell&lt;&amp;'long u32&gt;),
) {
    // 因为这些位置上的 variance 是单独计算的，
    // 所以我们可以在协变位置上自由缩小 'long 生命周期。
    let _: (&amp;'short u32, UnsafeCell&lt;&amp;'long u32&gt;) = x;
}

fn takes_fn_ptr&lt;'short, 'middle: 'short&gt;(
    // 'middle 生命周期在协变和逆变位置上都被使用。
    f: fn(&amp;'middle ()) -&gt; &amp;'middle (),
) {
    // 因为这些位置上的 variance 是单独计算的，
    // 所以我们可以在协变位置上自由缩小 'middle 生命周期，
    // 在逆变位置上自由扩展 'middle 生命周期。
    let _: fn(&amp;'static ()) -&gt; &amp;'short () = f;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-和-lifetime-约束"><a class="header" href="#trait-和-lifetime-约束">Trait 和 lifetime 约束</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>类型参数约束组</em> :<br />
   <em>类型参数约束</em> ( <code>+</code> <em>类型参数约束</em> )<sup>*</sup> <code>+</code><sup>?</sup></p>
<p><em>类型参数约束</em> :<br />
      <em>生命周期</em> | <em>Trait约束</em></p>
<p><em>Trait约束</em> :<br />
      <code>?</code><sup>?</sup>
<a href="trait-bounds.html#higher-ranked-trait-bounds"><em>对于生命周期</em></a><sup>?</sup> <a href="paths.html#paths-in-types"><em>类型路径</em></a><br />
   | <code>(</code> <code>?</code><sup>?</sup>
<a href="trait-bounds.html#higher-ranked-trait-bounds"><em>对于生命周期</em></a><sup>?</sup> <a href="paths.html#paths-in-types"><em>类型路径</em></a> <code>)</code></p>
<p><em>生命周期约束</em> :<br />
   ( <em>生命周期</em> <code>+</code> )<sup>*</sup> <em>生命周期</em><sup>?</sup></p>
<p><em>生命周期</em> :<br />
      <a href="tokens.html#lifetimes-and-loop-labels">生命周期或标签</a><br />
   | <code>'static</code><br />
   | <code>'_</code></p>
</blockquote>
<p><a href="items/traits.html#trait-bounds">Trait</a> 和生命周期约束提供了一种方式，让 <a href="items/generics.html">泛型条目</a> 可以限制使用哪些类型和生命周期作为它们的参数。
约束可以在 <a href="items/generics.html#where-clauses">where 子句</a> 中对任何类型提供。对于某些常见情况，也有更短的形式：</p>
<ul>
<li>在声明 <a href="items/generics.html">泛型参数</a> 之后写入约束: <code>fn f&lt;A: Copy&gt;() {}</code> 等同于 <code>fn f&lt;A&gt;() where A: Copy {}</code> 。</li>
<li>在 trait 声明中作为 <a href="items/traits.html#supertraits">supertraits</a> : <code>trait Circle : Shape {}</code> 等同于 <code>trait Circle where Self : Shape {}</code> 。</li>
<li>在 trait 声明中作为 <a href="items/associated-items.html#associated-types">关联类型</a> 的约束: <code>trait A { type B: Copy; }</code> 等同于 <code>trait A where Self::B: Copy { type B; }</code> 。</li>
</ul>
<p>在使用条目时必须满足条目上的约束。在对泛型条目进行类型检查和借用检查时，可以使用约束来确定类型是否实现了 trait 。例如，给定 <code>Ty: Trait</code> </p>
<ul>
<li>在泛型函数的主体中，可以在 <code>Ty</code> 值上调用 <code>Trait</code> 的方法。同样，可以使用 <code>Trait</code> 上的关联常量。</li>
<li>可以使用 <code>Trait</code> 的关联类型。</li>
<li>可以将具有 <code>T: Trait</code> 约束的泛型函数和类型用于 <code>T</code> 使用 <code>Ty</code> 。</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">type Surface = i32;
</span>trait Shape {
    fn draw(&amp;self, surface: Surface);
    fn name() -&gt; &amp;'static str;
}

fn draw_twice&lt;T: Shape&gt;(surface: Surface, sh: T) {
    sh.draw(surface);           // 可以调用方法，因为T: Shape
    sh.draw(surface);
}

fn copy_and_draw_twice&lt;T: Copy&gt;(surface: Surface, sh: T) where T: Shape {
    let shape_copy = sh;        // 不移动 sh ，因为T: Copy
    draw_twice(surface, sh);    // 可以使用泛型函数，因为T: Shape
}

struct Figure&lt;S: Shape&gt;(S, S);

fn name_figure&lt;U: Shape&gt;(
    figure: Figure&lt;U&gt;,          // 类型 Figure&lt;U&gt; 是 well-formed ，因为U: Shape
) {
    println!(
        &quot;Figure of two {}&quot;,
        U::name(),              // 可以使用关联函数
    );
}
<span class="boring">}</span></code></pre></pre>
<p>不涉及该条目参数或 <a href="trait-bounds.html#higher-ranked-trait-bounds">高层生命周期</a> 的约束在定义该条目时进行检查。如果这样的约束为假，就会出现错误。</p>
<p>对于某些泛型类型，即使使用时不提供具体类型，也会对 <a href="special-types-and-traits.html#copy"><code>Copy</code></a> ， <a href="special-types-and-traits.html#clone"><code>Clone</code></a> 和 <a href="special-types-and-traits.html#sized"><code>Sized</code></a> 约束进行检查。
在可变引用， <a href="types/trait-object.html">trait 对象</a> 或 <a href="types/slice.html">slice</a> 上使用 <code>Copy</code> 或 <code>Clone</code>  作为约束是错误的。在 <a href="types/trait-object.html">trait 对象</a> 或 <a href="types/slice.html">slice</a> 上使用 <code>Sized</code> 作为限制也是错误的。</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A&lt;'a, T&gt;
where
    i32: Default,           // 允许，但不实用
    i32: Iterator,          // 错误： `i32` 不是迭代器
    &amp;'a mut T: Copy,        // （在使用时）错误：无法满足 trait 约束
    [T]: Sized,             // （在使用时）错误：大小无法在编译时确定
{
    f: &amp;'a T,
}
struct UsesA&lt;'a, T&gt;(A&lt;'a, T&gt;);
<span class="boring">}</span></code></pre></pre>
<p>Trait 和 生命周期限制还用于命名 <a href="types/trait-object.html">trait 对象</a> 。</p>
<h2 id="sized"><a class="header" href="#sized"><code>?Sized</code></a></h2>
<p><code>?</code> 仅用于为 <a href="types/parameters.html">类型参数</a> 或 <a href="items/associated-items.html#associated-types">关联类型</a> 放宽隐含的 <a href="special-types-and-traits.html#sized"><code>Sized</code></a> trait 约束。 <code>?Sized</code> 不能用作其他类型的约束。</p>
<h2 id="生命周期约束"><a class="header" href="#生命周期约束">生命周期约束</a></h2>
<p>生命周期限制可以应用于类型或其他生命周期。约束 <code>'a: 'b</code> 通常被读作 <code>'a</code> <em>比</em> <code>'b</code> 活得更久。
<code>'a: 'b</code> 意味着 <code>'a</code> 至少和 <code>'b</code> 一样长，因此当 <code>&amp;'b ()</code> 有效时，引用 <code>&amp;'a ()</code> 也是有效的。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'a, 'b&gt;(x: &amp;'a i32, mut y: &amp;'b i32) where 'a: 'b {
    y = x;                      // `&amp;'a i32` 是 `&amp;'b i32` 的子类型，因为 `'a: 'b` 。
    let r: &amp;'b &amp;'a i32 = &amp;&amp;0;   // `&amp;'b &amp;'a i32` 是良好形式的，因为 `'a: 'b` 。
}
<span class="boring">}</span></code></pre></pre>
<p><code>T: 'a</code> 表示 <code>T</code> 的所有生命周期参数都比 <code>'a</code> 更长。
例如，如果 <code>'a</code> 是一个未约束的生命周期参数，那么 <code>i32: 'static</code> 和 <code>&amp;'static str: 'a</code> 是符合条件的，但是 <code>Vec&lt;&amp;'a ()&gt;: 'static</code> 不符合条件。</p>
<h2 id="高阶-trait-约束"><a class="header" href="#高阶-trait-约束">高阶 trait 约束</a></h2>
<blockquote>
<p><em>for生命周期</em> :<br />
   <code>for</code> <a href="items/generics.html"><em>泛型参数组</em></a></p>
</blockquote>
<p>Trait 约束可以对生命周期进行 <em>提阶</em> ，这些约束指定了一个对于 <em>所有</em> 生命周期都成立的约束。
例如， <code>for&lt;'a&gt; &amp;'a T: PartialEq&lt;i32&gt;</code> 这样的约束需要一个这样的实现:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct T;
</span>impl&lt;'a&gt; PartialEq&lt;i32&gt; for &amp;'a T {
    // ...
<span class="boring">   fn eq(&amp;self, other: &amp;i32) -&gt; bool {true}
</span>}
<span class="boring">}</span></code></pre></pre>
<p>可以用它来将一个 <code>&amp;'a T</code> 的生命周期与任意的 <code>i32</code> 进行比较。</p>
<p>只有一个更高层的约束可以在这里使用，因为引用的生命周期比函数上可能存在的任何生命周期参数都要短：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn call_on_ref_zero&lt;F&gt;(f: F) where for&lt;'a&gt; F: Fn(&amp;'a i32) {
    let zero = 0;
    f(&amp;zero);
}
<span class="boring">}</span></code></pre></pre>
<p>更高层的生命周期也可以在 trait 前面指定: 唯一的区别是生命周期参数的作用范围仅限于后面 trait 的末尾，而不是整个约束。这个函数与上一个函数是等价的。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn call_on_ref_zero&lt;F&gt;(f: F) where F: for&lt;'a&gt; Fn(&amp;'a i32) {
    let zero = 0;
    f(&amp;zero);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型强制转换"><a class="header" href="#类型强制转换">类型强制转换</a></h1>
<p><strong>类型强制转换</strong> 是隐式操作，可以更改值的类型。它们在特定位置自动发生，并且高度限制实际强制转换的类型。
由类型强制转换允许的任何转换也可以通过 <a href="expressions/operator-expr.html#type-cast-expressions">类型转换运算符</a> <code>as</code> 显式执行。
强制转换最初在 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md">RFC 401</a> 中定义，并在 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1558-closure-to-fn-coercion.md">RFC 1558</a> 中进行了扩展。</p>
<h2 id="强制转换位置"><a class="header" href="#强制转换位置">强制转换位置</a></h2>
<p>强制转换只能发生在程序的某些位置；通常这些位置上，期望的类型是显式或可以从显式类型(不需要类型推断)中衍生。可能的强制转换位置包括：</p>
<ul>
<li>
<p><code>let</code> 语句中给出显式类型的位置。
例如，在以下代码中， <code>&amp;mut 42</code> 被强制转换为类型 <code>&amp;i8</code> :</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _: &amp;i8 = &amp;mut 42;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><code>static</code> 和 <code>const</code> 条目的声明 (其类似于 <code>let</code> 语句) 。</p>
</li>
<li>
<p>函数调用的参数
被强制转换的值是实参，将其强制转换为形参的类型。</p>
<p>例如，在以下代码中，<code>&amp;mut 42</code> 被强制转换为类型 <code>&amp;i8</code> :</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn bar(_: &amp;i8) { }

fn main() {
    bar(&amp;mut 42);
}</code></pre></pre>
<p>在方法调用中，接收器 (<code>self</code> 参数) 只能利用 <a href="type-coercions.html#unsized-coercions">非定长强制转换</a> 。</p>
</li>
<li>
<p>结构体、联合体或枚举变体字段的实例化</p>
<p>例如，在以下示例中， <code>&amp;mut 42</code> 被强制转换为类型 <code>&amp;i8</code> ：</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Foo&lt;'a&gt; { x: &amp;'a i8 }

fn main() {
    Foo { x: &amp;mut 42 };
}</code></pre></pre>
</li>
<li>
<p>函数结果，可以是块的最后一行，如果它不以分号结尾，或者是 <code>return</code> 语句中的任何表达式。</p>
<p>例如，在以下示例中， <code>x</code> 被强制转换为类型 <code>&amp;dyn Display</code> ：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;
fn foo(x: &amp;u32) -&gt; &amp;dyn Display {
    x
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>如果在这些类型转换位置之一的表达式是一个类型转换传导表达式，那么该表达式中的相关子表达式也是类型转换位置。
传导从这些新的类型转换位置递归进行。传导表达式及其相关子表达式包括:</p>
<ul>
<li>
<p>数组字面值，数组类型为 <code>[U; n]</code> 。数组字面值中的每个子表达式都是类型强制转换到类型 <code>U</code> 的强制转换位置。</p>
</li>
<li>
<p>带有重复语法的数组字面值，数组类型为 <code>[U; n]</code> 。重复的子表达式是类型强制转换到类型 <code>U</code> 的强制转换位置。</p>
</li>
<li>
<p>元组，其中元组是类型强制转换到类型 <code>(U_0, U_1, ..., U_n)</code> 的强制转换位置。每个子表达式都是相应类型的类型转换位置，例如，第零个子表达式是类型强制转换到类型 <code>U_0</code> 的强制转换位置。</p>
</li>
<li>
<p>括号中的子表达式 (<code>(e)</code>) : 如果表达式的类型是 <code>U</code> ，那么子表达式就是类型强制转换到 <code>U</code> 的强制转换位置。</p>
</li>
<li>
<p>块: 如果块的类型是 <code>U</code> ，则块中的最后一个表达式 (如果它没有以分号结尾) 是类型强制转换到 <code>U</code> 的强制转换位置。
这包括控制流语句中的块，例如 <code>if</code>/<code>else</code> ，如果块具有已知类型的话。</p>
</li>
</ul>
<h2 id="强制类型转换"><a class="header" href="#强制类型转换">强制类型转换</a></h2>
<p>以下类型之间允许进行强制类型转换:</p>
<ul>
<li>
<p>如果 <code>T</code> 是 <code>U</code> 的 <a href="subtyping.html">子类型</a> ，则 <code>T</code> 可以强制转换为 <code>U</code> (<em>自反性的情况</em>)</p>
</li>
<li>
<p>当 <code>T_1</code> 转换为 <code>T_2</code> ， <code>T_2</code> 转换为 <code>T_3</code> 时，<code>T_1</code> 可以转换为 <code>T_3</code> (<em>可传递的情况</em>)</p>
<p>注意，这种情况目前尚未完全支持。</p>
</li>
<li>
<p><code>&amp;mut T</code> 可以强制转换为 <code>&amp;T</code></p>
</li>
<li>
<p><code>*mut T</code> 可以强制转换为 <code>*const T</code></p>
</li>
<li>
<p><code>&amp;T</code> 可以强制转换为 <code>*const T</code></p>
</li>
<li>
<p><code>&amp;mut T</code> 可以强制转换为 <code>*mut T</code></p>
</li>
<li>
<p>如果 <code>T</code> 实现了 <code>Deref&lt;Target = U&gt;</code> ，则 <code>&amp;T</code> 或 <code>&amp;mut T</code> 可以强制转换为 <code>&amp;U</code> 。例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Deref;

struct CharContainer {
    value: char,
}

impl Deref for CharContainer {
    type Target = char;

    fn deref&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a char {
        &amp;self.value
    }
}

fn foo(arg: &amp;char) {}

fn main() {
    let x = &amp;mut CharContainer { value: 'y' };
    foo(x); //&amp;mut `CharContainer` 被强制转换为 &amp;char 。
}</code></pre></pre>
</li>
<li>
<p>如果 <code>T</code> 实现了 <code>DerefMut&lt;Target = U&gt;</code>，则 <code>&amp;mut T</code> 可以强制转换为 <code>&amp;mut U</code>。</p>
</li>
<li>
<p>TyCtor(<code>T</code>) 可以强制转换为 TyCtor(<code>U</code>) ，其中 TyCtor(<code>T</code>) 是以下之一：</p>
<ul>
<li><code>&amp;T</code></li>
<li><code>&amp;mut T</code></li>
<li><code>*const T</code></li>
<li><code>*mut T</code></li>
<li><code>Box&lt;T&gt;</code></li>
</ul>
<p>而且 <code>U</code> 可以通过 <a href="type-coercions.html#unsized-coercions">不可调整大小强制转换</a> 从 <code>T</code> 中获得。</p>
<!-- 在未来，coerce_inner 将递归地扩展到元组和结构体。
  此外，将添加从子 trait 到超 trait 的强制转换。
  有关更多详细信息，请参见 [RFC 401]。-->
</li>
<li>
<p>函数条目类型到 <code>fn</code> 指针</p>
</li>
<li>
<p>非捕获闭包到 <code>fn</code> 指针</p>
</li>
<li>
<p><code>!</code> 到任何 <code>T</code> </p>
</li>
</ul>
<h3 id="不定大小的强制转换"><a class="header" href="#不定大小的强制转换">不定大小的强制转换</a></h3>
<p>下列类型强制转换被称为 <code>不定大小的强制转换</code> ，因为它们涉及将有大小限制的类型转换为无大小限制的类型，并且在一些其他强制转换不允许的情况下被允许，如上所述。
它们仍然可以发生在强制转换可以发生的任何地方。两个 trait <a href="../std/marker/trait.Unsize.html"><code>Unsize</code></a> 和 <a href="../std/ops/trait.CoerceUnsized.html"><code>CoerceUnsized</code></a> 用于协助此过程并将其公开供库使用。
下列强制转换是内置的，如果 <code>T</code> 可以通过其中之一转换为 <code>U</code> ，则将为 <code>T</code> 提供一个实现 <code>Unsize&lt;U&gt;</code> 的实现：</p>
<ul>
<li>
<p><code>[T; n]</code> 转换为 <code>[T]</code> 。</p>
</li>
<li>
<p>当 <code>T</code> 实现 <code>U + Sized</code> 时， <code>T</code> 转换为 <code>dyn U</code> ，而 <code>U</code> 是 <a href="items/traits.html#object-safety">对象安全</a> 的。</p>
</li>
<li>
<p>当满足以下条件时， <code>Foo&lt;..., T, ...&gt;</code> 转换为 <code>Foo&lt;..., U, ...&gt;</code> ：</p>
<ul>
<li><code>Foo</code> 是一个结构体。</li>
<li><code>T</code> 实现了 <code>Unsize&lt;U&gt;</code> 。</li>
<li><code>Foo</code> 的最后一个字段的类型涉及到了 <code>T</code> 。</li>
<li>如果该字段的类型为 <code>Bar&lt;T&gt;</code> ，则 <code>Bar&lt;T&gt;</code> 实现了 <code>Unsized&lt;Bar&lt;U&gt;&gt;</code> 。</li>
<li><code>T</code> 不是任何其他字段类型的一部分。</li>
</ul>
</li>
</ul>
<p>此外，当 <code>T</code> 实现了 <code>Unsize&lt;U&gt;</code> 或 <code>CoerceUnsized&lt;Foo&lt;U&gt;&gt;</code> 时，类型 <code>Foo&lt;T&gt;</code> 可以实现 <code>CoerceUnsized&lt;Foo&lt;U&gt;&gt;</code>。这使它可以提供到 <code>Foo&lt;U&gt;</code> 的不定大小的强制转换。</p>
<blockquote>
<p>注意：尽管已经稳定化了不定大小的强制转换的定义及其实现，但这些特性本身尚未稳定，因此不能在稳定的 Rust 中直接使用它们。</p>
</blockquote>
<h2 id="最小上界强制转换"><a class="header" href="#最小上界强制转换">最小上界强制转换</a></h2>
<p>在某些情况下，编译器必须将多个类型强制转换在一起，以尝试找到最通用的类型。
这被称为 &quot;最小上界强制转换&quot; (Least Upper Bound coercion，简称LUB 强转) 。LUB 强转仅在以下情况下使用：</p>
<ul>
<li>为一系列 if 分支查找公共类型。</li>
<li>为一系列 match 分支查找公共类型。</li>
<li>为数组元素查找公共类型。</li>
<li>为带有多个返回语句的闭包查找返回类型。</li>
<li>检查带有多个返回语句的函数的返回类型。</li>
</ul>
<p>在每种情况下，存在一组要相互强制转换为某个目标类型 <code>T_t</code> 的类型 <code>T0..Tn</code> ，该目标类型最初是未知的。
计算 LUB 强转是通过迭代完成的。目标类型 <code>T_t</code> 开始是类型 <code>T0</code> 。对于每个新类型 <code>Ti</code> ，我们考虑以下内容：</p>
<ul>
<li>如果 <code>Ti</code> 可以强制转换为当前目标类型 <code>T_t</code> ，则不进行任何更改。</li>
<li>否则，检查是否可以将 <code>T_t</code> 强制转换为 <code>Ti</code> ；如果可以，则将 <code>T_t</code> 更改为 <code>Ti</code> 。 (此检查还取决于迄今为止考虑的所有源表达式是否具有隐式强制转换。)</li>
<li>如果不行，则尝试计算 <code>T_t</code> 和 <code>Ti</code> 的共同超类，该超类将成为新的目标类型。</li>
</ul>
<h3 id="例如"><a class="header" href="#例如">例如:</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let (a, b, c) = (0, 1, 2);
</span>// 用于 if 条件分支
let bar = if true {
    a
} else if false {
    b
} else {
    c
};

// 用于 match 匹配分支
let baw = match 42 {
    0 =&gt; a,
    1 =&gt; b,
    _ =&gt; c,
};

// 用于数组元素
let bax = [a, b, c];

// 用于多个返回语句的闭包
let clo = || {
    if true {
        a
    } else if false {
        b
    } else {
        c
    }
};
let baz = clo();

// 用于多个返回语句的函数类型检查
fn foo() -&gt; i32 {
    let (a, b, c) = (0, 1, 2);
    match 42 {
        0 =&gt; a,
        1 =&gt; b,
        _ =&gt; c,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>在这些示例中， <code>ba*</code> 的类型是通过最小上界 LUB 强转来确定的。编译器在处理函数 <code>foo</code> 时检查 <code>a</code> ， <code>b</code> ， <code>c</code> 的 LUB 强转结果是否为 <code>i32</code> 。</p>
<h3 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h3>
<p>这个描述显然是非正式的。更精确的描述将作为规范 Rust 类型检查器的泛型尝试的一部分进行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="析构函数"><a class="header" href="#析构函数">析构函数</a></h1>
<p>当一个 <a href="glossary.html#initialized">初始化的</a> <a href="variables.html">变量</a> 或 <a href="expressions.html#temporaries">临时值</a> 超出 <a href="destructors.html#drop-scopes">作用域</a> 时，它的 <em>析构函数</em> 会被运行，或者它会被 <em>销毁</em> 。
<a href="expressions/operator-expr.html#assignment-expressions">赋值</a> 也会运行其左操作数的析构函数，如果它已经被初始化。
如果一个变量只被部分初始化，那么只有它的已初始化字段会被销毁。</p>
<p>类型 T 的析构函数包括:</p>
<ol>
<li>如果 <code>T: Drop</code> ，则调用 <a href="../std/ops/trait.Drop.html#tymethod.drop"><code>&lt;T as std::ops::Drop&gt;::drop</code></a> </li>
<li>递归运行其所有字段的析构函数。
<ul>
<li><a href="types/struct.html">结构体</a> 的字段按声明顺序被销毁。</li>
<li><a href="types/enum.html">枚举类型</a> 的活动变量的字段按声明顺序被销毁。</li>
<li><a href="types/tuple.html">元组</a> 的字段按顺序被销毁。</li>
<li><a href="types/array.html">数组</a> 或拥有的 <a href="types/slice.html">切片</a> 的元素从第一个元素到最后一个元素被销毁。</li>
<li><a href="types/closure.html">闭包</a> 通过移动捕获的变量按未指定的顺序被销毁。</li>
<li><a href="types/trait-object.html">Trait 对象</a> 运行底层类型的析构函数。</li>
<li>其他类型不会导致进一步的销毁。</li>
</ul>
</li>
</ol>
<p>如果必须手动运行析构函数，例如在实现自己的智能指针时，可以使用 <a href="../std/ptr/fn.drop_in_place.html"><code>std::ptr::drop_in_place</code></a> 。</p>
<p>一些例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PrintOnDrop(&amp;'static str);

impl Drop for PrintOnDrop {
    fn drop(&amp;mut self) {
        println!(&quot;{}&quot;, self.0);
    }
}

let mut overwritten = PrintOnDrop(&quot;drops when overwritten&quot;); // 当被覆盖时会被销毁
overwritten = PrintOnDrop(&quot;drops when scope ends&quot;); // 当作用域结束时会被销毁

let tuple = (PrintOnDrop(&quot;Tuple first&quot;), PrintOnDrop(&quot;Tuple second&quot;)); // Tuple 的第一个元素和第二个元素，分别在创建时被销毁

let moved;
// 在赋值时不会运行析构函数
moved = PrintOnDrop(&quot;Drops when moved&quot;); 
// 现在被销毁，但后来处于未初始化状态
moved;

// 未初始化不会被销毁
let uninitialized: PrintOnDrop;

// 在部分移动后，只有剩余的字段会被销毁
let mut partial_move = (PrintOnDrop(&quot;first&quot;), PrintOnDrop(&quot;forgotten&quot;));
// 进行部分移动，只剩下 `partial_move.0` 被初始化
core::mem::forget(partial_move.1);
// 当 `partial_move` 的作用域结束时，只有第一个字段被销毁。
<span class="boring">}</span></code></pre></pre>
<h2 id="析构作用域"><a class="header" href="#析构作用域">析构作用域</a></h2>
<p>每个变量或临时变量都与一个 <em>析构作用域</em> 相关联。
当控制流离开析构作用域时，与该作用域相关联的所有变量按照声明 (对于变量) 或创建 (对于临时变量) 的相反顺序进行销毁。
在使用 <a href="expressions/match-expr.html"><code>match</code></a> 表达式替换 <a href="expressions/loop-expr.html#iterator-loops"><code>for</code></a> 、 <a href="expressions/if-expr.html#if-let-expressions"><code>if let</code></a> 和 <a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a> 表达式之后，确定析构作用域。
重载的操作符与内置的操作符没有区别，绑定模式也不被考虑在内。
对于函数或闭包，有以下析构作用域:</p>
<ul>
<li>整个函数</li>
<li>每个 <a href="statements.html">语句</a></li>
<li>每个 <a href="expressions.html">表达式</a></li>
<li>每个块，包括函数体
<ul>
<li>对于 <a href="expressions/block-expr.html">块表达式</a> ，块和表达式的作用域是同一作用域。</li>
</ul>
</li>
<li><code>match</code> 表达式的每个分支</li>
</ul>
<p>析构作用域按如下嵌套。当一次离开多个作用域时，例如从函数返回时，变量从内向外进行销毁。</p>
<ul>
<li>整个函数的作用域是最外层的作用域。</li>
<li>函数体块包含在整个函数的作用域内。</li>
<li>表达式语句中表达式的父级是该语句的作用域。</li>
<li><a href="statements.html#let-statements"><code>let</code> 语句</a> 中初始化器的父级是 <code>let</code> 语句的作用域。</li>
<li>语句作用域的父级是包含该语句的块的作用域。</li>
<li><code>match</code> 守卫中表达式的父级是守卫所属分支的作用域。</li>
<li><code>=&gt;</code> 后的表达式在 <code>match</code> 表达式中所属分支的作用域内。</li>
<li>分支作用域的父级是所属的 <code>match</code> 表达式的作用域。</li>
<li>其他所有作用域的父级是最近的封闭表达式的作用域。</li>
</ul>
<h3 id="函数参数的作用域"><a class="header" href="#函数参数的作用域">函数参数的作用域</a></h3>
<p>所有函数参数都在整个函数体的作用域内，因此在评估函数时它们是最后被丢弃。
每个实际的函数参数在该参数模式中引入的任何绑定之后被丢弃。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PrintOnDrop(&amp;'static str);
</span><span class="boring">impl Drop for PrintOnDrop {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;drop({})&quot;, self.0);
</span><span class="boring">    }
</span><span class="boring">}
</span>// 按顺序丢弃 `y`、第二个参数、`x`，最后第一个参数
fn patterns_in_parameters(
    (x, _): (PrintOnDrop, PrintOnDrop),
    (_, y): (PrintOnDrop, PrintOnDrop),
) {}

// 丢弃顺序为 3 2 0 1
patterns_in_parameters(
    (PrintOnDrop(&quot;0&quot;), PrintOnDrop(&quot;1&quot;)),
    (PrintOnDrop(&quot;2&quot;), PrintOnDrop(&quot;3&quot;)),
);
<span class="boring">}</span></code></pre></pre>
<h3 id="局部变量的作用域"><a class="header" href="#局部变量的作用域">局部变量的作用域</a></h3>
<p>在 <code>let</code> 语句中声明的局部变量与包含 <code>let</code> 语句的块的作用域相关联。在 <code>match</code> 表达式中声明的局部变量与它们声明在的 <code>match</code> 分支的作用域相关联。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PrintOnDrop(&amp;'static str);
</span><span class="boring">impl Drop for PrintOnDrop {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;drop({})&quot;, self.0);
</span><span class="boring">    }
</span><span class="boring">}
</span>let declared_first = PrintOnDrop(&quot;Dropped last in outer scope&quot;);
{
    let declared_in_block = PrintOnDrop(&quot;Dropped in inner scope&quot;);
}
let declared_last = PrintOnDrop(&quot;Dropped first in outer scope&quot;);
<span class="boring">}</span></code></pre></pre>
<p>如果在 <code>match</code> 表达式的同一个 <code>arm</code> 中使用了多个模式，则将使用未指定的模式来确定释放顺序。</p>
<h3 id="临时作用域"><a class="header" href="#临时作用域">临时作用域</a></h3>
<p>表达式的 <em>临时作用域</em> 是在 <a href="expressions.html#place-expressions-and-value-expressions">位置上下文</a> 中使用该表达式的结果时用于保存临时变量的作用域，
除非它被 <a href="destructors.html#constant-promotion">提升</a> 。除了生命周期扩展之外，表达式的临时作用域是包含该表达式的最小作用域，并且是以下范围之一：</p>
<ul>
<li>整个函数体。</li>
<li>一个语句。</li>
<li><a href="expressions/if-expr.html#if-expressions"><code>if</code></a> ， <a href="expressions/loop-expr.html#predicate-loops"><code>while</code></a> 或 <a href="expressions/loop-expr.html#infinite-loops"><code>loop</code></a> 表达式的主体。</li>
<li><code>if</code> 表达式的 <code>else</code> 块 。</li>
<li><code>if</code> 或 <code>while</code> 表达式的条件表达式，或 <code>match</code> 守卫。</li>
<li>match 分支的表达式。</li>
<li><a href="expressions/operator-expr.html#lazy-boolean-operators">惰性布尔表达式</a> 的第二个操作数。</li>
</ul>
<blockquote>
<p><strong>注</strong>:</p>
<p>在函数体的最终表达式中创建的临时变量将在函数体绑定的任何命名变量之后释放，因为没有更小的封闭临时作用域。</p>
<p><code>match</code> 表达式的 <a href="glossary.html#scrutinee">被匹配项</a> 不是临时作用域，因此可以在 <code>match</code> 表达式之后丢弃被匹配对象中的临时变量。
例如，在 <code>match 1 { ref mut z =&gt; z };</code> 中的 <code>1</code> 的临时变量将一直存在到语句的结尾。</p>
</blockquote>
<p>一些例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PrintOnDrop(&amp;'static str);
</span><span class="boring">impl Drop for PrintOnDrop {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;drop({})&quot;, self.0);
</span><span class="boring">    }
</span><span class="boring">}
</span>let local_var = PrintOnDrop(&quot;局部变量&quot;);

// 一旦条件被评估，将被丢弃
if PrintOnDrop(&quot;if条件&quot;).0 == &quot;if条件&quot; {
    // 在块的末尾被丢弃
    PrintOnDrop(&quot;if块体&quot;).0
} else {
    unreachable!()
};

// 在语句的末尾被丢弃
(PrintOnDrop(&quot;第一个操作数&quot;).0 == &quot;&quot;
// 在 ) 处被丢弃
|| PrintOnDrop(&quot;第二个操作数&quot;).0 == &quot;&quot;)
// 在表达式的末尾被丢弃
|| PrintOnDrop(&quot;第三个操作数&quot;).0 == &quot;&quot;;

// 在函数的末尾被丢弃，在局部变量之后。
// 将其更改为包含返回表达式的语句将使临时变量在局部变量之前被释放。
// 将其绑定到变量并返回该变量也会使临时变量首先被释放。
match PrintOnDrop(&quot;匹配的值，用于最终表达式&quot;) {
    // 一旦条件被评估，将被丢弃
    _ if PrintOnDrop(&quot;守卫条件&quot;).0 == &quot;&quot; =&gt; (),
    _ =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="操作数"><a class="header" href="#操作数">操作数</a></h3>
<p>在表达式中，为了保存操作数的结果，也会创建临时变量，而其他操作数被评估。这些临时变量与该操作数的表达式作用域相关联。
由于临时变量在表达式被评估后被移动，除非表达式的操作数之一中断表达式、返回或抛出异常，否则将其丢弃不会产生副作用。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PrintOnDrop(&amp;'static str);
</span><span class="boring">impl Drop for PrintOnDrop {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;drop({})&quot;, self.0);
</span><span class="boring">    }
</span><span class="boring">}
</span>loop {
    // 元组表达式没有完成评估，因此操作数按相反的顺序删除
    (
        PrintOnDrop(&quot;外部元组第一个&quot;),
        PrintOnDrop(&quot;外部元组第二个&quot;),
        (
            PrintOnDrop(&quot;内部元组第一个&quot;),
            PrintOnDrop(&quot;内部元组第二个&quot;),
            break, // 循环中断，后面的表达式不会执行
        ),
        PrintOnDrop(&quot;永远不会创建&quot;),
    );
}
<span class="boring">}</span></code></pre></pre>
<h3 id="常量晋升"><a class="header" href="#常量晋升">常量晋升</a></h3>
<p>将值表达式晋升为一个 <code>'static</code> 槽发生在表达式可以写成常量并借用时，那个借用可以在不改变运行时行为的情况下在表达式原始写法的位置进行解引用。
也就是说，晋升的表达式可以在编译时计算，所得到的值不包含 <a href="interior-mutability.html">内部可变性</a> 或 <a href="destructors.html">析构函数</a> (这些属性在可能的情况下基于值来确定，
例如， <code>&amp;None</code> 始终具有类型 <code>&amp;'static Option&lt;_&gt;</code> ，因为它不包含任何被禁止的内容)。</p>
<h3 id="临时值生命周期延长"><a class="header" href="#临时值生命周期延长">临时值生命周期延长</a></h3>
<blockquote>
<p><strong>注意</strong>: 临时值生命周期延长的确切规则可能会发生变化。本文描述的是当前行为。</p>
</blockquote>
<p>在 <code>let</code> 语句中的表达式的临时值作用域有时会被 <em>延长</em> 到包含 <code>let</code> 语句的块的作用域。
这是根据某些语法规则判断，当通常的临时值作用域太小时进行的。例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;mut 0;
// 通常此时一个临时变量已经被丢弃了，但是 `0` 的临时变量会一直存活到该块的结尾。
println!(&quot;{}&quot;, x);
<span class="boring">}</span></code></pre></pre>
<p>如果一个 <a href="expressions/operator-expr.html#borrow-operators">借用表达式</a> 、 <a href="expressions/operator-expr.html#the-dereference-operator">解引用表达式</a> 、 <a href="expressions/field-expr.html">字段表达式</a> 或 <a href="expressions/tuple-expr.html#tuple-indexing-expressions">元组索引表达式</a> 具有扩展临时作用域，则其操作数也具有扩展临时作用域。
如果一个 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">索引表达式</a> 具有扩展临时作用域，则索引表达式也具有扩展临时作用域。</p>
<h4 id="基于模式的扩展"><a class="header" href="#基于模式的扩展">基于模式的扩展</a></h4>
<p>一个 <em>扩展模式</em> 可以是：</p>
<ul>
<li>一个通过引用或可变引用绑定的 <a href="patterns.html#identifier-patterns">标识符模式</a> 。</li>
<li>一个 <a href="patterns.html#struct-patterns">结构体模式</a> 、 <a href="patterns.html#tuple-patterns">元组模式</a> 、 <a href="patterns.html#tuple-struct-patterns">元组结构体模式</a> 或 <a href="patterns.html#slice-patterns">切片模式</a> ，其中至少一个直接子模式是扩展模式。
因此， <code>ref x</code> 、 <code>V(ref x)</code> 和 <code>[ref x, y]</code> 都是扩展模式，但 <code>x</code> 、 <code>&amp;ref x</code> 和 <code>&amp;(ref x,)</code> 不是。如果 <code>let</code> 语句中的模式是扩展模式，则初始化表达式的临时作用域会被扩展。</li>
</ul>
<h4 id="基于表达式的扩展"><a class="header" href="#基于表达式的扩展">基于表达式的扩展</a></h4>
<p>对于带有初始化器的 <code>let</code> 语句，一个 <em>扩展表达式</em> 是以下表达式之一:</p>
<ul>
<li>初始化表达式。</li>
<li>扩展的 <a href="expressions/operator-expr.html#borrow-operators">借用表达式</a> 的操作数。</li>
<li>扩展的 <a href="expressions/array-expr.html#array-expressions">数组表达式</a> 、 <a href="expressions/operator-expr.html#type-cast-expressions">强制类型转换表达式</a> 、 <a href="expressions/struct-expr.html">括号结构体表达式</a> 或 <a href="expressions/tuple-expr.html#tuple-expressions">元组表达式</a> 的操作数。</li>
<li>任何扩展的 <a href="expressions/block-expr.html">block 表达式</a> 的最后一个表达式。</li>
</ul>
<p>因此， <code>&amp;mut 0</code> 、 <code>(&amp;1, &amp;mut 2)</code> 和 <code>Some {0: &amp;mut 3}</code> 中的借用表达式都是扩展表达式。 <code>&amp;0 + &amp;1</code> 和 <code>Some(&amp;mut 0)</code> 中的借用表达式不是扩展表达式：后者在语法上是一个函数调用表达式。</p>
<p>任何扩展借用表达式的操作数都会扩展其临时作用域。</p>
<h4 id="示例-4"><a class="header" href="#示例-4">示例</a></h4>
<p>以下是一些表达式具有扩展临时作用域的示例:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">trait Use { fn use_temp(&amp;self) -&gt; &amp;Self { self } }
</span><span class="boring">impl Use for () {}
</span>// 存储 `temp()` 结果的临时变量在以下这些情况下与 x 具有相同的作用域。
let x = &amp;temp();
let x = &amp;temp() as &amp;dyn Send;
let x = (&amp;*&amp;temp(),);
let x = { [Some { 0: &amp;temp(), }] };
let ref x = temp();
let ref x = *&amp;temp();
<span class="boring">x;
</span><span class="boring">}</span></code></pre></pre>
<p>以下是一些表达式没有扩展临时作用域的示例:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">trait Use { fn use_temp(&amp;self) -&gt; &amp;Self { self } }
</span><span class="boring">impl Use for () {}
</span>// 存储`temp()`结果的临时变量在以下这些情况下只能在 let 语句结束之前使用。

let x = Some(&amp;temp());         // 错误
let x = (&amp;temp()).use_temp();  // 错误
<span class="boring">x;
</span><span class="boring">}</span></code></pre></pre>
<h2 id="不运行析构函数"><a class="header" href="#不运行析构函数">不运行析构函数</a></h2>
<p><a href="../std/mem/fn.forget.html"><code>std::mem::forget</code></a> 可以用来防止变量的析构函数被执行，而 <a href="../std/mem/struct.ManuallyDrop.html"><code>std::mem::ManuallyDrop</code></a> 提供了一个包装器来防止变量或字段被自动释放。</p>
<blockquote>
<p>注意：通过 <a href="../std/mem/fn.forget.html"><code>std::mem::forget</code></a> 或其他方式防止析构函数被执行即使具有不是 <code>'static</code> 类型的类型也是安全的。
除了在本文档中定义的保证运行析构函数的地方之外，类型不能安全地依赖析构函数被运行来确保安全性。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生命周期省略"><a class="header" href="#生命周期省略">生命周期省略</a></h1>
<p>在一些编译器可以推断出合理的默认选择的情况下，Rust 有规则允许省略生命周期。</p>
<h2 id="函数中的生命周期省略"><a class="header" href="#函数中的生命周期省略">函数中的生命周期省略</a></h2>
<p>为了让常见的模式更加人性化，生命周期参数可以在函数、函数指针和闭包 Trait 签名中被 <em>省略</em> 。
以下规则用于推断省略的生命周期参数。省略无法推断的生命周期参数是错误的。
占位符生命周期 <code>'_</code> 也可以被用来用同样的方式推断生命周期。对于路径上的生命周期，使用 <code>'_</code> 是更好的选择。
Trait 对象生命周期遵循不同的规则，下面会讨论。</p>
<ul>
<li>在参数中每个被省略的生命周期都成为一个独立的生命周期参数。</li>
<li>如果在参数中只有一个生命周期 (不论是否被省略) ，那么这个生命周期被分配到 <em>所有</em> 被省略的输出生命周期中。</li>
</ul>
<p>在方法签名中有另一个规则：</p>
<ul>
<li>如果接收器的类型是 <code>&amp;Self</code> 或 <code>&amp;mut Self</code>，那么指向 <code>Self</code> 的这个引用的生命周期会被分配到所有省略的输出生命周期参数上。</li>
</ul>
<p>例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait T {}
</span><span class="boring">trait ToCStr {}
</span><span class="boring">struct Thing&lt;'a&gt; {f: &amp;'a i32}
</span><span class="boring">struct Command;
</span><span class="boring">
</span><span class="boring">trait Example {
</span>fn print1(s: &amp;str);                                   // 省略生命周期
fn print2(s: &amp;'_ str);                                // 同样省略
fn print3&lt;'a&gt;(s: &amp;'a str);                            // 展开

fn debug1(lvl: usize, s: &amp;str);                       // 省略生命周期
fn debug2&lt;'a&gt;(lvl: usize, s: &amp;'a str);                // 展开

fn substr1(s: &amp;str, until: usize) -&gt; &amp;str;            // 省略生命周期
fn substr2&lt;'a&gt;(s: &amp;'a str, until: usize) -&gt; &amp;'a str;  // 展开

fn get_mut1(&amp;mut self) -&gt; &amp;mut dyn T;                 // 省略生命周期
fn get_mut2&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut dyn T;       // 展开

fn args1&lt;T: ToCStr&gt;(&amp;mut self, args: &amp;[T]) -&gt; &amp;mut Command;                  // 省略生命周期
fn args2&lt;'a, 'b, T: ToCStr&gt;(&amp;'a mut self, args: &amp;'b [T]) -&gt; &amp;'a mut Command; // 展开

fn new1(buf: &amp;mut [u8]) -&gt; Thing&lt;'_&gt;;                 // 省略生命周期 - 推荐
fn new2(buf: &amp;mut [u8]) -&gt; Thing;                     // 省略生命周期
fn new3&lt;'a&gt;(buf: &amp;'a mut [u8]) -&gt; Thing&lt;'a&gt;;          // 展开
<span class="boring">}
</span>
type FunPtr1 = fn(&amp;str) -&gt; &amp;str;                      // 省略生命周期
type FunPtr2 = for&lt;'a&gt; fn(&amp;'a str) -&gt; &amp;'a str;        // 展开

type FunTrait1 = dyn Fn(&amp;str) -&gt; &amp;str;                // 省略生命周期
type FunTrait2 = dyn for&lt;'a&gt; Fn(&amp;'a str) -&gt; &amp;'a str;  // 展开
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 以下示例展示了无法省略生命周期参数的情况。

<span class="boring">trait Example {
</span>// 无法推断，因为没有参数可推断。
fn get_str() -&gt; &amp;str;                                 // ILLEGAL

// 无法推断，不清楚是从第一个还是第二个参数中借用。
fn frob(s: &amp;str, t: &amp;str) -&gt; &amp;str;                    // ILLEGAL
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h2 id="默认trait对象生命周期"><a class="header" href="#默认trait对象生命周期">默认trait对象生命周期</a></h2>
<p>由 [trait 对象] 持有的引用的假定生命周期称为其 &quot;默认对象生命周期限制&quot; 。这些在 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md">RFC 599</a> 中定义并在 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md">RFC 1156</a> 中进行了修改。</p>
<p>这些默认对象生命周期限制在完全省略生命周期限制时使用，而不是使用上述省略生命周期参数的规则。如果将 <code>'_</code> 用作生命周期限制，则该限制遵循通常的省略规则。</p>
<p>如果 trait 对象用作泛型类型的类型参数，则首先使用包含类型来尝试推断约束。</p>
<ul>
<li>如果包含类型存在唯一的约束，则使用该约束作为默认值。</li>
<li>如果来自包含类型的约束超过一个，则必须指定显式约束。</li>
</ul>
<p>如果上述规则都不适用，则使用特征的限制：</p>
<ul>
<li>如果特征使用单个生命周期约束定义，则使用该约束。</li>
<li>如果使用 <code>'static</code> 作为任何生命周期限制，则使用 <code>'static</code> 。</li>
<li>如果特征没有生命周期限制，则在表达式中推断生命周期，并在表达式外部使用 <code>'static</code> 。</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对于下面的 trait...
trait Foo { }

// 这两者是相同的，因为 Box&lt;T&gt; 没有 T 上的生命周期限制
type T1 = Box&lt;dyn Foo&gt;;
type T2 = Box&lt;dyn Foo + 'static&gt;;

// ... 这两者也相同：
impl dyn Foo {}
impl dyn Foo + 'static {}

// ... 这两者也相同，因为 &amp;'a T 要求 T: 'a
type T3&lt;'a&gt; = &amp;'a dyn Foo;
type T4&lt;'a&gt; = &amp;'a (dyn Foo + 'a);

// std::cell::Ref&lt;'a, T&gt; 同样要求 T: 'a ，所以这两者相同
type T5&lt;'a&gt; = std::cell::Ref&lt;'a, dyn Foo&gt;;
type T6&lt;'a&gt; = std::cell::Ref&lt;'a, dyn Foo + 'a&gt;;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这是一个错误的示例。
<span class="boring">trait Foo { }
</span>struct TwoBounds&lt;'a, 'b, T: ?Sized + 'a + 'b&gt; {
    f1: &amp;'a i32,
    f2: &amp;'b i32,
    f3: T,
}
type T7&lt;'a, 'b&gt; = TwoBounds&lt;'a, 'b, dyn Foo&gt;;
//                                  ^^^^^^^
// 错误：无法从上下文中推断出对象类型的生命周期限制
<span class="boring">}</span></code></pre></pre>
<p>请注意，最内层的对象设置了生命周期约束，因此 <code>&amp;'a Box&lt;dyn Foo&gt;</code> 仍然等同于 <code>&amp;'a Box&lt;dyn Foo + 'static&gt;</code> 。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对于下面的 trait ...
trait Bar&lt;'a&gt;: 'a { }

// ...这两个是相同的:
type T1&lt;'a&gt; = Box&lt;dyn Bar&lt;'a&gt;&gt;;
type T2&lt;'a&gt; = Box&lt;dyn Bar&lt;'a&gt; + 'a&gt;;

// ...这两个也是相同的:
impl&lt;'a&gt; dyn Bar&lt;'a&gt; {}
impl&lt;'a&gt; dyn Bar&lt;'a&gt; + 'a {}
<span class="boring">}</span></code></pre></pre>
<h2 id="static-生命周期省略"><a class="header" href="#static-生命周期省略"><code>'static</code> 生命周期省略</a></h2>
<p>除非显式指定生命周期，否则引用类型的常量和静态声明都有 <em>隐含的</em> <code>'static</code> 生命周期。因此，上述涉及 <code>'static</code> 的常量声明可以不带生命周期。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// STRING: &amp;'static str
const STRING: &amp;str = &quot;bitstring&quot;;

struct BitsNStrings&lt;'a&gt; {
    mybits: [u32; 2],
    mystring: &amp;'a str,
}

// BITS_N_STRINGS: BitsNStrings&lt;'static&gt;
const BITS_N_STRINGS: BitsNStrings&lt;'_&gt; = BitsNStrings {
    mybits: [1, 2],
    mystring: STRING,
};
<span class="boring">}</span></code></pre></pre>
<p>请注意，如果 <code>static</code> 或 <code>const</code> 项包含函数或闭包引用，这些引用本身又包含引用，编译器将首先尝试标准省略规则。
如果它无法通过通常的规则解析生命周期，则会出现错误。以以下示例说明：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo;
</span><span class="boring">struct Bar;
</span><span class="boring">struct Baz;
</span><span class="boring">fn somefunc(a: &amp;Foo, b: &amp;Bar, c: &amp;Baz) -&gt; usize {42}
</span>// 解析为 `fn&lt;'a&gt;(&amp;'a str) -&gt; &amp;'a str`.
const RESOLVED_SINGLE: fn(&amp;str) -&gt; &amp;str = |x| x;

// 解析为 `Fn&lt;'a, 'b, 'c&gt;(&amp;'a Foo, &amp;'b Bar, &amp;'c Baz) -&gt; usize`.
const RESOLVED_MULTIPLE: &amp;dyn Fn(&amp;Foo, &amp;Bar, &amp;Baz) -&gt; usize = &amp;somefunc;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo;
</span><span class="boring">struct Bar;
</span><span class="boring">struct Baz;
</span><span class="boring">fn somefunc&lt;'a,'b&gt;(a: &amp;'a Foo, b: &amp;'b Bar) -&gt; &amp;'a Baz {unimplemented!()}
</span>// 缺少信息来将返回的引用生命周期绑定到参数的生命周期，
// 所以会出现错误。
const RESOLVED_STATIC: &amp;dyn Fn(&amp;Foo, &amp;Bar) -&gt; &amp;Baz = &amp;somefunc;
//                                            ^
// 此函数的返回类型包含了一个借用的值，但是函数签名并未表明它是从参数1还是参数2借用的。
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="特殊类型和-trait"><a class="header" href="#特殊类型和-trait">特殊类型和 trait</a></h1>
<p>某些在 <a href="../std/index.html">标准库</a> 中存在的类型和 trait 对于 Rust 编译器是已知的。本章介绍这些类型和 trait 的特殊特性。</p>
<h2 id="boxt"><a class="header" href="#boxt"><code>Box&lt;T&gt;</code></a></h2>
<p><a href="../std/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> 具有 Rust 目前不允许用户定义类型拥有的一些特殊特性。</p>
<ul>
<li><code>Box&lt;T&gt;</code> 的 <a href="expressions/operator-expr.html#the-dereference-operator">解引用运算符</a> 产生一个可以被移动的位置。这意味着 <code>*</code> 运算符和 <code>Box&lt;T&gt;</code> 的析构函数是内置到语言中的。</li>
<li><a href="items/associated-items.html#associated-functions-and-methods">方法</a> 可以以 <code>Box&lt;Self&gt;</code> 作为接收者。</li>
<li>在与 <code>T</code> 相同的 crate 中可以为 <code>Box&lt;T&gt;</code> 实现 trait，而 <a href="items/implementations.html#trait-implementation-coherence">孤儿规则</a> 阻止了对其他泛型类型的实现。</li>
</ul>
<h2 id="rct"><a class="header" href="#rct"><code>Rc&lt;T&gt;</code></a></h2>
<p><a href="../std/rc/struct.Rc.html"><code>Rc&lt;Self&gt;</code></a> 作为接收器也可以用于 <a href="items/associated-items.html#associated-functions-and-methods">方法</a> 。</p>
<h2 id="arct"><a class="header" href="#arct"><code>Arc&lt;T&gt;</code></a></h2>
<p><a href="../std/sync/struct.Arc.html"><code>Arc&lt;Self&gt;</code></a> 作为接收器也可以用于 <a href="items/associated-items.html#associated-functions-and-methods">方法</a> 。</p>
<h2 id="pinp"><a class="header" href="#pinp"><code>Pin&lt;P&gt;</code></a></h2>
<p><a href="../std/pin/struct.Pin.html"><code>Pin&lt;P&gt;</code></a> 作为接收器也可以用于 <a href="items/associated-items.html#associated-functions-and-methods">方法</a> 。</p>
<h2 id="unsafecellt"><a class="header" href="#unsafecellt"><code>UnsafeCell&lt;T&gt;</code></a></h2>
<p><a href="../std/cell/struct.UnsafeCell.html"><code>std::cell::UnsafeCell&lt;T&gt;</code></a> 用于 <a href="interior-mutability.html">内部可变性</a> 。它确保编译器不会为此类类型执行不正确的优化。
它还确保带有内部可变性的类型的 <a href="items/static-items.html"><code>static</code> 条目</a> 不会被放置在标记为只读的内存中。</p>
<h2 id="phantomdatat"><a class="header" href="#phantomdatat"><code>PhantomData&lt;T&gt;</code></a></h2>
<p><a href="../std/marker/struct.PhantomData.html"><code>std::marker::PhantomData&lt;T&gt;</code></a> 是一种零大小、最小对齐方式的类型。从 <a href="subtyping.html#variance">variance</a>、<a href="../nomicon/dropck.html">drop check</a> 和 <a href="special-types-and-traits.html#auto-traits">auto traits</a> 的角度来看，它被视为拥有一个类型为 <code>T</code> 的实例。</p>
<h2 id="运算符-trait"><a class="header" href="#运算符-trait">运算符 trait</a></h2>
<p><a href="../std/ops/index.html"><code>std::ops</code></a> 和 <a href="../std/cmp/index.html"><code>std::cmp</code></a> 中的 trait 用于重载 <a href="expressions/operator-expr.html">运算符</a> 、 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">索引表达式</a> 和 <a href="expressions/call-expr.html">调用表达式</a> 。</p>
<h2 id="deref-和-derefmut"><a class="header" href="#deref-和-derefmut"><code>Deref</code> 和 <code>DerefMut</code></a></h2>
<p>除了重载一元操作符 <code>*</code> 之外，<a href="../std/ops/trait.Deref.html"><code>Deref</code></a> 和 <a href="../std/ops/trait.DerefMut.html"><code>DerefMut</code></a> 还用于 <a href="expressions/method-call-expr.html">方法解析</a> 和 <a href="type-coercions.html#coercion-types">解引用强制转换</a>。</p>
<h2 id="drop"><a class="header" href="#drop"><code>Drop</code></a></h2>
<p><a href="../std/ops/trait.Drop.html"><code>Drop</code></a> trait 提供了一个 <a href="destructors.html">析构器</a> ，当该类型的值即将被销毁时运行。</p>
<h2 id="copy"><a class="header" href="#copy"><code>Copy</code></a></h2>
<p><a href="../std/marker/trait.Copy.html"><code>Copy</code></a> trait 改变了实现它的类型的语义。实现 <code>Copy</code> 的类型的值在赋值时会被复制而不是移动。只有不实现 <code>Drop</code> trait 并且其所有字段都是 <code>Copy</code> 类型的类型才能实现 <code>Copy</code> trait 。
对于枚举，这意味着所有变体的所有字段都必须是 <code>Copy</code> 类型。对于 union ，这意味着所有变体都必须是 <code>Copy</code> 类型。编译器为以下类型实现了 <code>Copy</code> trait ：</p>
<ul>
<li><code>Copy</code> 类型的元组</li>
<li><a href="types/function-pointer.html">函数指针</a></li>
<li><a href="types/function-item.html">函数条目</a></li>
<li>没有捕获任何值或仅捕获 <code>Copy</code> 类型值的 <a href="types/closure.html">闭包</a></li>
</ul>
<h2 id="clone"><a class="header" href="#clone"><code>Clone</code></a></h2>
<p><a href="../std/clone/trait.Clone.html"><code>Clone</code></a> trait 是 <code>Copy</code> 的超级 trait ，因此它也需要编译器生成的实现。编译器为以下类型实现了此 trait：</p>
<ul>
<li>有内置 <code>Copy</code> 实现的类型 (见上文)</li>
<li><a href="../std/clone/trait.Clone.html"><code>Clone</code></a> 类型的元组</li>
</ul>
<h2 id="send"><a class="header" href="#send"><code>Send</code></a></h2>
<p><a href="../std/marker/trait.Send.html"><code>Send</code></a> trait 表明此类型的值可以安全地从一个线程发送到另一个线程。</p>
<h2 id="sync"><a class="header" href="#sync"><code>Sync</code></a></h2>
<p><a href="../std/marker/trait.Sync.html"><code>Sync</code></a> trait 表明此类型的值可以安全地在多个线程之间共享。所有用于不可变 <a href="items/static-items.html"><code>static</code> 条目</a> 的类型都必须实现此 trait 。</p>
<h2 id="termination"><a class="header" href="#termination"><code>Termination</code></a></h2>
<p><a href="../std/process/trait.Termination.html"><code>Termination</code></a> trait 指示 <a href="crates-and-source-files.html#main-functions">main 函数</a> 和 <a href="attributes/testing.html#the-test-attribute">test 函数</a> 的可接受返回类型。</p>
<h2 id="自动-trait"><a class="header" href="#自动-trait">自动 trait</a></h2>
<p><a href="../std/marker/trait.Send.html"><code>Send</code></a>、<a href="../std/marker/trait.Sync.html"><code>Sync</code></a>、<a href="../std/marker/trait.Unpin.html"><code>Unpin</code></a>、<a href="../std/panic/trait.UnwindSafe.html"><code>UnwindSafe</code></a> 和 <a href="../std/panic/trait.RefUnwindSafe.html"><code>RefUnwindSafe</code></a> trait 是 &quot;自动 trait&quot; 。自动 trait 具有特殊的属性。如果对于给定类型的自动 trait 没有显式实现或负实现，则编译器会根据以下规则自动实现：</p>
<ul>
<li>如果类型 <code>T</code> 实现了 trait ，那么 <code>&amp;T</code> <code>&amp;mut T</code> <code>*const T</code> <code>*mut T</code> <code>[T; n]</code> 和 <code>[T]</code> 都会实现该 trait 。</li>
<li>函数条目类型和函数指针会自动实现该 trait 。</li>
<li>如果它们的所有字段都实现了该 trait ，则结构体、枚举、联合体和元组会实现该 trait 。</li>
<li>如果它们捕获的所有值的类型都实现了该 trait ，则闭包会实现该 trait 。</li>
</ul>
<p>捕获一个 <code>T</code> 的共享引用和一个 <code>U</code> 的值的闭包会实现两个 <code>&amp;T</code> 和 <code>U</code> 都实现的自动 trait 。
对于泛型类型 (将上面内置类型视为泛型的 <code>T</code> )，如果有通用实现，则编译器不会自动实现该 trait ，而是根据需要的 trait 限制为没有达到 trait 限制的类型实现。例如，标准库为所有 <code>T</code> 是 <code>Sync</code> 的 <code>&amp;T</code> 实现了 <code>Send</code> ；这意味着，如果 <code>T</code> 是 <code>Send</code> 但不是 <code>Sync</code> ，则编译器不会为 <code>&amp;T</code> 实现 <code>Send</code> 。
自动 trait 也可以有负实现，在标准库文档中表示为 <code>impl !AutoTrait for T</code> ，它们覆盖了自动实现。例如， <code>*mut T</code> 有一个 <code>Send</code> 的负实现，因此即使 <code>T</code> 是 <code>Send</code> ， <code>*mut T</code> 也不是 <code>Send</code> 。
目前没有稳定的方法指定额外的负实现；它们只存在于标准库中。自动 trait 可以作为 <a href="types/trait-object.html">trait 对象</a> 的附加限制添加到任何 trait 中，尽管通常只允许一个 trait 。
例如，<code>Box&lt;dyn Debug + Send + UnwindSafe&gt;</code>是一个有效的类型。</p>
<h2 id="sized-1"><a class="header" href="#sized-1"><code>Sized</code></a></h2>
<p><a href="../std/marker/trait.Sized.html"><code>Sized</code></a> trait 表示这个类型在编译时大小是已知的，即它不是 <a href="dynamically-sized-types.html">动态大小类型</a> 。
类型参数 (除了trait 中的 <code>Self</code> ) 默认都是 <code>Sized</code> 的，关联类型也是。
<code>Sized</code> trait 总是由编译器自动实现，而不是由 <a href="items/implementations.html">实现条目</a> 实现的。
这些隐式的 <code>Sized</code> 约束可以通过使用特殊的 <code>?Sized</code> 约束进行放宽。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="名称"><a class="header" href="#名称">名称</a></h1>
<p><em>实体</em> 是一种语言构造，可以通过某种方式在源程序中引用，通常是通过 <a href="paths.html">路径</a> 。
实体包括 <a href="types.html">类型</a> 、 <a href="items.html">条目</a> 、 <a href="items/generics.html">泛型参数</a> 、 <a href="patterns.html">变量绑定</a> 、 <a href="expressions/loop-expr.html#loop-labels">循环标签</a> 、 <a href="tokens.html#lifetimes-and-loop-labels">生命周期</a> 、 <a href="expressions/field-expr.html">字段</a> 、 <a href="attributes.html">属性</a> 和 <a href="attributes/diagnostics.html#lint-check-attributes">代码分析</a> 。</p>
<p><em>声明</em> 是一种语法构造，可以引入 <em>名称</em> 来引用一个实体。实体名称在 <a href="names/scopes.html"><em>作用域</em></a> 内是有效的 —— 源文本的一个区域，可以在其中引用该名称。
一些实体在源代码中 <a href="names.html#explicitly-declared-entities">显式声明</a>，一些实体则作为语言或编译器扩展的一部分 <a href="names.html#implicitly-declared-entities">隐式声明</a>。</p>
<p><a href="paths.html"><em>路径</em></a> 用于引用实体，可能在另一个作用域中。生命周期和循环标签使用 <a href="tokens.html#lifetimes-and-loop-labels">专用语法</a>，使用前导引号。</p>
<p>名称被分为不同的 <a href="names/namespaces.html"><em>命名空间</em></a> ，允许不同命名空间中的实体共享相同的名称而不冲突。</p>
<p><a href="names/name-resolution.html"><em>名称解析</em></a> 是将路径、标识符和标签与实体声明联系起来的编译时过程。</p>
<p>根据 <a href="visibility-and-privacy.html"><em>可见性</em></a> ，访问某些名称可能会受到限制。</p>
<h2 id="明确声明的实体"><a class="header" href="#明确声明的实体">明确声明的实体</a></h2>
<p>在源代码中明确引入名称的实体包括：</p>
<ul>
<li><a href="items.html">条目</a>：
<ul>
<li><a href="items/modules.html">模块声明</a></li>
<li><a href="items/extern-crates.html">外部 crate 声明</a></li>
<li><a href="items/use-declarations.html">使用声明</a></li>
<li><a href="items/functions.html">函数声明</a> 和 <a href="items/functions.html#function-parameters">函数参数</a></li>
<li><a href="items/type-aliases.html">类型别名</a></li>
<li><a href="items/structs.html">结构体</a> 、 <a href="items/unions.html">联合体</a> 、 <a href="items/enumerations.html">枚举</a> 、枚举变体声明及其命名字段</li>
<li><a href="items/constant-items.html">常量条目声明</a></li>
<li><a href="items/static-items.html">静态条目声明</a></li>
<li><a href="items/traits.html">Trait 条目声明</a> 及其 <a href="items/associated-items.html">关联条目</a></li>
<li><a href="items/external-blocks.html">外部块条目</a></li>
<li><a href="macros-by-example.html"><code>macro_rules</code> 声明</a> 和 <a href="macros-by-example.html#metavariables">匹配器元变量</a></li>
<li><a href="items/implementations.html">实现</a> 的关联条目</li>
</ul>
</li>
<li><a href="expressions.html">表达式</a>：
<ul>
<li><a href="expressions/closure-expr.html">闭包</a> 参数</li>
<li><a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a> 模式绑定</li>
<li><a href="expressions/loop-expr.html#iterator-loops"><code>for</code></a> 模式绑定</li>
<li><a href="expressions/if-expr.html#if-let-expressions"><code>if let</code></a> 模式绑定</li>
<li><a href="expressions/match-expr.html"><code>match</code></a> 模式绑定</li>
<li><a href="expressions/loop-expr.html#loop-labels">Loop标签</a></li>
</ul>
</li>
<li><a href="items/generics.html">泛型参数</a></li>
<li><a href="trait-bounds.html#higher-ranked-trait-bounds">高阶 trait 约束</a></li>
<li><a href="statements.html#let-statements"><code>let</code> 语句</a> 的模式绑定</li>
<li><a href="macros-by-example.html#the-macro_use-attribute"><code>macro_use</code> 属性</a> 可以引入另一个 crate 中的宏名称</li>
<li><a href="macros-by-example.html#path-based-scope"><code>macro_export</code> 属性</a> 可以将宏的别名引入 crate 根</li>
</ul>
<p>此外， <a href="macros.html#macro-invocation">宏调用</a> 和 <a href="attributes.html">属性</a> 可以通过扩展为上述项之一而引入名称。</p>
<h2 id="隐式声明的实体"><a class="header" href="#隐式声明的实体">隐式声明的实体</a></h2>
<p>以下实体是由语言隐式定义的，或者是由编译器选项和扩展引入的:</p>
<ul>
<li><a href="names/preludes.html#language-prelude">语言预定义</a>:
<ul>
<li><a href="types/boolean.html">布尔类型</a> — <code>bool</code></li>
<li><a href="types/textual.html">文本类型</a> — <code>char</code> 和 <code>str</code></li>
<li><a href="types/numeric.html#integer-types">整数类型</a> — <code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code>、<code>i128</code>、<code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code></li>
<li><a href="types/numeric.html#machine-dependent-integer-types">机器相关整数类型</a> — <code>usize</code> 和 <code>isize</code></li>
<li><a href="types/numeric.html#floating-point-types">浮点类型</a> — <code>f32</code> 和 <code>f64</code></li>
</ul>
</li>
<li><a href="attributes.html#built-in-attributes-index">内置属性</a></li>
<li><a href="names/preludes.html#standard-library-prelude">标准库预定义</a> 条目、属性和宏</li>
<li>根模块中的 <a href="names/preludes.html#extern-prelude">标准库</a> crate</li>
<li>编译器链接的 <a href="names/preludes.html#extern-prelude">外部 crate</a></li>
<li><a href="attributes.html#tool-attributes">工具属性</a></li>
<li><a href="attributes/diagnostics.html#lint-check-attributes">代码分析</a> 和 <a href="attributes/diagnostics.html#tool-lint-attributes">工具 Lint 属性</a></li>
<li><a href="procedural-macros.html#derive-macro-helper-attributes">衍生助手属性</a> 在条目内有效，无需显式导入</li>
<li><a href="keywords.html#weak-keywords"><code>'static</code></a> 生命周期</li>
</ul>
<p>此外，crate 根模块没有名称，但可以用某些 <a href="paths.html#path-qualifiers">路径限定符</a> 或别名来引用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命名空间"><a class="header" href="#命名空间">命名空间</a></h1>
<p><em>命名空间</em> 是指已声明的 <a href="names/../names.html">名称</a> 的逻辑分组。基于名称所指代实体的种类，将名称分隔到不同的命名空间中。
命名空间允许相同名称在一个命名空间中与另一个命名空间中的相同名称不发生冲突。</p>
<p>在一个命名空间内，名称按层次结构组织，每个层次结构都有其自己的命名实体集合。</p>
<p>有几个不同的命名空间，每个命名空间包含不同种类的实体。根据上下文，名称的使用将在不同的命名空间中查找该名称的声明，如 <a href="names/name-resolution.html">名称解析</a> 章节所述。</p>
<p>以下是命名空间及其相应实体的列表：</p>
<ul>
<li>类型命名空间
<ul>
<li><a href="names/../items/modules.html">模块声明</a></li>
<li><a href="names/../items/extern-crates.html">外部 crate 声明</a></li>
<li><a href="names/preludes.html#extern-prelude">外部 crate 预定义</a> 条目</li>
<li>结构体、联合体、枚举类型、枚举类型变量声明</li>
<li><a href="names/../items/traits.html">Trait条目声明</a></li>
<li><a href="names/../items/type-aliases.html">类型别名</a></li>
<li><a href="names/../items/associated-items.html#associated-types">关联类型声明</a></li>
<li>内置类型： <a href="names/../types/boolean.html">布尔</a> 、 <a href="names/../types/numeric.html">数字</a> 、 <a href="names/../types/textual.html">文本</a> </li>
<li><a href="names/../items/generics.html">泛型类型参数</a></li>
<li><a href="names/../paths.html#self-1"><code>Self</code> 类型</a></li>
<li><a href="names/../attributes.html#tool-attributes">工具属性模块</a></li>
</ul>
</li>
<li>值命名空间
<ul>
<li><a href="names/../items/functions.html">函数声明</a></li>
<li><a href="names/../items/constant-items.html">常量声明</a></li>
<li><a href="names/../items/static-items.html">静态声明</a></li>
<li><a href="names/../items/structs.html">结构体构造函数</a></li>
<li><a href="names/../items/enumerations.html">枚举类型变量构造函数</a></li>
<li><a href="names/../paths.html#self-1"><code>Self</code> 构造函数</a></li>
<li><a href="names/../items/generics.html#const-generics">泛型常量参数</a></li>
<li><a href="names/../items/associated-items.html#associated-constants">关联常量声明</a></li>
<li><a href="names/../items/associated-items.html#associated-functions-and-methods">关联函数声明</a></li>
<li>本地绑定 —  <a href="names/../statements.html#let-statements"><code>let</code></a> 、 <a href="names/../expressions/if-expr.html#if-let-expressions"><code>if let</code></a> 、 <a href="names/../expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a> 、 <a href="names/../expressions/loop-expr.html#iterator-loops"><code>for</code></a> 、 <a href="names/../expressions/match-expr.html"><code>match</code></a> 条件、 <a href="names/../items/functions.html#function-parameters">函数参数</a> 、 <a href="names/../expressions/closure-expr.html">闭包参数</a> </li>
<li>被 <a href="names/../expressions/closure-expr.html">闭包</a> 捕获的变量</li>
</ul>
</li>
<li>宏命名空间
<ul>
<li><a href="names/../macros-by-example.html"><code>macro_rules</code> 声明</a></li>
<li><a href="names/../attributes.html#built-in-attributes-index">内置属性</a></li>
<li><a href="names/../attributes.html#tool-attributes">工具属性</a></li>
<li><a href="names/../procedural-macros.html#function-like-procedural-macros">类函数过程宏</a></li>
<li><a href="names/../procedural-macros.html#derive-macros">衍生宏</a></li>
<li><a href="names/../procedural-macros.html#derive-macro-helper-attributes">衍生宏帮助工具</a></li>
<li><a href="names/../procedural-macros.html#attribute-macros">属性宏</a></li>
</ul>
</li>
<li>生命周期命名空间
<ul>
<li><a href="names/../items/generics.html">泛型生命周期参数</a></li>
</ul>
</li>
<li>标签命名空间
<ul>
<li><a href="names/../expressions/loop-expr.html#loop-labels">循环标签</a></li>
</ul>
</li>
</ul>
<p>不同命名空间中重复的名称如何可以无歧义地使用的示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Foo 在类型命名空间中引入了一个类型和在值命名空间中引入了一个构造函数。
struct Foo(u32);

// `Foo` 宏在宏命名空间中声明。
macro_rules! Foo {
    () =&gt; {};
}

// `Foo` 在 `f` 参数类型中引用了类型命名空间中的 `Foo` ， `'Foo` 引入了生命周期命名空间中的新生命周期。
fn example&lt;'Foo&gt;(f: Foo) {
    // `Foo` 引用了值命名空间中的 `Foo` 构造函数。
    let ctor = Foo;
    // `Foo` 引用了宏命名空间中的 `Foo` 宏。
    Foo!{}
    // `'Foo` 引入了标签命名空间中的一个标签。
    'Foo: loop {
        // `'Foo` 引用了 `'Foo` 生命周期参数，`Foo` 引用了类型命名空间。
        let x: &amp;'Foo Foo;
        // `'Foo` 引用了该标签。
        break 'Foo;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="没有命名空间的已命名实体"><a class="header" href="#没有命名空间的已命名实体">没有命名空间的已命名实体</a></h2>
<p>以下实体具有显式名称，但名称不属于任何特定命名空间。</p>
<h3 id="字段"><a class="header" href="#字段">字段</a></h3>
<p>尽管结构体、枚举和联合体字段是有名称的，但命名字段不属于显式的命名空间。
它们只能通过 <a href="names/../expressions/field-expr.html">字段表达式</a> 访问，该表达式仅检查正在访问的特定类型的字段名称。</p>
<h3 id="use-声明-1"><a class="header" href="#use-声明-1">use 声明</a></h3>
<p><a href="names/../items/use-declarations.html">use 声明</a> 具有命名别名，它们被导入到作用域中，但 <code>use</code> 条目本身不属于特定的命名空间。相反，它可以根据所导入的条目类型将别名引入到多个命名空间中。</p>
<!-- TODO: 描述 `use` 如何在 use 声明页上工作，并在此处链接到该页面。 -->
<h2 id="子命名空间"><a class="header" href="#子命名空间">子命名空间</a></h2>
<p>宏命名空间被分为两个子命名空间：一个用于 <a href="names/../macros.html">感叹号风格宏</a> ，一个用于 <a href="names/../attributes.html">属性</a>。
当解析属性时，将忽略作用域中的任何感叹号风格宏。
反之，解析感叹号风格宏将忽略作用域中的属性宏。
这样可以防止一个风格覆盖另一个。</p>
<p>例如， <a href="names/../conditional-compilation.html#the-cfg-attribute"><code>cfg</code> 属性</a> 和 <a href="names/../conditional-compilation.html#the-cfg-macro"><code>cfg</code> 宏</a> 是宏命名空间中具有相同名称的两个不同实体，但它们仍可以在各自的上下文中使用。</p>
<p>无论子命名空间如何， <a href="names/../items/use-declarations.html"><code>use</code> 导入</a> 覆盖另一个宏仍将导致错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="作用域"><a class="header" href="#作用域">作用域</a></h1>
<blockquote>
<p><strong>注意</strong>: 这是一个未来扩展的占位符。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="预定义"><a class="header" href="#预定义">预定义</a></h1>
<p><em>预定义</em> 是一组自动引入到一个 crate 中每个模块作用域的名称。</p>
<p>这些预定义名称不是模块本身的一部分: 它们在 <a href="names/name-resolution.html">命名解析</a> 期间隐式查询。例如，即使像 <a href="names/../../std/boxed/struct.Box.html"><code>Box</code></a> 这样的内容在每个模块中都处于作用域中，但您无法将其称为 <code>self::Box</code> ，因为它不是当前模块的成员。</p>
<p>有几个不同的预定义:</p>
<ul>
<li><a href="names/preludes.html#standard-library-prelude">标准库预定义</a></li>
<li><a href="names/preludes.html#extern-prelude">外部预定义</a></li>
<li><a href="names/preludes.html#language-prelude">语言预定义</a></li>
<li><a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> 预定义</a></li>
<li><a href="names/preludes.html#tool-prelude">工具预定义</a></li>
</ul>
<h2 id="标准库预定义"><a class="header" href="#标准库预定义">标准库预定义</a></h2>
<p>每个crate都有一个标准库预定义，其中包括来自单个标准库模块的名称。所使用的模块取决于 crate 的版本，以及是否应用了 <a href="names/preludes.html#the-no_std-attribute"><code>no_std</code>属性</a> ：</p>
<div class="table-wrapper"><table><thead><tr><th>版本</th><th>未应用<code>no_std</code></th><th>应用<code>no_std</code></th></tr></thead><tbody>
<tr><td>2015</td><td><a href="names/../../std/prelude/rust_2015/index.html"><code>std::prelude::rust_2015</code></a></td><td><a href="names/../../core/prelude/rust_2015/index.html"><code>core::prelude::rust_2015</code></a></td></tr>
<tr><td>2018</td><td><a href="names/../../std/prelude/rust_2018/index.html"><code>std::prelude::rust_2018</code></a></td><td><a href="names/../../core/prelude/rust_2018/index.html"><code>core::prelude::rust_2018</code></a></td></tr>
<tr><td>2021</td><td><a href="names/../../std/prelude/rust_2021/index.html"><code>std::prelude::rust_2021</code></a></td><td><a href="names/../../core/prelude/rust_2021/index.html"><code>core::prelude::rust_2021</code></a></td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>注意</strong>：</p>
<p><a href="names/../../std/prelude/rust_2015/index.html"><code>std::prelude::rust_2015</code></a> 和 <a href="names/../../std/prelude/rust_2018/index.html"><code>std::prelude::rust_2018</code></a> 的内容与 <a href="names/../../std/prelude/v1/index.html"><code>std::prelude::v1</code></a> 相同。</p>
<p><a href="names/../../core/prelude/rust_2015/index.html"><code>core::prelude::rust_2015</code></a> 和 <a href="names/../../core/prelude/rust_2018/index.html"><code>core::prelude::rust_2018</code></a> 的内容与 <a href="names/../../core/prelude/v1/index.html"><code>core::prelude::v1</code></a> 相同。</p>
</blockquote>
<h2 id="外部预定义"><a class="header" href="#外部预定义">外部预定义</a></h2>
<p>在根模块中使用 <a href="names/../items/extern-crates.html"><code>extern crate</code></a> 导入的外部 crate 或提供给编译器的 crate (例如使用 <code>rustc</code> 的 <code>--extern</code> 标志) 将被添加到 <em>外部定义</em> 中。如果使用别名导入，例如 <code>extern crate orig_name as new_name</code> ，则符号  <code>new_name</code> 将添加到预定义中。</p>
<p><a href="names/../../core/index.html"><code>core</code></a> crate 始终会被添加到外部预定义中。只要在 crate 根中未指定 [<code>no_std</code>属性] ， <a href="names/../../std/index.html"><code>std</code></a> crate 也会被添加到预定义中。</p>
<blockquote>
<p><strong>版本差异</strong>: 在 2015 版中，外部预定义中的 crate 不能通过 <a href="names/../items/use-declarations.html">use 声明</a> 引用，因此通常的做法是使用<code>extern crate</code>声明将它们引入作用域。</p>
<p>从 2018 年版开始， <a href="names/../items/use-declarations.html">use声明</a> 可以引用外部预定义中的 crate ，因此使用 <code>extern crate</code> 被认为不符合惯例。</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>: 随 <code>rustc</code> 一起提供的其他 crate ，例如 <a href="names/../../alloc/index.html"><code>alloc</code></a> 和 <a href="names/../../test/index.html"><code>test</code></a> ，在使用 Cargo 时不会自动包含在 <code>--extern</code> 标志中。它们必须通过 <code>extern crate</code> 声明引入作用域，即使在 2018 年版中也是如此。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate alloc;
use alloc::rc::Rc;
<span class="boring">}</span></code></pre></pre>
<p>对于 proc-macro crate ， Cargo 会将 <code>proc_macro</code> 自动添加到外部预定义中。</p>
</blockquote>
<!--
有关alloc/test限制的更多信息，请参见https://github.com/rust-lang/rust/issues/57288。
-->
<h3 id="no_std-属性"><a class="header" href="#no_std-属性"><code>no_std</code> 属性</a></h3>
<p>默认情况下，标准库会自动包含在 crate 的根模块中。<a href="names/../../std/index.html"><code>std</code></a> crate 与一个隐式的 <a href="names/../macros-by-example.html#the-macro_use-attribute"><code>macro_use</code> 属性</a> 一同添加到根模块，将 <code>std</code> 导出的所有宏都添加到 <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> 预定义模块</a> 中。同时，<a href="names/../../core/index.html"><code>core</code></a> 和 <a href="names/../../std/index.html"><code>std</code></a> 也会添加到 <a href="names/preludes.html#extern-prelude">extern 预定义</a> 中。</p>
<p>可以在 crate 级别应用 <em><code>no_std</code> <a href="names/../attributes.html">属性</a></em> 来阻止自动将 <a href="names/../../std/index.html"><code>std</code></a> crate 添加到作用域中。它会做三件事情：</p>
<ul>
<li>防止 <code>std</code> 添加到 <a href="names/preludes.html#extern-prelude">extern 预定义</a> 中。</li>
<li>影响用于构建 <a href="names/preludes.html#standard-library-prelude">标准库预定义</a> 的模块 (如上所述) 。</li>
<li>将 <a href="names/../../core/index.html"><code>core</code></a> crate 注入到 crate 根模块中，而不是 <a href="names/../../std/index.html"><code>std</code></a>，并将所有从 <code>core</code> 导出的宏添加到 <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> 预定义模块</a> 中。</li>
</ul>
<blockquote>
<p><strong>注意</strong>: 当 crate 目标平台不支持标准库或有意不使用标准库的功能时，使用核心预定义而不是标准库预定义很有用。
这些功能主要包括动态内存分配 (例如 <code>Box</code> 和 <code>Vec</code> ) 以及文件和网络功能 (例如 <code>std::fs</code> 和 <code>std::io</code> ) 。</p>
</blockquote>
<div class="warning">
<p>警告: 使用 <code>no_std</code> 不会防止标准库被链接。在 crate 中放置 <code>extern crate std;</code> 是有效的，依赖项也可以链接它。</p>
</div>
<h2 id="语言预定义"><a class="header" href="#语言预定义">语言预定义</a></h2>
<p>语言预定义包括内置于语言中的类型和属性名称。语言预定义始终在作用域内。它包括以下内容：</p>
<ul>
<li><a href="names/namespaces.html">类型命名空间</a>
<ul>
<li><a href="names/../types/boolean.html">布尔类型</a> — <code>bool</code></li>
<li><a href="names/../types/textual.html">文本类型</a> — <code>char</code> 和 <code>str</code></li>
<li><a href="names/../types/numeric.html#integer-types">整数类型</a> — <code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code>、<code>i128</code>、<code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code></li>
<li><a href="names/../types/numeric.html#machine-dependent-integer-types">与机器相关的整数类型</a> — <code>usize</code> 和 <code>isize</code></li>
<li><a href="names/../types/numeric.html#floating-point-types">浮点数类型</a> — <code>f32</code> 和 <code>f64</code></li>
</ul>
</li>
<li><a href="names/namespaces.html">宏命名空间</a>
<ul>
<li><a href="names/../attributes.html#built-in-attributes-index">内置属性</a></li>
</ul>
</li>
</ul>
<h2 id="macro_use-预定义"><a class="header" href="#macro_use-预定义"><code>macro_use</code> 预定义</a></h2>
<p><code>macro_use</code> 预定义包括来自外部 crate 的宏，这些宏是通过 [<code>macro_use</code>] 属性定义的。</p>
<h2 id="工具预定义"><a class="header" href="#工具预定义">工具预定义</a></h2>
<p>工具预定义包括外部工具的工具名称，位于 <a href="names/namespaces.html">类型命名空间</a> 中。有关详细信息，请参见 <a href="names/../attributes.html#tool-attributes">工具属性</a> 部分。</p>
<h2 id="no_implicit_prelude-属性"><a class="header" href="#no_implicit_prelude-属性"><code>no_implicit_prelude</code> 属性</a></h2>
<p><em><code>no_implicit_prelude</code> <a href="names/../attributes.html">attribute</a></em> 可以应用于 crate 级别或模块上，表示它不应自动为该模块或其任何子级引入 <a href="names/preludes.html#standard-library-prelude">标准库预定义</a>、 <a href="names/preludes.html#extern-prelude">extern 预定义</a> 或 <a href="names/preludes.html#tool-prelude">工具预定义</a> 。</p>
<p>该属性不影响 <a href="names/preludes.html#language-prelude">语言预定义</a> 。</p>
<blockquote>
<p><strong>版本差异</strong>：在 2015 版中，<code>no_implicit_prelude</code> 属性不影响 <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> 预定义</a> ，并且标准库导出的所有宏仍包含在 <code>macro_use</code> 预定义中。从 2018 版开始，将删除 <code>macro_use</code> 预定义。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="路径"><a class="header" href="#路径">路径</a></h1>
<p><em>路径</em> 是一个由一个或多个路径段 <em>逻辑上</em> 由命名空间 <span class="parenthetical">限定符(<code>::</code>)</span> 分隔的序列。
如果路径只包含一个段，则它引用一个局部控制作用域中的 <a href="items.html">条目</a> 或 <a href="variables.html">变量</a> 。如果路径有多个段，它总是引用一个条目。</p>
<p>以下是由标识符段组成的简单路径的两个示例：</p>
<!-- ignore: syntax fragment -->
<pre><code class="language-rust ignore">x;
x::y::z;</code></pre>
<h2 id="路径的类型"><a class="header" href="#路径的类型">路径的类型</a></h2>
<h3 id="简单路径"><a class="header" href="#简单路径">简单路径</a></h3>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>简单路径</em> :<br />
   <code>::</code><sup>?</sup> <em>简单路径语句</em> (<code>::</code> <em>简单路径语句</em>)<sup>*</sup></p>
<p><em>简单路径语句</em> :<br />
   <a href="identifiers.html">标识符</a> | <code>super</code> | <code>self</code> | <code>crate</code> | <code>$crate</code></p>
</blockquote>
<p>简单路径在 <a href="visibility-and-privacy.html">可见性</a> 标记， <a href="attributes.html">属性</a> ， <a href="macros-by-example.html">宏</a> 和 <a href="items/use-declarations.html"><code>use</code></a> 条目中使用。
例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};
mod m {
    #[clippy::cyclomatic_complexity = &quot;0&quot;]
    pub (in super) fn f1() {}
}
<span class="boring">}</span></code></pre></pre>
<h3 id="路径表达式-1"><a class="header" href="#路径表达式-1">路径表达式</a></h3>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>表达式中路径</em> :<br />
   <code>::</code><sup>?</sup> <em>路径表达式语句</em> (<code>::</code> <em>路径表达式语句</em>)<sup>*</sup></p>
<p><em>路径表达式语句</em> :<br />
   <em>路径ID语句</em> (<code>::</code> <em>泛型参数组</em>)<sup>?</sup></p>
<p><em>路径ID语句</em> :<br />
   <a href="identifiers.html">标识符</a> | <code>super</code> | <code>self</code> | <code>Self</code> | <code>crate</code> | <code>$crate</code></p>
<p><em>泛型参数组</em> :<br />
      <code>&lt;</code> <code>&gt;</code><br />
   | <code>&lt;</code> ( <em>泛型参数</em> <code>,</code> )<sup>*</sup> <em>泛型参数</em> <code>,</code><sup>?</sup> <code>&gt;</code></p>
<p><em>泛型参数</em> :<br />
   <a href="trait-bounds.html"><em>生命周期</em></a> | <a href="types.html#type-expressions"><em>类型</em></a> | <em>泛型参数组常量</em> | <em>泛型参数组绑定</em></p>
<p><em>泛型参数组常量</em> :<br />
      <a href="expressions/block-expr.html"><em>块表达式</em></a><br />
   | <a href="expressions/literal-expr.html"><em>字面值表达式</em></a><br />
   | <code>-</code> <a href="expressions/literal-expr.html"><em>字面值表达式</em></a><br />
   | <a href="paths.html#simple-paths"><em>简单路径语句</em></a></p>
<p><em>泛型参数组绑定</em> :<br />
   <a href="identifiers.html">标识符</a><code>=</code> <a href="types.html#type-expressions"><em>类型</em></a></p>
</blockquote>
<p>表达式中的路径允许指定带有泛型参数的路径。它们在表达式和模式的各种位置使用。</p>
<p>在泛型参数的左括号 <code>&lt;</code> 前面需要添加 <code>::</code> 标记以避免与小于号操作符产生歧义。这通常被称为 &quot;turbofish&quot; 语法。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(0..10).collect::&lt;Vec&lt;_&gt;&gt;();
Vec::&lt;u8&gt;::with_capacity(1024);
<span class="boring">}</span></code></pre></pre>
<p>泛型参数的顺序是受限的，首先是生命周期参数，然后是类型参数，然后是常量参数，最后是相等性约束。</p>
<p>常量参数必须用花括号括起来，除非它们是字面量或单个路径段。</p>
<p>对于 <code>impl Trait</code> 类型对应的合成类型参数是隐式的，不能显式地指定。</p>
<h2 id="限定路径"><a class="header" href="#限定路径">限定路径</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>表达式中的限定路径</em> :<br />
   <em>限定路径类型</em> (<code>::</code> <em>路径表达式语句</em>)<sup>+</sup></p>
<p><em>限定路径类型</em> :<br />
   <code>&lt;</code> <a href="types.html#type-expressions"><em>Type</em></a> (<code>as</code> <em>类型路径</em>)<sup>?</sup> <code>&gt;</code></p>
<p><em>类型中限定路径</em> :<br />
   <em>限定路径类型</em> (<code>::</code> <em>类型路径语句</em>)<sup>+</sup></p>
</blockquote>
<p>完全限定路径用于在 <a href="items/implementations.html#trait-implementations">trait 实现</a> 中消除歧义，并用于指定 <a href="paths.html#canonical-paths">规范路径</a> 。在类型规范中使用时，它支持使用下面指定的类型语法。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S;
impl S {
    fn f() { println!(&quot;S&quot;); }
}
trait T1 {
    fn f() { println!(&quot;T1 f&quot;); }
}
impl T1 for S {}
trait T2 {
    fn f() { println!(&quot;T2 f&quot;); }
}
impl T2 for S {}
S::f();  // 调用内部 impl.
&lt;S as T1&gt;::f();  // 调用 T1 trait 函数。
&lt;S as T2&gt;::f();  // 调用 T2 trait 函数。
<span class="boring">}</span></code></pre></pre>
<h3 id="类型中路径"><a class="header" href="#类型中路径">类型中路径</a></h3>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>类型路径</em> :<br />
   <code>::</code><sup>?</sup> <em>类型路径语句</em> (<code>::</code> <em>类型路径语句</em>)<sup>*</sup></p>
<p><em>类型路径语句</em> :<br />
   <em>类型ID语句</em> <code>::</code><sup>?</sup> (<a href="paths.html#paths-in-expressions"><em>泛型参数</em></a> | <em>类型路径Fn</em>)<sup>?</sup></p>
<p><em>类型路径Fn</em> :<br />
<code>(</code> <em>类型路径Fn输入</em><sup>?</sup> <code>)</code> (<code>-&gt;</code> <a href="types.html#type-expressions"><em>类型</em></a>)<sup>?</sup></p>
<p><em>类型路径Fn输入</em> :<br />
<a href="types.html#type-expressions"><em>类型</em></a> (<code>,</code> <a href="types.html#type-expressions"><em>类型</em></a>)<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<p>类型路径在类型定义、trait 约束、类型参数约束和限定路径中使用。</p>
<p>虽然 <code>::</code> 令牌在泛型参数之前是允许的，但不是必须的，因为与在 <em>表达式中路径</em> 的情况不同，这里没有歧义。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod ops {
</span><span class="boring">    pub struct Range&lt;T&gt; {f1: T}
</span><span class="boring">    pub trait Index&lt;T&gt; {}
</span><span class="boring">    pub struct Example&lt;'a&gt; {f1: &amp;'a i32}
</span><span class="boring">}
</span><span class="boring">struct S;
</span>impl ops::Index&lt;ops::Range&lt;usize&gt;&gt; for S { /*...*/ }
fn i&lt;'a&gt;() -&gt; impl Iterator&lt;Item = ops::Example&lt;'a&gt;&gt; {
    // ...
<span class="boring">   const EXAMPLE: Vec&lt;ops::Example&lt;'static&gt;&gt; = Vec::new();
</span><span class="boring">   EXAMPLE.into_iter()
</span>}
type G = std::boxed::Box&lt;dyn std::ops::FnOnce(isize) -&gt; isize&gt;;
<span class="boring">}</span></code></pre></pre>
<h2 id="路径限定符"><a class="header" href="#路径限定符">路径限定符</a></h2>
<p>路径可以用各种前导限定符来改变它解析的方式。</p>
<h3 id=""><a class="header" href="#"><code>::</code></a></h3>
<p>以 <code>::</code> 开头的路径被认为是 <em>全局路径</em> ，路径中的段从不同的起点开始解析，这个起点是根据版本不同而不同。路径中的每个标识符都必须解析为一个条目。</p>
<blockquote>
<p><strong>版本差异</strong>：在 2015 版本中，标识符从 “crate root” 开始解析 (在 2018 版本中是 <code>crate::</code>) ，其中包含各种不同的项，包括外部 crate、默认的 crate (如 <code>std</code> 或 <code>core</code>) 以及 crate 顶级的项 (包括 <code>use</code> 导入) 。</p>
<p>从 2018 版本开始，以 <code>::</code> 开头的路径从 <a href="names/preludes.html#extern-prelude">extern prelude</a> 中的 crate 解析。也就是说，它们必须跟随一个 crate 的名称。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn foo() {
    // 在 2018 版中，这通过 extern 预导模块访问 std。
    // 在 2015 版中，这通过 crate root 访问 std。
    let now = ::std::time::Instant::now();
    println!(&quot;{:?}&quot;, now);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2015">// 2015 版
mod a {
    pub fn foo() {}
}
mod b {
    pub fn foo() {
        ::a::foo(); // 调用 `a` 的 foo 函数
        // 在 Rust 2018 中， `::a` 将被解释为 crate `a` 。
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="self"><a class="header" href="#self"><code>self</code></a></h3>
<p><code>self</code> 用于相对于当前模块解析路径，只能作为路径的第一个段出现，不能在前面加上 <code>::</code> 。</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn foo() {}
fn bar() {
    self::foo();
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="self-1"><a class="header" href="#self-1"><code>Self</code></a></h3>
<p><code>Self</code> (注意大写) 用于在 <a href="items/traits.html">traits</a> 和 <a href="items/implementations.html">实现</a> 中引用实现类型本身。</p>
<p><code>Self</code> 只能作为第一个段使用，不能有前导 <code>::</code> 。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T {
    type Item;
    const C: i32;
    // `Self` 将是任何实现 `T` 的类型。
    fn new() -&gt; Self;
    // `Self::Item` 将是实现中的类型别名。
    fn f(&amp;self) -&gt; Self::Item;
}
struct S;
impl T for S {
    type Item = i32;
    const C: i32 = 9;
    fn new() -&gt; Self {           // `Self` 是类型 `S`。
        S
    }
    fn f(&amp;self) -&gt; Self::Item {  // `Self::Item` 是类型 `i32`。
        Self::C                  // `Self::C` 是常量值 `9`。
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="super"><a class="header" href="#super"><code>super</code></a></h3>
<p><code>super</code> 在路径中解析为父模块。它只能在路径的前导段中使用，可能在一个初始的 <code>self</code> 段之后。</p>
<pre><pre class="playground"><code class="language-rust edition2021">mod a {
    pub fn foo() {}
}
mod b {
    pub fn foo() {
        super::a::foo(); // call a's foo function
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p><code>super</code> 可以在第一个 <code>super</code> 或 <code>self</code> 之后重复使用，以引用祖先模块。</p>
<pre><pre class="playground"><code class="language-rust edition2021">mod a {
    fn foo() {}

    mod b {
        mod c {
            fn foo() {
                super::super::foo(); // 调用 a's foo 函数
                self::super::super::foo(); // 调用 a's foo 函数
            }
        }
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="crate"><a class="header" href="#crate"><code>crate</code></a></h3>
<p><code>crate</code> 用于解析与当前 crate 相关的路径。 <code>crate</code> 只能用作路径的第一个标识符，不能在其前面加上 <code>::</code> 。</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn foo() {}
mod a {
    fn bar() {
        crate::foo();
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="crate-1"><a class="header" href="#crate-1"><code>$crate</code></a></h3>
<p><code>$crate</code> 仅在 <a href="macros-by-example.html">宏转录器</a> 中使用，且只能用作第一个段，没有前置 <code>::</code> 。 <code>$crate</code> 将扩展为一个路径，以访问在定义宏的 crate 顶层的条目，而不管宏被调用的 crate 是哪个。</p>
<pre><pre class="playground"><code class="language-rust edition2021">pub fn increment(x: u32) -&gt; u32 {
    x + 1
}

#[macro_export]
macro_rules! inc {
    ($x:expr) =&gt; ( $crate::increment($x) )
}
<span class="boring">fn main() { }</span></code></pre></pre>
<h2 id="规范化路径"><a class="header" href="#规范化路径">规范化路径</a></h2>
<p>在模块或实现中定义的条目具有与其所在的 crate 中定义的位置对应的 <em>规范路径</em> 。对这些条目的所有其他路径都是别名。规范路径被定义为 <em>路径前缀</em> 加上条目本身定义的路径段。</p>
<p><a href="items/implementations.html">实现</a> 和 <a href="items/use-declarations.html">use 声明</a> 没有规范路径，虽然实现定义的条目具有规范路径。在块表达式中定义的条目没有规范路径。
在没有规范路径的模块中定义的条目没有规范路径。在实现中定义的关联条目引用没有规范路径的条目，例如实现类型、被实现的 trait 、类型参数或类型参数的约束，没有规范路径。</p>
<p>对于模块，路径前缀是该模块的规范路径。对于裸实现，路径前缀是被实现条目的规范路径，用尖括号 (<code>&lt;&gt;</code>) 括起来。
对于 <a href="items/implementations.html#trait-implementations">trait 实现</a> ，路径前缀是被实现条目的规范路径，后跟 <code>as</code> ，后跟该 trait 的规范路径，全部用尖括号 (<code>&lt;&gt;</code>) 括起来。</p>
<p>规范路径仅在给定 crate 中具有意义。跨 crate 没有全局命名空间；条目的规范路径仅标识其在 crate 中的位置。</p>
<pre><pre class="playground"><code class="language-rust edition2021">// 注释显示了条目的规范路径。

mod a { // crate::a
    pub struct Struct; // crate::a::Struct

    pub trait Trait { // crate::a::Trait
        fn f(&amp;self); // crate::a::Trait::f
    }

    impl Trait for Struct {
        fn f(&amp;self) {} // &lt;crate::a::Struct as crate::a::Trait&gt;::f
    }

    impl Struct {
        fn g(&amp;self) {} // &lt;crate::a::Struct&gt;::g
    }
}

mod without { // crate::without
    fn canonicals() { // crate::without::canonicals
        struct OtherStruct; // None

        trait OtherTrait { // None
            fn g(&amp;self); // None
        }

        impl OtherTrait for OtherStruct {
            fn g(&amp;self) {} // None
        }

        impl OtherTrait for crate::a::Struct {
            fn g(&amp;self) {} // None
        }

        impl crate::a::Trait for OtherStruct {
            fn f(&amp;self) {} // None
        }
    }
}

<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="name-resolution"><a class="header" href="#name-resolution">Name resolution</a></h1>
<blockquote>
<p><strong>注意</strong>: 这是一个未来扩展的占位符。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可见性和私有性"><a class="header" href="#可见性和私有性">可见性和私有性</a></h1>
<blockquote>
<p><strong><sup>语法<sup></strong><br />
<em>可见性</em> :<br />
      <code>pub</code><br />
   | <code>pub</code> <code>(</code> <code>crate</code> <code>)</code><br />
   | <code>pub</code> <code>(</code> <code>self</code> <code>)</code><br />
   | <code>pub</code> <code>(</code> <code>super</code> <code>)</code><br />
   | <code>pub</code> <code>(</code> <code>in</code> <a href="paths.html#simple-paths"><em>SimplePath</em></a> <code>)</code></p>
</blockquote>
<p>这两个术语经常被交替使用，它们试图表达 &quot;此条目是否可在此位置使用？&quot; 的答案。</p>
<p>Rust 的名称解析是在全局层次结构的命名空间中运行的。层次结构中的每个级别都可以被视为某个条目。
这些条目是上面提到的其中之一，但也包括外部 crate 。声明或定义新模块可以被视为在定义位置将一个新树插入层次结构中。</p>
<p>为了控制接口是否可以跨模块使用， Rust 检查每个条目的使用情况，以确定是否允许使用。
这就是产生隐私警告的地方，从而提示 &quot;你使用了另一个模块的私有条目，但未被允许&quot; 。</p>
<p>默认情况下，所有内容都是 <em>私有的</em> ，有两个例外: 在 <code>pub</code> Trait 中的关联条目默认是公共的；在 <code>pub</code> 枚举中的枚举变量也默认是公共的。
当一个条目被声明为 <code>pub</code> 时，可以将其视为对外界可访问的。例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {}
</span>// 声明一个私有结构体
struct Foo;

// 声明一个公共结构体，其中有一个私有字段
pub struct Bar {
    field: i32,
}

// 声明一个公共枚举类型，其中有两个公共变体
pub enum State {
    PubliclyAccessibleState,
    PubliclyAccessibleState2,
}</code></pre></pre>
<p>在 Rust 中，通过将条目定义为公共或私有，允许在以下两种情况下访问条目：</p>
<ol>
<li>如果条目是公共的，则可以从一些模块 <code>m</code> 外部访问它，如果您可以从 <code>m</code> 访问所有条目的祖先模块，则还可以通过重新导出的方式命名该条目。</li>
<li>如果条目是私有的，则当前模块及其后代可以访问它。</li>
</ol>
<p>这两种情况对于创建公开 API 的模块层次结构并隐藏内部实现细节非常有用。以下是一些用例及其含义：</p>
<ul>
<li>库开发人员需要向链接其库的 crate 公开功能。作为第一种情况的结果，这意味着任何可在外部使用的内容必须从根到目标条目都是 <code>pub</code> 的。链中的任何私有条目都将禁止外部访问。</li>
<li>一个 crate 需要一个仅对自己可用的全局 &quot;帮助模块&quot; ，但它不想将该模块公开为公共 API 。为此，crate 层次结构的根将具有一个私有模块，该模块内部具有 &quot;公共 API&quot; 。由于整个 crate 是根的后代，因此整个本地 crate 可以通过第二种情况访问此私有模块。</li>
<li>在为模块编写单元测试时，通常的惯用语法是让待测试的模块的直接子条目命名为 <code>mod test</code>。此模块可以通过第二种情况访问父模块的任何条目，从而可以轻松测试内部实现细节。</li>
</ul>
<p>在第二种情况中，它提到了私有条目可以被当前模块和其子孙模块 &quot;访问&quot; ，但是访问条目的确切含义取决于该条目是什么。
例如，访问模块将意味着查看其中的内容 (以导入更多条目) 。另一方面，访问函数将意味着调用它。
此外，路径表达式和导入语句被认为是访问条目，因为只有在目标在当前可见范围内时，导入/表达式才是有效的。</p>
<p>下面是一个程序示例，说明了上述三种情况:</p>
<pre><pre class="playground"><code class="language-rust edition2021">// 这个模块是私有的，意味着没有外部 crate 可以访问这个模块。然而，因为它在当前 crate 的根目录下是私有的，所以任何在 crate 中的模块都可以访问这个模块中任何公开可见的条目。
mod crate_helper_module {

    // 这个函数可以被当前 crate 中的任何东西使用
    pub fn crate_helper() {}

    // 这个函数 *不能* 被 crate 中的其他任何东西使用。它在 `crate_helper_module` 之外不可公开访问，因此只有这个当前模块及其子代可以访问它。
    fn implementation_detail() {}
}

// 这个函数是 &quot;对根可见的公共&quot;，这意味着它可以在链接到这个 crate 的外部 crate 中使用。
pub fn public_api() {}

// 类似于 'public_api'，这个模块是公共的，因此外部 crate 可以查看其内部。
pub mod submodule {
    use crate::crate_helper_module;

    pub fn my_method() {
        // 通过上述两条规则的组合，本地 crate 中的任何条目都可以调用辅助模块的公共接口。
        crate_helper_module::crate_helper();
    }

    // 这个函数对于不是 `submodule` 的子孙模块是隐藏的。
    fn my_implementation() {}

    #[cfg(test)]
    mod test {

        #[test]
        fn test_my_implementation() {
            // 因为这个模块是 `submodule` 的子孙模块，所以它允许访问 `submodule` 中的私有条目而不会违反隐私规定。
            super::my_implementation();
        }
    }
}

<span class="boring">fn main() {}</span></code></pre></pre>
<p>为了使 Rust 程序通过隐私检查，所有路径必须根据上述两条规则进行有效访问。这包括所有的 use 语句、表达式、类型等。</p>
<h2 id="pubin-path--pubcrate--pubsuper--和-pubself"><a class="header" href="#pubin-path--pubcrate--pubsuper--和-pubself"><code>pub(in path)</code> , <code>pub(crate)</code> , <code>pub(super)</code> , 和 <code>pub(self)</code></a></h2>
<p>除了 public 和 private 之外， Rust 还允许用户将一个条目声明为仅在给定范围内可见。 <code>pub</code> 限制的规则如下：</p>
<ul>
<li><code>pub(in path)</code> 使得一个条目在提供的 <code>path</code> 中可见。 <code>path</code> 必须是正在声明其可见性的条目的祖先模块。</li>
<li><code>pub(crate)</code> 使得一个条目在当前 crate 内可见。</li>
<li><code>pub(super)</code> 使得一个条目对其父模块可见。这等价于 <code>pub(in super)</code> 。</li>
<li><code>pub(self)</code> 使得一个条目对当前模块可见。这等价于 <code>pub(in self)</code> 或者不使用 <code>pub</code> 。</li>
</ul>
<blockquote>
<p><strong>版本差异</strong>: 从 2018 版开始， <code>pub(in path)</code> 的路径必须以 <code>crate</code> 、 <code>self</code> 或 <code>super</code> 开头。 2015 版也可以使用以 <code>::</code> 开头的路径或来自 crate 根的模块。</p>
</blockquote>
<p>这是一个例子：</p>
<pre><pre class="playground"><code class="language-rust edition2015">pub mod outer_mod {
    pub mod inner_mod {
        // 此函数在 `outer_mod` 中可见
        pub(in crate::outer_mod) fn outer_mod_visible_fn() {}
        // 与上面的相同，在 2015 版中仅适用。
        pub(in outer_mod) fn outer_mod_visible_fn_2015() {}

        // 此函数在整个 crate 中可见
        pub(crate) fn crate_visible_fn() {}

        // 此函数在 `super` 中可见
        pub(super) fn super_mod_visible_fn() {
            // 因为在同一 `mod` 中，所以此函数可见
            inner_mod_visible_fn();
        }

        // 此函数仅在 `inner_mod` 中可见，
        // 这等同于将其声明为 private。
        pub(self) fn inner_mod_visible_fn() {}
    }
    pub fn foo() {
        inner_mod::outer_mod_visible_fn();
        inner_mod::crate_visible_fn();
        inner_mod::super_mod_visible_fn();

        // 由于已经在 `inner_mod` 的外部，因此此函数不再可见。
        // 错误！ `inner_mod_visible_fn` 是私有的
        //inner_mod::inner_mod_visible_fn();
    }
}

fn bar() {
    // 因为我们在同一 crate 中，所以此函数仍然可见。
    outer_mod::inner_mod::crate_visible_fn();

    // 由于我们在 `outer_mod` 的外部，因此此函数不再可见。
    // 错误！ `super_mod_visible_fn` 是私有的
    //outer_mod::inner_mod::super_mod_visible_fn();

    // 由于我们在 `outer_mod` 的外部，因此此函数不再可见。
    // 错误！ `outer_mod_visible_fn` 是私有的
    //outer_mod::inner_mod::outer_mod_visible_fn();

    outer_mod::foo();
}

fn main() { bar() }</code></pre></pre>
<blockquote>
<p><strong>注意:</strong> 这种语法只是增加了一个对条目可见性的限制，它并不保证该条目在指定范围内的所有部分都可见。
要访问一个条目，它的所有父级条目直到当前范围仍然必须可见。</p>
</blockquote>
<h2 id="重新导出和可见性"><a class="header" href="#重新导出和可见性">重新导出和可见性</a></h2>
<p>Rust 允许通过 <code>pub use</code> 指令公开重新导出条目。因为这是一个公共指令，这允许通过上面的规则在当前模块中使用该条目。
这实际上允许了对重新导出的条目的公共访问。例如，这个程序是有效的：</p>
<pre><pre class="playground"><code class="language-rust edition2021">pub use self::implementation::api;

mod implementation {
    pub mod api {
        pub fn f() {}
    }
}

<span class="boring">fn main() {}</span></code></pre></pre>
<p>这意味着，任何引用 <code>implementation::api::f</code> 的外部 crate 都将遭受隐私侵犯，而路径 <code>api::f</code> 将被允许。</p>
<p>当重新导出一个私有条目时，可以将其视为通过重新导出而允许 &quot;隐私链&quot; 短路，而不是像通常一样通过命名空间层次结构传递。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存模型"><a class="header" href="#内存模型">内存模型</a></h1>
<p>目前 Rust 还没有定义一个明确的内存模型。相关学者和工业专业人士正在研究各种提案，但目前来说，这是语言中一个未定义的领域。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存分配和生命周期"><a class="header" href="#内存分配和生命周期">内存分配和生命周期</a></h1>
<p>程序中的 <em>条目</em> 是指那些在编译时计算值并唯一存储在 Rust 进程的内存映像中的函数、模块和类型。条目既不是动态分配的，也不会被释放。</p>
<p><em>堆</em> 是一个泛指的术语，用于描述堆箱。在堆中分配的内存的生命周期取决于指向它的堆箱值的生命周期。
由于堆箱值本身可能在帧之间传递，或者存储在堆中，因此堆分配可能会超出它们分配所在的帧的生命周期。
在堆中分配的内存保证在整个分配的生命周期中都驻留在堆的单个位置 - 它永远不会由于移动堆箱值而被移动。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量"><a class="header" href="#变量">变量</a></h1>
<p><em>变量</em> 是栈帧的组成部分，可以是函数的具名参数、匿名的 <a href="expressions.html#temporaries">临时变量</a> 或具名的局部变量。</p>
<p><em>局部变量</em> (或称为 <em>栈局部</em> 分配) 直接持有一个值，该值在栈的内存中分配。该值是栈帧的一部分。</p>
<p>除非另有声明，否则局部变量是不可变的。例如: <code>let mut x = ...</code> 。</p>
<p>函数参数是不可变的，除非声明为 <code>mut</code> 。 <code>mut</code> 关键字仅适用于其后面的参数。
例如: <code>|mut x, y|</code> 和 <code>fn f(mut x: Box&lt;i32&gt;, y: Box&lt;i32&gt;)</code> 声明了一个可变变量 <code>x</code> 和一个不可变变量 <code>y</code>。</p>
<p>局部变量在分配时不会初始化。相反，整个栈帧的局部变量在进入栈帧时以未初始化状态进行分配。
函数内的后续语句可能会或可能不会初始化局部变量。只有在通过所有可达控制流路径初始化后，局部变量才能被使用。</p>
<p>在下面的例子中，<code>init_after_if</code> 在 <a href="expressions/if-expr.html#if-expressions"><code>if</code> 表达式</a> 后被初始化，而 <code>uninit_after_if</code> 没有被初始化，因为它在 <code>else</code> 分支中没有被初始化。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn random_bool() -&gt; bool { true }
</span>fn initialization_example() {
    let init_after_if: ();
    let uninit_after_if: ();

    if random_bool() {
        init_after_if = ();
        uninit_after_if = ();
    } else {
        init_after_if = ();
    }

    init_after_if; // ok
    // uninit_after_if; // err: 使用可能未初始化 `uninit_after_if`
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="链接"><a class="header" href="#链接">链接</a></h1>
<blockquote>
<p>注意: 这一部分更多地从编译器而非语言的角度进行描述。</p>
</blockquote>
<p>编译器支持静态和动态地链接不同的 crate 。
本节将探讨链接 crate 的各种方法，有关本地库的更多信息可以在 <a href="../book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code">《Rust 程序设计语言》中的 FFI 章节</a> 中找到。</p>
<p>在一次编译会话中，编译器可以通过使用命令行标志或 <code>crate_type</code> 属性生成多个制品。
如果指定了一个或多个命令行标志，则忽略所有 <code>crate_type</code> 属性，仅构建由命令行指定制品。</p>
<ul>
<li>
<p><code>--crate-type=bin</code> ， <code>#![crate_type = &quot;bin&quot;]</code> - 将生成可运行的可执行文件。在 crate 中需要有一个 <code>main</code> 函数，程序开始执行时首先运行。这将链接所有的 Rust 和本地依赖项，生成一个可分发的单个二进制文件。是默认的 crate 类型。</p>
</li>
<li>
<p><code>--crate-type=lib</code>，<code>#![crate_type = &quot;lib&quot;]</code> - 将生成一个 Rust 库。这是一个广义概念，因为库可以以多种形式呈现。这个通用的 <code>lib</code> 选项的目的是生成 &quot;编译器推荐&quot; 的库风格。输出的库始终可由 rustc 使用，但实际的库类型可能会随时间而变化。其余的输出类型都是不同的库类型，而 <code>lib</code> 类型可以看作是其中一个的别名 (但实际的类型是由编译器定义的) 。</p>
</li>
<li>
<p><code>--crate-type=dylib</code>，<code>#![crate_type = &quot;dylib&quot;]</code> - 将生成一个动态 Rust 库。这与 <code>lib</code> 输出类型不同，因为它强制生成动态库。生成的动态库可以用作其他库和/或可执行文件的依赖项。此输出类型将在 Linux 上创建 <code>*.so</code> 文件，在 macOS 上创建 <code>*.dylib</code> 文件，在 Windows 上创建 <code>*.dll</code> 文件。</p>
</li>
<li>
<p><code>--crate-type=staticlib</code>，<code>#![crate_type = &quot;staticlib&quot;]</code> - 将生成一个静态系统库。这与其他库输出不同，因为编译器永远不会尝试链接到 <code>staticlib</code> 输出。此输出类型的目的是创建一个包含所有本地 crate 代码以及所有上游依赖项的静态库。此输出类型将在 Linux、macOS 和 Windows (MinGW) 上创建 <code>*.a</code> 文件，在 Windows (MSVC) 上创建 <code>*.lib</code> 文件。此格式推荐在将 Rust 代码链接到现有的非 Rust 应用程序时使用，因为它不会对其他 Rust 代码产生动态依赖关系。</p>
</li>
<li>
<p><code>--crate-type=cdylib</code>，<code>#![crate_type = &quot;cdylib&quot;]</code> - 将生成一个动态系统库。这用于编译从另一种语言加载的动态库。此输出类型将在 Linux 上创建 <code>*.so</code> 文件，在 macOS 上创建 <code>*.dylib</code> 文件，在 Windows 上创建 <code>*.dll</code> 文件。</p>
</li>
<li>
<p><code>--crate-type=rlib</code>，<code>#![crate_type = &quot;rlib&quot;]</code> - 会生成一个 &quot;Rust库&quot; 文件。这是一个中间产物，可以看作是一个 &quot;静态的Rust库&quot; 。与 <code>staticlib</code> 文件不同，这些 <code>rlib</code> 文件将在未来的链接中由编译器进行解释。这基本上意味着， <code>rustc</code> 将像在动态库中查找元数据一样在 <code>rlib</code> 文件中查找元数据。这种输出形式用于生成静态链接的可执行文件以及 <code>staticlib</code> 输出。</p>
</li>
<li>
<p><code>--crate-type=proc-macro</code> ， <code>#![crate_type = &quot;proc-macro&quot;]</code> - 产生的输出未指定，但如果给它提供一个 <code>-L</code> 路径，编译器将识别制品为一个宏，并且它可以被程序加载。使用这种 crate 类型编译的 crate 必须只导出 <a href="procedural-macros.html">过程宏</a> 。编译器将自动设置 <code>proc_macro</code> <a href="conditional-compilation.html">配置选项</a> 。这些 crate 始终使用编译器本身构建时的相同目标进行编译。例如，如果您在 Linux 上使用 <code>x86_64</code> CPU 执行编译器，则目标将为 <code>x86_64-unknown-linux-gnu</code> ，即使该 crate 是另一个 crate 正在为不同目标而构建的依赖项。</p>
</li>
</ul>
<p>请注意，这些输出是可重叠的，即可指定多个，则编译器将同时生成每种形式的输出，而无需重新编译。但是，这仅适用于由同一方法指定的输出。如果仅指定 <code>crate_type</code> 属性，则所有属性都将被构建，但如果指定一个或多个 <code>--crate-type</code> 命令行标志，则仅构建那些输出。</p>
<p>有了所有这些不同类型的输出，如果 crate A 依赖于 crate B ，那么编译器可以在系统中以各种不同的形式找到 B 。然而，编译器查找的唯一格式是 <code>rlib</code> 格式和动态库格式。有了这两个选项，编译器必须在这两种格式之间做出选择。考虑到这一点，编译器在确定将使用哪种依赖关系格式时遵循以下规则：</p>
<ol>
<li>
<p>如果正在生成静态库，则所有上游依赖项都必须以 <code>rlib</code> 格式可用。这个要求源于动态库无法转换为静态格式的原因。</p>
<p>请注意，无法将本机动态依赖项链接到静态库中，在这种情况下，将打印所有未链接的本机动态依赖项的警告。</p>
</li>
<li>
<p>如果正在生成一个 <code>rlib</code> 文件，则上游依赖项可用的格式没有限制。只需要所有上游依赖项都可用于读取元数据。</p>
<p>这样做的原因是， <code>rlib</code> 文件不包含任何上游依赖项。所有 <code>rlib</code> 文件包含 <code>libstd.rlib</code> 的副本时效率不高！</p>
</li>
<li>
<p>如果正在生成可执行文件且未指定 <code>-C prefer-dynamic</code> 标志，则首先尝试在 <code>rlib</code> 格式中查找依赖项。如果某些依赖项在 <code>rlib</code> 格式中不可用，则尝试动态链接 (见下文) 。</p>
</li>
<li>
<p>如果正在生成动态库或正在以动态链接方式链接的可执行文件，则编译器将尝试在 rlib 或 dylib 格式中协调可用的依赖项以创建最终产品。</p>
<p>编译器的主要目标是确保库在任何构件中都不会出现多次。例如，如果动态库 B 和 C 分别静态链接到库 A，那么一个 crate 就无法将 B 和 C 链接在一起，因为会有两个 A 的副本。编译器允许混合使用 rlib 和 dylib 格式，但必须满足此限制。</p>
<p>目前，编译器没有实现提示链接库应使用哪种格式的方法。在动态链接时，编译器将尝试最大化动态依赖性，同时仍允许某些依赖性通过 rlib 进行链接。</p>
<p>对于大多数情况，如果要动态链接，建议将所有库都作为 dylib 可用。对于其他情况，如果编译器无法确定链接每个库时要使用的格式，编译器将发出警告。</p>
</li>
</ol>
<p>总的来说， <code>--crate-type=bin</code> 或 <code>--crate-type=lib</code> 应该足以满足所有编译需求，其他选项只是提供更细粒度的控制，以便更好地控制 crate 的输出格式。</p>
<h2 id="静态和动态c运行时"><a class="header" href="#静态和动态c运行时">静态和动态C运行时</a></h2>
<p>通常，标准库会尽可能地支持适当目标的静态链接和动态链接 C 运行时。例如， <code>x86_64-pc-windows-msvc</code> 和 <code>x86_64-unknown-linux-musl</code> 目标通常都带有两种运行时，用户可以选择其中一个。编译器中的所有目标都有链接到 C 运行时的默认模式。通常，默认情况下目标是动态链接的，但也有一些例外，默认情况下是静态链接的，例如：</p>
<ul>
<li><code>arm-unknown-linux-musleabi</code></li>
<li><code>arm-unknown-linux-musleabihf</code></li>
<li><code>armv7-unknown-linux-musleabihf</code></li>
<li><code>i686-unknown-linux-musl</code></li>
<li><code>x86_64-unknown-linux-musl</code></li>
</ul>
<p>C 运行时的链接是配置为遵守 <code>crt-static</code> 目标特性的。这些目标特性通常是通过编译器本身的标志从命令行配置的。例如，要启用静态运行时，您将执行：</p>
<pre><code class="language-sh">rustc -C target-feature=+crt-static foo.rs
</code></pre>
<p>而要动态链接到 C 运行时，则会执行：</p>
<pre><code class="language-sh">rustc -C target-feature=-crt-static foo.rs
</code></pre>
<p>不支持在 C 运行时链接方式之间切换的目标将忽略此标志。建议在编译器成功后检查生成的二进制文件，确保它被链接为您所期望的方式。</p>
<p>Crates 也可以了解 C 运行时的链接方式。例如，在 MSVC 上编写的代码需要根据链接的运行时以不同的方式编译 (例如使用 <code>/MT</code> 或 <code>/MD</code> ) 。这是通过 <a href="conditional-compilation.html#target_feature"><code>cfg</code> 属性 <code>target_feature</code> 选项</a> 导出的：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_feature = &quot;crt-static&quot;)]
fn foo() {
    println!(&quot;the C runtime should be statically linked&quot;);
}

#[cfg(not(target_feature = &quot;crt-static&quot;))]
fn foo() {
    println!(&quot;the C runtime should be dynamically linked&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>还请注意，Cargo 构建脚本可以通过 <a href="../cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">环境变量</a> 了解这个特性。在构建脚本中，你可以通过以下方式检测链接方式：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::env;

fn main() {
    let linkage = env::var(&quot;CARGO_CFG_TARGET_FEATURE&quot;).unwrap_or(String::new());

    if linkage.contains(&quot;crt-static&quot;) {
        println!(&quot;the C runtime will be statically linked&quot;);
    } else {
        println!(&quot;the C runtime will be dynamically linked&quot;);
    }
}</code></pre></pre>
<p>要在本地使用此功能，通常会使用 <code>RUSTFLAGS</code> 环境变量通过 Cargo 指定编译器的标志。例如，在 MSVC 上编译静态链接的二进制文件，您可以执行：</p>
<pre><code class="language-sh">RUSTFLAGS='-C target-feature=+crt-static' cargo build --target x86_64-pc-windows-msvc
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内联汇编"><a class="header" href="#内联汇编">内联汇编</a></h1>
<p>通过 <a href="../core/arch/macro.asm.html"><code>asm!</code></a> 和 <a href="../core/arch/macro.global_asm.html"><code>global_asm!</code></a> 宏提供对内联汇编的支持。可以使用它来嵌入手写汇编到编译器生成的汇编输出中。</p>
<p>以下体系结构上的内联汇编支持已经稳定：</p>
<ul>
<li>x86 和 x86-64</li>
<li>ARM</li>
<li>AArch64</li>
<li>RISC-V</li>
</ul>
<p>如果在不支持的目标上使用 <code>asm!</code> ，编译器会发出错误。</p>
<h2 id="示例-5"><a class="header" href="#示例-5">示例</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

// 使用移位和加法将 x 乘以 6
let mut x: u64 = 4;
unsafe {
    asm!(
        &quot;mov {tmp}, {x}&quot;,
        &quot;shl {tmp}, 1&quot;,
        &quot;shl {x}, 2&quot;,
        &quot;add {x}, {tmp}&quot;,
        x = inout(reg) x,
        tmp = out(reg) _,
    );
}
assert_eq!(x, 4 * 6);
<span class="boring">}</span></code></pre></pre>
<h2 id="语法-1"><a class="header" href="#语法-1">语法</a></h2>
<p>以下 ABNF 规定了通用语法：</p>
<pre><code class="language-text">format_string := STRING_LITERAL / RAW_STRING_LITERAL
dir_spec := &quot;in&quot; / &quot;out&quot; / &quot;lateout&quot; / &quot;inout&quot; / &quot;inlateout&quot;
reg_spec := &lt;register class&gt; / &quot;\&quot;&quot; &lt;explicit register&gt; &quot;\&quot;&quot;
operand_expr := expr / &quot;_&quot; / expr &quot;=&gt;&quot; expr / expr &quot;=&gt;&quot; &quot;_&quot;
reg_operand := dir_spec &quot;(&quot; reg_spec &quot;)&quot; operand_expr
operand := reg_operand
clobber_abi := &quot;clobber_abi(&quot; &lt;abi&gt; *(&quot;,&quot; &lt;abi&gt;) [&quot;,&quot;] &quot;)&quot;
option := &quot;pure&quot; / &quot;nomem&quot; / &quot;readonly&quot; / &quot;preserves_flags&quot; / &quot;noreturn&quot; / &quot;nostack&quot; / &quot;att_syntax&quot; / &quot;raw&quot;
options := &quot;options(&quot; option *(&quot;,&quot; option) [&quot;,&quot;] &quot;)&quot;
asm := &quot;asm!(&quot; format_string *(&quot;,&quot; format_string) *(&quot;,&quot; [ident &quot;=&quot;] operand) *(&quot;,&quot; clobber_abi) *(&quot;,&quot; options) [&quot;,&quot;] &quot;)&quot;
global_asm := &quot;global_asm!(&quot; format_string *(&quot;,&quot; format_string) *(&quot;,&quot; [ident &quot;=&quot;] operand) *(&quot;,&quot; options) [&quot;,&quot;] &quot;)&quot;
</code></pre>
<h2 id="作用域-1"><a class="header" href="#作用域-1">作用域</a></h2>
<p>内联汇编有两种使用方式。</p>
<p>使用 <code>asm!</code> 宏时，汇编代码在函数作用域中生成，并集成到函数的编译器生成的汇编代码中。这些汇编代码必须遵守 <a href="inline-assembly.html#rules-for-inline-assembly">严格规则</a> 以避免未定义行为。注意，在某些情况下，编译器可能会选择将汇编代码生成为一个单独的函数并生成对它的调用。</p>
<p>使用 <code>global_asm!</code> 宏时，汇编代码在全局作用域中生成，不在函数内。这可以用于使用汇编代码手写整个函数，并且通常提供更多使用任意寄存器和汇编指令的自由。</p>
<h2 id="模板字符串参数"><a class="header" href="#模板字符串参数">模板字符串参数</a></h2>
<p>汇编器模板使用与 <a href="../std/fmt/index.html#syntax">格式字符串</a> 相同的语法 (花括号占位符) 。
相应的参数按顺序、索引或名称访问。
但是，不支持隐式命名参数 (由<a href="https://github.com/rust-lang/rfcs/pull/2795">RFC #2795</a>引入) 。</p>
<p><code>asm!</code> 调用可能有一个或多个模板字符串参数；具有多个模板字符串参数的 <code>asm!</code> 被视为所有字符串在它们之间使用 <code>\n</code> 连接。
预期的用法是每个模板字符串参数对应于汇编代码的一行。
所有模板字符串参数必须出现在任何其他参数之前。</p>
<p>与格式字符串一样，命名参数必须出现在位置参数之后。
显式的 <a href="inline-assembly.html#register-operands">寄存器操作数</a> 必须出现在操作数列表的末尾，在任何命名参数之后。</p>
<p>模板字符串中的占位符不能使用显式寄存器操作数。
所有其他命名和位置操作数都必须至少在模板字符串中出现一次，否则将生成编译器错误。</p>
<p>确切的汇编代码语法是特定于目标的，对编译器不透明，除了将操作数替换为模板字符串以形成传递给汇编器的代码的方式之外。</p>
<p>目前，所有支持的目标都遵循 LLVM 内部汇编器使用的汇编代码语法，这通常对应于 GNU 汇编器 (GAS) 的语法。
在 x86 上，默认使用 GAS 的 <code>.intel_syntax noprefix</code> 模式。
在 ARM 上，使用 <code>.syntax unified</code> 模式。
这些目标对汇编代码施加了一个额外的限制：任何汇编器状态 (例如，可以使用 <code>.section</code> 改变的当前节) 必须在 asm 字符串的末尾恢复到其原始值。
不符合 GAS 语法的汇编代码将导致特定于汇编器的行为。
有关内联汇编使用的指令的进一步限制在 <a href="inline-assembly.html#directives-support">指令支持</a> 中指定。</p>
<h2 id="操作数类型"><a class="header" href="#操作数类型">操作数类型</a></h2>
<p>支持几种操作数类型:</p>
<ul>
<li><code>in(&lt;reg&gt;) &lt;expr&gt;</code>
<ul>
<li><code>&lt;reg&gt;</code> 可以是寄存器类或显式寄存器。
分配的寄存器名称将替换为 asm 模板字符串中的名称。</li>
<li>分配的寄存器将在 asm 代码开始时包含 <code>&lt;expr&gt;</code> 的值。</li>
<li>在 asm 代码结束时，分配的寄存器必须包含相同的值 (除非另一个 <code>lateout</code> 被分配到相同的寄存器) 。</li>
</ul>
</li>
<li><code>out(&lt;reg&gt;) &lt;expr&gt;</code>
<ul>
<li><code>&lt;reg&gt;</code> 可以是寄存器类或显式寄存器。
分配的寄存器名称将替换为 asm 模板字符串中的名称。</li>
<li>分配的寄存器在 asm 代码开始时包含未定义的值。</li>
<li><code>&lt;expr&gt;</code> 必须是一个 (可能未初始化的) place 表达式，分配的寄存器的内容在 asm 代码结束时写入该表达式。</li>
<li>可以使用下划线 (<code>_</code>) 代替表达式，在 asm 代码结束时会丢弃寄存器的内容 (有效地作为 clobber) 。</li>
</ul>
</li>
<li><code>lateout(&lt;reg&gt;) &lt;expr&gt;</code>
<ul>
<li>与 <code>out</code> 相同，但是寄存器分配器可以重新使用分配给 <code>in</code> 的寄存器。</li>
<li>应在读取所有输入之后再写入寄存器，否则可能破坏输入。</li>
</ul>
</li>
<li><code>inout(&lt;reg&gt;) &lt;expr&gt;</code>
<ul>
<li><code>&lt;reg&gt;</code>可以引用寄存器类或显式寄存器。
分配的寄存器名称将替换为汇编模板字符串中。</li>
<li>分配的寄存器将在汇编代码开始时包含 <code>&lt;expr&gt;</code> 的值。</li>
<li><code>&lt;expr&gt;</code>必须是一个可变的初始化地点表达式，分配的寄存器的内容将在汇编代码结束时写入该表达式。</li>
</ul>
</li>
<li><code>inout(&lt;reg&gt;) &lt;in expr&gt; =&gt; &lt;out expr&gt;</code>
<ul>
<li>与 <code>inout</code> 相同，但是寄存器的初始值取自 <code>&lt;in expr&gt;</code> 的值。</li>
<li><code>&lt;out expr&gt;</code> 必须是一个 (可能未初始化的) 地点表达式，分配的寄存器的内容将在汇编代码结束时写入该表达式。</li>
<li>可以为 <code>&lt;out expr&gt;</code> 指定下划线 (<code>_</code>) ，这将导致在汇编代码结束时丢弃寄存器的内容 (实际上起到破坏作用) 。</li>
<li><code>&lt;in expr&gt;</code>和<code>&lt;out expr&gt;</code>可能具有不同的类型。</li>
</ul>
</li>
<li><code>inlateout(&lt;reg&gt;) &lt;expr&gt;</code> / <code>inlateout(&lt;reg&gt;) &lt;in expr&gt; =&gt; &lt;out expr&gt;</code>
<ul>
<li>与 <code>inout</code> 相同，但是寄存器分配器可以重用分配给 <code>in</code> 的寄存器 (如果编译器知道 <code>in</code> 具有与 <code>inlateout</code> 相同的初始值，则可能会发生这种情况) 。</li>
<li>只有在读取所有输入后才应写入寄存器，否则可能会破坏输入。</li>
</ul>
</li>
<li><code>sym &lt;path&gt;</code>
<ul>
<li><code>&lt;path&gt;</code> 必须引用 <code>fn</code> 或 <code>static</code> 。</li>
<li>指向该项的重命名符号名称将替换为汇编模板字符串中。</li>
<li>替换的字符串不包括任何修改器 (例如 GOT 、 PLT 、重定位等) 。</li>
<li><code>&lt;path&gt;</code> 允许指向 <code>#[thread_local]</code> 静态变量，在这种情况下，汇编代码可以将符号与重定位 (例如 <code>@plt</code> 、 <code>@TPOFF</code> ) 组合以从线程本地数据读取。</li>
</ul>
</li>
</ul>
<p>操作数表达式从左到右依次评估，就像函数调用参数一样。
在 <code>asm!</code> 执行完成后，输出按照从左到右的顺序进行写入。
如果两个输出指向同一个位置，则该位置将包含最右边输出的值。</p>
<p>由于 <code>global_asm!</code> 存在于函数外部，因此它只能使用 <code>sym</code> 操作数。</p>
<h2 id="寄存器操作数"><a class="header" href="#寄存器操作数">寄存器操作数</a></h2>
<p>输入和输出操作数可以被指定为显式寄存器或者是寄存器类，从中寄存器分配器可以选择一个寄存器。
显式寄存器以字符串字面量表示 (例如 <code>&quot;eax&quot;</code> ) ，而寄存器类则以标识符表示 (例如 <code>reg</code> ) 。</p>
<p>需要注意的是，显式寄存器将寄存器别名 (例如 ARM 上的 <code>r14</code> vs <code>lr</code>) 和寄存器的较小视图 (例如<code>eax</code> vs <code>rax</code>) 视为等效于基础寄存器。
在两个输入操作数或两个输出操作数中使用相同的显式寄存器是编译时错误。
此外，在输入操作数或输出操作数中使用重叠的寄存器 (例如 ARM VFP) 也是编译时错误。</p>
<p>只有以下类型的操作数被允许用于内联汇编：</p>
<ul>
<li>整数 (有符号和无符号) </li>
<li>浮点数</li>
<li>指针 (仅限thin) </li>
<li>函数指针</li>
<li>SIMD 向量 (用 <code>#[repr(simd)]</code> 定义的结构体，并且实现了 <code>Copy</code> ) 。其中包括在 <code>std::arch</code> 中定义的架构特定的向量类型，例如 <code>__m128</code> (x86) 或 <code>int8x16_t</code> (ARM) 。</li>
</ul>
<p>以下是当前支持的寄存器类的列表：</p>
<div class="table-wrapper"><table><thead><tr><th>Architecture</th><th>Register class</th><th>Registers</th><th>LLVM constraint code</th></tr></thead><tbody>
<tr><td>x86</td><td><code>reg</code></td><td><code>ax</code>, <code>bx</code>, <code>cx</code>, <code>dx</code>, <code>si</code>, <code>di</code>, <code>bp</code>, <code>r[8-15]</code> (x86-64 only)</td><td><code>r</code></td></tr>
<tr><td>x86</td><td><code>reg_abcd</code></td><td><code>ax</code>, <code>bx</code>, <code>cx</code>, <code>dx</code></td><td><code>Q</code></td></tr>
<tr><td>x86-32</td><td><code>reg_byte</code></td><td><code>al</code>, <code>bl</code>, <code>cl</code>, <code>dl</code>, <code>ah</code>, <code>bh</code>, <code>ch</code>, <code>dh</code></td><td><code>q</code></td></tr>
<tr><td>x86-64</td><td><code>reg_byte</code>*</td><td><code>al</code>, <code>bl</code>, <code>cl</code>, <code>dl</code>, <code>sil</code>, <code>dil</code>, <code>bpl</code>, <code>r[8-15]b</code></td><td><code>q</code></td></tr>
<tr><td>x86</td><td><code>xmm_reg</code></td><td><code>xmm[0-7]</code> (x86) <code>xmm[0-15]</code> (x86-64)</td><td><code>x</code></td></tr>
<tr><td>x86</td><td><code>ymm_reg</code></td><td><code>ymm[0-7]</code> (x86) <code>ymm[0-15]</code> (x86-64)</td><td><code>x</code></td></tr>
<tr><td>x86</td><td><code>zmm_reg</code></td><td><code>zmm[0-7]</code> (x86) <code>zmm[0-31]</code> (x86-64)</td><td><code>v</code></td></tr>
<tr><td>x86</td><td><code>kreg</code></td><td><code>k[1-7]</code></td><td><code>Yk</code></td></tr>
<tr><td>x86</td><td><code>kreg0</code></td><td><code>k0</code></td><td>Only clobbers</td></tr>
<tr><td>x86</td><td><code>x87_reg</code></td><td><code>st([0-7])</code></td><td>Only clobbers</td></tr>
<tr><td>x86</td><td><code>mmx_reg</code></td><td><code>mm[0-7]</code></td><td>Only clobbers</td></tr>
<tr><td>x86-64</td><td><code>tmm_reg</code></td><td><code>tmm[0-7]</code></td><td>Only clobbers</td></tr>
<tr><td>AArch64</td><td><code>reg</code></td><td><code>x[0-30]</code></td><td><code>r</code></td></tr>
<tr><td>AArch64</td><td><code>vreg</code></td><td><code>v[0-31]</code></td><td><code>w</code></td></tr>
<tr><td>AArch64</td><td><code>vreg_low16</code></td><td><code>v[0-15]</code></td><td><code>x</code></td></tr>
<tr><td>AArch64</td><td><code>preg</code></td><td><code>p[0-15]</code>, <code>ffr</code></td><td>Only clobbers</td></tr>
<tr><td>ARM (ARM/Thumb2)</td><td><code>reg</code></td><td><code>r[0-12]</code>, <code>r14</code></td><td><code>r</code></td></tr>
<tr><td>ARM (Thumb1)</td><td><code>reg</code></td><td><code>r[0-7]</code></td><td><code>r</code></td></tr>
<tr><td>ARM</td><td><code>sreg</code></td><td><code>s[0-31]</code></td><td><code>t</code></td></tr>
<tr><td>ARM</td><td><code>sreg_low16</code></td><td><code>s[0-15]</code></td><td><code>x</code></td></tr>
<tr><td>ARM</td><td><code>dreg</code></td><td><code>d[0-31]</code></td><td><code>w</code></td></tr>
<tr><td>ARM</td><td><code>dreg_low16</code></td><td><code>d[0-15]</code></td><td><code>t</code></td></tr>
<tr><td>ARM</td><td><code>dreg_low8</code></td><td><code>d[0-8]</code></td><td><code>x</code></td></tr>
<tr><td>ARM</td><td><code>qreg</code></td><td><code>q[0-15]</code></td><td><code>w</code></td></tr>
<tr><td>ARM</td><td><code>qreg_low8</code></td><td><code>q[0-7]</code></td><td><code>t</code></td></tr>
<tr><td>ARM</td><td><code>qreg_low4</code></td><td><code>q[0-3]</code></td><td><code>x</code></td></tr>
<tr><td>RISC-V</td><td><code>reg</code></td><td><code>x1</code>, <code>x[5-7]</code>, <code>x[9-15]</code>, <code>x[16-31]</code> (non-RV32E)</td><td><code>r</code></td></tr>
<tr><td>RISC-V</td><td><code>freg</code></td><td><code>f[0-31]</code></td><td><code>f</code></td></tr>
<tr><td>RISC-V</td><td><code>vreg</code></td><td><code>v[0-31]</code></td><td>Only clobbers</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>注</strong>：</p>
<ul>
<li>
<p>在 x86 上，我们将 <code>reg_byte</code> 与 <code>reg</code> 区别对待，因为编译器可以分别分配 <code>al</code> 和 <code>ah</code>，而 <code>reg</code> 保留整个寄存器。</p>
</li>
<li>
<p>在 x86-64 上，高字节寄存器 (例如 <code>ah</code>) 不可用于 <code>reg_byte</code> 寄存器类。</p>
</li>
<li>
<p>一些寄存器类被标记为 &quot;仅占用&quot; ，这意味着这些类中的寄存器不能用作输入或输出，只能用作类似 <code>out(&lt;explicit register&gt;) _</code> 或 <code>lateout(&lt;explicit register&gt;) _</code> 的占用。</p>
</li>
</ul>
</blockquote>
<p>每个寄存器类对可以与其一起使用的值类型有约束。
这是必要的，因为将值加载到寄存器中的方式取决于其类型。
例如，在大端系统上，将 <code>i32x4</code> 和 <code>i8x16</code> 加载到 SIMD 寄存器中可能会导致不同的寄存器内容，即使这两个值的按字节的内存表示相同。
支持特定寄存器类的类型的可用性可能取决于当前启用的目标特性。</p>
<div class="table-wrapper"><table><thead><tr><th>Architecture</th><th>Register class</th><th>Target feature</th><th>Allowed types</th></tr></thead><tbody>
<tr><td>x86-32</td><td><code>reg</code></td><td>None</td><td><code>i16</code>, <code>i32</code>, <code>f32</code></td></tr>
<tr><td>x86-64</td><td><code>reg</code></td><td>None</td><td><code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code></td></tr>
<tr><td>x86</td><td><code>reg_byte</code></td><td>None</td><td><code>i8</code></td></tr>
<tr><td>x86</td><td><code>xmm_reg</code></td><td><code>sse</code></td><td><code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code></td></tr>
<tr><td>x86</td><td><code>ymm_reg</code></td><td><code>avx</code></td><td><code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code> <br> <code>i8x32</code>, <code>i16x16</code>, <code>i32x8</code>, <code>i64x4</code>, <code>f32x8</code>, <code>f64x4</code></td></tr>
<tr><td>x86</td><td><code>zmm_reg</code></td><td><code>avx512f</code></td><td><code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code> <br> <code>i8x32</code>, <code>i16x16</code>, <code>i32x8</code>, <code>i64x4</code>, <code>f32x8</code>, <code>f64x4</code> <br> <code>i8x64</code>, <code>i16x32</code>, <code>i32x16</code>, <code>i64x8</code>, <code>f32x16</code>, <code>f64x8</code></td></tr>
<tr><td>x86</td><td><code>kreg</code></td><td><code>avx512f</code></td><td><code>i8</code>, <code>i16</code></td></tr>
<tr><td>x86</td><td><code>kreg</code></td><td><code>avx512bw</code></td><td><code>i32</code>, <code>i64</code></td></tr>
<tr><td>x86</td><td><code>mmx_reg</code></td><td>N/A</td><td>Only clobbers</td></tr>
<tr><td>x86</td><td><code>x87_reg</code></td><td>N/A</td><td>Only clobbers</td></tr>
<tr><td>x86</td><td><code>tmm_reg</code></td><td>N/A</td><td>Only clobbers</td></tr>
<tr><td>AArch64</td><td><code>reg</code></td><td>None</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code></td></tr>
<tr><td>AArch64</td><td><code>vreg</code></td><td><code>neon</code></td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x8</code>, <code>i16x4</code>, <code>i32x2</code>, <code>i64x1</code>, <code>f32x2</code>, <code>f64x1</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code></td></tr>
<tr><td>AArch64</td><td><code>preg</code></td><td>N/A</td><td>Only clobbers</td></tr>
<tr><td>ARM</td><td><code>reg</code></td><td>None</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code></td></tr>
<tr><td>ARM</td><td><code>sreg</code></td><td><code>vfp2</code></td><td><code>i32</code>, <code>f32</code></td></tr>
<tr><td>ARM</td><td><code>dreg</code></td><td><code>vfp2</code></td><td><code>i64</code>, <code>f64</code>, <code>i8x8</code>, <code>i16x4</code>, <code>i32x2</code>, <code>i64x1</code>, <code>f32x2</code></td></tr>
<tr><td>ARM</td><td><code>qreg</code></td><td><code>neon</code></td><td><code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code></td></tr>
<tr><td>RISC-V32</td><td><code>reg</code></td><td>None</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code></td></tr>
<tr><td>RISC-V64</td><td><code>reg</code></td><td>None</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code></td></tr>
<tr><td>RISC-V</td><td><code>freg</code></td><td><code>f</code></td><td><code>f32</code></td></tr>
<tr><td>RISC-V</td><td><code>freg</code></td><td><code>d</code></td><td><code>f64</code></td></tr>
<tr><td>RISC-V</td><td><code>vreg</code></td><td>N/A</td><td>Only clobbers</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>注意</strong>：为了上表的目的，指针、函数指针和 <code>isize</code>/<code>usize</code> 被视为相应整数类型的等效类型 (取决于目标的 <code>i16</code>/<code>i32</code>/<code>i64</code> ) 。</p>
</blockquote>
<p>如果一个值的大小比分配给它的寄存器小，那么对于输入，该寄存器的高位将具有未定义的值，对于输出，将被忽略。
唯一的例外是 RISC-V 上的 <code>freg</code> 寄存器类，其中 <code>f32</code> 值作为 RISC-V 架构所需的 NaN 被封装在 <code>f64</code> 中。</p>
<p>当为 <code>inout</code> 操作数指定分开的输入和输出表达式时，两个表达式必须具有相同的类型。
唯一的例外是如果两个操作数都是指针或整数，则它们只需要具有相同的大小。
这个限制存在是因为 LLVM 和 GCC 中的寄存器分配器有时无法处理具有不同类型的绑定操作数。</p>
<h2 id="寄存器名称"><a class="header" href="#寄存器名称">寄存器名称</a></h2>
<p>一些寄存器有多个名称，编译器会将这些名称都视为与基础寄存器名称相同。以下是所有支持的寄存器别名列表：</p>
<div class="table-wrapper"><table><thead><tr><th>Architecture</th><th>Base register</th><th>Aliases</th></tr></thead><tbody>
<tr><td>x86</td><td><code>ax</code></td><td><code>eax</code>, <code>rax</code></td></tr>
<tr><td>x86</td><td><code>bx</code></td><td><code>ebx</code>, <code>rbx</code></td></tr>
<tr><td>x86</td><td><code>cx</code></td><td><code>ecx</code>, <code>rcx</code></td></tr>
<tr><td>x86</td><td><code>dx</code></td><td><code>edx</code>, <code>rdx</code></td></tr>
<tr><td>x86</td><td><code>si</code></td><td><code>esi</code>, <code>rsi</code></td></tr>
<tr><td>x86</td><td><code>di</code></td><td><code>edi</code>, <code>rdi</code></td></tr>
<tr><td>x86</td><td><code>bp</code></td><td><code>bpl</code>, <code>ebp</code>, <code>rbp</code></td></tr>
<tr><td>x86</td><td><code>sp</code></td><td><code>spl</code>, <code>esp</code>, <code>rsp</code></td></tr>
<tr><td>x86</td><td><code>ip</code></td><td><code>eip</code>, <code>rip</code></td></tr>
<tr><td>x86</td><td><code>st(0)</code></td><td><code>st</code></td></tr>
<tr><td>x86</td><td><code>r[8-15]</code></td><td><code>r[8-15]b</code>, <code>r[8-15]w</code>, <code>r[8-15]d</code></td></tr>
<tr><td>x86</td><td><code>xmm[0-31]</code></td><td><code>ymm[0-31]</code>, <code>zmm[0-31]</code></td></tr>
<tr><td>AArch64</td><td><code>x[0-30]</code></td><td><code>w[0-30]</code></td></tr>
<tr><td>AArch64</td><td><code>x29</code></td><td><code>fp</code></td></tr>
<tr><td>AArch64</td><td><code>x30</code></td><td><code>lr</code></td></tr>
<tr><td>AArch64</td><td><code>sp</code></td><td><code>wsp</code></td></tr>
<tr><td>AArch64</td><td><code>xzr</code></td><td><code>wzr</code></td></tr>
<tr><td>AArch64</td><td><code>v[0-31]</code></td><td><code>b[0-31]</code>, <code>h[0-31]</code>, <code>s[0-31]</code>, <code>d[0-31]</code>, <code>q[0-31]</code></td></tr>
<tr><td>ARM</td><td><code>r[0-3]</code></td><td><code>a[1-4]</code></td></tr>
<tr><td>ARM</td><td><code>r[4-9]</code></td><td><code>v[1-6]</code></td></tr>
<tr><td>ARM</td><td><code>r9</code></td><td><code>rfp</code></td></tr>
<tr><td>ARM</td><td><code>r10</code></td><td><code>sl</code></td></tr>
<tr><td>ARM</td><td><code>r11</code></td><td><code>fp</code></td></tr>
<tr><td>ARM</td><td><code>r12</code></td><td><code>ip</code></td></tr>
<tr><td>ARM</td><td><code>r13</code></td><td><code>sp</code></td></tr>
<tr><td>ARM</td><td><code>r14</code></td><td><code>lr</code></td></tr>
<tr><td>ARM</td><td><code>r15</code></td><td><code>pc</code></td></tr>
<tr><td>RISC-V</td><td><code>x0</code></td><td><code>zero</code></td></tr>
<tr><td>RISC-V</td><td><code>x1</code></td><td><code>ra</code></td></tr>
<tr><td>RISC-V</td><td><code>x2</code></td><td><code>sp</code></td></tr>
<tr><td>RISC-V</td><td><code>x3</code></td><td><code>gp</code></td></tr>
<tr><td>RISC-V</td><td><code>x4</code></td><td><code>tp</code></td></tr>
<tr><td>RISC-V</td><td><code>x[5-7]</code></td><td><code>t[0-2]</code></td></tr>
<tr><td>RISC-V</td><td><code>x8</code></td><td><code>fp</code>, <code>s0</code></td></tr>
<tr><td>RISC-V</td><td><code>x9</code></td><td><code>s1</code></td></tr>
<tr><td>RISC-V</td><td><code>x[10-17]</code></td><td><code>a[0-7]</code></td></tr>
<tr><td>RISC-V</td><td><code>x[18-27]</code></td><td><code>s[2-11]</code></td></tr>
<tr><td>RISC-V</td><td><code>x[28-31]</code></td><td><code>t[3-6]</code></td></tr>
<tr><td>RISC-V</td><td><code>f[0-7]</code></td><td><code>ft[0-7]</code></td></tr>
<tr><td>RISC-V</td><td><code>f[8-9]</code></td><td><code>fs[0-1]</code></td></tr>
<tr><td>RISC-V</td><td><code>f[10-17]</code></td><td><code>fa[0-7]</code></td></tr>
<tr><td>RISC-V</td><td><code>f[18-27]</code></td><td><code>fs[2-11]</code></td></tr>
<tr><td>RISC-V</td><td><code>f[28-31]</code></td><td><code>ft[8-11]</code></td></tr>
</tbody></table>
</div>
<p>有些寄存器不能用于输入或输出操作数：</p>
<div class="table-wrapper"><table><thead><tr><th>架构</th><th>不支持的寄存器</th><th>原因</th></tr></thead><tbody>
<tr><td>All</td><td><code>sp</code></td><td>栈指针必须在 asm 代码块结束时恢复为其原始值。</td></tr>
<tr><td>All</td><td><code>bp</code> (x86), <code>x29</code> (AArch64), <code>x8</code> (RISC-V)</td><td>帧指针不能用作输入或输出。</td></tr>
<tr><td>ARM</td><td><code>r7</code> 或 <code>r11</code></td><td>在 ARM 上，帧指针可以是 <code>r7</code> 或 <code>r11</code>，具体取决于目标。帧指针不能用作输入或输出。</td></tr>
<tr><td>All</td><td><code>si</code> (x86-32), <code>bx</code> (x86-64), <code>r6</code> (ARM), <code>x19</code> (AArch64), <code>x9</code> (RISC-V)</td><td>LLVM 在函数具有复杂堆栈帧的情况下将其用作“基指针”。</td></tr>
<tr><td>x86</td><td><code>ip</code></td><td>这是程序计数器，不是实际的寄存器。</td></tr>
<tr><td>AArch64</td><td><code>xzr</code></td><td>这是一个无法修改的常量零寄存器。</td></tr>
<tr><td>AArch64</td><td><code>x18</code></td><td>这是某些 AArch64 目标上保留的操作系统寄存器。</td></tr>
<tr><td>ARM</td><td><code>pc</code></td><td>这是程序计数器，不是实际的寄存器。</td></tr>
<tr><td>ARM</td><td><code>r9</code></td><td>这是某些 ARM 目标上保留的操作系统寄存器。</td></tr>
<tr><td>RISC-V</td><td><code>x0</code></td><td>这是一个无法修改的常量零寄存器。</td></tr>
<tr><td>RISC-V</td><td><code>gp</code>，<code>tp</code></td><td>这些寄存器是保留的，不能用作输入或输出。</td></tr>
</tbody></table>
</div>
<p>帧指针和基指针寄存器被 LLVM 保留作为内部使用。虽然 <code>asm!</code> 语句不能显式地指定保留寄存器的使用，但在某些情况下，LLVM 将为 <code>reg</code> 操作数分配其中一个保留寄存器。
使用保留寄存器的汇编代码应该小心，因为 <code>reg</code> 操作数可能会使用相同的寄存器。</p>
<h2 id="模板修改器"><a class="header" href="#模板修改器">模板修改器</a></h2>
<p>在花括号中的 <code>:</code> 后可以加上修改器，来改变插入模板字符串时操作数的格式，这些修改器不影响寄存器分配。每个模板占位符只能有一个修改器。</p>
<p>这些修改器是 LLVM 和 GCC 的汇编模板参数修改器的子集，但使用的字母代码不同。</p>
<div class="table-wrapper"><table><thead><tr><th>Architecture</th><th>Register class</th><th>Modifier</th><th>Example output</th><th>LLVM modifier</th></tr></thead><tbody>
<tr><td>x86-32</td><td><code>reg</code></td><td>None</td><td><code>eax</code></td><td><code>k</code></td></tr>
<tr><td>x86-64</td><td><code>reg</code></td><td>None</td><td><code>rax</code></td><td><code>q</code></td></tr>
<tr><td>x86-32</td><td><code>reg_abcd</code></td><td><code>l</code></td><td><code>al</code></td><td><code>b</code></td></tr>
<tr><td>x86-64</td><td><code>reg</code></td><td><code>l</code></td><td><code>al</code></td><td><code>b</code></td></tr>
<tr><td>x86</td><td><code>reg_abcd</code></td><td><code>h</code></td><td><code>ah</code></td><td><code>h</code></td></tr>
<tr><td>x86</td><td><code>reg</code></td><td><code>x</code></td><td><code>ax</code></td><td><code>w</code></td></tr>
<tr><td>x86</td><td><code>reg</code></td><td><code>e</code></td><td><code>eax</code></td><td><code>k</code></td></tr>
<tr><td>x86-64</td><td><code>reg</code></td><td><code>r</code></td><td><code>rax</code></td><td><code>q</code></td></tr>
<tr><td>x86</td><td><code>reg_byte</code></td><td>None</td><td><code>al</code> / <code>ah</code></td><td>None</td></tr>
<tr><td>x86</td><td><code>xmm_reg</code></td><td>None</td><td><code>xmm0</code></td><td><code>x</code></td></tr>
<tr><td>x86</td><td><code>ymm_reg</code></td><td>None</td><td><code>ymm0</code></td><td><code>t</code></td></tr>
<tr><td>x86</td><td><code>zmm_reg</code></td><td>None</td><td><code>zmm0</code></td><td><code>g</code></td></tr>
<tr><td>x86</td><td><code>*mm_reg</code></td><td><code>x</code></td><td><code>xmm0</code></td><td><code>x</code></td></tr>
<tr><td>x86</td><td><code>*mm_reg</code></td><td><code>y</code></td><td><code>ymm0</code></td><td><code>t</code></td></tr>
<tr><td>x86</td><td><code>*mm_reg</code></td><td><code>z</code></td><td><code>zmm0</code></td><td><code>g</code></td></tr>
<tr><td>x86</td><td><code>kreg</code></td><td>None</td><td><code>k1</code></td><td>None</td></tr>
<tr><td>AArch64</td><td><code>reg</code></td><td>None</td><td><code>x0</code></td><td><code>x</code></td></tr>
<tr><td>AArch64</td><td><code>reg</code></td><td><code>w</code></td><td><code>w0</code></td><td><code>w</code></td></tr>
<tr><td>AArch64</td><td><code>reg</code></td><td><code>x</code></td><td><code>x0</code></td><td><code>x</code></td></tr>
<tr><td>AArch64</td><td><code>vreg</code></td><td>None</td><td><code>v0</code></td><td>None</td></tr>
<tr><td>AArch64</td><td><code>vreg</code></td><td><code>v</code></td><td><code>v0</code></td><td>None</td></tr>
<tr><td>AArch64</td><td><code>vreg</code></td><td><code>b</code></td><td><code>b0</code></td><td><code>b</code></td></tr>
<tr><td>AArch64</td><td><code>vreg</code></td><td><code>h</code></td><td><code>h0</code></td><td><code>h</code></td></tr>
<tr><td>AArch64</td><td><code>vreg</code></td><td><code>s</code></td><td><code>s0</code></td><td><code>s</code></td></tr>
<tr><td>AArch64</td><td><code>vreg</code></td><td><code>d</code></td><td><code>d0</code></td><td><code>d</code></td></tr>
<tr><td>AArch64</td><td><code>vreg</code></td><td><code>q</code></td><td><code>q0</code></td><td><code>q</code></td></tr>
<tr><td>ARM</td><td><code>reg</code></td><td>None</td><td><code>r0</code></td><td>None</td></tr>
<tr><td>ARM</td><td><code>sreg</code></td><td>None</td><td><code>s0</code></td><td>None</td></tr>
<tr><td>ARM</td><td><code>dreg</code></td><td>None</td><td><code>d0</code></td><td><code>P</code></td></tr>
<tr><td>ARM</td><td><code>qreg</code></td><td>None</td><td><code>q0</code></td><td><code>q</code></td></tr>
<tr><td>ARM</td><td><code>qreg</code></td><td><code>e</code> / <code>f</code></td><td><code>d0</code> / <code>d1</code></td><td><code>e</code> / <code>f</code></td></tr>
<tr><td>RISC-V</td><td><code>reg</code></td><td>None</td><td><code>x1</code></td><td>None</td></tr>
<tr><td>RISC-V</td><td><code>freg</code></td><td>None</td><td><code>f0</code></td><td>None</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>注</strong>：</p>
<ul>
<li>在 ARM 上， <code>e</code>/<code>f</code> ：打印 NEON 四重 (128 位) 寄存器的低位或高位双字寄存器名称。</li>
<li>在 x86 上：我们对于没有修饰符的 <code>reg</code> 的行为与 GCC 不同。
GCC 将根据操作数值类型推断修饰符，而我们默认使用完整的寄存器大小。</li>
<li>在 x86 上， <code>xmm_reg</code> ：LLVM 修饰符 <code>x</code> 、 <code>t</code> 和 <code>g</code> 尚未在 LLVM 中实现 (仅由 GCC 支持) ，但这应该是一个简单的更改。</li>
</ul>
</blockquote>
<p>如前一节所述，如果内联汇编传递的输入值比寄存器宽度小，则寄存器的上位比特将包含未定义的值。
如果内联汇编只访问寄存器的低位，这不是一个问题，可以通过使用模板修饰符在汇编代码中使用子寄存器名称 (例如，使用 <code>ax</code> 代替 <code>rax</code>) 来实现。
由于这是一个简单的错误，编译器将根据输入类型在适当的地方建议使用模板修饰符。
如果对一个操作数的所有引用已经有修饰符，则该警告将对该操作数进行抑制。</p>
<h2 id="abi破坏标记"><a class="header" href="#abi破坏标记">ABI破坏标记</a></h2>
<p><code>clobber_abi</code> 关键字可用于将默认一组破坏标记应用于 <code>asm!</code> 块。这将根据特定调用约定自动插入必要的破坏标记：如果调用约定在函数调用时不能完全保留寄存器的值，则会在操作数列表中隐式添加 <code>lateout(&quot;...&quot;) _</code> (其中 <code>...</code> 替换为寄存器名称) 。</p>
<p><code>clobber_abi</code> 可以指定任意次数。它将为所有指定的调用约定的并集中的所有唯一寄存器插入一个破坏标记。</p>
<p>当使用 <code>clobber_abi</code> 时，编译器禁止使用通用寄存器类输出：所有输出都必须指定显式寄存器。显式寄存器输出优先于由 <code>clobber_abi</code> 插入的隐式破坏标记：仅当该寄存器未用作输出时，才会为该寄存器插入破坏标记。</p>
<p>以下 ABIs 可与 <code>clobber_abi</code> 一起使用：</p>
<div class="table-wrapper"><table><thead><tr><th>Architecture</th><th>ABI name</th><th>Clobbered registers</th></tr></thead><tbody>
<tr><td>x86-32</td><td><code>&quot;C&quot;</code>, <code>&quot;system&quot;</code>, <code>&quot;efiapi&quot;</code>, <code>&quot;cdecl&quot;</code>, <code>&quot;stdcall&quot;</code>, <code>&quot;fastcall&quot;</code></td><td><code>ax</code>, <code>cx</code>, <code>dx</code>, <code>xmm[0-7]</code>, <code>mm[0-7]</code>, <code>k[0-7]</code>, <code>st([0-7])</code></td></tr>
<tr><td>x86-64</td><td><code>&quot;C&quot;</code>, <code>&quot;system&quot;</code> (on Windows), <code>&quot;efiapi&quot;</code>, <code>&quot;win64&quot;</code></td><td><code>ax</code>, <code>cx</code>, <code>dx</code>, <code>r[8-11]</code>, <code>xmm[0-31]</code>, <code>mm[0-7]</code>, <code>k[0-7]</code>, <code>st([0-7])</code>, <code>tmm[0-7]</code></td></tr>
<tr><td>x86-64</td><td><code>&quot;C&quot;</code>, <code>&quot;system&quot;</code> (on non-Windows), <code>&quot;sysv64&quot;</code></td><td><code>ax</code>, <code>cx</code>, <code>dx</code>, <code>si</code>, <code>di</code>, <code>r[8-11]</code>, <code>xmm[0-31]</code>, <code>mm[0-7]</code>, <code>k[0-7]</code>, <code>st([0-7])</code>, <code>tmm[0-7]</code></td></tr>
<tr><td>AArch64</td><td><code>&quot;C&quot;</code>, <code>&quot;system&quot;</code>, <code>&quot;efiapi&quot;</code></td><td><code>x[0-17]</code>, <code>x18</code>*, <code>x30</code>, <code>v[0-31]</code>, <code>p[0-15]</code>, <code>ffr</code></td></tr>
<tr><td>ARM</td><td><code>&quot;C&quot;</code>, <code>&quot;system&quot;</code>, <code>&quot;efiapi&quot;</code>, <code>&quot;aapcs&quot;</code></td><td><code>r[0-3]</code>, <code>r12</code>, <code>r14</code>, <code>s[0-15]</code>, <code>d[0-7]</code>, <code>d[16-31]</code></td></tr>
<tr><td>RISC-V</td><td><code>&quot;C&quot;</code>, <code>&quot;system&quot;</code>, <code>&quot;efiapi&quot;</code></td><td><code>x1</code>, <code>x[5-7]</code>, <code>x[10-17]</code>, <code>x[28-31]</code>, <code>f[0-7]</code>, <code>f[10-17]</code>, <code>f[28-31]</code>, <code>v[0-31]</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p>注意：</p>
<ul>
<li>在 AArch64 上，仅当 <code>x18</code> 在目标上不被视为保留寄存器时，才将其包括在破坏列表中。</li>
</ul>
</blockquote>
<p>每个 ABI 的受破坏寄存器列表会随着架构获取新寄存器而在 rustc 中更新：这确保了当 LLVM 在其生成的代码中开始使用这些新寄存器时， <code>asm！</code> 破坏项将继续正确。</p>
<h2 id="选项"><a class="header" href="#选项">选项</a></h2>
<p>标志用于进一步影响内联汇编块的行为。目前定义了以下选项：</p>
<ul>
<li><code>pure</code>: <code>asm!</code> 块没有副作用，其输出仅取决于其直接输入 (即值本身，而不是它们所指向的内容) 或从内存读取的值 (除非也设置了 <code>nomem</code> 选项) 。这使得编译器可以执行比程序中指定的更少的 <code>asm!</code> 块次数 (例如将其提升出循环) 或甚至完全消除它 (如果输出没有使用) 。</li>
<li><code>nomem</code>: <code>asm!</code> 块不读取或写入任何内存。这使得编译器可以在 <code>asm!</code> 块之间缓存修改后的全局变量的值，因为它知道它们不会被 <code>asm!</code> 读取或写入。</li>
<li><code>readonly</code>: <code>asm!</code> 块不写入任何内存。这使得编译器可以在 <code>asm!</code> 块之间缓存未修改的全局变量的值，因为它知道它们不会被 <code>asm!</code> 写入。</li>
<li><code>preserves_flags</code>: <code>asm!</code> 块不修改标志寄存器 (在下面的规则中定义) 。这使得编译器可以在 <code>asm!</code> 块之后避免重新计算条件标志。</li>
<li><code>noreturn</code>: <code>asm!</code> 块永远不会返回，其返回类型定义为 <code>!</code> (永远不会) 。如果执行超过 asm 代码的结尾，行为是未定义的。 <code>noreturn</code> asm 块的行为就像不返回的函数一样；特别是，作用域中的局部变量在调用之前不会被丢弃。</li>
<li><code>nostack</code>: <code>asm!</code> 块不将数据推入栈，也不写入堆栈保护区域 (如果目标支持) 。如果未使用此选项，则栈指针保证根据目标 ABI 适当对齐，以用于函数调用。</li>
<li><code>att_syntax</code>: 此选项仅在 x86 上有效，导致汇编程序使用 GNU 汇编程序的 <code>.att_syntax</code> 前缀模式。寄存器操作数将替换为带有前导 <code>%</code> 的操作数。</li>
<li><code>raw</code>: 这将导致模板字符串被解析为原始汇编字符串，没有对 <code>{</code> 和 <code>}</code> 进行特殊处理。这在使用 <code>include_str!</code> 包含来自外部文件的原始汇编代码时非常有用。</li>
</ul>
<p>编译器对选项进行了一些额外的检查：</p>
<ul>
<li><code>nomem</code> 和 <code>readonly</code> 选项是互斥的：指定两者都会导致编译时错误。</li>
<li><code>pure</code> 选项必须与 <code>nomem</code> 或 <code>readonly</code> 选项结合使用，否则会发出编译时错误。</li>
<li>在没有输出或只有被丢弃的输出 (<code>_</code>) 的 <code>asm!</code> 块上指定 <code>pure</code> 是编译时错误。</li>
<li>在带有输出的 <code>asm!</code> 块上指定 <code>noreturn</code> 是编译时错误。</li>
</ul>
<p><code>global_asm!</code> 只支持 <code>att_syntax</code> 和 <code>raw</code> 选项。
其他选项在全局作用域内的内联汇编中没有意义。</p>
<h2 id="函数内联汇编规则"><a class="header" href="#函数内联汇编规则">函数内联汇编规则</a></h2>
<p>为了避免未定义的行为，在使用函数内联汇编 (<code>asm!</code>) 时必须遵守以下规则:</p>
<ul>
<li>任何未在输入中指定的寄存器，在进入汇编块时将包含未定义的值。
<ul>
<li>在内联汇编的上下文中， &quot;未定义的值&quot; 意味着该寄存器可以 (非确定性地) 具有体系结构允许的任何可能值。
需要注意的是，它与 LLVM 中的 <code>undef</code> 不同，后者每次读取时都可以具有不同的值 (因为在汇编代码中不存在这样的概念) 。</li>
</ul>
</li>
<li>任何未指定为输出的寄存器，在离开汇编块时必须具有与进入时相同的值，否则行为是未定义的。
<ul>
<li>这仅适用于可以指定为输入或输出的寄存器。
其他寄存器遵循特定于目标的规则。</li>
<li>需要注意的是，<code>lateout</code> 可能会分配到与 <code>in</code> 相同的寄存器中，此时此规则不适用。
不过代码不应该依赖此规则，因为它取决于寄存器分配的结果。</li>
</ul>
</li>
<li>如果执行从汇编块中退出，则行为是未定义的。
<ul>
<li>如果汇编代码调用一个函数，然后函数抛出异常也同样适用。</li>
</ul>
</li>
<li>汇编代码被允许读取和写入的内存位置集合与 FFI 函数允许的位置集合相同。
<ul>
<li>参考不安全代码指南了解确切的规则。</li>
<li>如果设置了 <code>readonly</code> 选项，则只允许内存读取。</li>
<li>如果设置了 <code>nomem</code> 选项，则不允许读取或写入内存。</li>
<li>这些规则不适用于汇编代码私有的内存，例如在汇编块中分配的栈空间。</li>
</ul>
</li>
<li>编译器不能假设汇编中的指令实际上就是将要执行的指令。
<ul>
<li>这实际上意味着编译器必须将 <code>asm!</code> 视为黑匣子，并仅考虑接口规范，而不考虑指令本身。</li>
<li>可以通过特定于目标的机制进行运行时代码修补。</li>
</ul>
</li>
<li>除非设置了 <code>nostack</code> 选项，汇编代码可以使用堆栈指针下面的堆栈空间。
<ul>
<li>进入汇编块时，堆栈指针保证对于函数调用具有适当的对齐方式 (根据目标 ABI) 。</li>
<li>你负责确保不会溢出堆栈 (例如，使用堆栈探测以确保触发警戒页) 。</li>
<li>分配堆栈内存时，应根据目标 ABI 调整堆栈指针。</li>
<li>在离开 asm 块之前，堆栈指针必须恢复到其原始值。</li>
</ul>
</li>
<li>如果设置了 <code>noreturn</code> 选项，则执行控制流落到 <code>asm</code> 块末尾时的行为未定义。</li>
<li>如果设置了 <code>pure</code> 选项，则执行除直接输出之外的副作用的 <code>asm!</code> 的行为是未定义的。 如果相同输入的两次 <code>asm!</code> 执行产生不同的输出，则行为也是未定义的。
<ul>
<li>在与 <code>nomem</code> 选项一起使用时，&quot;输入&quot; 只是 <code>asm!</code> 的直接输入。</li>
<li>在与 <code>readonly</code> 选项一起使用时，&quot;输入&quot; 包括 <code>asm!</code> 的直接输入以及 <code>asm!</code> 块允许读取的任何内存。</li>
</ul>
</li>
<li>如果设置了 <code>preserves_flags</code> 选项，则必须在退出 <code>asm</code> 块时还原这些标志寄存器：
<ul>
<li>x86
<ul>
<li><code>EFLAGS</code> 中的状态标志位 (CF、PF、AF、ZF、SF、OF) 。</li>
<li>浮点状态字 (全部) 。</li>
<li><code>MXCSR</code> 中的浮点异常标志 (PE、UE、OE、ZE、DE、IE) 。</li>
</ul>
</li>
<li>ARM
<ul>
<li><code>CPSR</code> 中的条件标志 (N、Z、C、V) 。</li>
<li><code>CPSR</code> 中的饱和标志 (Q) 。</li>
<li><code>CPSR</code> 中的大于或等于标志 (GE) 。</li>
<li><code>FPSCR</code> 中的条件标志 (N、Z、C、V) 。</li>
<li><code>FPSCR</code> 中的饱和标志 (QC) 。</li>
<li><code>FPSCR</code> 中的浮点异常标志 (IDC、IXC、UFC、OFC、DZC、IOC) 。</li>
</ul>
</li>
<li>AArch64
<ul>
<li>条件标志 (<code>NZCV</code> 寄存器) 。</li>
<li>浮点状态 (<code>FPSR</code> 寄存器) 。</li>
</ul>
</li>
<li>RISC-V
<ul>
<li><code>fcsr</code> 中的浮点异常标志 (<code>fflags</code>) 。</li>
<li>向量扩展状态 (<code>vtype</code>、<code>vl</code>、<code>vcsr</code>) 。</li>
</ul>
</li>
</ul>
</li>
<li>在 x86 上，进入 asm 块时方向标志 (<code>EFLAGS</code> 中的 DF) 被清除，并且在退出时必须保持清除状态。
<ul>
<li>如果在退出 asm 块时设置了方向标志，则行为未定义。</li>
</ul>
</li>
<li>在 x86 上，除非所有的 <code>st([0-7])</code> 寄存器都被标记为被污染的，否则 x87 浮点寄存器堆栈必须保持不变，方法是使用 <code>out(&quot;st(0)&quot;) _，out(&quot;st(1)&quot;) _，...</code>。
<ul>
<li>如果所有 x87 寄存器都被污染，则在进入 <code>asm</code> 块时保证 x87 寄存器堆栈为空。汇编代码必须确保在退出 asm 块时 x87 寄存器堆栈也为空。</li>
</ul>
</li>
<li>将栈指针和非输出寄存器恢复到其原始值的要求仅适用于退出 <code>asm!</code> 块时。
<ul>
<li>这意味着从不返回的 <code>asm!</code> 块 (即使没有标记为 <code>noreturn</code>) 不需要保留这些寄存器。</li>
<li>当返回到与您进入的 <code>asm!</code> 块不同的 <code>asm!</code> 块时 (例如用于上下文切换) ，这些寄存器必须包含您正在 <em>退出</em> 的 <code>asm!</code> 块进入时的值。
<ul>
<li>您不能退出未进入的 <code>asm!</code> 块。也不能退出已经退出的 <code>asm!</code> 块 (除非首先再次进入它) 。</li>
<li>您负责切换任何特定于目标的状态 (例如线程本地存储，堆栈边界) 。</li>
<li>您不能从一个 <code>asm!</code> 块中的地址跳转到另一个 <code>asm!</code> 块中的地址，即使在同一个函数或块中，也必须将它们的上下文视为可能不同并要求进行上下文切换。您不能假设这些上下文中的任何特定值 (例如当前堆栈指针或堆栈指针下方的临时值) 在两个 <code>asm!</code> 块之间保持不变。</li>
<li>您可以访问的内存位置集是您输入和退出的 <code>asm!</code> 块所允许的位置集的交集。</li>
</ul>
</li>
</ul>
</li>
<li>您不能假设两个在源代码中相邻的 <code>asm!</code> 块，即使它们之间没有其他代码，也会在二进制代码中以连续的地址出现，而没有其他指令在它们之间。</li>
<li>您不能假设 <code>asm!</code> 块将在输出二进制代码中出现一次。
编译器可以实例化多个 <code>asm!</code> 块，例如当包含它的函数在多个位置内联时。</li>
<li>在 x86 平台上，内联汇编不得以指令前缀 (如 <code>LOCK</code> ) 作为结尾，因为这将应用于编译器生成的指令。
<ul>
<li>目前，编译器无法检测到这种情况，但将来可能会检测并拒绝此类代码。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>: 通常情况下，<code>preserves_flags</code> 覆盖的标志位是在函数调用时 <em>不会</em> 保留的标志位。</p>
</blockquote>
<h3 id="指令支持"><a class="header" href="#指令支持">指令支持</a></h3>
<p>内联汇编支持一些 GNU AS 和 LLVM 内部汇编器支持的指令子集，具体如下。
使用其他指令的结果是汇编器特定的 (可能会导致错误，也可能按原样接受) 。</p>
<p>如果内联汇编包含任何 &quot;有状态&quot; 的指令，修改了后续汇编的处理方式，那么该块在内联汇编结束前必须撤销任何此类指令的影响。</p>
<p>以下指令保证被汇编器支持：</p>
<ul>
<li><code>.2byte</code></li>
<li><code>.4byte</code></li>
<li><code>.8byte</code></li>
<li><code>.align</code></li>
<li><code>.ascii</code></li>
<li><code>.asciz</code></li>
<li><code>.alt_entry</code></li>
<li><code>.balign</code></li>
<li><code>.balignl</code></li>
<li><code>.balignw</code></li>
<li><code>.balign</code></li>
<li><code>.balignl</code></li>
<li><code>.balignw</code></li>
<li><code>.bss</code></li>
<li><code>.byte</code></li>
<li><code>.comm</code></li>
<li><code>.data</code></li>
<li><code>.def</code></li>
<li><code>.double</code></li>
<li><code>.endef</code></li>
<li><code>.equ</code></li>
<li><code>.equiv</code></li>
<li><code>.eqv</code></li>
<li><code>.fill</code></li>
<li><code>.float</code></li>
<li><code>.globl</code></li>
<li><code>.global</code></li>
<li><code>.lcomm</code></li>
<li><code>.inst</code></li>
<li><code>.long</code></li>
<li><code>.octa</code></li>
<li><code>.option</code></li>
<li><code>.private_extern</code></li>
<li><code>.p2align</code></li>
<li><code>.pushsection</code></li>
<li><code>.popsection</code></li>
<li><code>.quad</code></li>
<li><code>.scl</code></li>
<li><code>.section</code></li>
<li><code>.set</code></li>
<li><code>.short</code></li>
<li><code>.size</code></li>
<li><code>.skip</code></li>
<li><code>.sleb128</code></li>
<li><code>.space</code></li>
<li><code>.string</code></li>
<li><code>.text</code></li>
<li><code>.type</code></li>
<li><code>.uleb128</code></li>
<li><code>.word</code></li>
</ul>
<h4 id="目标特定指令支持"><a class="header" href="#目标特定指令支持">目标特定指令支持</a></h4>
<h5 id="dwarf-帧解构指令"><a class="header" href="#dwarf-帧解构指令">DWARF 帧解构指令</a></h5>
<p>以下指令在支持 DWARF 帧解构信息的 ELF 目标上被支持：</p>
<ul>
<li><code>.cfi_adjust_cfa_offset</code></li>
<li><code>.cfi_def_cfa</code></li>
<li><code>.cfi_def_cfa_offset</code></li>
<li><code>.cfi_def_cfa_register</code></li>
<li><code>.cfi_endproc</code></li>
<li><code>.cfi_escape</code></li>
<li><code>.cfi_lsda</code></li>
<li><code>.cfi_offset</code></li>
<li><code>.cfi_personality</code></li>
<li><code>.cfi_register</code></li>
<li><code>.cfi_rel_offset</code></li>
<li><code>.cfi_remember_state</code></li>
<li><code>.cfi_restore</code></li>
<li><code>.cfi_restore_state</code></li>
<li><code>.cfi_return_column</code></li>
<li><code>.cfi_same_value</code></li>
<li><code>.cfi_sections</code></li>
<li><code>.cfi_signal_frame</code></li>
<li><code>.cfi_startproc</code></li>
<li><code>.cfi_undefined</code></li>
<li><code>.cfi_window_save</code></li>
</ul>
<h5 id="结构化异常处理"><a class="header" href="#结构化异常处理">结构化异常处理</a></h5>
<p>对于具有结构化异常处理的目标，以下附加指令被保证受支持：</p>
<ul>
<li><code>.seh_endproc</code></li>
<li><code>.seh_endprologue</code></li>
<li><code>.seh_proc</code></li>
<li><code>.seh_pushreg</code></li>
<li><code>.seh_savereg</code></li>
<li><code>.seh_setframe</code></li>
<li><code>.seh_stackalloc</code></li>
</ul>
<h5 id="x86-32位和64位"><a class="header" href="#x86-32位和64位">x86 (32位和64位)</a></h5>
<p>在 x86 目标上，无论是 32 位还是 64 位，保证支持以下附加指令：</p>
<ul>
<li><code>.nops</code></li>
<li><code>.code16</code></li>
<li><code>.code32</code></li>
<li><code>.code64</code></li>
</ul>
<p>对于使用 <code>.code16</code>, <code>.code32</code> 和 <code>.code64</code> 指令的情况，只有在退出汇编块之前将状态重置为默认值才受支持。
32 位 x86 默认使用 <code>.code32</code>，而 x86_64 默认使用 <code>.code64</code>。</p>
<h5 id="arm-32-位"><a class="header" href="#arm-32-位">ARM (32 位)</a></h5>
<p>在 ARM 上，以下其他指令保证得到支持：</p>
<ul>
<li><code>.even</code></li>
<li><code>.fnstart</code></li>
<li><code>.fnend</code></li>
<li><code>.save</code></li>
<li><code>.movsp</code></li>
<li><code>.code</code></li>
<li><code>.thumb</code></li>
<li><code>.thumb_func</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="不安全性"><a class="header" href="#不安全性">不安全性</a></h1>
<p>不安全操作是指那些可能违反 Rust 静态语义内存安全保证的操作。</p>
<p>以下语言级别的特性不能在 Rust 的安全子集中使用:</p>
<ul>
<li>解引用一个 <a href="types/pointer.html">裸指针</a> 。</li>
<li>读取或写入一个 <a href="items/static-items.html#mutable-statics">可变</a> 或 <a href="items/external-blocks.html">外部</a> 静态变量。</li>
<li>访问一个 <a href="items/unions.html"><code>union</code></a> 的字段，除了给它赋值之外。</li>
<li>调用一个不安全的函数 (包括一个内部函数或外部函数) 。</li>
<li>实现一个 <a href="items/traits.html#unsafe-traits">不安全 trait</a> 。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-关键字"><a class="header" href="#unsafe-关键字"><code>unsafe</code> 关键字</a></h1>
<p><code>unsafe</code> 关键字可以出现在几种不同的上下文: 不安全函数 (<code>unsafe fn</code>) ，不安全块 (<code>unsafe {}</code>) ，不安全 trait (<code>unsafe trait</code>) 和不安全 trait 实现 (<code>unsafe impl</code>) 中。
它在不同的使用情况下扮演不同的角色，具体取决于它在哪里使用以及是否启用了 <code>unsafe_op_in_unsafe_fn</code> 代码分析: </p>
<ul>
<li>它用于标记 <em>定义</em> 额外安全条件的代码 (<code>unsafe fn</code> ， <code>unsafe trait</code>) 。</li>
<li>它用于标记需要 <em>满足</em> 额外安全条件的代码 (<code>unsafe {}</code> ， <code>unsafe impl</code> ，没有 <a href="../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn"><code>unsafe_op_in_unsafe_fn</code></a> 的 <code>unsafe fn</code>) 。</li>
</ul>
<p>以下讨论了这些情况的每个案例。参见 <a href="../std/keyword.unsafe.html">关键字文档</a> 以获取一些说明性示例。</p>
<h2 id="不安全函数-unsafe-fn"><a class="header" href="#不安全函数-unsafe-fn">不安全函数 (<code>unsafe fn</code>)</a></h2>
<p>不安全函数是在所有上下文和/或所有可能的输入上都不安全的函数。我们说它们具有 <em>额外安全条件</em> ，这些条件是所有调用者必须满足的要求，编译器不会检查。
例如， <a href="../std/primitive.slice.html#method.get_unchecked"><code>get_unchecked</code></a> 具有额外的安全条件，即索引必须在边界内。不安全函数应该配有说明文档，解释这些额外的安全条件。</p>
<p>这样的函数必须以关键字 <code>unsafe</code> 为前缀，并且只能从 <code>unsafe</code> 块内部调用，或者在没有 <a href="../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn"><code>unsafe_op_in_unsafe_fn</code></a> lint 的情况下在 <code>unsafe fn</code> 中调用。</p>
<h2 id="不安全块-unsafe-"><a class="header" href="#不安全块-unsafe-">不安全块 (<code>unsafe {}</code>)</a></h2>
<p>一个代码块可以加上 <code>unsafe</code> 关键字，以允许调用 <code>unsafe</code> 函数或对原始指针进行引用。
默认情况下，不安全函数的函数体也被视为不安全块；这可以通过启用 <a href="../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn"><code>unsafe_op_in_unsafe_fn</code></a> 限制来改变。</p>
<p>通过将操作放入不安全块中，程序员声明他们已经满足了该块内所有操作的额外安全条件。</p>
<p>不安全块是不安全函数的逻辑对偶：不安全函数定义调用者必须满足的证明义务，而不安全块则声明所有相关证明义务已得到满足。
有许多方法可以满足证明义务；例如，可能存在运行时检查或数据结构不变式，保证某些属性肯定为真，或者不安全块可以位于 <code>unsafe fn</code> 中，并使用其自己的证明义务来满足其调用方的证明义务。</p>
<p>不安全块用于包装外部库、直接使用硬件或实现语言中未直接出现的特性。
例如，Rust 提供了实现内存安全并发所需的语言特性，但标准库中的线程和消息传递的实现使用了不安全块。</p>
<p>Rust 的类型系统是动态安全要求的保守近似，因此在某些情况下，使用安全代码会带来性能成本。
例如，双向链表不是树结构，只能在安全代码中使用引用计数指针来表示。
通过使用 <code>unsafe</code> 块来将反向链接表示为原始指针，可以在不使用引用计数的情况下实现它。
(有关此特定示例的更深入探索，请参见 <a href="https://rust-unofficial.github.io/too-many-lists/">&quot;使用太多链表学习Rust&quot;</a> )</p>
<h2 id="不安全-trait-unsafe-trait"><a class="header" href="#不安全-trait-unsafe-trait">不安全 trait (<code>unsafe trait</code>)</a></h2>
<p>不安全 trait 是一种需要实现额外的安全条件的 trait，实现该 trait 必须遵守这些额外的安全条件。该不安全 trait 应该附带有说明这些额外安全条件的文档。</p>
<p>这样的 trait 必须以关键字 <code>unsafe</code> 为前缀，并且只能由 <code>unsafe impl</code> 块实现。</p>
<h2 id="不安全-trait-实现-unsafe-impl"><a class="header" href="#不安全-trait-实现-unsafe-impl">不安全 trait 实现 (<code>unsafe impl</code>)</a></h2>
<p>在实现不安全 trait 时，实现必须以 <code>unsafe</code> 关键字为前缀。通过编写 <code>unsafe impl</code>，程序员表明他们已经注意到了 trait 所需的额外安全条件。</p>
<p>不安全 trait 实现是不安全 trait 的逻辑对偶：不安全 trait 定义了实现必须遵守的证明义务，而不安全实现则声明已经履行了所有相关的证明义务。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="未定义的行为"><a class="header" href="#未定义的行为">未定义的行为</a></h2>
<p>如果 Rust 代码表现出以下列表中的任何行为，则它是不正确的。这包括 <code>unsafe</code> 块和 <code>unsafe</code> 函数中的代码。 <code>unsafe</code> 只意味着避免未定义行为是由程序员负责；它并不改变 Rust 程序永远不应该导致未定义行为的事实。</p>
<p>在编写 <code>unsafe</code> 代码时，程序员的责任是确保与 <code>unsafe</code> 代码交互的任何安全代码都不会触发这些行为。对于任何安全客户端都满足这个属性的 <code>unsafe</code> 代码被称为 <em>健壮的</em> ；如果安全代码可以误用 <code>unsafe</code> 代码来表现出未定义的行为，那么它就是<em>不健壮的</em>。</p>
<div class="warning">
<p><em><strong>警告:</strong></em> 以下列表不是穷尽的。 Rust 中不允许哪些操作和不允许的行为没有正式的模型，因此可能还有更多被视为不安全的行为。以下列表仅列出了我们知道的肯定是未定义行为的内容。请在编写不安全代码之前阅读 <a href="../nomicon/index.html">Rustonomicon</a>。</p>
</div>
<ul>
<li>数据竞争。</li>
<li>在原始指针上评估解引用表达式 (<code>*expr</code>) ，即使在 <a href="expressions.html#place-expressions-and-value-expressions">占位表达式上下文</a> 上也是如此，该原始指针是 <a href="behavior-considered-undefined.html#dangling-pointers">dangling</a> 或不对齐的。(例如， <code>addr_of!(&amp;*expr)</code> ).</li>
<li>破坏 <a href="http://llvm.org/docs/LangRef.html#pointer-aliasing-rules">指针别名规则</a> 。 <code>Box&lt;T&gt;</code> 、 <code>&amp;mut T</code> 和 <code>&amp;T</code> 遵循 LLVM 的作用域 <a href="http://llvm.org/docs/LangRef.html#noalias">noalias</a> 模型，除非 <code>&amp;T</code> 包含 <a href="../std/cell/struct.UnsafeCell.html"><code>UnsafeCell&lt;U&gt;</code></a> 。当引用和 box 无效时，它们不能处于活动状态。确切的存活时间没有指定，但存在一些界限:
<ul>
<li>对于引用，存活时间的上界是借用检查器分配的语法生命周期；它不能活得比那个生命周期更长。</li>
<li>每次引用或 box 被传递给或从函数返回时，它都被视为处于活动状态。</li>
<li>当引用 (但不是 <code>Box</code>! ) 被传递到函数时，它至少在那个函数调用期间是活动的，再次除非 <code>&amp;T</code> 包含一个 <a href="../std/cell/struct.UnsafeCell.html"><code>UnsafeCell&lt;U&gt;</code></a> 。</li>
</ul>
</li>
</ul>
<p>以下内容也适用于这些类型的值作为复合类型的 (嵌套) 字段传递，但不适用于指针间接引用的情况。</p>
<ul>
<li>
<p>修改不可变数据。 <a href="items/constant-items.html"><code>const</code></a> 中的所有数据都是不可变的。此外，通过共享引用访问的数据或由不可变绑定拥有的数据也是不可变的，除非该数据包含在 <a href="../std/cell/struct.UnsafeCell.html"><code>UnsafeCell&lt;U&gt;</code></a> 中。</p>
</li>
<li>
<p>通过编译器内部函数调用产生未定义行为。</p>
</li>
<li>
<p>执行使用当前平台不支持的平台特性编译的代码 (请参阅 <a href="attributes/codegen.html#the-target_feature-attribute"><code>target_feature</code></a>) ， <em>除非</em> 该平台明确记录此操作是安全的。</p>
</li>
<li>
<p>使用错误的调用 ABI 调用函数或从错误的取消 ABI 函数中回溯。</p>
</li>
<li>
<p>在私有字段和局部变量中生成无效值。 &quot;生成&quot; 值是指将值分配给或从位置读取值、将值传递给函数/原始操作或从函数/原始操作返回值。
以下值是无效的 (在其各自的类型中) :</p>
<ul>
<li>
<p>在 <a href="types/boolean.html"><code>bool</code></a> 中除了 <code>false</code> (<code>0</code>) 或 <code>true</code> (<code>1</code>) 之外的值。</p>
</li>
<li>
<p>枚举中的鉴别器不在类型定义中。</p>
</li>
<li>
<p>空的 <code>fn</code> 指针。</p>
</li>
<li>
<p><code>char</code> 中的值是代理或大于 <code>char::MAX</code> 。</p>
</li>
<li>
<p><code>!</code> (所有值对于此类型都是无效的) 。</p>
</li>
<li>
<p>从 <a href="http://llvm.org/docs/LangRef.html#undefined-values">未初始化的内存</a> 中获取的整数 ( <code>i*</code>/<code>u*</code> ) 、浮点数 ( <code>f*</code> ) 或裸指针，或在 <code>str</code> 中使用未初始化的内存。</p>
</li>
<li>
<p>悬空引用或 <code>Box&lt;T&gt;</code> ，不对齐或指向无效值。</p>
</li>
<li>
<p>宽指针、 <code>Box&lt;T&gt;</code> 或裸指针中的无效元数据:</p>
<ul>
<li>如果 <code>dyn Trait</code> 的元数据不是指向与指针或引用指向的实际动态特性相匹配的 <code>Trait</code> 的虚表的指针，则该元数据是无效的。</li>
<li>如果长度不是有效的 <code>usize</code> (即不能从未初始化的内存中读取) ，则切片元数据无效。</li>
</ul>
</li>
<li>
<p>自定义无效值类型的无效值。在标准库中，这会影响 <a href="../core/ptr/struct.NonNull.html"><code>NonNull&lt;T&gt;</code></a> 和 <a href="../core/num/index.html"><code>NonZero*</code></a> 。</p>
<blockquote>
<p><strong>注意</strong>: <code>rustc</code> 使用未稳定的 <code>rustc_layout_scalar_valid_range_*</code> 属性来实现此功能。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>不正确使用内联汇编。有关更多详细信息，请参阅使用内联汇编编写代码时要遵循的 <a href="inline-assembly.html#rules-for-inline-assembly">规则</a> 。</p>
</li>
</ul>
<p><strong>注意:</strong> 对于任何具有受限制的有效值集的类型，未初始化的内存也是隐式无效的。换句话说，读取未初始化的内存仅在 <code>union</code> 内部和在类型的字段/元素之间 &quot;填充&quot; (间隙)中是允许的。</p>
<blockquote>
<p><strong>注意</strong>: 未定义行为影响整个程序。例如，在C中调用表现出未定义行为的函数意味着你的整个程序包含未定义行为，这也可能影响 Rust 代码。反之，在 Rust 中发生未定义行为也会对调用其他语言的 FFI 调用执行的代码产生不利影响。</p>
</blockquote>
<h3 id="悬垂指针"><a class="header" href="#悬垂指针">悬垂指针</a></h3>
<p>如果引用/指针为 null ，或者它所指向的字节不全属于同一个活跃分配 (因此特别注意它们必须全部属于 <em>某个</em> 分配) ，则该引用/指针是 &quot;悬垂&quot; 的。它所指向的字节跨度由指针值和指向类型的大小 (使用 <code>size_of_val</code> ) 确定。</p>
<p>如果大小为 0 ，则指针必须指向活动分配的内部 (包括指向分配的最后一个字节的后面) ，或者直接从非零整数字面值构建而来。</p>
<p>请注意，动态大小的类型 (例如切片和字符串) 指向它们的整个范围，因此重要的是长度元数据永远不要太大。特别是， Rust 值的动态大小(由 <code>size_of_val</code> 确定) 不能超过 <code>isize::MAX</code> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="行为不被视为-unsafe"><a class="header" href="#行为不被视为-unsafe">行为不被视为 <code>unsafe</code></a></h2>
<p>Rust 编译器不认为以下行为是不安全的，尽管程序员可能 (应该) 认为它们是不可取、不符合预期或错误的。</p>
<h5 id="死锁"><a class="header" href="#死锁">死锁</a></h5>
<h5 id="内存和其他资源泄漏"><a class="header" href="#内存和其他资源泄漏">内存和其他资源泄漏</a></h5>
<h5 id="退出时未调用析构函数"><a class="header" href="#退出时未调用析构函数">退出时未调用析构函数</a></h5>
<h5 id="通过指针泄漏公开随机化的基址"><a class="header" href="#通过指针泄漏公开随机化的基址">通过指针泄漏公开随机化的基址</a></h5>
<h5 id="整数溢出"><a class="header" href="#整数溢出">整数溢出</a></h5>
<p>如果程序出现算术溢出，那么程序员就犯了一个错误。在下面的讨论中，我们保持算术溢出和包装算术之间的区别。前者是错误的，而后者是有意的。</p>
<p>当程序员启用了 <code>debug_assert!</code> 断言 (例如，启用了非优化构建) 时，实现必须插入动态检查以在溢出时引发 <code>panic</code> 。其他类型的构建可能会在溢出时导致 <code>panics</code> 或静默地包装值，实现自行决定。</p>
<p>在隐式包装溢出的情况下，实现必须使用二进制补码溢出约定提供明确定义的 (即使仍然被认为是错误的) 结果。</p>
<p>整数类型提供了固有方法，允许程序员显式地执行包装算术。例如， <code>i32::wrapping_add</code> 提供了二进制补码的包装加法。</p>
<p>标准库还提供了一个 <code>Wrapping&lt;T&gt;</code> 的新类型，它确保 <code>T</code> 的所有标准算术操作都具有包装语义。</p>
<p>有关整数溢出的错误条件、原理和更多细节，请参见 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md">RFC 560</a> 。</p>
<h5 id="逻辑错误"><a class="header" href="#逻辑错误">逻辑错误</a></h5>
<p>安全的代码可能会施加额外的逻辑约束，这些约束既无法在编译时检查，也无法在运行时检查。如果程序违反了这些约束，则其行为可能是未指定的，但不会导致未定义的行为。这可能包括恐慌、不正确的结果、终止和非终止。这种行为可能也会因为运行次数、构建方式或不同的编译方式而不同。</p>
<p>例如，实现 <code>Hash</code> 和 <code>Eq</code> 都要求被认为相等的值具有相等的哈希值。另一个例子是数据结构，如 <code>BinaryHeap</code> 、 <code>BTreeMap</code> 、 <code>BTreeSet</code> 、 <code>HashMap</code> 和 <code>HashSet</code> ，这些数据结构描述了在它们的键在数据结构中时修改的约束。违反这样的约束被认为不是不安全的，但程序被认为是错误的，其行为是不可预测的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常量求值"><a class="header" href="#常量求值">常量求值</a></h1>
<p>常量求值是在编译期间计算 <a href="expressions.html">表达式</a> 结果的过程。只有所有表达式的一个子集能够在编译时进行求值。</p>
<h2 id="常量表达式"><a class="header" href="#常量表达式">常量表达式</a></h2>
<p>某些形式的表达式被称为常量表达式，可以在编译时求值。在 <a href="const_eval.html#const-context">常量上下文</a> 中，这些是唯一允许的表达式，并且始终在编译时求值。
在其他地方，如 <a href="statements.html#let-statements">let语句</a> 中，常量表达式可能会被求值，但不能保证在编译时求值。
如果必须在编译时求值 (即在常量上下文中) ，则越界的 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">数组索引</a> 或 <a href="expressions/operator-expr.html#overflow">溢出</a> 等行为会导致编译器错误。
否则，这些行为会导致警告，但可能会在运行时崩溃。</p>
<p>以下表达式是常量表达式，只要任何操作数也是常量表达式并且不会导致任何 <a href="destructors.html"><code>Drop::drop</code></a> 调用运行。</p>
<ul>
<li><a href="expressions/literal-expr.html">字面量</a>。</li>
<li><a href="items/generics.html">常量参数</a>。</li>
<li><a href="items/functions.html">函数</a> 和 <a href="items/constant-items.html">常量</a> 的 <a href="expressions/path-expr.html">路径</a> 。不允许递归定义常量。</li>
<li><a href="items/static-items.html">静态变量</a> 的路径。这些只允许在静态变量的初始化器中使用。</li>
<li><a href="expressions/tuple-expr.html">元组表达式</a> 。</li>
<li><a href="expressions/array-expr.html">数组表达式</a> 。</li>
<li><a href="expressions/struct-expr.html">结构体</a> 表达式。</li>
<li><a href="expressions/block-expr.html">块表达式</a> ，包括 <code>unsafe</code> 块。
<ul>
<li><a href="statements.html#let-statements">let语句</a> 和因此不可反驳的 <a href="patterns.html">模式</a> ，包括可变绑定。</li>
<li><a href="expressions/operator-expr.html#assignment-expressions">赋值表达式</a></li>
<li><a href="expressions/operator-expr.html#compound-assignment-expressions">复合赋值表达式</a></li>
<li><a href="statements.html#expression-statements">表达式语句</a></li>
</ul>
</li>
<li><a href="expressions/field-expr.html">字段</a> 表达式。</li>
<li>索引表达式，使用 <code>usize</code> 的 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">数组索引</a> 或 <a href="types/slice.html">切片</a> 。</li>
<li><a href="expressions/range-expr.html">范围表达式</a> 。</li>
<li>不捕获环境变量的 <a href="expressions/closure-expr.html">闭包表达式</a> 。</li>
<li>在整数和浮点数类型、 <code>bool</code> 和 <code>char</code> 上使用的内置 <a href="expressions/operator-expr.html#negation-operators">否定</a> 、 <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">算术</a> 、 <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">逻辑</a> 、 <a href="expressions/operator-expr.html#comparison-operators">比较</a> 或 <a href="expressions/operator-expr.html#lazy-boolean-operators">惰性布尔</a> 运算符。</li>
<li>共享 <a href="expressions/operator-expr.html#borrow-operators">借用</a> ，除非应用于具有 <a href="interior-mutability.html">内部可变性</a> 的类型。</li>
<li><a href="expressions/operator-expr.html#the-dereference-operator">解引用运算符</a> ，除了原始指针。</li>
<li><a href="expressions/grouped-expr.html">分组</a> 表达式。</li>
<li><a href="expressions/operator-expr.html#type-cast-expressions">转换</a> 表达式，除了
<ul>
<li>指针到地址转换和</li>
<li>函数指针到地址转换。</li>
</ul>
</li>
<li><a href="items/functions.html#const-functions">const函数</a> 和 const 方法的调用。</li>
<li><a href="expressions/loop-expr.html#infinite-loops">loop</a> 、 <a href="expressions/loop-expr.html#predicate-loops">while</a> 和 <a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a> 表达式。</li>
<li><a href="expressions/if-expr.html#if-expressions">if</a> 、 <a href="expressions/if-expr.html#if-let-expressions"><code>if let</code></a> 和 <a href="expressions/match-expr.html">match</a> 表达式。</li>
</ul>
<h2 id="常量上下文"><a class="header" href="#常量上下文">常量上下文</a></h2>
<p><em>常量上下文</em> 是以下情况之一:</p>
<ul>
<li><a href="types/array.html">数组类型长度表达式</a></li>
<li><a href="expressions/array-expr.html">数组重复长度表达式</a></li>
<li><a href="items/constant-items.html">常量</a> 、 <a href="items/static-items.html">静态变量</a> 或 <a href="items/enumerations.html#discriminants">枚举判别式</a> 的初始化器</li>
<li><a href="items/generics.html#const-generics">常量泛型参数</a></li>
</ul>
<h2 id="常量函数"><a class="header" href="#常量函数">常量函数</a></h2>
<p>常量函数是指允许在常量上下文中调用的函数。
将函数声明为 <code>const</code> 不会影响任何现有用途，它只限制了参数和返回类型可能使用的类型，并防止在其中使用各种表达式。您可以像普通函数一样自由地使用常量函数做相同的操作。</p>
<p>在常量上下文中调用函数时，编译器会在编译时解释该函数。解释发生在编译目标的环境中，而不是主机的环境中。
因此，如果您正在针对 32 位系统进行编译，则无论您在 64 位系统还是 32 位系统上构建， <code>usize</code> 都是 32 位。</p>
<p>常量函数有各种限制，以确保它们可以在编译时求值。例如，不可能将随机数生成器编写为常量函数。
在编译时调用常量函数将始终产生与在运行时调用它相同的结果，即使调用多次也是如此。
有一个例外：如果在极端情况下进行复杂的浮点数运算，则可能会得到(极微小的)不同结果。
建议不要使数组长度和枚举判别式依赖于浮点数计算。</p>
<p>允许在常量上下文中使用但不允许在常量函数中使用的显著特性包括：</p>
<ul>
<li>浮点运算
<ul>
<li>浮点值与不包含超出 <code>Copy</code> 之外的 trait 约束的泛型参数一样处理。因此，您无法对它们进行任何操作，只能复制/移动它们。</li>
</ul>
</li>
</ul>
<p>相反，在常量函数中可以使用以下内容，但在常量上下文中不行：</p>
<ul>
<li>使用泛型类型和生命周期参数。
<ul>
<li>常量上下文允许有限使用 <a href="items/generics.html#const-generics">常量泛型参数</a> 。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="应用程序二进制接口-abi"><a class="header" href="#应用程序二进制接口-abi">应用程序二进制接口 (ABI)</a></h1>
<p>本节记录了影响创建的编译结果的 ABI 的功能。</p>
<p>有关指定导出函数的 ABI 的信息，请参见 <em><a href="items/functions.html#extern-function-qualifier">extern functions</a></em> 。 有关指定链接外部库的 ABI 的信息，请参见 <em><a href="items/external-blocks.html">external blocks</a></em> 。</p>
<h2 id="used属性"><a class="header" href="#used属性"><code>used</code>属性</a></h2>
<p><em><code>used</code> 属性</em> 仅适用于 <a href="items/static-items.html"><code>static</code> 条目</a> 。此 <a href="attributes.html">属性</a> 强制编译器将变量保留在输出对象文件 (.o .rlib 等，不包括最终二进制文件) 中，即使该变量没有被 crate 中的任何其他条目使用或引用。但是，链接器仍然可以删除这样的条目。</p>
<p>下面是一个示例，展示了编译器在什么条件下保留一个 <code>static</code> 条目在输出对象文件中。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// foo.rs

// 因为 `#[used]` 而保留:
#[used]
static FOO: u32 = 0;

// 因为未使用而可移除：
#[allow(dead_code)]
static BAR: u32 = 0;

// 因为可以被公开访问而保留：
pub static BAZ: u32 = 0;

// 因为被公开可访问的函数所引用而保留：
static QUUX: u32 = 0;

pub fn quux() -&gt; &amp;'static u32 {
    &amp;QUUX
}

// 因为被私有未使用的函数所引用而可移除：
static CORGE: u32 = 0;

#[allow(dead_code)]
fn corge() -&gt; &amp;'static u32 {
    &amp;CORGE
}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-console">$ rustc -O --emit=obj --crate-type=rlib foo.rs

$ nm -C foo.o
0000000000000000 R foo::BAZ
0000000000000000 r foo::FOO
0000000000000000 R foo::QUUX
0000000000000000 T foo::quux
</code></pre>
<h2 id="no_mangle-属性"><a class="header" href="#no_mangle-属性"><code>no_mangle</code> 属性</a></h2>
<p><em><code>no_mangle</code> 属性</em> 可以用于任何 <a href="items.html">条目</a> ，以禁用标准符号名混淆。该条目的符号将是该条目名称的标识符。</p>
<p>此外，该条目将从生成的库或对象文件中公开导出，类似于 <a href="abi.html#the-used-attribute"><code>used</code> 属性</a> 。</p>
<h2 id="link_section-属性"><a class="header" href="#link_section-属性"><code>link_section</code> 属性</a></h2>
<p><em><code>link_section</code> 属性</em> 指定将 <a href="items/functions.html">函数</a> 或 <a href="items/static-items.html">静态</a> 内容放置到的对象文件部分。它使用 <a href="attributes.html#meta-item-attribute-syntax"><em>元名称值字符串</em></a> 语法来指定部分名称。</p>
<!-- no_run: don't link. The format of the section name is platform-specific. -->
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
#[link_section = &quot;.example_section&quot;]
pub static VAR1: u32 = 1;
<span class="boring">}</span></code></pre></pre>
<h2 id="export_name-属性"><a class="header" href="#export_name-属性"><code>export_name</code> 属性</a></h2>
<p><em><code>export_name</code> 属性</em> 指定将在 <a href="items/functions.html">函数</a> 或 <a href="items/static-items.html">静态变量</a> 上导出的符号名称。它使用 <a href="attributes.html#meta-item-attribute-syntax"><em>元名称值字符串</em></a> 语法来指定符号名称。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export_name = &quot;exported_symbol_name&quot;]
pub fn name_in_rust() { }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-运行时"><a class="header" href="#rust-运行时">Rust 运行时</a></h1>
<p>本节记录了定义 Rust 运行时某些方面的功能。</p>
<h2 id="panic_handler-属性"><a class="header" href="#panic_handler-属性"><code>panic_handler</code> 属性</a></h2>
<p><em><code>panic_handler</code> 属性</em> 只能应用于具有签名 <code>fn(&amp;PanicInfo) -&gt; !</code> 的函数。使用此 <a href="attributes.html">属性</a> 标记的函数定义了 panic 的行为。
<a href="../core/panic/struct.PanicInfo.html"><code>PanicInfo</code></a> 结构包含有关 panic 位置的信息。在二进制、 dylib 或 cdylib crate 的依赖图中，必须有一个单独的 <code>panic_handler</code> 函数。</p>
<p>下面是一个 <code>panic_handler</code> 函数，它记录 panic 消息，然后停止线程。</p>
<!-- ignore: test infrastructure can't handle no_std -->
<pre><code class="language-rust ignore">#![no_std]

use core::fmt::{self, Write};
use core::panic::PanicInfo;

struct Sink {
    // ..
<span class="boring">   _0: (),
</span>}
<span class="boring">
</span><span class="boring">impl Sink {
</span><span class="boring">    fn new() -&gt; Sink { Sink { _0: () }}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Write for Sink {
</span><span class="boring">    fn write_str(&amp;mut self, _: &amp;str) -&gt; fmt::Result { Ok(()) }
</span><span class="boring">}
</span>
#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    let mut sink = Sink::new();

    // logs &quot;panicked at '$reason', src/main.rs:27:4&quot; to some `sink`
    let _ = writeln!(sink, &quot;{}&quot;, info);

    loop {}
}</code></pre>
<h3 id="标准行为"><a class="header" href="#标准行为">标准行为</a></h3>
<p>标准库提供了一个默认情况下会展开堆栈的 <code>panic_handler</code> 实现，但可以 <a href="../book/ch09-01-unrecoverable-errors-with-panic.html">更改为终止进程</a>。可以使用 <a href="../std/panic/fn.set_hook.html">set_hook</a> 函数在运行时修改标准库的 panic 行为。</p>
<h2 id="global_allocator-属性"><a class="header" href="#global_allocator-属性"><code>global_allocator</code> 属性</a></h2>
<p><em><code>global_allocator</code> 属性</em> 用于设置实现 <a href="../alloc/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a> trait 的 <a href="items/static-items.html">静态条目</a> 的全局分配器。</p>
<h2 id="windows_subsystem-属性"><a class="header" href="#windows_subsystem-属性"><code>windows_subsystem</code> 属性</a></h2>
<p><em><code>windows_subsystem</code> 属性</em> 可以在 Windows 目标上的链接时应用于 crate 级别，以设置 <a href="https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx">subsystem</a>。
它使用 <a href="attributes.html#meta-item-attribute-syntax"><em>元名称值字符串</em></a> 语法来指定子系统，值为 <code>console</code> 或 <code>windows</code>。在非 Windows 目标上，此属性将被忽略，对于非 <code>bin</code> <a href="linkage.html">crate types</a> 也是如此。</p>
<p>&quot;console&quot; 子系统是默认值。如果从现有控制台运行控制台进程，则它将附加到该控制台，否则将创建一个新的控制台窗口。</p>
<p>&quot;windows&quot; 子系统通常用于不希望在启动时显示控制台窗口的 GUI 应用程序。它将在任何现有控制台之外运行。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>#![windows_subsystem = &quot;windows&quot;]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendices"><a class="header" href="#appendices">Appendices</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录-宏的follow-set歧义性形式化规范"><a class="header" href="#附录-宏的follow-set歧义性形式化规范">附录: 宏的Follow-Set歧义性形式化规范</a></h1>
<p>该规范是为了帮助理解 Rust 宏展开期间的 Follow-Set 歧义性而设计的。 Follow-Set 是指给定上下文环境下宏可能展开的所有可能性集合。在某些情况下，这些集合可能会有歧义，这会导致宏展开出现问题。</p>
<p>本页面记录了 <a href="macros-by-example.html">示例宏</a> 的正式规范，其中包括以下规则。
这些规则最初在 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md">RFC 550</a> 中进行了规定，本文大部分内容均来自该规范，并在随后的 RFC 中进行了扩展。</p>
<h2 id="定义和约定"><a class="header" href="#定义和约定">定义和约定</a></h2>
<ul>
<li><code>macro</code>: 在源代码中作为 <code>foo!(...)</code> 可调用的任何内容。</li>
<li><code>MBE</code>: 由 <code>macro_rules</code> 定义的实例宏。</li>
<li><code>matcher</code>: <code>macro_rules</code> 调用中规则的左侧或其子部分。</li>
<li><code>macro parser</code>: Rust 解析器中将使用从所有匹配器派生的语法分析输入的代码部分。</li>
<li><code>fragment</code>: 给定匹配器将接受 (或 &quot;匹配&quot; 的) Rust 语法类别。</li>
<li><code>repetition</code>: 遵循规律重复模式的片段。</li>
<li><code>NT</code>: 非终端，可以出现在匹配器中的各种 &quot;元变量&quot; 或重复匹配器，在 MBE 语法中使用前缀 $ 字符指定。</li>
<li><code>simple NT</code>: 一种 &quot;元变量&quot; 非终端符 (下面会进一步讨论)。</li>
<li><code>complex NT</code>: 通过重复运算符 (<code>*</code> 、 <code>+</code> 、 <code>?</code> ) 指定的重复匹配非终端符。</li>
<li><code>token</code>: 匹配器的原子元素，即标识符、运算符、开/闭定界符、 <em>以及</em> 简单 NT 。</li>
<li><code>token tree</code>: 由标记 (叶子)、复杂 NT 和标记树的有限序列形成的树结构。</li>
<li><code>delimiter token</code>: 用于分隔一个片段的结尾和下一个片段的开头的标记。</li>
<li><code>separator token</code>: 复杂 NT 中的可选分隔符标记，用于分隔匹配重复中每对元素。</li>
<li><code>separated complex NT</code>: 具有自己的分隔符标记的复杂 NT 。</li>
<li><code>delimited sequence</code>: 带有适当的开/闭定界符的标记树序列。</li>
<li><code>empty fragment</code>: Rust 语言中分隔标记的无形语法类，即空格或 (在某些词法上下文中) 空标记序列。</li>
<li><code>fragment specifier</code>: 简单 NT 中指定 NT 接受的片段的标识符。</li>
<li><code>language</code>: 无上下文的语言。</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! i_am_an_mbe {
    (start $foo:expr $($i:ident),* end) =&gt; ($foo)
}
<span class="boring">}</span></code></pre></pre>
<p><code>(start $foo:expr $($i:ident),* end)</code> 是一个匹配器。
整个匹配器是一个带有开/闭定界符 <code>(</code> 和 <code>)</code> 的定界序列， <code>$foo</code> 和 <code>$i</code> 是具有 <code>expr</code> 和 <code>ident</code> 作为它们各自的片段规格的简单 NT 。</p>
<p><code>$(i:ident),*</code> 也是一个 NT ; 它是一个复杂 NT ，用于匹配逗号分隔的标识符的重复。
<code>,</code> 是复杂 NT 的分隔符标记；它出现在匹配片段的每一对元素 (如果有的话) 之间。</p>
<p><code>$(hi $e:expr ;)+</code> 是一个复杂的非终端符(NT)的例子，它匹配形式为 <code>hi &lt;expr&gt;; hi &lt;expr&gt;; ...</code> 的片段，其中至少包含一次 <code>hi &lt;expr&gt;;</code> 。请注意，这个复杂的非终端符并没有专用的分隔符令牌。</p>
<p>(注意， Rust 的解析器确保定界序列始终具有正确嵌套的标记树结构和正确匹配的开/闭定界符。)</p>
<p>我们通常使用变量 &quot;M&quot; 代表一个匹配器，变量 &quot;t&quot; 和 &quot;u&quot; 代表任意单个标记，变量 &quot;tt&quot; 和 &quot;uu&quot; 代表任意标记树。( &quot;tt&quot; 的使用可能存在潜在的歧义，因为它还作为片段规格的额外角色；但从上下文中可以清楚地知道意思。)</p>
<p>&quot;SEP&quot; 将遍历分隔符标记， &quot;OP&quot; 将遍历重复运算符 <code>*</code> 、 <code>+</code> 和 <code>?</code> ， &quot;OPEN&quot;/&quot;CLOSE&quot; 将遍历匹配定界序列的标记对 (例如 <code>[</code> 和 <code>]</code> )。</p>
<p>希腊字母 &quot;α&quot; &quot;β&quot; &quot;γ&quot; &quot;δ&quot; 表示可能为空的标记树序列。
(然而，希腊字母 &quot;ε&quot; (epsilon) 在表述中具有特殊作用，不代表标记树序列。)</p>
<ul>
<li>这种希腊字母约定通常只在序列的存在是技术细节时使用；特别地，当我们希望 <em>强调</em> 我们正在操作标记树序列时，我们将使用符号 &quot;tt ...&quot; 表示序列，而不是希腊字母。</li>
</ul>
<p>请注意，匹配器仅仅是一个标记树。如上所述，&quot;简单 NT&quot; 是一个元变量 NT；因此它是一个非重复项。例如， <code>$foo:ty</code> 是一个简单的 NT ，但 <code>$($foo:ty)+</code> 是一个复杂的 NT。</p>
<p>还请注意，在这种形式化语境下，术语 &quot;token&quot; 通常包括简单的 NT。</p>
<p>最后，读者应该记住，根据这个形式化的定义，没有简单的 NT 匹配空片段，同样，没有 token 匹配 Rust 语法的空片段。(因此，唯一可以匹配空片段的 NT 是复杂的 NT。) 这实际上并不正确，因为 <code>vis</code> 匹配器可以匹配空片段。因此，为了形式化的目的，我们将把 <code>$v:vis</code> 实际上视为 <code>$($v:vis)?</code> ，并要求匹配器匹配一个空片段。</p>
<h3 id="匹配器的不变性"><a class="header" href="#匹配器的不变性">匹配器的不变性</a></h3>
<p>要有效，匹配器必须符合以下三个不变量。FIRST 和 FOLLOW 的定义将在后面描述。</p>
<ol>
<li>对于匹配器 <code>M</code> 中的任意两个连续的标记树序列 (即 <code>M = ... tt uu ...</code>，其中 <code>uu ...</code> 非空) ，我们必须有 FOLLOW(<code>... tt</code>) ∪ {ε} ⊇ FIRST(<code>uu ...</code>)。</li>
<li>对于匹配器中的任何分隔的复杂 NT，<code>M = ... $(tt ...) SEP OP ...</code>，我们必须有 <code>SEP</code> ∈ FOLLOW(<code>tt ...</code>)。</li>
<li>对于匹配器中的未分隔的复杂 NT，<code>M = ... $(tt ...) OP ...</code>，如果 OP = <code>*</code> 或 <code>+</code>，则我们必须有 FOLLOW(<code>tt ...</code>) ⊇ FIRST(<code>tt ...</code>)。</li>
</ol>
<p>第一个不变量表示，无论匹配器后面有什么实际标记 (如果有的话) ，它都必须在预定的 FOLLOW 集中的某个位置。这确保了一个合法的宏定义将继续分配相同的决定，即 <code>... tt</code> 结束并且 <code>uu ...</code> 开始的位置，即使语言中添加了新的语法形式。</p>
<p>第二个不变量表示，分隔的复杂 NT 必须使用作为 NT 内部内容预定 FOLLOW 集的分隔符标记。这确保了一个合法的宏定义将继续将输入片段解析为相同的 <code>tt ...</code> 的定界序列，即使语言中添加了新的语法形式。</p>
<p>第三个不变量表示，当我们有一个复杂的 NT 可以匹配两个或多个连续的相同元素而不需要分隔符时，根据第一个不变量，这些元素必须可以被放在一起。该不变量还要求它们必须是非空的，这消除了可能的歧义。</p>
<p><strong>注意: 由于历史遗漏和对该行为的重要依赖，目前未执行第三个不变量。目前尚未决定如何继续处理此问题。不遵守此行为的宏在 Rust 的未来版本中可能会变得无效。请参见 <a href="https://github.com/rust-lang/rust/issues/56575">问题跟踪</a>。</strong></p>
<h3 id="first-和-follow非正式描述"><a class="header" href="#first-和-follow非正式描述">FIRST 和 FOLLOW，非正式描述</a></h3>
<p>一个给定的匹配器 M 映射到三个集合: FIRST(M)、LAST(M) 和 FOLLOW(M)。</p>
<p>这三个集合都由标记组成。 FIRST(M) 和 LAST(M) 还可能包含一个特殊的非标记元素 ε (&quot;epsilon&quot;) ，它表示 M 可以匹配空片段。(但 FOLLOW(M) 总是由一组标记组成。)</p>
<p>非正式地说：</p>
<ul>
<li>
<p>FIRST(M)：在将片段与 M 匹配时，收集可能首先使用的标记。</p>
</li>
<li>
<p>LAST(M)：在将片段与 M 匹配时，收集可能最后使用的标记。</p>
</li>
<li>
<p>FOLLOW(M)：在 M 匹配某个片段之后立即允许其后面紧跟的标记集合。</p>
<p>换句话说：当且仅当存在 (可能为空的) 标记序列 α β γ δ 时，t ∈ FOLLOW(M)，其中：</p>
</li>
<li>
<p>M 匹配 β，</p>
</li>
<li>
<p>t 匹配 γ ，以及</p>
</li>
<li>
<p>连接 α β γ δ 是一个可解析的 Rust 程序。 </p>
</li>
</ul>
<p>我们使用简写 ANYTOKEN 来表示所有标记 (包括简单的 NT )。例如，如果在匹配器 M 之后任何标记都是合法的，则 FOLLOW(M) = ANYTOKEN 。</p>
<p>(为了回顾对上述非正式描述的理解，读者此时可能希望跳转到 <a href="macro-ambiguity.html#examples-of-first-and-last">FIRST/LAST的示例</a> ，然后再阅读它们的正式定义。) </p>
<h3 id="first-last"><a class="header" href="#first-last">FIRST, LAST</a></h3>
<p>以下是 FIRST 和 LAST 的正式归纳定义。</p>
<p>&quot;A ∪ B&quot; 表示并集， &quot;A ∩ B&quot; 表示交集， &quot;A \ B&quot; 表示差集 (即 A 中所有在 B 中不存在的元素)。</p>
<h4 id="first"><a class="header" href="#first">FIRST</a></h4>
<p>对于序列 M 及其第一个标记树的结构 (如果有) ，对 FIRST(M) 进行情况分析定义：</p>
<ul>
<li>
<p>如果 M 是空序列，则 FIRST(M) = { ε }，</p>
</li>
<li>
<p>如果 M 以一个标记 t 开头，则 FIRST(M) = { t } ，</p>
<p>(注意：这涵盖了 M 以定界的标记树序列开头的情况， <code>M = OPEN tt ... CLOSE ...</code> ，在这种情况下，<code>t = OPEN</code>，因此 FIRST(M) = { <code>OPEN</code> }。)</p>
<p>(注意：这主要依赖于一个属性，即没有简单的 NT 可以匹配空片段。)</p>
</li>
<li>
<p>否则， M 是以复杂的 NT 开头的标记树序列： <code>M = $( tt ... ) OP α</code> 或 <code>M = $( tt ... ) SEP OP α</code> ， (其中 <code>α</code> 是匹配器的其余部分的 (可能为空的) 标记树序列)。</p>
<ul>
<li>如果 SEP 存在且 ε ∈ FIRST(<code>tt ...</code>) ，则让 SEP_SET(M) = { SEP }; 否则，SEP_SET(M) = {}。</li>
</ul>
</li>
<li>
<p>如果 OP = <code>*</code> 或 <code>?</code> ，则让 ALPHA_SET(M) = FIRST(<code>α</code>) ，如果 OP = <code>+</code>，则 ALPHA_SET(M) = {}。</p>
</li>
<li>
<p>FIRST(M) = (FIRST(<code>tt ...</code>) \ {ε}) ∪ SEP_SET(M) ∪ ALPHA_SET(M) 。</p>
</li>
</ul>
<p>复杂非终端符的定义需要一些解释。 SEP_SET (M) 定义了分隔符可能是 M 的有效首个符号的可能性，当定义了分隔符并且重复片段可能为空时会发生这种情况。 ALPHA_SET (M) 定义了复杂非终端符可以为空的可能性，这意味着 M 的有效首个符号是以下 token-tree 序列 <code>α</code> 中的符号。当使用 <code>*</code> 或 <code>?</code> 时会发生这种情况，此时可能没有重复。理论上，如果使用 <code>+</code> 并带有潜在为空的重复片段，则也可能发生这种情况，但这被第三个不变量禁止。</p>
<p>从这里开始，显然 FIRST(M) 可以包括来自 SEP_SET(M) 或 ALPHA_SET(M) 的任何令牌，如果复合 NT 匹配非空，则任何以 FIRST(<code>tt ...</code>) 开头的令牌也可以使用。考虑的最后一个部分是 ε 。 SEP_SET(M) 和 FIRST(<code>tt ...</code>) \ {ε}不能包含 ε，但 ALPHA_SET(M) 可能会包含。
因此，这个定义允许 M 接受 ε ，当且仅当 ε∈ALPHA_SET(M) 。这是正确的，因为对于 M 在复合 NT 情况下接受 ε ，复合 NT 和 α 都必须接受它。
如果 OP = <code>+</code> ，意味着复合 NT 不能为空，根据定义， ε∉ALPHA_SET(M) 。
否则，复合 NT 可以接受零次重复，然后 ALPHA_SET(M)=FOLLOW(<code>α</code>) 。因此，这个定义在 ε 方面是正确的。 </p>
<h4 id="last"><a class="header" href="#last">LAST</a></h4>
<p>LAST(M) 是根据 M 本身 (一个令牌树序列) 的情况分析定义的。</p>
<ul>
<li>
<p>如果 M 是空序列，则 LAST(M) = { ε } 。</p>
</li>
<li>
<p>如果 M 是单个令牌 t ，则 LAST(M) = { t } 。</p>
</li>
<li>
<p>如果 M 是单一的复合 NT ，重复出现零次或多次，如 <code>M = $( tt ... ) *</code> 或 <code>M = $( tt ... ) SEP *</code>，则 LAST(M)={LAST('tt ...')}。</p>
<ul>
<li>如果存在 SEP ，则令 sep_set = { SEP } ；否则，令 sep_set = {} 。</li>
<li>如果 ε ∈ LAST(<code>tt ...</code>) ，则 LAST(M) = LAST(<code>tt ...</code>) ∪ sep_set 。</li>
<li>否则，序列'tt ...'必须是非空的；LAST(M) = LAST(<code>tt ...</code>) ∪ {ε} 。</li>
</ul>
</li>
<li>
<p>如果 M 是重复出现一次或多次的单一复合 NT ，如 <code>M = $( tt ... ) +</code> 或 <code>M = $( tt ... ) SEP +</code> ，</p>
<ul>
<li>如果存在 SEP ，则令 sep_set = { SEP } ；否则，令s ep_set = {} 。</li>
<li>如果 ε ∈ LAST(<code>tt ...</code>) ，则 LAST(M) = LAST(<code>tt ...</code>) ∪ sep_set 。</li>
<li>否则，序列 <code>tt ...</code> 必须是非空的；LAST(M) = LAST('tt ...')。</li>
</ul>
</li>
<li>
<p>如果 M 是重复出现零次或一次的单一复合 NT ，如 <code>M = $( tt ...) ?</code>，则 LAST(M) = LAST(<code>tt ...</code>) ∪ {ε} 。</p>
</li>
<li>
<p>如果 M 是一个定界的标记树序列 <code>OPEN tt ... CLOSE</code> ，则 LAST(M) = { <code>CLOSE</code> }。</p>
</li>
<li>
<p>如果 M 是一个非空的令牌树的序列 <code>tt uu ...</code> ，</p>
<ul>
<li>
<p>如果 ε ∈ LAST(<code>uu ...</code>) ，那么 LAST(M) = LAST(<code>tt</code>) ∪ (LAST(<code>uu ...</code>) \ { ε }) .</p>
</li>
<li>
<p>否则，序列 <code>uu ...</code> 必须是非空的；那么 LAST(M) = LAST(<code>uu ...</code>) 。</p>
</li>
</ul>
</li>
</ul>
<h3 id="first和last的例子"><a class="header" href="#first和last的例子">FIRST和LAST的例子</a></h3>
<p>以下是一些 FIRST 和 LAST 的例子。
(特别注意，基于输入的不同部分之间的交互，特殊元素 ε 是如何被引入和消除的。)</p>
<p>我们的第一个例子以树形结构呈现，以详细阐述匹配器的分析是如何组合的。 (一些简单的子树已省略。)</p>
<pre><code class="language-text">INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g
            ~~~~~~~~   ~~~~~~~                ~
                |         |                   |
FIRST:   { $d:ident }  { $e:expr }          { h }


INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+
            ~~~~~~~~~~~~~~~~~~             ~~~~~~~           ~~~
                        |                      |               |
FIRST:          { $d:ident }               { h, ε }         { f }

INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~    ~~~~~~~~~   ~
                        |                       |              |       |
FIRST:        { $d:ident, ε }            {  h, ε, ;  }      { f }   { g }


INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                        |
FIRST:                       { $d:ident, h, ;,  f }
</code></pre>
<p>因此:</p>
<ul>
<li>FIRST(<code>$($d:ident $e:expr );* $( $(h)* );* $( f ;)+ g</code>) = { <code>$d:ident</code>, <code>h</code>, <code>;</code>, <code>f</code> }</li>
</ul>
<p>值得注意:</p>
<ul>
<li>FIRST(<code>$($d:ident $e:expr );* $( $(h)* );* $($( f ;)+ g)*</code>) = { <code>$d:ident</code>, <code>h</code>, <code>;</code>, <code>f</code>, ε }</li>
</ul>
<p>以下是类似的例子，但现在是关于 LAST 的。</p>
<ul>
<li>LAST(<code>$d:ident $e:expr</code>) = { <code>$e:expr</code> }</li>
<li>LAST(<code>$( $d:ident $e:expr );*</code>) = { <code>$e:expr</code>, ε }</li>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)*</code>) = { <code>$e:expr</code>, ε, <code>h</code> }</li>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)* $( f ;)+</code>) = { <code>;</code> }</li>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)* $( f ;)+ g</code>) = { <code>g</code> }</li>
</ul>
<h3 id="followm"><a class="header" href="#followm">FOLLOW(M)</a></h3>
<p>最后， FOLLOW(M) 的定义如下构建。 pat ， expr 等表示具有给定片段说明符的简单非终端符。</p>
<ul>
<li>
<p>FOLLOW(pat) = {<code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code>, <code>in</code>}`.</p>
</li>
<li>
<p>FOLLOW(expr) = FOLLOW(stmt) =  {<code>=&gt;</code>, <code>,</code>, <code>;</code>}`.</p>
</li>
<li>
<p>FOLLOW(ty) = FOLLOW(path) = {<code>{</code>, <code>[</code>, <code>,</code>, <code>=&gt;</code>, <code>:</code>, <code>=</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>;</code>,<code>|</code>, <code>as</code>, <code>where</code>, 块非终端符}。</p>
</li>
<li>
<p>FOLLOW(vis) = { <code>,</code> l 除非是非原始的 <code>priv</code> ，任何关键字或标识符; 可以开始类型的任何令牌; ident ， ty 和 path 非终端符}。</p>
</li>
<li>
<p>对于任何其他简单的 token ，包括 block 、 ident 、 tt 、 item 、 lifetime 、 literal 和 meta 的简单非终端符以及所有终端符， FOLLOW(t) = ANYTOKEN 。</p>
</li>
<li>
<p>对于任何其他 M ， FOLLOW(M) 的定义是对 (LAST(M){ε}) 的所有 t 的 FOLLOW(t) 的交集，其中 t 在终端符中范围。</p>
</li>
</ul>
<p>可以开始类型的令牌是，截至本写作时，为 {<code>(</code>、<code>[</code>、<code>!</code>、<code>*</code>、<code>&amp;</code>、<code>&amp;&amp;</code>、<code>?</code>、lifetime、<code>&gt;</code>、<code>&gt;&gt;</code>、<code>::</code>、任何非关键字标识符、<code>super</code>、<code>self</code>、<code>Self</code>、<code>extern</code>、<code>crate</code>、<code>$crate</code>、<code>_</code>、<code>for</code>、<code>impl</code>、<code>fn</code>、<code>unsafe</code>、<code>typeof</code>、<code>dyn</code>}，尽管此列表可能不完整，因为人们不会总是记得在添加新令牌时更新附录。</p>
<p>复杂 M 的 FOLLOW 的例子:</p>
<ul>
<li>FOLLOW(<code>$( $d:ident $e:expr )*</code>) = FOLLOW(<code>$e:expr</code>)</li>
<li>FOLLOW(<code>$( $d:ident $e:expr )* $(;)*</code>) = FOLLOW(<code>$e:expr</code>) ∩ ANYTOKEN = FOLLOW(<code>$e:expr</code>)</li>
<li>FOLLOW(<code>$( $d:ident $e:expr )* $(;)* $( f |)+</code>) = ANYTOKEN</li>
</ul>
<h3 id="有效和无效匹配器的示例"><a class="header" href="#有效和无效匹配器的示例">有效和无效匹配器的示例</a></h3>
<p>有了上述规范，我们可以提出为什么特定匹配器合法而其他匹配器不合法的论据。</p>
<ul>
<li>
<p><code>($ty:ty &lt; foo ,)</code> : 不合法, 因为 FIRST(<code>&lt; foo ,</code>) = { <code>&lt;</code> } ⊈ FOLLOW(<code>ty</code>)</p>
</li>
<li>
<p><code>($ty:ty , foo &lt;)</code> : 合法, 因为 FIRST(<code>, foo &lt;</code>) = { <code>,</code> }  is ⊆ FOLLOW(<code>ty</code>).</p>
</li>
<li>
<p><code>($pa:pat $pb:pat $ty:ty ,)</code> : 不合法, 因为 FIRST(<code>$pb:pat $ty:ty ,</code>) = { <code>$pb:pat</code> } ⊈ FOLLOW(<code>pat</code>), 而且 FIRST(<code>$ty:ty ,</code>) = { <code>$ty:ty</code> } ⊈ FOLLOW(<code>pat</code>).</p>
</li>
<li>
<p><code>( $($a:tt $b:tt)* ; )</code> : 合法, 因为 FIRST(<code>$b:tt</code>) = { <code>$b:tt</code> } is ⊆ FOLLOW(<code>tt</code>) = ANYTOKEN, as is FIRST(<code>;</code>) = { <code>;</code> }.</p>
</li>
<li>
<p><code>( $($t:tt),* , $(t:tt),* )</code> : 合法,  (尽管任何尝试实际使用此宏都将在扩展期间发出本地歧义错误的信号。).</p>
</li>
<li>
<p><code>($ty:ty $(; not sep)* -)</code> : 不合法，因为 FIRST(<code>$(; not sep)* -</code>) = { <code>;</code>, <code>-</code> } 不在 FOLLOW(<code>ty</code>) 中。</p>
</li>
<li>
<p><code>($($ty:ty)-+)</code>：不合法，因为分隔符 <code>-</code> 不在 FOLLOW(<code>ty</code>) 中。</p>
</li>
<li>
<p><code>($($e:expr)*)</code>：不合法，因为表达式 NT 不在 FOLLOW(expr NT) 中。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="影响"><a class="header" href="#影响">影响</a></h1>
<p>Rust 并不是一个特别原创的语言，其设计元素来自于广泛的来源。下面列出了一些这样的来源 (包括已经被删除的元素) ：</p>
<ul>
<li>SML，OCaml: 代数数据类型、模式匹配、类型推断、分号语句分隔符</li>
<li>C++: 引用、RAII、智能指针、移动语义、单态化、内存模型</li>
<li>ML Kit，Cyclone: 基于区域的内存管理</li>
<li>Haskell (GHC) : 类型类、类型族</li>
<li>Newsqueak，Alef，Limbo: 通道，并发</li>
<li>Erlang: 消息传递、线程故障、<strike>链接线程故障</strike>、<strike>轻量级并发</strike></li>
<li>Swift: 可选绑定</li>
<li>Scheme: 卫生宏</li>
<li>C#: 属性</li>
<li>Ruby: 闭包语法、<strike>块语法</strike></li>
<li>NIL，Hermes: <strike>类型状态</strike></li>
<li><a href="http://www.unicode.org/reports/tr31/">Unicode 附录 #31</a>: 标识符和模式语法</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="术语表"><a class="header" href="#术语表">术语表</a></h1>
<h3 id="抽象语法树"><a class="header" href="#抽象语法树">抽象语法树</a></h3>
<p>&quot;抽象语法树&quot; (AST) 是编译器在编译程序时的中间表示程序结构的一种方式。</p>
<h3 id="对齐"><a class="header" href="#对齐">对齐</a></h3>
<p>值的对齐方式指定了值的首选地址。始终是 2 的幂次方。值的引用必须对齐。
<a href="type-layout.html#size-and-alignment">更多</a>。</p>
<h3 id="函数的元数"><a class="header" href="#函数的元数">函数的元数</a></h3>
<p>元数是指函数或操作符接受的参数数量。例如， <code>f(2, 3)</code> 和 <code>g(4, 6)</code> 的元数为 2 ，而 <code>h(8, 2, 6)</code> 的元数为 3 。<code>!</code> 操作符的元数为 1 。 </p>
<h3 id="数组"><a class="header" href="#数组">数组</a></h3>
<p>数组有时也称为固定大小数组或内联数组，是一个值，描述了一个由元素组成的集合，每个元素都可以由程序在运行时计算的索引所选择。它占用了一段连续的内存区域。</p>
<h3 id="关联条目-1"><a class="header" href="#关联条目-1">关联条目</a></h3>
<p>关联条目是与另一个条目相关联的条目。关联条目在 <a href="items/implementations.html">实现</a> 中定义并在 <a href="items/traits.html">traits</a> 中声明。
只有函数、常量和类型别名可以是关联的。与 <a href="glossary.html#free-item">自由条目</a> 相对。</p>
<h3 id="泛型实现-1"><a class="header" href="#泛型实现-1">泛型实现</a></h3>
<p>任何一个类型出现 <a href="glossary.html#uncovered-type">uncovered</a> 的实现都是泛型实现。
<code>impl&lt;T&gt; Foo for T</code> ， <code>impl&lt;T&gt; Bar&lt;T&gt; for T</code> ， <code>impl&lt;T&gt; Bar&lt;Vec&lt;T&gt;&gt; for T</code> 和 <code>impl&lt;T&gt; Bar&lt;T&gt; for Vec&lt;T&gt;</code> 都被视为泛型实现。
但是， <code>impl&lt;T&gt; Bar&lt;Vec&lt;T&gt;&gt; for Vec&lt;T&gt;</code> 不是泛型实现，因为此 <code>impl</code> 中出现的所有 <code>T</code> 的实例都被 <code>Vec</code> 覆盖了。</p>
<h3 id="约束"><a class="header" href="#约束">约束</a></h3>
<p>约束是对类型或特征的限制。例如，如果在函数的参数上放置了约束，则传递给该函数的类型必须遵守该约束。</p>
<h3 id="组合子"><a class="header" href="#组合子">组合子</a></h3>
<p>组合子是只应用函数和先前定义的组合子以从其参数提供结果的高阶函数。它们可用于以模块化的方式管理控制流。</p>
<h3 id="crate-2"><a class="header" href="#crate-2">Crate</a></h3>
<p>Crate (箱体) 是编译和链接的基本单位。它有不同的类型，例如库或可执行文件。 Crate 可以链接和引用其他库 Crate ，称为外部 Crate 。 Crate 具有一个自包含的模块树，从一个未命名的根模块开始，称为 Crate 根。通过在 Crate 根中将条目标记为公共的，包括公共模块的路径，可以使这些条目对其他 Crate 可见。请参考 <a href="crates-and-source-files.html">Rust文档</a> 以了解更多信息。</p>
<h3 id="调度"><a class="header" href="#调度">调度</a></h3>
<p>调度是在涉及多态性时确定实际运行的特定代码版本的机制。静态调度和动态调度是两种主要的调度形式。虽然 Rust 更偏爱静态调度，但它也通过称为 &quot;特征对象&quot; 的机制支持动态调度。</p>
<h3 id="动态大小类型-1"><a class="header" href="#动态大小类型-1">动态大小类型</a></h3>
<p>动态大小类型 (DST) 是一种没有静态已知大小或对齐方式的类型。</p>
<h3 id="实体"><a class="header" href="#实体">实体</a></h3>
<p><a href="names.html"><em>实体</em></a> 是一种语言结构，在源程序中可以通过某种方式进行引用，通常是通过 <a href="paths.html">路径</a> 。实体包括 <a href="types.html">类型</a> 、<a href="items.html">条目</a> 、<a href="items/generics.html">泛型参数</a> 、 <a href="patterns.html">变量绑定</a> 、 <a href="tokens.html#lifetimes-and-loop-labels">循环标签</a> 、 <a href="tokens.html#lifetimes-and-loop-labels">生命周期</a> 、 <a href="expressions/field-expr.html">字段</a>、 <a href="attributes.html">属性</a> 和 <a href="attributes/diagnostics.html#lint-check-attributes">lints</a> 。</p>
<h3 id="表达式-1"><a class="header" href="#表达式-1">表达式</a></h3>
<p>表达式是值、常量、变量、运算符和函数的组合，可以求值为单个值，带有或不带有副作用。</p>
<p>例如，<code>2 + (3 * 4)</code> 是一个返回值为 14 的表达式。</p>
<h3 id="自由条目"><a class="header" href="#自由条目">自由条目</a></h3>
<p>不属于 <a href="items/implementations.html">实现</a> 的 <a href="items.html">条目</a> ，例如 <em>自由函数</em> 或 <em>自由常量</em> 。与 <a href="glossary.html#associated-item">关联条目</a> 相对。</p>
<h3 id="基本-trait"><a class="header" href="#基本-trait">基本 trait</a></h3>
<p>基本 trait 是指为现有类型添加一个 impl 会导致代码不兼容的 trait 。 <code>Fn</code> trait 和 <code>Sized</code> trait 是基本 trait 。</p>
<h3 id="基本类型构造器"><a class="header" href="#基本类型构造器">基本类型构造器</a></h3>
<p>基本类型构造器是指实现 <a href="glossary.html#blanket-implementation">泛型实现</a> 会破坏其结构的类型。 <code>&amp;</code> 、 <code>&amp;mut</code> 、 <code>Box</code> 和 <code>Pin</code> 是基本类型构造器。</p>
<p>任何时候，只要类型 <code>T</code> 被视为 <a href="glossary.html#local-type">局部类型</a>， <code>&amp;T</code> 、 <code>&amp;mut T</code> 、 <code>Box&lt;T&gt;</code> 和 <code>Pin&lt;T&gt;</code> 也会被视为局部类型。基本类型构造器不能<a href="glossary.html#uncovered-type">覆盖</a>其他类型。每当使用术语 &quot;覆盖类型&quot; 时， <code>&amp;T</code> 、 <code>&amp;mut T</code> 、 <code>Box&lt;T&gt;</code> 和 <code>Pin&lt;T&gt;</code> 中的 <code>T</code> 不被视为覆盖的类型。</p>
<h3 id="有实例"><a class="header" href="#有实例">有实例</a></h3>
<p>如果一个类型具有构造函数并且因此可以被实例化，则称其为 &quot;有实例&quot; 。有实例的类型不是 &quot;空的&quot; ，因为它可以有值。与 <a href="glossary.html#uninhabited">无实例</a> 相对。</p>
<h3 id="内在实现"><a class="header" href="#内在实现">内在实现</a></h3>
<p>适用于命名类型而不是 trait-类型对的 <a href="items/implementations.html">实现</a> 。 <a href="items/implementations.html#inherent-implementations">更多</a> 。</p>
<h3 id="内在方法"><a class="header" href="#内在方法">内在方法</a></h3>
<p>在内在实现中定义的方法，而不是在 trait 实现中定义的方法。</p>
<h3 id="初始化"><a class="header" href="#初始化">初始化</a></h3>
<p>如果变量被赋值且未被移动，那么它就被初始化了。所有其他的内存位置都被认为是未初始化的。只有使用不安全 Rust 才能创建未初始化的内存位置。</p>
<h3 id="本地-trait"><a class="header" href="#本地-trait">本地 trait</a></h3>
<p>在当前 crate 中定义的 <code>trait</code> 。一个 trait 定义是否本地与应用的类型参数无关。例如对于 <code>trait Foo&lt;T, U&gt;</code> ，不管 <code>T</code> 和 <code>U</code> 被替换为哪些类型， <code>Foo</code> 都是本地的。</p>
<h3 id="局部类型"><a class="header" href="#局部类型">局部类型</a></h3>
<p>在当前 crate 中定义的 <code>struct</code> 、 <code>enum</code> 或 <code>union</code> 类型。应用的类型参数不会影响此定义。例如， <code>struct Foo</code> 被认为是局部类型，但 <code>Vec&lt;Foo&gt;</code> 不是。<code>LocalType&lt;ForeignType&gt;</code> 也是局部类型。类型别名不影响类型的局部性。</p>
<h3 id="模块-1"><a class="header" href="#模块-1">模块</a></h3>
<p>模块是容纳零个或多个 <a href="items.html">条目</a> 的容器。模块被组织成一棵树，从一个未命名的根模块开始，称为 crate root 或 root module。可以使用 <a href="paths.html">路径</a> 引用其他模块中的条目，这些引用可能受 <a href="visibility-and-privacy.html">可见性规则</a> 的限制。
<a href="items/modules.html">更多信息</a></p>
<h3 id="名称-1"><a class="header" href="#名称-1">名称</a></h3>
<p><a href="names.html"><em>名称</em></a> 是指引用一个 <a href="glossary.html#entity">实体</a> 的 <a href="identifiers.html">标识符</a> 、 <a href="tokens.html#lifetimes-and-loop-labels">生命周期或循环标签</a> 。当一个实体声明引入与该实体相关联的标识符或标签时，称之为 <em>名称绑定</em> 。可以使用 <a href="paths.html">路径</a> 、标识符和标签来引用实体。</p>
<h3 id="名称解析"><a class="header" href="#名称解析">名称解析</a></h3>
<p><a href="names/name-resolution.html"><em>名称解析</em></a> 是将 <a href="paths.html">路径</a> 、 <a href="identifiers.html">标识符</a> 和 <a href="tokens.html#lifetimes-and-loop-labels">标签</a> 与 <a href="glossary.html#entity">实体</a> 声明绑定的编译时过程。</p>
<h3 id="命名空间-1"><a class="header" href="#命名空间-1">命名空间</a></h3>
<p><em>命名空间</em> 是基于名称所引用的 <a href="glossary.html#entity">实体</a> 的种类而声明的名称的逻辑分组。
命名空间允许一个命名空间中的名称与另一个命名空间中相同的名称不发生冲突。</p>
<p>在命名空间内，名称按层级组织，每个层级都有自己的命名实体集合。</p>
<h3 id="名义类型"><a class="header" href="#名义类型">名义类型</a></h3>
<p>可直接通过路径引用的类型。具体而言，包括 <a href="items/enumerations.html">枚举</a> 、 <a href="items/structs.html">结构体</a> 、 <a href="items/unions.html">联合体</a> 和 <a href="types/trait-object.html">trait 对象</a> 。</p>
<h3 id="对象安全trait"><a class="header" href="#对象安全trait">对象安全trait</a></h3>
<p>可以用作 <a href="types/trait-object.html">trait objects</a> 的 <a href="items/traits.html">Traits</a> 。只有符合特定 <a href="items/traits.html#object-safety">规则</a> 的 Trait 才是对象安全。</p>
<h3 id="路径-1"><a class="header" href="#路径-1">路径</a></h3>
<p><a href="paths.html"><em>Path</em></a> 是一个由一个或多个路径段组成的序列，用于引用当前作用域或其他层级的 <a href="glossary.html#namespace">命名空间</a> 中的 <a href="glossary.html#entity">实体</a> 。</p>
<h3 id="预导入"><a class="header" href="#预导入">预导入</a></h3>
<p>预导入模块，或称为 Rust 预导入库，是一个小集合的项目，主要是 Trait ，被导入到每个 crate 的每个模块中。预导入库中的 Trait 是普遍适用的。</p>
<h3 id="作用域-2"><a class="header" href="#作用域-2">作用域</a></h3>
<p>作用域 <a href="names/scopes.html"><em>scope</em></a> 是源代码文本中的一个区域，在此区域内的命名实体 <a href="glossary.html#entity">entity</a> 可以使用其名称引用。</p>
<h3 id="被匹配对象"><a class="header" href="#被匹配对象">被匹配对象</a></h3>
<p>被匹配对象 [<em>Scrutinee</em>] 是在 <code>match</code> 表达式和类似的模式匹配结构中被匹配的表达式。例如，在 <code>match x { A =&gt; 1, B =&gt; 2 }</code> 中，表达式 <code>x</code> 是被匹配对象。</p>
<h3 id="size"><a class="header" href="#size">Size</a></h3>
<p>一个值的 [<em>Size</em>] 有两个定义:</p>
<p>第一个定义是该值所需的内存量。</p>
<p>第二个定义是具有该项类型的数组中，相邻元素之间的偏移量 (以字节为单位) 。</p>
<p>大小是对齐的倍数，包括零。大小可以根据编译器版本 (随着新的优化) 和目标平台而变化 (类似于<code>usize</code>因平台而异) 。</p>
<p>请参考 <a href="type-layout.html#size-and-alignment">Rust文档</a> 以了解更多信息。</p>
<h3 id="切片"><a class="header" href="#切片">切片</a></h3>
<p>切片 [<em>Slice</em>] 是对连续序列的动态大小视图，写作 <code>[T]</code> 。</p>
<p>它经常以其借用形式出现，可以是可变的或共享的。共享切片类型是 <code>&amp;[T]</code> ，而可变切片类型是 <code>&amp;mut [T]</code> ，其中 <code>T</code> 表示元素类型。</p>
<h3 id="语句-1"><a class="header" href="#语句-1">语句</a></h3>
<p>语句 [<em>Statement</em>] 语句是编程语言中最小的独立元素，它命令计算机执行一个操作。</p>
<h3 id="字符串字面值-1"><a class="header" href="#字符串字面值-1">字符串字面值</a></h3>
<p>字符串字面值 [<em>String literal</em>] 是直接存储在最终二进制文件中的字符串，因此将对 <code>'static</code> 持续时间有效。</p>
<p>它的类型是 <code>'static</code> 持续时间借用字符串切片， <code>&amp;'static str</code> 。</p>
<h3 id="字符串切片"><a class="header" href="#字符串切片">字符串切片</a></h3>
<p>字符串切片 [<em>String slice</em>] 是 Rust 中最原始的字符串类型，写作<code>str</code>。它经常以其借用形式出现，可以是可变的或共享的。共享字符串切片类型是<code>&amp;str</code>，而可变字符串切片类型是<code>&amp;mut str</code>。</p>
<p>字符串切片始终有效的UTF-8。</p>
<h3 id="trait"><a class="header" href="#trait">Trait</a></h3>
<p>[<em>Trait</em>]是一种语言条目，用于描述类型必须提供的功能。它允许类型对其行为做出某些承诺。</p>
<p>通用函数和通用结构可以使用特征来约束或限制它们接受的类型。</p>
<h3 id="turbofish"><a class="header" href="#turbofish">Turbofish</a></h3>
<p>在表达式中具有通用参数的路径必须在开括号前加上 <code>::</code> 。与通用角括号结合使用，看起来像鱼形符号 <code>::&lt;&gt;</code> 。因此，这种语法俗称为 turbofish 语法。</p>
<p>例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ok_num = Ok::&lt;_, ()&gt;(5);
let vec = [1, 2, 3].iter().map(|n| n * 2).collect::&lt;Vec&lt;_&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<p>这个 <code>::</code> 前缀是为了消除在逗号分隔列表中有多个类型参数的泛型路径的歧义。
请参见 <a href="https://github.com/rust-lang/rust/blob/1.58.0/src/test/ui/parser/bastion-of-the-turbofish.rs">turbofish test</a> ，其中有一个在没有前缀时产生歧义的例子。</p>
<h3 id="未涵盖的类型"><a class="header" href="#未涵盖的类型">未涵盖的类型</a></h3>
<p>一个未出现为另一个类型的参数的类型。例如， <code>T</code> 是未涵盖的类型，而 <code>Vec&lt;T&gt;</code> 中的 <code>T</code> 是涵盖的。这仅与类型参数有关。</p>
<h3 id="未定义行为"><a class="header" href="#未定义行为">未定义行为</a></h3>
<p>未指定的编译时或运行时行为。这可能导致但不限于：进程终止或破坏；不适当、不正确或意外的计算；或平台特定的结果。<a href="behavior-considered-undefined.html">更多信息</a>。</p>
<h3 id="无法驻留的"><a class="header" href="#无法驻留的">无法驻留的</a></h3>
<p>如果一个类型没有构造函数，因此永远无法被实例化，则该类型是无法驻留的。一个无法驻留的类型在某种意义上是 &quot;空的&quot; ，因为该类型没有值。无法居住类型的典型示例是 <a href="types/never.html">永不类型</a> <code>!</code> ，或者没有变体的枚举 <code>enum Never { }</code> 。与 <a href="glossary.html#inhabited">Inhabited</a> 相对。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
