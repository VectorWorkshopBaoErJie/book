<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>模式 - The Rust Reference</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">介绍</a></li><li class="chapter-item expanded "><a href="notation.html"><strong aria-hidden="true">1.</strong> 符号约定</a></li><li class="chapter-item expanded "><a href="lexical-structure.html"><strong aria-hidden="true">2.</strong> 词法结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="input-format.html"><strong aria-hidden="true">2.1.</strong> 输入格式</a></li><li class="chapter-item expanded "><a href="keywords.html"><strong aria-hidden="true">2.2.</strong> 关键字</a></li><li class="chapter-item expanded "><a href="identifiers.html"><strong aria-hidden="true">2.3.</strong> 标识符</a></li><li class="chapter-item expanded "><a href="comments.html"><strong aria-hidden="true">2.4.</strong> 注释</a></li><li class="chapter-item expanded "><a href="whitespace.html"><strong aria-hidden="true">2.5.</strong> 空白</a></li><li class="chapter-item expanded "><a href="tokens.html"><strong aria-hidden="true">2.6.</strong> 令牌</a></li></ol></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">3.</strong> 宏</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macros-by-example.html"><strong aria-hidden="true">3.1.</strong> 实例宏</a></li><li class="chapter-item expanded "><a href="procedural-macros.html"><strong aria-hidden="true">3.2.</strong> 过程宏</a></li></ol></li><li class="chapter-item expanded "><a href="crates-and-source-files.html"><strong aria-hidden="true">4.</strong> Crate和源文件</a></li><li class="chapter-item expanded "><a href="conditional-compilation.html"><strong aria-hidden="true">5.</strong> 条件编译</a></li><li class="chapter-item expanded "><a href="items.html"><strong aria-hidden="true">6.</strong> 条目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="items/modules.html"><strong aria-hidden="true">6.1.</strong> 模块</a></li><li class="chapter-item expanded "><a href="items/extern-crates.html"><strong aria-hidden="true">6.2.</strong> 外部Crate</a></li><li class="chapter-item expanded "><a href="items/use-declarations.html"><strong aria-hidden="true">6.3.</strong> Use 声明</a></li><li class="chapter-item expanded "><a href="items/functions.html"><strong aria-hidden="true">6.4.</strong> 函数</a></li><li class="chapter-item expanded "><a href="items/type-aliases.html"><strong aria-hidden="true">6.5.</strong> 类型别名</a></li><li class="chapter-item expanded "><a href="items/structs.html"><strong aria-hidden="true">6.6.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="items/enumerations.html"><strong aria-hidden="true">6.7.</strong> 枚举</a></li><li class="chapter-item expanded "><a href="items/unions.html"><strong aria-hidden="true">6.8.</strong> 联合体</a></li><li class="chapter-item expanded "><a href="items/constant-items.html"><strong aria-hidden="true">6.9.</strong> 常量条目</a></li><li class="chapter-item expanded "><a href="items/static-items.html"><strong aria-hidden="true">6.10.</strong> 静态条目</a></li><li class="chapter-item expanded "><a href="items/traits.html"><strong aria-hidden="true">6.11.</strong> Trait</a></li><li class="chapter-item expanded "><a href="items/implementations.html"><strong aria-hidden="true">6.12.</strong> 实现</a></li><li class="chapter-item expanded "><a href="items/external-blocks.html"><strong aria-hidden="true">6.13.</strong> 外部块</a></li><li class="chapter-item expanded "><a href="items/generics.html"><strong aria-hidden="true">6.14.</strong> 泛型参数</a></li><li class="chapter-item expanded "><a href="items/associated-items.html"><strong aria-hidden="true">6.15.</strong> 关联条目</a></li></ol></li><li class="chapter-item expanded "><a href="attributes.html"><strong aria-hidden="true">7.</strong> 属性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="attributes/testing.html"><strong aria-hidden="true">7.1.</strong> 测试</a></li><li class="chapter-item expanded "><a href="attributes/derive.html"><strong aria-hidden="true">7.2.</strong> 派生</a></li><li class="chapter-item expanded "><a href="attributes/diagnostics.html"><strong aria-hidden="true">7.3.</strong> 诊断</a></li><li class="chapter-item expanded "><a href="attributes/codegen.html"><strong aria-hidden="true">7.4.</strong> 代码生成</a></li><li class="chapter-item expanded "><a href="attributes/limits.html"><strong aria-hidden="true">7.5.</strong> 约束</a></li><li class="chapter-item expanded "><a href="attributes/type_system.html"><strong aria-hidden="true">7.6.</strong> 类型系统</a></li></ol></li><li class="chapter-item expanded "><a href="statements-and-expressions.html"><strong aria-hidden="true">8.</strong> 语句和表达式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="statements.html"><strong aria-hidden="true">8.1.</strong> 语句</a></li><li class="chapter-item expanded "><a href="expressions.html"><strong aria-hidden="true">8.2.</strong> 表达式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="expressions/literal-expr.html"><strong aria-hidden="true">8.2.1.</strong> 字面值表达式</a></li><li class="chapter-item expanded "><a href="expressions/path-expr.html"><strong aria-hidden="true">8.2.2.</strong> 路径表达式</a></li><li class="chapter-item expanded "><a href="expressions/block-expr.html"><strong aria-hidden="true">8.2.3.</strong> 块表达式</a></li><li class="chapter-item expanded "><a href="expressions/operator-expr.html"><strong aria-hidden="true">8.2.4.</strong> 运算符表达式</a></li><li class="chapter-item expanded "><a href="expressions/grouped-expr.html"><strong aria-hidden="true">8.2.5.</strong> 分组表达式</a></li><li class="chapter-item expanded "><a href="expressions/array-expr.html"><strong aria-hidden="true">8.2.6.</strong> 数组和索引表达式</a></li><li class="chapter-item expanded "><a href="expressions/tuple-expr.html"><strong aria-hidden="true">8.2.7.</strong> 元组和索引表达式</a></li><li class="chapter-item expanded "><a href="expressions/struct-expr.html"><strong aria-hidden="true">8.2.8.</strong> 结构体表达式</a></li><li class="chapter-item expanded "><a href="expressions/call-expr.html"><strong aria-hidden="true">8.2.9.</strong> 调用表达式</a></li><li class="chapter-item expanded "><a href="expressions/method-call-expr.html"><strong aria-hidden="true">8.2.10.</strong> 方法调用表达式</a></li><li class="chapter-item expanded "><a href="expressions/field-expr.html"><strong aria-hidden="true">8.2.11.</strong> 字段访问表达式</a></li><li class="chapter-item expanded "><a href="expressions/closure-expr.html"><strong aria-hidden="true">8.2.12.</strong> 闭包表达式</a></li><li class="chapter-item expanded "><a href="expressions/loop-expr.html"><strong aria-hidden="true">8.2.13.</strong> 循环表达式</a></li><li class="chapter-item expanded "><a href="expressions/range-expr.html"><strong aria-hidden="true">8.2.14.</strong> 区间表达式</a></li><li class="chapter-item expanded "><a href="expressions/if-expr.html"><strong aria-hidden="true">8.2.15.</strong> if 和 if let 表达式</a></li><li class="chapter-item expanded "><a href="expressions/match-expr.html"><strong aria-hidden="true">8.2.16.</strong> 匹配表达式</a></li><li class="chapter-item expanded "><a href="expressions/return-expr.html"><strong aria-hidden="true">8.2.17.</strong> 返回表达式</a></li><li class="chapter-item expanded "><a href="expressions/await-expr.html"><strong aria-hidden="true">8.2.18.</strong> 等待表达式</a></li><li class="chapter-item expanded "><a href="expressions/underscore-expr.html"><strong aria-hidden="true">8.2.19.</strong> 下划线表达式</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="patterns.html" class="active"><strong aria-hidden="true">9.</strong> 模式</a></li><li class="chapter-item expanded "><a href="type-system.html"><strong aria-hidden="true">10.</strong> 类型系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">10.1.</strong> 类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/boolean.html"><strong aria-hidden="true">10.1.1.</strong> 布尔类型</a></li><li class="chapter-item expanded "><a href="types/numeric.html"><strong aria-hidden="true">10.1.2.</strong> 数字类型</a></li><li class="chapter-item expanded "><a href="types/textual.html"><strong aria-hidden="true">10.1.3.</strong> 文本类型</a></li><li class="chapter-item expanded "><a href="types/never.html"><strong aria-hidden="true">10.1.4.</strong> 永不类型</a></li><li class="chapter-item expanded "><a href="types/tuple.html"><strong aria-hidden="true">10.1.5.</strong> 元组类型</a></li><li class="chapter-item expanded "><a href="types/array.html"><strong aria-hidden="true">10.1.6.</strong> 数组类型</a></li><li class="chapter-item expanded "><a href="types/slice.html"><strong aria-hidden="true">10.1.7.</strong> 切片类型</a></li><li class="chapter-item expanded "><a href="types/struct.html"><strong aria-hidden="true">10.1.8.</strong> 结构体类型</a></li><li class="chapter-item expanded "><a href="types/enum.html"><strong aria-hidden="true">10.1.9.</strong> 枚举类型</a></li><li class="chapter-item expanded "><a href="types/union.html"><strong aria-hidden="true">10.1.10.</strong> 联合类型</a></li><li class="chapter-item expanded "><a href="types/function-item.html"><strong aria-hidden="true">10.1.11.</strong> 函数条目类型</a></li><li class="chapter-item expanded "><a href="types/closure.html"><strong aria-hidden="true">10.1.12.</strong> 闭包类型</a></li><li class="chapter-item expanded "><a href="types/pointer.html"><strong aria-hidden="true">10.1.13.</strong> 指针类型</a></li><li class="chapter-item expanded "><a href="types/function-pointer.html"><strong aria-hidden="true">10.1.14.</strong> 函数指针类型</a></li><li class="chapter-item expanded "><a href="types/trait-object.html"><strong aria-hidden="true">10.1.15.</strong> Trait 对象类型</a></li><li class="chapter-item expanded "><a href="types/impl-trait.html"><strong aria-hidden="true">10.1.16.</strong> 实现 Trait 的类型</a></li><li class="chapter-item expanded "><a href="types/parameters.html"><strong aria-hidden="true">10.1.17.</strong> 类型参数</a></li><li class="chapter-item expanded "><a href="types/inferred.html"><strong aria-hidden="true">10.1.18.</strong> 推导出的类型</a></li></ol></li><li class="chapter-item expanded "><a href="dynamically-sized-types.html"><strong aria-hidden="true">10.2.</strong> 动态大小类型</a></li><li class="chapter-item expanded "><a href="type-layout.html"><strong aria-hidden="true">10.3.</strong> 类型布局</a></li><li class="chapter-item expanded "><a href="interior-mutability.html"><strong aria-hidden="true">10.4.</strong> 内部可变性</a></li><li class="chapter-item expanded "><a href="subtyping.html"><strong aria-hidden="true">10.5.</strong> 子类型和协变</a></li><li class="chapter-item expanded "><a href="trait-bounds.html"><strong aria-hidden="true">10.6.</strong> Trait 和生命周期约束</a></li><li class="chapter-item expanded "><a href="type-coercions.html"><strong aria-hidden="true">10.7.</strong> 类型强制转换</a></li><li class="chapter-item expanded "><a href="destructors.html"><strong aria-hidden="true">10.8.</strong> 析构函数</a></li><li class="chapter-item expanded "><a href="lifetime-elision.html"><strong aria-hidden="true">10.9.</strong> 生命周期省略</a></li></ol></li><li class="chapter-item expanded "><a href="special-types-and-traits.html"><strong aria-hidden="true">11.</strong> 特殊类型和Trait</a></li><li class="chapter-item expanded "><a href="names.html"><strong aria-hidden="true">12.</strong> 名称</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="names/namespaces.html"><strong aria-hidden="true">12.1.</strong> 命名空间</a></li><li class="chapter-item expanded "><a href="names/scopes.html"><strong aria-hidden="true">12.2.</strong> 作用域</a></li><li class="chapter-item expanded "><a href="names/preludes.html"><strong aria-hidden="true">12.3.</strong> 预定义</a></li><li class="chapter-item expanded "><a href="paths.html"><strong aria-hidden="true">12.4.</strong> 路径</a></li><li class="chapter-item expanded "><a href="names/name-resolution.html"><strong aria-hidden="true">12.5.</strong> 名称解析</a></li><li class="chapter-item expanded "><a href="visibility-and-privacy.html"><strong aria-hidden="true">12.6.</strong> 可见性和私有性</a></li></ol></li><li class="chapter-item expanded "><a href="memory-model.html"><strong aria-hidden="true">13.</strong> 内存模型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="memory-allocation-and-lifetime.html"><strong aria-hidden="true">13.1.</strong> 内存分配和生命周期</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">13.2.</strong> 变量</a></li></ol></li><li class="chapter-item expanded "><a href="linkage.html"><strong aria-hidden="true">14.</strong> 链接</a></li><li class="chapter-item expanded "><a href="inline-assembly.html"><strong aria-hidden="true">15.</strong> 内联汇编</a></li><li class="chapter-item expanded "><a href="unsafety.html"><strong aria-hidden="true">16.</strong> Unsafety</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="unsafe-keyword.html"><strong aria-hidden="true">16.1.</strong> unsafe 关键字</a></li><li class="chapter-item expanded "><a href="behavior-considered-undefined.html"><strong aria-hidden="true">16.2.</strong> 被视为未定义行为的行为</a></li><li class="chapter-item expanded "><a href="behavior-not-considered-unsafe.html"><strong aria-hidden="true">16.3.</strong> 不被视为不安全的行为</a></li></ol></li><li class="chapter-item expanded "><a href="const_eval.html"><strong aria-hidden="true">17.</strong> 常量求值</a></li><li class="chapter-item expanded "><a href="abi.html"><strong aria-hidden="true">18.</strong> 应用程序二进制接口</a></li><li class="chapter-item expanded "><a href="runtime.html"><strong aria-hidden="true">19.</strong> Rust 运行时</a></li><li class="chapter-item expanded "><a href="appendices.html"><strong aria-hidden="true">20.</strong> 附录</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macro-ambiguity.html"><strong aria-hidden="true">20.1.</strong> 宏 Follow-Set 歧义正式规范</a></li><li class="chapter-item expanded "><a href="influences.html"><strong aria-hidden="true">20.2.</strong> 影响</a></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">20.3.</strong> 术语表</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/patterns.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="模式"><a class="header" href="#模式">模式</a></h1>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>模式</em> :<br />
      <code>|</code><sup>?</sup> <em>模式非顶层选项</em>  ( <code>|</code> <em>模式非顶层选项</em> )<sup>*</sup></p>
<p><em>模式非顶层选项</em> :<br />
      <em>无区间模式</em><br />
   | <a href="#range-patterns"><em>区间模式</em></a></p>
<p><em>无区间模式</em> :<br />
      <a href="#literal-patterns"><em>字面值模式</em></a><br />
   | <a href="#identifier-patterns"><em>标识符模式</em></a><br />
   | <a href="#wildcard-pattern"><em>通配符模式</em></a><br />
   | <a href="#rest-patterns"><em>剩余模式</em></a><br />
   | <a href="#reference-patterns"><em>引用模式</em></a><br />
   | <a href="#struct-patterns"><em>结构体模式</em></a><br />
   | <a href="#tuple-struct-patterns"><em>元组结构体模式</em></a><br />
   | <a href="#tuple-patterns"><em>元组模式</em></a><br />
   | <a href="#grouped-patterns"><em>分组模式</em></a><br />
   | <a href="#slice-patterns"><em>切片模式</em></a><br />
   | <a href="#path-patterns"><em>路径模式</em></a><br />
   | <a href="macros.html#macro-invocation"><em>宏调用</em></a></p>
</blockquote>
<p>模式用于将值与结构进行匹配，并在这些结构内将变量绑定到值(可选)。
它们还用于函数和闭包的变量声明和参数。以下示例中的模式执行四个操作：</p>
<ul>
<li>检查 <code>person</code> 是否有填充了某些内容的 <code>car</code> 字段。</li>
<li>检查 <code>person</code> 的 <code>age</code> 字段是否在 13 到 19 之间，并将其值绑定到 <code>person_age</code> 变量。</li>
<li>将 <code>name</code> 字段的引用绑定到变量 <code>person_name</code> 。</li>
<li>忽略 <code>person</code> 的其余字段。剩余字段可以具有任何值，并且不会绑定到任何变量。</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Car;
</span><span class="boring">struct Computer;
</span><span class="boring">struct Person {
</span><span class="boring">    name: String,
</span><span class="boring">    car: Option&lt;Car&gt;,
</span><span class="boring">    computer: Option&lt;Computer&gt;,
</span><span class="boring">    age: u8,
</span><span class="boring">}
</span><span class="boring">let person = Person {
</span><span class="boring">    name: String::from(&quot;John&quot;),
</span><span class="boring">    car: Some(Car),
</span><span class="boring">    computer: None,
</span><span class="boring">    age: 15,
</span><span class="boring">};
</span>if let
    Person {
        car: Some(_),
        age: person_age @ 13..=19,
        name: ref person_name,
        ..
    } = person
{
    println!(&quot;{} has a car and is {} years old.&quot;, person_name, person_age);
}
<span class="boring">}</span></code></pre></pre>
<p>模式用于:</p>
<ul>
<li><a href="statements.html#let-statements"><code>let</code> 声明</a></li>
<li><a href="items/functions.html">函数</a> 和 <a href="expressions/closure-expr.html">闭包</a> 参数</li>
<li><a href="expressions/match-expr.html"><code>match</code> 表达式</a></li>
<li><a href="expressions/if-expr.html"><code>if let</code> 表达式</a></li>
<li><a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code> 表达式</a></li>
<li><a href="expressions/loop-expr.html#iterator-loops"><code>for</code> 表达式</a></li>
</ul>
<h2 id="解构"><a class="header" href="#解构">解构</a></h2>
<p>模式可以用于解构 <a href="items/structs.html">structs</a> 、 <a href="items/enumerations.html">enums</a> 和 <a href="types/tuple.html">tuples</a> 。解构将一个值分解成其组成部分。
使用的语法与创建这些值时几乎相同。在一个模式中，其 <a href="glossary.html#scrutinee">被匹配项</a> 表达式具有 <code>struct</code>、<code>enum</code> 或 <code>tuple</code> 类型，占位符 (<code>_</code>) 代表 <em>单个</em> 数据字段，而通配符 <code>..</code> 代表 <em>特定变体的所有</em> 其余字段。
当解构具有命名字段 (但未编号) 的数据结构时，允许将 <code>fieldname</code> 写成 <code>fieldname: fieldname</code> 的简写形式。
在 Rust 中，解构是一种方便的工具，可用于从结构化数据类型中提取所需数据。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Message {
</span><span class="boring">    Quit,
</span><span class="boring">    WriteString(String),
</span><span class="boring">    Move { x: i32, y: i32 },
</span><span class="boring">    ChangeColor(u8, u8, u8),
</span><span class="boring">}
</span><span class="boring">let message = Message::Quit;
</span>match message {
    Message::Quit =&gt; println!(&quot;Quit&quot;),
    Message::WriteString(write) =&gt; println!(&quot;{}&quot;, &amp;write),
    Message::Move{ x, y: 0 } =&gt; println!(&quot;move {} horizontally&quot;, x),
    Message::Move{ .. } =&gt; println!(&quot;other move&quot;),
    Message::ChangeColor { 0: red, 1: green, 2: _ } =&gt; {
        println!(&quot;color change, red: {}, green: {}&quot;, red, green);
    }
};
<span class="boring">}</span></code></pre></pre>
<h2 id="可反驳性"><a class="header" href="#可反驳性">可反驳性</a></h2>
<p>当模式可能无法匹配其所匹配的值时，该模式被称为 <em>可反驳的</em> 。相反， <em>不可反驳</em> 模式总是与其所匹配的值匹配。例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x, y) = (1, 2);               // &quot;(x, y)&quot; 是一个不可反驳的模式

if let (a, 3) = (1, 2) {           // &quot;(a, 3)&quot; 是可反驳的，将不匹配
    panic!(&quot;不应该到达这里&quot;);
} else if let (a, 4) = (3, 4) {    // &quot;(a, 4)&quot; 是可反驳的，并将匹配
    println!(&quot;匹配到 ({}, 4)&quot;, a);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="字面值模式"><a class="header" href="#字面值模式">字面值模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>字面值模式</em> :<br />
      <code>true</code> | <code>false</code><br />
   | <a href="tokens.html#character-literals">字符字面值</a><br />
   | <a href="tokens.html#byte-literals">字节字面值</a><br />
   | <a href="tokens.html#string-literals">字符串字面值</a><br />
   | <a href="tokens.html#raw-string-literals">原始字符串字面值</a><br />
   | <a href="tokens.html#byte-string-literals">字节字符串字面值</a><br />
   | <a href="tokens.html#raw-byte-string-literals">原始字节字符串字面值</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#integer-literals">整数字面值</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#floating-point-literals">浮点数字面值</a></p>
</blockquote>
<p><em>字面值模式</em> 正好匹配与字面值创建的值相同的值。
由于负数不是字面值，字面值模式也接受字面值前面的可选负号，其作用类似于否定运算符。</p>
<div class="warning">
<p>目前接受浮点型字面值，但由于比较复杂，未来的 Rust 版本中将禁止在字面值模式中使用它们 (参见<a href="https://github.com/rust-lang/rust/issues/41620">问题 #41620</a>)。</p>
</div>
<p>字面值模式总是可反驳的。</p>
<p>例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in -2..5 {
    match i {
        -1 =&gt; println!(&quot;It's minus one&quot;),
        1 =&gt; println!(&quot;It's a one&quot;),
        2|4 =&gt; println!(&quot;It's either a two or a four&quot;),
        _ =&gt; println!(&quot;Matched none of the arms&quot;),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="标识符模式"><a class="header" href="#标识符模式">标识符模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>标识符模式</em> :<br />
      <code>ref</code><sup>?</sup> <code>mut</code><sup>?</sup> <a href="identifiers.html">标识符</a> (<code>@</code> <a href="#patterns"><em>模式非顶层选项</em></a> ) <sup>?</sup></p>
</blockquote>
<p>标识符模式将其匹配的值绑定到变量上。
标识符在模式中必须是唯一的。
该变量将隐藏作用域中具有相同名称的任何变量。
新绑定的作用域取决于模式用于何处的上下文 (例如 <code>let</code> 绑定或 <code>match</code> 分支) 。</p>
<p>仅由标识符组成的模式 (可能带有 <code>mut</code> ) 会匹配任何值并将其绑定到该标识符上。这是变量声明和函数及闭包参数中最常用的模式。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut variable = 10;
fn sum(x: i32, y: i32) -&gt; i32 {
<span class="boring">   x + y
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>要将模式的匹配值绑定到变量上，请使用语法 <code>variable @ subpattern</code> 。
例如，以下代码将值 2 绑定到 <code>e</code> (而不是整个区间：这里的区间是一个区间子模式) 。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;

match x {
    e @ 1 ..= 5 =&gt; println!(&quot;got a range element {}&quot;, e),
    _ =&gt; println!(&quot;anything&quot;),
}
<span class="boring">}</span></code></pre></pre>
<p>默认情况下，标识符模式将根据匹配的值是否实现了 <a href="special-types-and-traits.html#copy"><code>Copy</code></a> ，绑定一个变量到匹配值的复制或移动。
可以使用 <code>ref</code> 关键字将其更改为绑定到一个引用，或使用 <code>ref mut</code> 更改为可变引用。例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let a = Some(10);
</span>match a {
    None =&gt; (),
    Some(value) =&gt; (),
}

match a {
    None =&gt; (),
    Some(ref value) =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p>在第一个 match 表达式中，该值被复制 (或移动) 。在第二个 match 中，对同一内存位置的引用被绑定到变量值。
这种语法是必要的，因为在解构子模式中， <code>&amp;</code> 操作符不能应用于值的字段。
例如，以下是无效的:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let value = Person { name: String::from(&quot;John&quot;), age: 23 };
</span>if let Person { name: &amp;person_name, age: 18..=150 } = value { }
<span class="boring">}</span></code></pre></pre>
<p>要使其有效，请写如下代码:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let value = Person { name: String::from(&quot;John&quot;), age: 23 };
</span>if let Person {name: ref person_name, age: 18..=150 } = value { }
<span class="boring">}</span></code></pre></pre>
<p>因此， <code>ref</code> 不是被匹配的内容。
它的目的仅仅是将匹配的绑定作为引用而不是复制或移动匹配的内容。</p>
<p><a href="#path-patterns">路径模式</a> 优先于标识符模式。如果指定了 <code>ref</code> 或 <code>ref mut</code> ，并且标识符遮蔽了一个常量，则会出现错误。</p>
<p>如果子模式是不可反驳的或未指定子模式，则标识符模式是不可反驳的。</p>
<h3 id="绑定模式"><a class="header" href="#绑定模式">绑定模式</a></h3>
<p>为了提供更好的人机交互，模式运行在不同的 <em>绑定模式</em> 中，以便更容易地将引用绑定到值。
当引用值被非引用模式匹配时，它会自动被视为 <code>ref</code> 或 <code>ref mut</code> 绑定。
例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: &amp;Option&lt;i32&gt; = &amp;Some(3);    // 创建一个类型为 &amp;Option&lt;i32&gt; 的引用 x，指向 Some(3)
if let Some(y) = x {               // 对 x 进行模式匹配
    // y 被转换成了 `ref y`，其类型为 &amp;i32
}
<span class="boring">}</span></code></pre></pre>
<p><em>非引用模式</em> 包括除绑定、 <a href="#wildcard-pattern">通配符模式</a> (<code>_</code>)、引用类型的 <a href="#path-patterns"><code>const</code> 模式</a> 和 <a href="#reference-patterns">引用模式</a> 之外的所有模式。</p>
<p>如果一个绑定模式没有明确指定 <code>ref</code> 、 <code>ref mut</code> 或 <code>mut</code> ，则会使用 <em>默认绑定模式</em> 来确定变量如何被绑定。
默认绑定模式开始于 &quot;移动&quot; 模式，使用移动语义。
匹配模式时，编译器从外向内开始。
每次使用非引用模式匹配引用时，它将自动解引用该值并更新默认绑定模式。
引用将默认绑定模式设置为 <code>ref</code> 。
可变引用将模式设置为 <code>ref mut</code> ，除非模式已经是 <code>ref</code> ，否则它将保持为 <code>ref</code> 。
如果自动解引用的值仍然是引用，则解引用该值并重复此过程。</p>
<p>移动绑定和引用绑定可以混合在同一个模式中。
这样做将导致对象的部分移动绑定，并且之后无法再使用该对象。
如果类型不能复制，则适用此规则。</p>
<p>在下面的示例中， <code>name</code> 从 <code>person</code> 中移动出来。试图将 <code>person</code> 作为整体或 <code>person.name</code> 使用会导致错误，因为存在 <em>部分移动</em> 。</p>
<p>例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let person = Person{ name: String::from(&quot;John&quot;), age: 23 };
</span>// `name` 从 `person` 中被移动了，而 `age` 则被引用。
let Person { name, ref age } = person;
<span class="boring">}</span></code></pre></pre>
<h2 id="通配符模式"><a class="header" href="#通配符模式">通配符模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>通配符模式</em> :<br />
   <code>_</code></p>
</blockquote>
<p><em>通配符模式</em> (下划线符号) 匹配任何值。它用于在不重要时忽略值。
在其他模式内部，它匹配单个数据字段 (与 <code>..</code> 匹配剩余字段不同)。
与标识符模式不同，它不会复制、移动或借用它所匹配的值。</p>
<p>例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let x = 20;
</span>let (a, _) = (10, x);   // x总是被 _ 匹配
<span class="boring">assert_eq!(a, 10);
</span>
// 忽略函数/闭包的参数
let real_part = |a: f64, _: f64| { a };

// 忽略函数/闭包的参数
<span class="boring">struct RGBA {
</span><span class="boring">   r: f32,
</span><span class="boring">   g: f32,
</span><span class="boring">   b: f32,
</span><span class="boring">   a: f32,
</span><span class="boring">}
</span><span class="boring">let color = RGBA{r: 0.4, g: 0.1, b: 0.9, a: 0.5};
</span>let RGBA{r: red, g: green, b: blue, a: _} = color;
<span class="boring">assert_eq!(color.r, red);
</span><span class="boring">assert_eq!(color.g, green);
</span><span class="boring">assert_eq!(color.b, blue);
</span>
// 接受任何 Some，与任何值
<span class="boring">let x = Some(10);
</span>if let Some(_) = x {}
<span class="boring">}</span></code></pre></pre>
<p>通配符模式始终是不可反驳的。</p>
<h2 id="剩余模式"><a class="header" href="#剩余模式">剩余模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>剩余模式</em> :<br />
   <code>..</code></p>
</blockquote>
<p><em>剩余模式</em> (<code>..</code> 符号) 作为一个可变长度的模式，用于匹配在之前和之后尚未被匹配到的零个或多个元素。
它只能在 <a href="#tuple-patterns">元组模式</a> 、 <a href="#tuple-struct-patterns">元组结构体模式</a> 和 <a href="#slice-patterns">切片模式</a> 中使用，并且只能出现一次作为这些模式中的一个元素。
在 <a href="#slice-patterns">切片模式</a> 中，它也允许出现在 <a href="#identifier-patterns">标识符模式</a> 中。</p>
<p>剩余模式始终是不可反驳的。</p>
<p>例如:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let words = vec![&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
</span><span class="boring">let slice = &amp;words[..];
</span>match slice {
    [] =&gt; println!(&quot;slice is empty&quot;),
    [one] =&gt; println!(&quot;single element {}&quot;, one),
    [head, tail @ ..] =&gt; println!(&quot;head={} tail={:?}&quot;, head, tail), // 匹配第一个元素和其余元素

}

match slice {
    [.., &quot;!&quot;] =&gt; println!(&quot;!!!&quot;), // 忽略除了最后一个元素之外的所有元素，最后一个元素必须是 &quot;!&quot; 
    [start @ .., &quot;z&quot;] =&gt; println!(&quot;starts with: {:?}&quot;, start), // `start` 是除了最后一个元素之外的所有元素，最后一个元素必须是 &quot;z&quot; 
    [&quot;a&quot;, end @ ..] =&gt; println!(&quot;ends with: {:?}&quot;, end), // `end` 是除了第一个元素之外的所有元素，第一个元素必须是&quot;a&quot;
    whole @ [.., last] =&gt; println!(&quot;the last element of {:?} is {}&quot;, whole, last), // 'whole' 是整个切片， `last` 是最后一个元素
    rest =&gt; println!(&quot;{:?}&quot;, rest),
}

if let [.., penultimate, _] = slice {
    println!(&quot;next to last is {}&quot;, penultimate); // 获取倒数第二个元素
}

<span class="boring">let tuple = (1, 2, 3, 4, 5);
</span>// 剩余模式也可以用于元组和元组结构体模式。
match tuple {
    (1, .., y, z) =&gt; println!(&quot;y={} z={}&quot;, y, z), // 匹配第一个元素和其余元素，但是只保留最后两个元素
    (.., 5) =&gt; println!(&quot;tail must be 5&quot;), // 必须以 5 结尾
    (..) =&gt; println!(&quot;matches everything else&quot;), // 匹配所有其他情况
}
<span class="boring">}</span></code></pre></pre>
<h2 id="区间模式"><a class="header" href="#区间模式">区间模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>区间模式</em> :<br />
      <em>区间内部模式</em><br />
   | <em>区间From模式</em><br />
   | <em>区间To内部模式</em><br />
   | <em>废弃区间模式</em></p>
<p><em>区间内部模式</em> :<br />
      <em>区间模式约束</em> <code>..=</code> <em>区间模式约束</em></p>
<p><em>区间From模式</em> :<br />
      <em>区间模式约束</em> <code>..</code></p>
<p><em>区间To内部模式</em> :<br />
      <code>..=</code> <em>区间模式约束</em></p>
<p><em>废弃区间模式</em> :<br />
   <em>区间模式约束</em> <code>...</code> <em>区间模式约束</em></p>
<p><em>区间模式约束</em> :<br />
      <a href="tokens.html#character-literals">字符字面值</a><br />
   | <a href="tokens.html#byte-literals">字节字面值</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#integer-literals">整数字面值</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#floating-point-literals">浮点数字面值</a><br />
   | <a href="expressions/path-expr.html"><em>路径表达式</em></a></p>
</blockquote>
<p><em>区间模式</em> 匹配由其边界定义的区间内的标量值。它们由一个 <em>符号</em> ( <code>..</code> 、 <code>..=</code> 或 <code>...</code> 中的一个) 和一个或两个边界组成。在符号左边的边界是 <em>下界</em> ，在右边的是 <em>上界</em> 。</p>
<p>具有下界和上界的区间模式将匹配其两个边界之间及其包括的所有值。它由其下界、后跟 <code>..=</code> ，后跟其上界组成。区间模式的类型与其上界和下界的类型统一。</p>
<p>例如，模式 <code>'m'..='p'</code> 将仅匹配值 <code>'m'</code>  <code>'n'</code>  <code>'o'</code> 和 <code>'p'</code>。</p>
<p>下界不能大于上界。也就是说，在 <code>a..=b</code> 中，必须满足 $a ≤ b$。例如，拥有区间模式 <code>10..=0</code> 是错误的。</p>
<p>只有下界的区间模式将匹配大于或等于下界的任何值。它由其下界后跟 <code>..</code> 组成，与其下界具有相同的类型。例如， <code>1..</code> 将匹配 1、9、9001 或 9007199254740991 (如果它是适当大小的) ，但不匹配 0 和有符号整数的负数。</p>
<p>只有上界的区间模式将匹配小于或等于上界的任何值。它由 <code>..=</code> 后跟其上界组成，与其上界具有相同的类型。例如， <code>..=10</code> 将匹配 10、1、0 和有符号整数类型的所有负值。</p>
<p>只有一个边界的区间模式不能用作 <a href="#slice-patterns">切片模式</a> 的子模式的顶级模式。</p>
<p>边界值可以写作以下其中之一:</p>
<ul>
<li>字符、字节、整数或浮点数字面值。</li>
<li><code>-</code> 后跟一个整数或浮点数字面值。</li>
<li><a href="expressions/path-expr.html">路径</a>。</li>
</ul>
<p>如果边界值是作为路径写的，在宏展开后，该路径必须解析为类型为 <code>char</code> 、整数类型或浮点类型的常量条目。</p>
<p>边界的类型和值取决于它的写法。如果边界是一个路径，则模式具有路径解析为的常量的类型和值。
如果是字面值，则它具有相应的字面表达式的类型和值。
如果是一个以 <code>-</code> 开头的字面值，则它具有与相应字面值表达式相同的类型，以及相应字面值表达式的值的 <a href="expressions/operator-expr.html#negation-operators">取反</a> 的值。</p>
<p>Examples:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let c = 'f';
</span>let valid_variable = match c {
    'a'..='z' =&gt; true,
    'A'..='Z' =&gt; true,
    'α'..='ω' =&gt; true,
    _ =&gt; false,
};

<span class="boring">let ph = 10;
</span>println!(&quot;{}&quot;, match ph {
    0..=6 =&gt; &quot;acid&quot;,
    7 =&gt; &quot;neutral&quot;,
    8..=14 =&gt; &quot;base&quot;,
    _ =&gt; unreachable!(),
});

<span class="boring">let uint: u32 = 5;
</span>match uint {
    0 =&gt; &quot;zero!&quot;,
    1.. =&gt; &quot;positive number!&quot;,
};

// using paths to constants:
<span class="boring">const TROPOSPHERE_MIN : u8 = 6;
</span><span class="boring">const TROPOSPHERE_MAX : u8 = 20;
</span><span class="boring">
</span><span class="boring">const STRATOSPHERE_MIN : u8 = TROPOSPHERE_MAX + 1;
</span><span class="boring">const STRATOSPHERE_MAX : u8 = 50;
</span><span class="boring">
</span><span class="boring">const MESOSPHERE_MIN : u8 = STRATOSPHERE_MAX + 1;
</span><span class="boring">const MESOSPHERE_MAX : u8 = 85;
</span><span class="boring">
</span><span class="boring">let altitude = 70;
</span><span class="boring">
</span>println!(&quot;{}&quot;, match altitude {
    TROPOSPHERE_MIN..=TROPOSPHERE_MAX =&gt; &quot;troposphere&quot;,
    STRATOSPHERE_MIN..=STRATOSPHERE_MAX =&gt; &quot;stratosphere&quot;,
    MESOSPHERE_MIN..=MESOSPHERE_MAX =&gt; &quot;mesosphere&quot;,
    _ =&gt; &quot;outer space, maybe&quot;,
});

<span class="boring">pub mod binary {
</span><span class="boring">    pub const MEGA : u64 = 1024*1024;
</span><span class="boring">    pub const GIGA : u64 = 1024*1024*1024;
</span><span class="boring">}
</span><span class="boring">let n_items = 20_832_425;
</span><span class="boring">let bytes_per_item = 12;
</span>if let size @ binary::MEGA..=binary::GIGA = n_items * bytes_per_item {
    println!(&quot;It fits and occupies {} bytes&quot;, size);
}

<span class="boring">trait MaxValue {
</span><span class="boring">    const MAX: u64;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u8 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 8) - 1;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u16 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 16) - 1;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u32 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 32) - 1;
</span><span class="boring">}
</span>// using qualified paths:
println!(&quot;{}&quot;, match 0xfacade {
    0 ..= &lt;u8 as MaxValue&gt;::MAX =&gt; &quot;fits in a u8&quot;,
    0 ..= &lt;u16 as MaxValue&gt;::MAX =&gt; &quot;fits in a u16&quot;,
    0 ..= &lt;u32 as MaxValue&gt;::MAX =&gt; &quot;fits in a u32&quot;,
    _ =&gt; &quot;too big&quot;,
});
<span class="boring">}</span></code></pre></pre>
<p>固定宽度整数和 <code>char</code> 类型的区间模式在它们 span 类型的所有可能值时是不可反驳的。
例如， <code>0u8..=255u8</code> 是不可反驳的。
整数类型的值区间是从其最小值到最大值的闭区间。
<code>char</code> 类型的值区间恰好包含所有 Unicode 标量值的区间: <code>'\U{0000}'..='\U{D7FF}'</code> 和 <code>'\U{E000}'..='\U{10FFFF}'</code> 。</p>
<p>浮点数区间模式已被弃用，可能会在未来的Rust版本中删除。
有关更多信息，请参见 <a href="https://github.com/rust-lang/rust/issues/41620">issue #41620</a> 。</p>
<blockquote>
<p><strong>版本差异</strong>: 在 2021 版之前，带有下限和上限的区间模式也可以使用 <code>...</code> 代替 <code>..=</code> 进行编写，具有相同的含义。</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>: 尽管区间模式使用与 <a href="expressions/range-expr.html">区间表达式</a> 相同的语法，但不存在独占区间模式。
也就是说， <code>x .. y</code> 和 <code>.. x</code> 都不是有效的区间模式。</p>
</blockquote>
<h2 id="引用模式"><a class="header" href="#引用模式">引用模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>引用模式</em> :<br />
   (<code>&amp;</code>|<code>&amp;&amp;</code>) <code>mut</code><sup>?</sup> <a href="#patterns"><em>无区间模式</em></a></p>
</blockquote>
<p>引用模式会对正在匹配的指针进行解引用，因此会将它们借用。</p>
<p>例如，以下两个对 <code>x: &amp;i32</code> 的匹配是等效的:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let int_reference = &amp;3;

let a = match *int_reference { 0 =&gt; &quot;zero&quot;, _ =&gt; &quot;some&quot; };
let b = match int_reference { &amp;0 =&gt; &quot;zero&quot;, _ =&gt; &quot;some&quot; };

assert_eq!(a, b);
<span class="boring">}</span></code></pre></pre>
<p>引用模式的语法规则必须匹配标记 <code>&amp;&amp;</code> 来匹配引用到引用，因为它本身是一个标记，不是两个 <code>&amp;</code> 标记。</p>
<p>添加 <code>mut</code> 关键字会对可变引用进行解引用。
可变性必须与引用的可变性相匹配。</p>
<p>引用模式始终是不可反驳的。</p>
<h2 id="结构体模式"><a class="header" href="#结构体模式">结构体模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>结构体模式</em> :<br />
   <a href="paths.html#paths-in-expressions"><em>表达式中路径</em></a> <code>{</code><br />
      <em>结构体模式组</em> <sup>?</sup><br />
   <code>}</code></p>
<p><em>结构体模式组</em> :<br />
      <em>结构体模式字段组</em> (<code>,</code> | <code>,</code> <em>结构体模式符加</em>)<sup>?</sup><br />
   | <em>结构体模式符加</em></p>
<p><em>结构体模式字段组</em> :<br />
   <em>结构体模式字段</em> (<code>,</code> <em>结构体模式字段</em>) <sup>*</sup></p>
<p><em>结构体模式字段</em> :<br />
   <a href="attributes.html"><em>外围属性</em></a> <sup>*</sup><br />
   (<br />
         <a href="tokens.html#tuple-index">元组索引</a> <code>:</code> <a href="#patterns"><em>模式</em></a><br />
      | <a href="identifiers.html">标识符</a> <code>:</code> <a href="#patterns"><em>模式</em></a><br />
      | <code>ref</code><sup>?</sup> <code>mut</code><sup>?</sup> <a href="identifiers.html">标识符</a><br />
   )</p>
<p><em>结构体模式符加</em> :<br />
   <a href="attributes.html"><em>外围属性</em></a> <sup>*</sup><br />
   <code>..</code></p>
</blockquote>
<p>结构体模式匹配满足其子模式定义的所有条件的结构体值。
它们还用于 <a href="#destructuring">解构</a> 结构体。</p>
<p>在结构体模式中，可以通过名称、索引 (对于元组结构体) 引用字段，或通过使用 <code>..</code> 忽略字段：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point {
</span><span class="boring">    x: u32,
</span><span class="boring">    y: u32,
</span><span class="boring">}
</span><span class="boring">let s = Point {x: 1, y: 1};
</span><span class="boring">
</span>match s {
    Point {x: 10, y: 20} =&gt; (),
    Point {y: 10, x: 20} =&gt; (),    // order doesn't matter
    Point {x: 10, ..} =&gt; (),
    Point {..} =&gt; (),
}

<span class="boring">struct PointTuple (
</span><span class="boring">    u32,
</span><span class="boring">    u32,
</span><span class="boring">);
</span><span class="boring">let t = PointTuple(1, 2);
</span><span class="boring">
</span>match t {
    PointTuple {0: 10, 1: 20} =&gt; (),
    PointTuple {1: 10, 0: 20} =&gt; (),   // order doesn't matter
    PointTuple {0: 10, ..} =&gt; (),
    PointTuple {..} =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p>如果没有使用 <code>..</code> ，则需要匹配所有字段:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct {
</span><span class="boring">   a: i32,
</span><span class="boring">   b: char,
</span><span class="boring">   c: bool,
</span><span class="boring">}
</span><span class="boring">let mut struct_value = Struct{a: 10, b: 'X', c: false};
</span><span class="boring">
</span>match struct_value {
    Struct{a: 10, b: 'X', c: false} =&gt; (),
    Struct{a: 10, b: 'X', ref c} =&gt; (),
    Struct{a: 10, b: 'X', ref mut c} =&gt; (),
    Struct{a: 10, b: 'X', c: _} =&gt; (),
    Struct{a: _, b: _, c: _} =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p><code>ref</code> 和/或 <code>mut</code> <em>标识符</em> 语法匹配任何值，并将其绑定到与给定字段同名的变量。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct {
</span><span class="boring">   a: i32,
</span><span class="boring">   b: char,
</span><span class="boring">   c: bool,
</span><span class="boring">}
</span><span class="boring">let struct_value = Struct{a: 10, b: 'X', c: false};
</span><span class="boring">
</span>let Struct{a: x, b: y, c: z} = struct_value;          // destructure all fields
<span class="boring">}</span></code></pre></pre>
<p>当结构体模式的任何子模式都是可反驳的时，结构体模式就是可反驳的。</p>
<h2 id="元组结构模式"><a class="header" href="#元组结构模式">元组结构模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>元组结构模式</em> :<br />
   <a href="paths.html#paths-in-expressions"><em>表达式中路径</em></a> <code>(</code> <em>元组结构条目组</em><sup>?</sup> <code>)</code></p>
<p><em>元组结构条目组</em> :<br />
   <a href="#patterns"><em>模式</em></a> ( <code>,</code> <a href="#patterns"><em>模式</em></a> )<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<p>元组结构体模式匹配元组结构体和枚举值，匹配所有符合其子模式定义的条件。它们还可用于 <a href="#destructuring">解构</a> 元组结构体或枚举值。</p>
<p>当子模式中有不可反驳模式时，元组结构体模式就是可反驳的。</p>
<h2 id="元组模式"><a class="header" href="#元组模式">元组模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>元组模式</em> :<br />
   <code>(</code> <em>元组模式条目组</em><sup>?</sup> <code>)</code></p>
<p><em>元组模式条目组</em> :<br />
      <a href="#patterns"><em>模式</em></a> <code>,</code><br />
   | <a href="#rest-patterns"><em>剩余模式</em></a><br />
   | <a href="#patterns"><em>模式</em></a> (<code>,</code> <a href="#patterns"><em>模式</em></a>)<sup>+</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<p>元组模式匹配满足其子模式定义的所有条件的元组值。它们也用于 <a href="#destructuring">解构</a> 元组。
形式为 <code>(..)</code> 且具有单个 <a href="#rest-patterns"><em>剩余模式</em></a> 的是一种特殊形式，它不需要逗号，可以匹配任意大小的元组。</p>
<p>当其子模式中有一个可反驳时，元组模式是可反驳的。</p>
<p>以下是使用元组模式的示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pair = (10, &quot;ten&quot;);
let (a, b) = pair;

assert_eq!(a, 10);
assert_eq!(b, &quot;ten&quot;);
<span class="boring">}</span></code></pre></pre>
<h2 id="分组模式"><a class="header" href="#分组模式">分组模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>分组模式</em> :<br />
   <code>(</code> <a href="#patterns"><em>模式</em></a> <code>)</code></p>
</blockquote>
<p>将一个模式括在括号中可以用于显式地控制复合模式的优先级。
例如，一个引用模式紧贴着一个区间模式，如 <code>&amp;0..=5</code> 是有歧义的并且不被允许，但可以用括号来表示。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let int_reference = &amp;3;
match int_reference {
    &amp;(0..=5) =&gt; (),
    _ =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="切片模式"><a class="header" href="#切片模式">切片模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>切片模式</em> :<br />
   <code>[</code> <em>切片模式条目组</em><sup>?</sup> <code>]</code></p>
<p><em>切片模式条目组</em> :<br />
   <a href="#patterns"><em>模式</em></a> (<code>,</code> <a href="#patterns"><em>模式</em></a>)<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<p>切片模式可以匹配固定大小的数组和动态大小的切片。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fixed size
let arr = [1, 2, 3];
match arr {
    [1, _, _] =&gt; &quot;starts with one&quot;,
    [a, b, c] =&gt; &quot;starts with something else&quot;,
};
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 动态大小
let v = vec![1, 2, 3];
match v[..] {
    [a, b] =&gt; { /* 这个分支不会匹配，因为长度不匹配 */ }
    [a, b, c] =&gt; { /* 这个分支会匹配 */ }
    _ =&gt; { /* 这个通配符是必须的，因为长度不能在编译时确定 */ }
};
<span class="boring">}</span></code></pre></pre>
<p>切片模式在匹配数组时是不可反驳的，只要每个元素都是不可反驳的。
在匹配切片时，只有在形式为单个 <code>..</code> 的 <a href="#rest-patterns">剩余模式</a> 或 <a href="#identifier-patterns">标识符模式</a> 时才是不可反驳的，其中 <code>..</code> 剩余模式作为子模式。</p>
<p>在切片内，没有同时具有下限和上限的区间模式必须用括号括起来，例如 <code>(a..)</code>，以明确其意图是匹配单个切片元素。
同时具有下限和上限的区间模式，例如 <code>a..=b</code> ，不需要用括号括起来。</p>
<h2 id="路径模式"><a class="header" href="#路径模式">路径模式</a></h2>
<blockquote>
<p><strong><sup>语法</sup></strong><br />
<em>路径模式</em> :<br />
      <a href="expressions/path-expr.html"><em>路径表达式</em></a></p>
</blockquote>
<p><em>路径模式</em> 是指引用常量值或没有字段的结构体或枚举变体的模式。</p>
<p>未经修饰的路径模式可以引用：</p>
<ul>
<li>枚举变体</li>
<li>结构体</li>
<li>常量</li>
<li>关联常量</li>
</ul>
<p>修饰的路径模式只能引用关联常量。常量不能是联合类型。结构体和枚举常量必须有 <code>#[derive(PartialEq, Eq)]</code> (而不是仅实现) 。
当路径模式引用结构体或枚举变体并且枚举只有一个变体或类型为不可反驳类型的常量时，路径模式是不可反驳的。当路径模式引用可反驳的常量或具有多个变体的枚举变体时，它们是可反驳的。</p>
<h2 id="或模式"><a class="header" href="#或模式">或模式</a></h2>
<p><em>或模式</em> 是指可以匹配两个或更多子模式的模式 (例如 <code>A | B | C</code> )。它们可以任意嵌套。
从语法上讲，或模式可以在任何其他模式允许的地方使用 (由 <em>模式</em> 生成式表示)，但有一些例外情况，例如 <code>let</code> 绑定和函数和闭包参数 (由 <em>模式非顶层选项</em> 产生式表示) 。</p>
<h3 id="静态语义"><a class="header" href="#静态语义">静态语义</a></h3>
<ol>
<li>
<p>对于任意的模式 <code>p | q</code> ，其中 <code>p</code> 和 <code>q</code> 是任意模式，如果:</p>
<ul>
<li>推断出的 <code>p</code> 的类型不能与推断出的 <code>q</code> 的类型统一，或者</li>
<li>在 <code>p</code> 和 <code>q</code> 中没有引入相同的绑定，或者</li>
<li>在 <code>p</code> 和 <code>q</code> 中具有相同名称的绑定的类型或绑定模式不能相互统一，那么此模式将被视为非法。</li>
</ul>
<p>在上述所有情况中，类型统一都是确切的，且不应用隐式 <a href="type-coercions.html">类型强制转换</a> 。</p>
</li>
<li>
<p>在类型检查表达式 <code>match e_s { a_1 =&gt; e_1, ... a_n =&gt; e_n }</code> 时，对于每个包含形式为 <code>p_i | q_i</code> 的模式的匹配分支 <code>a_i</code> ，如果在其所处的深度 <code>d</code> 处，<code>e_s</code> 中的片段类型不能与 <code>p_i | q_i</code> 统一，则模式 <code>p_i | q_i</code> 被视为非法。</p>
</li>
<li>
<p>在考虑穷尽性时，将模式 <code>p | q</code> 视为同时匹配 <code>p</code> 和 <code>q</code> 。对于某个构造函数 <code>c(x, ..)</code>，分配律适用于 <code>c(p | q, ..rest)</code> 和 <code>c(p, ..rest) | c(q, ..rest)</code> 。递归应用此规则，直到不存在除顶层外的形式为 <code>p | q</code> 的嵌套模式为止。</p>
<p>请注意，<em>&quot;构造函数&quot;</em> 并不是指元组结构模式，而是指任何产品类型的模式。这包括枚举变体、元组结构、具有命名字段的结构体、数组、元组和切片。</p>
</li>
</ol>
<h3 id="动态语义"><a class="header" href="#动态语义">动态语义</a></h3>
<ol>
<li>在深度为 <code>d</code> 处使用模式 <code>c(p | q, ..rest)</code> 匹配被匹配表达式 <code>e_s</code> 的动态语义，其中 <code>c</code> 是某个构造函数，<code>p</code> 和 <code>q</code> 是任意模式，<code>rest</code> 可选地包含 <code>c</code> 中的其他因子，其定义与 <code>c(p, ..rest) | c(q, ..rest)</code> 相同。</li>
</ol>
<h3 id="与其他未限定模式的优先级"><a class="header" href="#与其他未限定模式的优先级">与其他未限定模式的优先级</a></h3>
<p>正如本章的其他地方所示，有几种语法上未限定的模式，包括标识符模式、引用模式和或模式。或模式始终具有最低的优先级。
这使我们可以为未来可能的类型注释功能保留语法空间，并减少歧义。
例如，<code>x @ A(..) | B(..)</code> 将导致错误，即 <code>x</code> 在所有模式中都未绑定。<code>&amp;A(x) | B(x)</code> 将导致在不同的子模式中 <code>x</code> 类型不匹配的错误。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="expressions/underscore-expr.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="type-system.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="expressions/underscore-expr.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="type-system.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
