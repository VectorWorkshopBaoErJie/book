<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>类型布局 - The Rust Reference</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">介绍</a></li><li class="chapter-item expanded "><a href="notation.html"><strong aria-hidden="true">1.</strong> 符号约定</a></li><li class="chapter-item expanded "><a href="lexical-structure.html"><strong aria-hidden="true">2.</strong> 词法结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="input-format.html"><strong aria-hidden="true">2.1.</strong> 输入格式</a></li><li class="chapter-item expanded "><a href="keywords.html"><strong aria-hidden="true">2.2.</strong> 关键字</a></li><li class="chapter-item expanded "><a href="identifiers.html"><strong aria-hidden="true">2.3.</strong> 标识符</a></li><li class="chapter-item expanded "><a href="comments.html"><strong aria-hidden="true">2.4.</strong> 注释</a></li><li class="chapter-item expanded "><a href="whitespace.html"><strong aria-hidden="true">2.5.</strong> 空白</a></li><li class="chapter-item expanded "><a href="tokens.html"><strong aria-hidden="true">2.6.</strong> 令牌</a></li></ol></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">3.</strong> 宏</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macros-by-example.html"><strong aria-hidden="true">3.1.</strong> 实例宏</a></li><li class="chapter-item expanded "><a href="procedural-macros.html"><strong aria-hidden="true">3.2.</strong> 过程宏</a></li></ol></li><li class="chapter-item expanded "><a href="crates-and-source-files.html"><strong aria-hidden="true">4.</strong> Crate和源文件</a></li><li class="chapter-item expanded "><a href="conditional-compilation.html"><strong aria-hidden="true">5.</strong> 条件编译</a></li><li class="chapter-item expanded "><a href="items.html"><strong aria-hidden="true">6.</strong> 条目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="items/modules.html"><strong aria-hidden="true">6.1.</strong> 模块</a></li><li class="chapter-item expanded "><a href="items/extern-crates.html"><strong aria-hidden="true">6.2.</strong> 外部Crate</a></li><li class="chapter-item expanded "><a href="items/use-declarations.html"><strong aria-hidden="true">6.3.</strong> Use 声明</a></li><li class="chapter-item expanded "><a href="items/functions.html"><strong aria-hidden="true">6.4.</strong> 函数</a></li><li class="chapter-item expanded "><a href="items/type-aliases.html"><strong aria-hidden="true">6.5.</strong> 类型别名</a></li><li class="chapter-item expanded "><a href="items/structs.html"><strong aria-hidden="true">6.6.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="items/enumerations.html"><strong aria-hidden="true">6.7.</strong> 枚举</a></li><li class="chapter-item expanded "><a href="items/unions.html"><strong aria-hidden="true">6.8.</strong> 联合体</a></li><li class="chapter-item expanded "><a href="items/constant-items.html"><strong aria-hidden="true">6.9.</strong> 常量条目</a></li><li class="chapter-item expanded "><a href="items/static-items.html"><strong aria-hidden="true">6.10.</strong> 静态条目</a></li><li class="chapter-item expanded "><a href="items/traits.html"><strong aria-hidden="true">6.11.</strong> Trait</a></li><li class="chapter-item expanded "><a href="items/implementations.html"><strong aria-hidden="true">6.12.</strong> 实现</a></li><li class="chapter-item expanded "><a href="items/external-blocks.html"><strong aria-hidden="true">6.13.</strong> 外部块</a></li><li class="chapter-item expanded "><a href="items/generics.html"><strong aria-hidden="true">6.14.</strong> 泛型参数</a></li><li class="chapter-item expanded "><a href="items/associated-items.html"><strong aria-hidden="true">6.15.</strong> 关联条目</a></li></ol></li><li class="chapter-item expanded "><a href="attributes.html"><strong aria-hidden="true">7.</strong> 属性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="attributes/testing.html"><strong aria-hidden="true">7.1.</strong> 测试</a></li><li class="chapter-item expanded "><a href="attributes/derive.html"><strong aria-hidden="true">7.2.</strong> 派生</a></li><li class="chapter-item expanded "><a href="attributes/diagnostics.html"><strong aria-hidden="true">7.3.</strong> 诊断</a></li><li class="chapter-item expanded "><a href="attributes/codegen.html"><strong aria-hidden="true">7.4.</strong> 代码生成</a></li><li class="chapter-item expanded "><a href="attributes/limits.html"><strong aria-hidden="true">7.5.</strong> 约束</a></li><li class="chapter-item expanded "><a href="attributes/type_system.html"><strong aria-hidden="true">7.6.</strong> 类型系统</a></li></ol></li><li class="chapter-item expanded "><a href="statements-and-expressions.html"><strong aria-hidden="true">8.</strong> 语句和表达式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="statements.html"><strong aria-hidden="true">8.1.</strong> 语句</a></li><li class="chapter-item expanded "><a href="expressions.html"><strong aria-hidden="true">8.2.</strong> 表达式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="expressions/literal-expr.html"><strong aria-hidden="true">8.2.1.</strong> 字面值表达式</a></li><li class="chapter-item expanded "><a href="expressions/path-expr.html"><strong aria-hidden="true">8.2.2.</strong> 路径表达式</a></li><li class="chapter-item expanded "><a href="expressions/block-expr.html"><strong aria-hidden="true">8.2.3.</strong> 块表达式</a></li><li class="chapter-item expanded "><a href="expressions/operator-expr.html"><strong aria-hidden="true">8.2.4.</strong> 运算符表达式</a></li><li class="chapter-item expanded "><a href="expressions/grouped-expr.html"><strong aria-hidden="true">8.2.5.</strong> 分组表达式</a></li><li class="chapter-item expanded "><a href="expressions/array-expr.html"><strong aria-hidden="true">8.2.6.</strong> 数组和索引表达式</a></li><li class="chapter-item expanded "><a href="expressions/tuple-expr.html"><strong aria-hidden="true">8.2.7.</strong> 元组和索引表达式</a></li><li class="chapter-item expanded "><a href="expressions/struct-expr.html"><strong aria-hidden="true">8.2.8.</strong> 结构体表达式</a></li><li class="chapter-item expanded "><a href="expressions/call-expr.html"><strong aria-hidden="true">8.2.9.</strong> 调用表达式</a></li><li class="chapter-item expanded "><a href="expressions/method-call-expr.html"><strong aria-hidden="true">8.2.10.</strong> 方法调用表达式</a></li><li class="chapter-item expanded "><a href="expressions/field-expr.html"><strong aria-hidden="true">8.2.11.</strong> 字段访问表达式</a></li><li class="chapter-item expanded "><a href="expressions/closure-expr.html"><strong aria-hidden="true">8.2.12.</strong> 闭包表达式</a></li><li class="chapter-item expanded "><a href="expressions/loop-expr.html"><strong aria-hidden="true">8.2.13.</strong> 循环表达式</a></li><li class="chapter-item expanded "><a href="expressions/range-expr.html"><strong aria-hidden="true">8.2.14.</strong> 区间表达式</a></li><li class="chapter-item expanded "><a href="expressions/if-expr.html"><strong aria-hidden="true">8.2.15.</strong> if 和 if let 表达式</a></li><li class="chapter-item expanded "><a href="expressions/match-expr.html"><strong aria-hidden="true">8.2.16.</strong> 匹配表达式</a></li><li class="chapter-item expanded "><a href="expressions/return-expr.html"><strong aria-hidden="true">8.2.17.</strong> 返回表达式</a></li><li class="chapter-item expanded "><a href="expressions/await-expr.html"><strong aria-hidden="true">8.2.18.</strong> 等待表达式</a></li><li class="chapter-item expanded "><a href="expressions/underscore-expr.html"><strong aria-hidden="true">8.2.19.</strong> 下划线表达式</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="patterns.html"><strong aria-hidden="true">9.</strong> 模式</a></li><li class="chapter-item expanded "><a href="type-system.html"><strong aria-hidden="true">10.</strong> 类型系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">10.1.</strong> 类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/boolean.html"><strong aria-hidden="true">10.1.1.</strong> 布尔类型</a></li><li class="chapter-item expanded "><a href="types/numeric.html"><strong aria-hidden="true">10.1.2.</strong> 数字类型</a></li><li class="chapter-item expanded "><a href="types/textual.html"><strong aria-hidden="true">10.1.3.</strong> 文本类型</a></li><li class="chapter-item expanded "><a href="types/never.html"><strong aria-hidden="true">10.1.4.</strong> 永不类型</a></li><li class="chapter-item expanded "><a href="types/tuple.html"><strong aria-hidden="true">10.1.5.</strong> 元组类型</a></li><li class="chapter-item expanded "><a href="types/array.html"><strong aria-hidden="true">10.1.6.</strong> 数组类型</a></li><li class="chapter-item expanded "><a href="types/slice.html"><strong aria-hidden="true">10.1.7.</strong> 切片类型</a></li><li class="chapter-item expanded "><a href="types/struct.html"><strong aria-hidden="true">10.1.8.</strong> 结构体类型</a></li><li class="chapter-item expanded "><a href="types/enum.html"><strong aria-hidden="true">10.1.9.</strong> 枚举类型</a></li><li class="chapter-item expanded "><a href="types/union.html"><strong aria-hidden="true">10.1.10.</strong> 联合类型</a></li><li class="chapter-item expanded "><a href="types/function-item.html"><strong aria-hidden="true">10.1.11.</strong> 函数条目类型</a></li><li class="chapter-item expanded "><a href="types/closure.html"><strong aria-hidden="true">10.1.12.</strong> 闭包类型</a></li><li class="chapter-item expanded "><a href="types/pointer.html"><strong aria-hidden="true">10.1.13.</strong> 指针类型</a></li><li class="chapter-item expanded "><a href="types/function-pointer.html"><strong aria-hidden="true">10.1.14.</strong> 函数指针类型</a></li><li class="chapter-item expanded "><a href="types/trait-object.html"><strong aria-hidden="true">10.1.15.</strong> Trait 对象类型</a></li><li class="chapter-item expanded "><a href="types/impl-trait.html"><strong aria-hidden="true">10.1.16.</strong> 实现 Trait 的类型</a></li><li class="chapter-item expanded "><a href="types/parameters.html"><strong aria-hidden="true">10.1.17.</strong> 类型参数</a></li><li class="chapter-item expanded "><a href="types/inferred.html"><strong aria-hidden="true">10.1.18.</strong> 推导出的类型</a></li></ol></li><li class="chapter-item expanded "><a href="dynamically-sized-types.html"><strong aria-hidden="true">10.2.</strong> 动态大小类型</a></li><li class="chapter-item expanded "><a href="type-layout.html" class="active"><strong aria-hidden="true">10.3.</strong> 类型布局</a></li><li class="chapter-item expanded "><a href="interior-mutability.html"><strong aria-hidden="true">10.4.</strong> 内部可变性</a></li><li class="chapter-item expanded "><a href="subtyping.html"><strong aria-hidden="true">10.5.</strong> 子类型和协变</a></li><li class="chapter-item expanded "><a href="trait-bounds.html"><strong aria-hidden="true">10.6.</strong> Trait 和生命周期约束</a></li><li class="chapter-item expanded "><a href="type-coercions.html"><strong aria-hidden="true">10.7.</strong> 类型强制转换</a></li><li class="chapter-item expanded "><a href="destructors.html"><strong aria-hidden="true">10.8.</strong> 析构函数</a></li><li class="chapter-item expanded "><a href="lifetime-elision.html"><strong aria-hidden="true">10.9.</strong> 生命周期省略</a></li></ol></li><li class="chapter-item expanded "><a href="special-types-and-traits.html"><strong aria-hidden="true">11.</strong> 特殊类型和Trait</a></li><li class="chapter-item expanded "><a href="names.html"><strong aria-hidden="true">12.</strong> 名称</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="names/namespaces.html"><strong aria-hidden="true">12.1.</strong> 命名空间</a></li><li class="chapter-item expanded "><a href="names/scopes.html"><strong aria-hidden="true">12.2.</strong> 作用域</a></li><li class="chapter-item expanded "><a href="names/preludes.html"><strong aria-hidden="true">12.3.</strong> 预定义</a></li><li class="chapter-item expanded "><a href="paths.html"><strong aria-hidden="true">12.4.</strong> 路径</a></li><li class="chapter-item expanded "><a href="names/name-resolution.html"><strong aria-hidden="true">12.5.</strong> 名称解析</a></li><li class="chapter-item expanded "><a href="visibility-and-privacy.html"><strong aria-hidden="true">12.6.</strong> 可见性和私有性</a></li></ol></li><li class="chapter-item expanded "><a href="memory-model.html"><strong aria-hidden="true">13.</strong> 内存模型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="memory-allocation-and-lifetime.html"><strong aria-hidden="true">13.1.</strong> 内存分配和生命周期</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">13.2.</strong> 变量</a></li></ol></li><li class="chapter-item expanded "><a href="linkage.html"><strong aria-hidden="true">14.</strong> 链接</a></li><li class="chapter-item expanded "><a href="inline-assembly.html"><strong aria-hidden="true">15.</strong> 内联汇编</a></li><li class="chapter-item expanded "><a href="unsafety.html"><strong aria-hidden="true">16.</strong> Unsafety</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="unsafe-keyword.html"><strong aria-hidden="true">16.1.</strong> unsafe 关键字</a></li><li class="chapter-item expanded "><a href="behavior-considered-undefined.html"><strong aria-hidden="true">16.2.</strong> 被视为未定义行为的行为</a></li><li class="chapter-item expanded "><a href="behavior-not-considered-unsafe.html"><strong aria-hidden="true">16.3.</strong> 不被视为不安全的行为</a></li></ol></li><li class="chapter-item expanded "><a href="const_eval.html"><strong aria-hidden="true">17.</strong> 常量求值</a></li><li class="chapter-item expanded "><a href="abi.html"><strong aria-hidden="true">18.</strong> 应用程序二进制接口</a></li><li class="chapter-item expanded "><a href="runtime.html"><strong aria-hidden="true">19.</strong> Rust 运行时</a></li><li class="chapter-item expanded "><a href="appendices.html"><strong aria-hidden="true">20.</strong> 附录</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macro-ambiguity.html"><strong aria-hidden="true">20.1.</strong> 宏 Follow-Set 歧义正式规范</a></li><li class="chapter-item expanded "><a href="influences.html"><strong aria-hidden="true">20.2.</strong> 影响</a></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">20.3.</strong> 术语表</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/type-layout.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="类型布局"><a class="header" href="#类型布局">类型布局</a></h1>
<p>一个类型的布局包括其大小、对齐方式以及其字段的相对偏移量。
对于枚举类型，判别标志的布局和解释方式也是类型布局的一部分。
每次编译都可以更改类型布局。为了避免尝试记录确切的变化，我们只记录目前的可以保证的部分。</p>
<h2 id="大小和对齐"><a class="header" href="#大小和对齐">大小和对齐</a></h2>
<p>所有的值都有一个对齐和大小。</p>
<p>一个值的 <em>对齐</em> 决定了存储这个值的地址必须是什么样的，一个对齐值为 <code>n</code> 的值必须存储在地址是 <code>n</code> 的倍数的位置上。
例如，对齐值为 2 的值必须存储在偶数地址上，而对齐值为 1 的值可以存储在任何地址上。
对齐值以字节为单位衡量，必须至少为 1 ，而且始终是 2 的幂次方。可以使用 <a href="../std/mem/fn.align_of_val.html"><code>align_of_val</code></a> 函数检查一个值的对齐方式。</p>
<p>一个值的 <em>大小</em> 是数组中具有该条目类型的连续元素之间的字节偏移，包括对齐填充。一个值的大小始终是它的对齐值的倍数。
请注意，某些类型的大小为零； 0 被认为是任何对齐值的倍数 (例如，在某些平台上，类型 <code>[u16; 0]</code> 的大小为 0 ，对齐值为 2 )。可以使用 <a href="../std/mem/fn.size_of_val.html"><code>size_of_val</code></a> 函数检查一个值的大小。</p>
<p>所有值都具有相同大小和对齐的类型实现了 <a href="../std/marker/trait.Sized.html"><code>Sized</code></a> trait，并可以使用 <a href="../std/mem/fn.size_of.html"><code>size_of</code></a> 和 <a href="../std/mem/fn.align_of.html"><code>align_of</code></a> 函数进行检查。
那些不是 <a href="../std/marker/trait.Sized.html"><code>Sized</code></a> 的类型称为 <a href="dynamically-sized-types.html">动态大小类型</a> 。由于所有 <code>Sized</code> 类型的值都共享相同的大小和对齐，因此我们将这些共享值称为类型的大小和类型的对齐值。</p>
<h2 id="原始数据布局"><a class="header" href="#原始数据布局">原始数据布局</a></h2>
<p>这张表格给出了大多数原始类型的大小。</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th><code>size_of::&lt;Type&gt;()</code></th></tr></thead><tbody>
<tr><td><code>bool</code></td><td>1</td></tr>
<tr><td><code>u8</code> / <code>i8</code></td><td>1</td></tr>
<tr><td><code>u16</code> / <code>i16</code></td><td>2</td></tr>
<tr><td><code>u32</code> / <code>i32</code></td><td>4</td></tr>
<tr><td><code>u64</code> / <code>i64</code></td><td>8</td></tr>
<tr><td><code>u128</code> / <code>i128</code></td><td>16</td></tr>
<tr><td><code>f32</code></td><td>4</td></tr>
<tr><td><code>f64</code></td><td>8</td></tr>
<tr><td><code>char</code></td><td>4</td></tr>
</tbody></table>
</div>
<p><code>usize</code> 和 <code>isize</code> 的大小足以包含目标平台上的每个地址。例如，在 32 位目标平台上，它的大小为 4 个字节，在 64 位目标平台上，它的大小为 8 个字节。</p>
<p>大多数基本数据类型的对齐方式通常是按照它们的大小对齐的，尽管这是平台特定的行为。特别地，在 x86 架构下， <code>u64</code> 和 <code>f64</code> 仅按照 32 位对齐。</p>
<h2 id="指针和引用的布局"><a class="header" href="#指针和引用的布局">指针和引用的布局</a></h2>
<p>指针和引用具有相同的布局。指针或引用的可变性不会改变其布局。指向有大小的类型的指针与 <code>usize</code> 具有相同的大小和对齐方式。
指向无大小的类型的指针是有大小的。其大小和对齐方式保证至少等于一个指针的大小和对齐方式。</p>
<blockquote>
<p>注意: 虽然你不应该依赖此信息，但是所有指向动态大小类型的指针目前都是 <code>usize</code> 大小的两倍，并具有相同的对齐方式。</p>
</blockquote>
<h2 id="数组布局"><a class="header" href="#数组布局">数组布局</a></h2>
<p>一个 <code>[T; N]</code> 的数组大小为 <code>size_of::&lt;T&gt;() * N</code> ，并且具有与 <code>T</code> 相同的对齐方式。
数组的布局使得从零开始的第 <code>n</code> 个元素相对于数组的起始位置偏移了 <code>n * size_of::&lt;T&gt;()</code> 字节。</p>
<h2 id="切片布局"><a class="header" href="#切片布局">切片布局</a></h2>
<p>切片的布局与它们切片的数组部分相同。</p>
<blockquote>
<p>注意: 这是关于原始 <code>[T]</code> 类型的，而不是指向切片的指针 (<code>&amp;[T]</code> ， <code>Box&lt;[T]&gt;</code> 等) 。</p>
</blockquote>
<h2 id="str-的布局"><a class="header" href="#str-的布局"><code>str</code> 的布局</a></h2>
<p>字符串切片是字符的 UTF-8 表示，其布局与类型为 <code>[u8]</code> 的切片相同。</p>
<h2 id="元组布局"><a class="header" href="#元组布局">元组布局</a></h2>
<p>元组的布局遵循 <a href="#the-default-representation">默认表示</a> 。</p>
<p>例外情况是空元组 (<code>()</code>) ，它被保证作为零大小的类型，大小为 0 ，对齐为 1 。</p>
<h2 id="trait-对象布局"><a class="header" href="#trait-对象布局">Trait 对象布局</a></h2>
<p>Trait 对象的布局与其包含的值相同。</p>
<blockquote>
<p>注意: 这里是指原始的 Trait 对象类型，而不是指指针 (如 <code>&amp;dyn Trait</code> 、 <code>Box&lt;dyn Trait&gt;</code> 等) 到 Trait 对象的类型。</p>
</blockquote>
<h2 id="闭包布局"><a class="header" href="#闭包布局">闭包布局</a></h2>
<p>闭包没有布局的保证。</p>
<h2 id="表示形式"><a class="header" href="#表示形式">表示形式</a></h2>
<p>所有用户定义的复合类型 ( <code>struct</code> 、 <code>enum</code> 和 <code>union</code> ) 都有一个 <em>表示形式</em> ，用于指定类型的布局。
类型的可能表示形式包括:</p>
<ul>
<li><a href="#the-default-representation">默认</a></li>
<li><a href="#the-c-representation"><code>C</code></a></li>
<li><a href="#primitive-representations">原始表示形式</a></li>
<li><a href="#the-transparent-representation"><code>transparent</code></a></li>
</ul>
<p>可以通过在类型上应用 <code>repr</code> 属性来更改类型的表示形式。以下示例显示具有 <code>C</code> 表示形式的结构体。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct ThreeInts {
    first: i16,
    second: i8,
    third: i32
}
<span class="boring">}</span></code></pre></pre>
<p>通过 <code>align</code> 和 <code>packed</code> 修饰符可以分别提高或降低对齐方式。
它们会修改属性中指定的表示方式。如果未指定表示方式，则修改默认表示方式。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 默认的表示，对齐方式被降低到 2。
#[repr(packed(2))]
struct PackedStruct {
    first: i16,
    second: i8,
    third: i32
}

// C 表示，对齐方式被提高到 8。
#[repr(C, align(8))]
struct AlignedStruct {
    first: i16,
    second: i8,
    third: i32
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>注意: 由于表示是条目的属性，表示不依赖于泛型参数。任何两个具有相同名称的类型都具有相同的表示。例如， <code>Foo&lt;Bar&gt;</code> 和 <code>Foo&lt;Baz&gt;</code> 都具有相同的表示。</p>
</blockquote>
<p>类型的表示可以改变字段之间的填充，但不会改变字段本身的布局。例如，具有 <code>C</code> 表示的结构体中包含具有默认表示的结构体 <code>Inner</code> ，不会改变 <code>Inner</code> 的布局。</p>
<h3 id="默认表示形式"><a class="header" href="#默认表示形式">默认表示形式</a></h3>
<p>没有 <code>repr</code> 属性的名义类型采用默认表示形式。非正式地说，这个表示形式也被称为 <code>rust</code> 表示形式。此表示形式所做的唯一数据布局保证是为了保持正确性。它们是:</p>
<ol>
<li>字段正确对齐。</li>
<li>字段不重叠。</li>
<li>类型的对齐方式至少是其字段的最大对齐方式。</li>
</ol>
<p>严格地说，第一个保证意味着任何字段的偏移量都是该字段的对齐方式的倍数。
第二个保证意味着可以对字段进行排序，使得任何字段的偏移量加上其大小小于或等于排序中下一个字段的偏移量。排序不必与在类型声明中指定字段的顺序相同。</p>
<p>请注意，第二个保证并不意味着字段具有不同的地址: 零大小类型可能与结构中其他字段具有相同的地址。</p>
<p>此表示形式没有其他数据布局保证。</p>
<h3 id="c-表示形式"><a class="header" href="#c-表示形式"><code>C</code> 表示形式</a></h3>
<p><code>C</code> 表示形式旨在实现两个目的。一个目的是创建可与 C 语言互操作的类型，另一个目的是创建可以对其执行依赖于数据布局的操作 (如将值重新解释为不同类型) 的类型。
由于这个双重目的，可以创建对于与 C 编程语言进行接口编程无用的类型。</p>
<p>这个表示形式可以应用于结构体、联合体和枚举。但是，<a href="items/enumerations.html#zero-variant-enums">空变体枚举</a> 不支持 <code>C</code> 表示。</p>
<h4 id="reprc-结构体"><a class="header" href="#reprc-结构体"><code>#[repr(C)]</code> 结构体</a></h4>
<p>结构体的对齐方式是其中对齐要求最高的字段的对齐方式。</p>
<p>字段的大小和偏移量由以下算法决定。</p>
<p>将当前偏移量初始化为 0 字节。</p>
<p>对于结构体中的每个字段，按照声明顺序，首先确定字段的大小和对齐方式。
如果当前偏移量不是字段对齐要求的倍数，则添加填充字节，直到当前偏移量是字段对齐要求的倍数。
字段的偏移量是当前偏移量。然后增加当前偏移量的大小。</p>
<p>最后，结构体的大小是将当前偏移量向上舍入到结构体对齐方式的最接近的倍数。</p>
<p>以下是这个算法的伪代码描述。</p>
<!-- ignore: pseudocode -->
<pre><code class="language-rust ignore">/// 返回在偏移 `offset` 之后需要的填充量，以确保以下地址将对齐到 `alignment`。
fn padding_needed_for(offset: usize, alignment: usize) -&gt; usize {
    let misalignment = offset % alignment;
    if misalignment &gt; 0 {
        // 向上舍入到下一个 `alignment` 的倍数
        alignment - misalignment
    } else {
        // 已经是 `alignment` 的倍数
        0
    }
}

// 计算结构体中最大字段的对齐方式，作为结构体自身的对齐方式
struct.alignment = struct.fields().map(|field| field.alignment).max();

let current_offset = 0;

for field in struct.fields_in_declaration_order() {
    // 增加当前偏移量，使其成为此字段的对齐方式的倍数。对于第一个字段，这将始终为零。
    // 被跳过的字节称为填充字节。
    current_offset += padding_needed_for(current_offset, field.alignment);

    struct[field].offset = current_offset;

    current_offset += field.size;
}

// 结构体的大小为当前偏移量加上在此处添加的填充量，以确保结构体整体对齐到 `alignment` 的倍数
struct.size = current_offset + padding_needed_for(current_offset, struct.alignment);</code></pre>
<div class="warning">
<p>警告：此伪代码使用一种简单算法，为了清晰起见忽略了溢出问题。为了在实际代码中执行内存布局计算，请使用 <a href="../std/alloc/struct.Layout.html"><code>Layout</code></a> 。</p>
</div>
<blockquote>
<p>注意: 此算法可能会产生大小为零的结构体。在 C 中，像 <code>struct Foo { }</code> 这样的空结构体声明是不合法的。
但是，gcc 和 clang 都支持启用这样的结构体，并将它们分配为大小为零。
相比之下，C++ 给空结构体赋予大小为 1 ，除非它们是从其他结构体继承而来的，或者它们是带有 <code>[[no_unique_address]]</code> 属性的字段，在这种情况下，它们不会增加结构体的整体大小。</p>
</blockquote>
<h4 id="reprc-联合体"><a class="header" href="#reprc-联合体"><code>#[repr(C)]</code> 联合体</a></h4>
<p>使用 <code>#[repr(C)]</code> 声明的联合体将与目标平台上等效的 C 语言联合体声明具有相同的大小和对齐方式。
该联合体的大小将是其所有字段的最大大小舍入为其对齐方式，其对齐方式将是其所有字段的最大对齐方式。这些最大值可以来自不同的字段。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
union Union {
    f1: u16,
    f2: [u8; 4],
}

assert_eq!(std::mem::size_of::&lt;Union&gt;(), 4);  // 来自 f2
assert_eq!(std::mem::align_of::&lt;Union&gt;(), 2); // 来自 f1

#[repr(C)]
union SizeRoundedUp {
   a: u32,
   b: [u16; 3],
}

assert_eq!(std::mem::size_of::&lt;SizeRoundedUp&gt;(), 8);  // 大小为 6，来自 b，舍入为 8，来自 a 的对齐
assert_eq!(std::mem::align_of::&lt;SizeRoundedUp&gt;(), 4); // 来自 a
<span class="boring">}</span></code></pre></pre>
<h4 id="reprc-无字段的枚举"><a class="header" href="#reprc-无字段的枚举"><code>#[repr(C)]</code> 无字段的枚举</a></h4>
<p>对于 <a href="items/enumerations.html#field-less-enum">无字段的枚举</a> ，其 <code>C</code> 表示具有目标平台 C ABI 的默认 <code>enum</code> 大小和对齐方式。</p>
<blockquote>
<p>注意：C 中的枚举表示是实现定义的，因此这只是一个 &quot;最佳猜测&quot; 。特别地，当所关注的 C 代码使用某些标志编译时，这可能是不正确的。</p>
</blockquote>
<div class="warning">
<p>警告：C 语言中的 <code>enum</code> 和 Rust 的 <a href="items/enumerations.html#field-less-enum">无字段的枚举</a> 在这种表示方式下存在关键差异。
在 C 中，<code>enum</code> 主要是一个 <code>typedef</code> 加上一些命名常量；换句话说， <code>enum</code> 类型的对象可以容纳任何整数值。
例如，在 <code>C</code> 中，这通常用于位标志。
相比之下，Rust 的 <a href="items/enumerations.html#field-less-enum">无字段的枚举</a> 只能合法地容纳判别值，其他一切都是 <a href="behavior-considered-undefined.html">未定义行为</a> 。
因此，在 FFI 中使用无字段的枚举来模拟 C <code>enum</code> 通常是错误的。</p>
</div>
<h4 id="reprc-枚举类型的字段"><a class="header" href="#reprc-枚举类型的字段"><code>#[repr(C)]</code> 枚举类型的字段</a></h4>
<p>使用 <code>#[repr(C)]</code> 声明的带有字段的枚举类型的表示形式是一个带有两个字段的 <code>repr(C)</code> 结构体，也称为 C 语言中的 &quot;带标签联合体&quot; ：</p>
<ul>
<li>一个去掉所有字段的 <code>repr(C)</code> 版本的枚举类型 (&quot;标签&quot;)</li>
<li>一个 <code>repr(C)</code> 联合体，其中包含每个有字段的变体的 <code>repr(C)</code> 结构体 (&quot;有效载荷&quot;)</li>
</ul>
<blockquote>
<p>注意: 由于 <code>repr(C)</code> 结构体和联合体的表示方式，如果一个变体只有一个字段，在联合体中直接放置该字段或将其包装在结构体中没有区别；
因此，任何希望操作这种 <code>enum</code> 表示形式的系统都可以使用对他们来说更方便或更一致的形式。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这个枚举与下面的结构体具有相同的表示方式
#[repr(C)]
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
 }

// ... 这个结构体
#[repr(C)]
struct MyEnumRepr {
    tag: MyEnumDiscriminant, // 枚举的判别值
    payload: MyEnumFields, // 枚举的数据部分
}

// 这是枚举的判别值枚举
#[repr(C)]
enum MyEnumDiscriminant { A, B, C, D }

// 这是变体的联合体
#[repr(C)]
union MyEnumFields {
    A: MyAFields,
    B: MyBFields,
    C: MyCFields,
    D: MyDFields,
}

#[repr(C)]
#[derive(Copy, Clone)]
struct MyAFields(u32);

#[repr(C)]
#[derive(Copy, Clone)]
struct MyBFields(f32, u64);

#[repr(C)]
#[derive(Copy, Clone)]
struct MyCFields { x: u32, y: u8 }

// 这个结构体可以省略 (它是零大小的类型) ，并且它必须在 C/C++ 头文件中。
#[repr(C)]
#[derive(Copy, Clone)]
struct MyDFields;
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>注意: 带有非 <code>Copy</code> 字段的 <code>union</code> 是未稳定的，请参见 <a href="https://github.com/rust-lang/rust/issues/55149">55149</a>。</p>
</blockquote>
<h3 id="原始表示"><a class="header" href="#原始表示">原始表示</a></h3>
<p><em>原始表示</em> 是与原始整数类型具有相同名称的表示。
即：<code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code>、<code>usize</code>、<code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code>、<code>i128</code>和<code>isize</code>。</p>
<p>原始表示仅适用于枚举类型，并根据枚举是否有字段具有不同的行为。
对于 <a href="items/enumerations.html#zero-variant-enums">零变体枚举</a> 来说，使用原始表示是错误的。将两个原始表示结合在一起也是错误的。</p>
<h4 id="无字段枚举的原始表示"><a class="header" href="#无字段枚举的原始表示">无字段枚举的原始表示</a></h4>
<p>对于 <a href="items/enumerations.html#field-less-enum">无字段枚举</a> ，原始表示将大小和对齐方式设置为与同名的原始类型相同。
例如，具有 <code>u8</code> 表示的无字段枚举只能具有 0 到 255 之间 (包括 0 和 255 ) 的鉴别标志。</p>
<h4 id="具有字段的枚举的基本表示"><a class="header" href="#具有字段的枚举的基本表示">具有字段的枚举的基本表示</a></h4>
<p>具有字段的基本表示枚举的表示是 <code>repr(C)</code> 联合，其中包含每个变量的 <code>repr(C)</code> 结构。
联合中每个结构的第一个字段是去除所有字段的枚举的基本表示版本 (&quot;标签&quot;) ，剩余字段是该变量的字段。</p>
<blockquote>
<p>注意：如果标签在联合中有自己的成员，则该表示不会改变，这样可以更清晰地进行操作 (尽管为了遵循 C++ 标准，标签成员应该包装在一个 <code>struct</code> 中)。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这个枚举和...具有相同的表示形式
#[repr(u8)]
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
 }

// ... 这个联合体。
#[repr(C)]
union MyEnumRepr {
    A: MyVariantA,
    B: MyVariantB,
    C: MyVariantC,
    D: MyVariantD,
}

// 这是鉴别器枚举。
#[repr(u8)]
#[derive(Copy, Clone)]
enum MyEnumDiscriminant { A, B, C, D }

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantA(MyEnumDiscriminant, u32);

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantB(MyEnumDiscriminant, f32, u64);

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantC { tag: MyEnumDiscriminant, x: u32, y: u8 }

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantD(MyEnumDiscriminant);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>注意: 具有非 <code>Copy</code> 字段的联合体是未稳定的，请参见 <a href="https://github.com/rust-lang/rust/issues/55149">55149</a> 。</p>
</blockquote>
<h4 id="将带字段的枚举的原始表示与-reprc-结合使用"><a class="header" href="#将带字段的枚举的原始表示与-reprc-结合使用">将带字段的枚举的原始表示与 <code>#[repr(C)]</code> 结合使用</a></h4>
<p>对于带字段的枚举，还可以将 <code>repr(C)</code> 和原始表示 (例如 <code>repr(C, u8)</code>) 结合使用。这会修改 <a href="#reprc-enums-with-fields"><code>repr(C)</code></a> ，将鉴别器枚举的表示方式更改为所选择的原始表示。
因此，如果你选择了 <code>u8</code> 表示方式，则鉴别器枚举的大小和对齐方式将为 1 字节。来自 <a href="#reprc-enums-with-fields">之前</a> 示例的鉴别器枚举如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C, u8)] // 添加了 `u8`
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
 }

// ...

#[repr(u8)] // 所以这里使用了 `u8` 而不是 `C`
enum MyEnumDiscriminant { A, B, C, D }

// ...
<span class="boring">}</span></code></pre></pre>
<p>例如，对于一个 <code>repr(C, u8)</code> 枚举，不可能有 257 个唯一的鉴别器 (&quot;标签&quot;) ，而只有一个 <code>repr(C)</code> 属性的相同枚举将在没有任何问题的情况下编译。</p>
<p>在 <code>repr(C)</code> 之外使用原始表示方式可能会改变枚举的大小:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
enum EnumC {
    Variant0(u8),
    Variant1,
}

#[repr(C, u8)]
enum Enum8 {
    Variant0(u8),
    Variant1,
}

#[repr(C, u16)]
enum Enum16 {
    Variant0(u8),
    Variant1,
}

// C 表示方式的大小取决于平台
assert_eq!(std::mem::size_of::&lt;EnumC&gt;(), 8);
// Enum8::Variant0 中鉴别器和值各占 1 个字节
assert_eq!(std::mem::size_of::&lt;Enum8&gt;(), 2);
// Enum16::Variant0 中鉴别器和值各占 1 个字节，再加上 1 个字节的填充
assert_eq!(std::mem::size_of::&lt;Enum16&gt;(), 4);
<span class="boring">}</span></code></pre></pre>
<h3 id="对齐修饰符"><a class="header" href="#对齐修饰符">对齐修饰符</a></h3>
<p><code>align</code> 和 <code>packed</code> 修饰符可以用于分别提高或降低 <code>struct</code> 和 <code>union</code> 的对齐方式。
<code>packed</code> 也可以改变字段之间的填充 (但不会改变任何字段内部的填充) 。</p>
<p>对齐方式是以整数形式的参数指定的，形式为 <code>#[repr(align(x))]</code> 或 <code>#[repr(packed(x))]</code> 。
对齐值必须是从 1 到 2<sup>29</sup> 的 2 的幂。对于 <code>packed</code>，如果没有给出值，例如 <code>#[repr(packed)]</code>，那么该值为 1。
对于 <code>align</code>，如果指定的对齐方式小于没有 <code>align</code> 修饰符的类型的对齐方式，则对齐方式不受影响。</p>
<p>对于 <code>packed</code>，如果指定的对齐方式大于没有 <code>packed</code> 修饰符的类型的对齐方式，则对齐方式和布局不受影响。
对于定位字段的目的，每个字段的对齐方式是指定的对齐方式和字段类型的对齐方式中较小的一个。
确保字段间的填充是最小的，以满足每个字段的 (可能已更改的) 对齐方式 (尽管请注意，单独使用 <code>packed</code> 不能提供有关字段顺序的任何保证) 。
这些规则的一个重要后果是，具有 <code>#[repr(packed(1))]</code> (或 <code>#[repr(packed)]</code>) 的类型将没有字段间的填充。</p>
<p><code>align</code> 和 <code>packed</code> 修饰符不能应用于同一类型，<code>packed</code> 类型不能传递地包含另一个 <code>align</code>ed 类型。
<code>align</code> 和 <code>packed</code> 只能应用于 [默认] 和 <a href="#the-c-representation"><code>C</code></a> 表示。</p>
<p><code>align</code> 修饰符也可以应用于 <code>enum</code>。 
当这样做时，<code>enum</code> 的对齐方式的效果与如果将 <code>enum</code> 包装在具有相同 <code>align</code> 修饰符的新类型 <code>struct</code> 中相同。</p>
<div class="warning">
<p><em><strong>警告:</strong></em> 对未对齐的指针进行解引用是 <a href="behavior-considered-undefined.html">未定义行为</a> ，可以 <a href="https://github.com/rust-lang/rust/issues/27060">安全地创建指向 <code>packed</code> 字段的未对齐指针</a>。
与 Rust 中所有安全地创建未定义行为的方式一样，这是一个错误。</p>
</div>
<h3 id="transparent-表示"><a class="header" href="#transparent-表示"><code>transparent</code> 表示</a></h3>
<p><code>transparent</code> 表示只能用于具有以下特点的 <code>struct</code> 或 <code>enum</code> 中的单个变体:</p>
<ul>
<li>具有非零大小的单个字段，且</li>
<li>具有大小为 0 且对齐方式为 1 的任意数量的字段 (例如 <a href="special-types-and-traits.html#phantomdatat"><code>PhantomData&lt;T&gt;</code></a>) 。</li>
</ul>
<p>具有此表示的结构体和枚举具有与单个非零大小字段相同的布局和 ABI 。</p>
<p>这与 <code>C</code> 表示不同，因为具有 <code>C</code> 表示的结构体将始终具有 <code>C</code> <code>struct</code> 的 ABI，而例如具有基元字段的 <code>transparent</code> 表示的结构体将具有基元字段的 ABI 。</p>
<p>由于此表示将类型布局委托给另一种类型，因此无法与任何其他表示一起使用。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="dynamically-sized-types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="interior-mutability.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="dynamically-sized-types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="interior-mutability.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
