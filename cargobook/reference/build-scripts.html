<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>构建脚本 - The Cargo Book</title>


        <!-- Custom HTML head -->
        <style>
            dd {
                margin-bottom: 1em;
            }
        </style>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">简介</a></li><li class="chapter-item expanded "><a href="../getting-started/index.html"><strong aria-hidden="true">1.</strong> 入门指南</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-started/installation.html"><strong aria-hidden="true">1.1.</strong> 安装</a></li><li class="chapter-item expanded "><a href="../getting-started/first-steps.html"><strong aria-hidden="true">1.2.</strong> Cargo起步</a></li></ol></li><li class="chapter-item expanded "><a href="../guide/index.html"><strong aria-hidden="true">2.</strong> Cargo指南</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guide/why-cargo-exists.html"><strong aria-hidden="true">2.1.</strong> 为何有Cargo</a></li><li class="chapter-item expanded "><a href="../guide/creating-a-new-project.html"><strong aria-hidden="true">2.2.</strong> 创建新包</a></li><li class="chapter-item expanded "><a href="../guide/working-on-an-existing-project.html"><strong aria-hidden="true">2.3.</strong> 让包工作</a></li><li class="chapter-item expanded "><a href="../guide/dependencies.html"><strong aria-hidden="true">2.4.</strong> 依赖</a></li><li class="chapter-item expanded "><a href="../guide/project-layout.html"><strong aria-hidden="true">2.5.</strong> 包的设计</a></li><li class="chapter-item expanded "><a href="../guide/cargo-toml-vs-cargo-lock.html"><strong aria-hidden="true">2.6.</strong> Cargo.toml vs Cargo.lock</a></li><li class="chapter-item expanded "><a href="../guide/tests.html"><strong aria-hidden="true">2.7.</strong> 测试</a></li><li class="chapter-item expanded "><a href="../guide/continuous-integration.html"><strong aria-hidden="true">2.8.</strong> 持续集成</a></li><li class="chapter-item expanded "><a href="../guide/cargo-home.html"><strong aria-hidden="true">2.9.</strong> Cargo主页</a></li><li class="chapter-item expanded "><a href="../guide/build-cache.html"><strong aria-hidden="true">2.10.</strong> 构建缓存</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/index.html"><strong aria-hidden="true">3.</strong> Cargo参考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/specifying-dependencies.html"><strong aria-hidden="true">3.1.</strong> 指定依赖</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/overriding-dependencies.html"><strong aria-hidden="true">3.1.1.</strong> 覆盖依赖</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/manifest.html"><strong aria-hidden="true">3.2.</strong> 配置格式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/cargo-targets.html"><strong aria-hidden="true">3.2.1.</strong> Cargo目标</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/workspaces.html"><strong aria-hidden="true">3.3.</strong> 工作空间</a></li><li class="chapter-item expanded "><a href="../reference/features.html"><strong aria-hidden="true">3.4.</strong> 特性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/features-examples.html"><strong aria-hidden="true">3.4.1.</strong> 特性示例</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/profiles.html"><strong aria-hidden="true">3.5.</strong> 编译设置</a></li><li class="chapter-item expanded "><a href="../reference/config.html"><strong aria-hidden="true">3.6.</strong> 配置</a></li><li class="chapter-item expanded "><a href="../reference/environment-variables.html"><strong aria-hidden="true">3.7.</strong> 环境变量</a></li><li class="chapter-item expanded "><a href="../reference/build-scripts.html" class="active"><strong aria-hidden="true">3.8.</strong> 构建脚本</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/build-script-examples.html"><strong aria-hidden="true">3.8.1.</strong> 构建脚本示例</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/publishing.html"><strong aria-hidden="true">3.9.</strong> 发布到crates.io</a></li><li class="chapter-item expanded "><a href="../reference/pkgid-spec.html"><strong aria-hidden="true">3.10.</strong> 包ID规范</a></li><li class="chapter-item expanded "><a href="../reference/source-replacement.html"><strong aria-hidden="true">3.11.</strong> 源替换</a></li><li class="chapter-item expanded "><a href="../reference/external-tools.html"><strong aria-hidden="true">3.12.</strong> 插件</a></li><li class="chapter-item expanded "><a href="../reference/registries.html"><strong aria-hidden="true">3.13.</strong> 注册中心</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/running-a-registry.html"><strong aria-hidden="true">3.13.1.</strong> 运行注册中心</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/registry-index.html"><strong aria-hidden="true">3.13.1.1.</strong> 注册中心索引</a></li><li class="chapter-item expanded "><a href="../reference/registry-web-api.html"><strong aria-hidden="true">3.13.1.2.</strong> 注册中心Web API</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../reference/resolver.html"><strong aria-hidden="true">3.14.</strong> 依赖解析</a></li><li class="chapter-item expanded "><a href="../reference/semver.html"><strong aria-hidden="true">3.15.</strong> 语义化兼容</a></li><li class="chapter-item expanded "><a href="../reference/future-incompat-report.html"><strong aria-hidden="true">3.16.</strong> 未来不兼容报告</a></li><li class="chapter-item expanded "><a href="../reference/timings.html"><strong aria-hidden="true">3.17.</strong> 报告构建时间</a></li><li class="chapter-item expanded "><a href="../reference/unstable.html"><strong aria-hidden="true">3.18.</strong> 不稳定特性</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/index.html"><strong aria-hidden="true">4.</strong> Cargo命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/general-commands.html"><strong aria-hidden="true">4.1.</strong> 常用命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo.html"><strong aria-hidden="true">4.1.1.</strong> cargo</a></li><li class="chapter-item expanded "><a href="../commands/cargo-help.html"><strong aria-hidden="true">4.1.2.</strong> cargo help</a></li><li class="chapter-item expanded "><a href="../commands/cargo-version.html"><strong aria-hidden="true">4.1.3.</strong> cargo version</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/build-commands.html"><strong aria-hidden="true">4.2.</strong> 构建命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo-bench.html"><strong aria-hidden="true">4.2.1.</strong> cargo bench</a></li><li class="chapter-item expanded "><a href="../commands/cargo-build.html"><strong aria-hidden="true">4.2.2.</strong> cargo build</a></li><li class="chapter-item expanded "><a href="../commands/cargo-check.html"><strong aria-hidden="true">4.2.3.</strong> cargo check</a></li><li class="chapter-item expanded "><a href="../commands/cargo-clean.html"><strong aria-hidden="true">4.2.4.</strong> cargo clean</a></li><li class="chapter-item expanded "><a href="../commands/cargo-doc.html"><strong aria-hidden="true">4.2.5.</strong> cargo doc</a></li><li class="chapter-item expanded "><a href="../commands/cargo-fetch.html"><strong aria-hidden="true">4.2.6.</strong> cargo fetch</a></li><li class="chapter-item expanded "><a href="../commands/cargo-fix.html"><strong aria-hidden="true">4.2.7.</strong> cargo fix</a></li><li class="chapter-item expanded "><a href="../commands/cargo-run.html"><strong aria-hidden="true">4.2.8.</strong> cargo run</a></li><li class="chapter-item expanded "><a href="../commands/cargo-rustc.html"><strong aria-hidden="true">4.2.9.</strong> cargo rustc</a></li><li class="chapter-item expanded "><a href="../commands/cargo-rustdoc.html"><strong aria-hidden="true">4.2.10.</strong> cargo rustdoc</a></li><li class="chapter-item expanded "><a href="../commands/cargo-test.html"><strong aria-hidden="true">4.2.11.</strong> cargo test</a></li><li class="chapter-item expanded "><a href="../commands/cargo-report.html"><strong aria-hidden="true">4.2.12.</strong> cargo report</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/manifest-commands.html"><strong aria-hidden="true">4.3.</strong> 配置命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo-add.html"><strong aria-hidden="true">4.3.1.</strong> cargo add</a></li><li class="chapter-item expanded "><a href="../commands/cargo-generate-lockfile.html"><strong aria-hidden="true">4.3.2.</strong> cargo generate-lockfile</a></li><li class="chapter-item expanded "><a href="../commands/cargo-locate-project.html"><strong aria-hidden="true">4.3.3.</strong> cargo locate-project</a></li><li class="chapter-item expanded "><a href="../commands/cargo-metadata.html"><strong aria-hidden="true">4.3.4.</strong> cargo metadata</a></li><li class="chapter-item expanded "><a href="../commands/cargo-pkgid.html"><strong aria-hidden="true">4.3.5.</strong> cargo pkgid</a></li><li class="chapter-item expanded "><a href="../commands/cargo-remove.html"><strong aria-hidden="true">4.3.6.</strong> cargo remove</a></li><li class="chapter-item expanded "><a href="../commands/cargo-tree.html"><strong aria-hidden="true">4.3.7.</strong> cargo tree</a></li><li class="chapter-item expanded "><a href="../commands/cargo-update.html"><strong aria-hidden="true">4.3.8.</strong> cargo update</a></li><li class="chapter-item expanded "><a href="../commands/cargo-vendor.html"><strong aria-hidden="true">4.3.9.</strong> cargo vendor</a></li><li class="chapter-item expanded "><a href="../commands/cargo-verify-project.html"><strong aria-hidden="true">4.3.10.</strong> cargo verify-project</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/package-commands.html"><strong aria-hidden="true">4.4.</strong> 包命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo-init.html"><strong aria-hidden="true">4.4.1.</strong> cargo init</a></li><li class="chapter-item expanded "><a href="../commands/cargo-install.html"><strong aria-hidden="true">4.4.2.</strong> cargo install</a></li><li class="chapter-item expanded "><a href="../commands/cargo-new.html"><strong aria-hidden="true">4.4.3.</strong> cargo new</a></li><li class="chapter-item expanded "><a href="../commands/cargo-search.html"><strong aria-hidden="true">4.4.4.</strong> cargo search</a></li><li class="chapter-item expanded "><a href="../commands/cargo-uninstall.html"><strong aria-hidden="true">4.4.5.</strong> cargo uninstall</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/publishing-commands.html"><strong aria-hidden="true">4.5.</strong> 发布命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo-login.html"><strong aria-hidden="true">4.5.1.</strong> cargo login</a></li><li class="chapter-item expanded "><a href="../commands/cargo-owner.html"><strong aria-hidden="true">4.5.2.</strong> cargo owner</a></li><li class="chapter-item expanded "><a href="../commands/cargo-package.html"><strong aria-hidden="true">4.5.3.</strong> cargo package</a></li><li class="chapter-item expanded "><a href="../commands/cargo-publish.html"><strong aria-hidden="true">4.5.4.</strong> cargo publish</a></li><li class="chapter-item expanded "><a href="../commands/cargo-yank.html"><strong aria-hidden="true">4.5.5.</strong> cargo yank</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">5.</strong> 常见问题</a></li><li class="chapter-item expanded "><a href="../appendix/glossary.html"><strong aria-hidden="true">6.</strong> 附录: 词汇表</a></li><li class="chapter-item expanded "><a href="../appendix/git-authentication.html"><strong aria-hidden="true">7.</strong> 附录: Git认证</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cargo Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/cargo/tree/master/src/doc/src" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/cargo/edit/master/src/doc/src/reference/build-scripts.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="构建脚本"><a class="header" href="#构建脚本">构建脚本</a></h2>
<p>有些包需要编译第三方的非Rust代码，例如C库。
有些包需要链接到C库，这些库可能位于系统中，也可能需要从源代码构建。
还有包需要一些功能性工具，比如在构建前生成代码(想想语法分析生成器)。</p>
<p>Cargo的目的并不是要取代为这些任务而优化的其他工具，Cargo可以通过定制构建脚本与这些工具进行整合。
在包的根目录下放置一个名为 <code>build.rs</code> 的文件，就会使Cargo在构建包之前编译该脚本并执行。</p>
<pre><code class="language-rust ignore">// 自定义构建脚本实例
fn main() {
    // 告诉Cargo，如果给定的文件发生更改，则重新运行此构建脚本。
    println!(&quot;cargo:rerun-if-changed=src/hello.c&quot;);
    // 使用 `cc` crate 构建一个C文件并静态链接它。
    cc::Build::new()
        .file(&quot;src/hello.c&quot;)
        .compile(&quot;hello&quot;);
}</code></pre>
<p>构建脚本的一些用例如下:</p>
<ul>
<li>构建C库绑定。</li>
<li>在主机系统上查找C库。</li>
<li>根据规范生成Rust模块。</li>
<li>执行crate所需的任意平台特定配置。</li>
</ul>
<p>下面的章节描述了构建脚本的工作方式，<a href="build-script-examples.html">示例章节</a> 展示了关于如何编写脚本的各种示例。</p>
<blockquote>
<p>注意: 可以使用 <a href="manifest.html#package-build"><code>package.build</code> 配置键</a> 来改变构建脚本的名称，或完全禁用它。</p>
</blockquote>
<h3 id="构建脚本的生命周期"><a class="header" href="#构建脚本的生命周期">构建脚本的生命周期</a></h3>
<p>在构建包之前，Cargo会将构建脚本编译成可执行文件(如果还没有构建的话)。
然后运行脚本，该脚本可以执行任意数量的任务。
脚本可以通过将带有 <code>cargo:</code> 前缀的特殊格式化命令打印到标准输出来与Cargo通信。</p>
<p>如果构建脚本的任意源文件或依赖项发生更改，将重新构建脚本。</p>
<p>默认情况下，如果包中的任何文件发生变化，Cargo 会重新运行构建脚本。
通常，最好使用下面 <a href="#change-detection">change detection</a> 一节中描述的 <code>rerun-if</code> 命令，以缩小触发构建脚本重新运行的关注点。</p>
<p>一旦构建脚本成功执行完毕，就会编译包的其他部分。
脚本应该以非零的退出代码退出，以便在出现错误时停止编译，在这种情况下，编译脚本的输出将显示在终端。</p>
<h3 id="构建脚本的输入"><a class="header" href="#构建脚本的输入">构建脚本的输入</a></h3>
<p>当构建脚本运行时，若有一些输入到构建脚本，则都是以 <a href="environment-variables.html#environment-variables-cargo-sets-for-build-scripts">环境变量</a> 的形式传递。</p>
<p>除了环境变量外，构建脚本的当前目录是构建脚本的包的源目录。</p>
<h3 id="构建脚本的输出"><a class="header" href="#构建脚本的输出">构建脚本的输出</a></h3>
<p>构建脚本可以将任何输出文件或中间构件保存在 <a href="environment-variables.html#environment-variables-cargo-sets-for-build-scripts"><code>OUT_DIR</code> 环境变量</a> 指定的目录中。
脚本不应该修改该目录之外的任何文件。</p>
<p>构建脚本通过打印到标准输出与Cargo交流。
Cargo会把每一行以 <code>cargo:</code> 开头的字解释为影响包编译的指令。忽略所有其他行。</p>
<blockquote>
<p>注意：构建脚本打印的 <code>cargo:</code> 指令的顺序 <em>可能</em> 会影响 <code>cargo</code> 传递给 <code>rustc</code> 的参数的顺序。
反过来，传递给 <code>rustc</code> 的参数顺序也可能影响传递给链接器的参数顺序。
因此，你要注意构建脚本的指令顺序。
例如，如果对象 <code>foo</code> 需要与库 <code>bar</code> 链接，你可能需要确保库 <code>bar</code> 的 <a href="#rustc-link-lib"><code>cargo:rustc-link-lib</code></a> 指令出现在链接对象 <code>foo</code> 的指令 <em>之后</em> 。</p>
</blockquote>
<p>在正常的编译过程中，脚本的输出被隐藏在终端中。
如果你想在终端上直接看到输出，可以用 <code>-vv</code> 标志来调用Cargo的 &quot;very verbose&quot; 。
这只发生在编译脚本运行的时候。
如果Cargo认为没有任何变化，它就不会重新运行脚本，更多信息请参见下面的 <a href="#change-detection">变化检测</a> 。</p>
<p>构建脚本打印到标准输出的所有行都被写入一个文件，如 <code>target/debug/build/&lt;pkg&gt;/output</code>(确切位置可能取决于你的配置)。标准错误输出也保存在同一目录。</p>
<p>以下是 Cargo 所认识的指令摘要，每条指令都在下面详细说明。</p>
<ul>
<li><a href="#rerun-if-changed"><code>cargo:rerun-if-changed=PATH</code></a> — 告诉Cargo何时重新运行脚本。</li>
<li><a href="#rerun-if-env-changed"><code>cargo:rerun-if-env-changed=VAR</code></a> — 告诉Cargo何时重新运行脚本。</li>
<li><a href="#rustc-link-arg"><code>cargo:rustc-link-arg=FLAG</code></a> — 为基准、二进制文件、<code>cdylib</code> crates、示例和测试的链接器传递自定义标志。</li>
<li><a href="#rustc-link-arg-bin"><code>cargo:rustc-link-arg-bin=BIN=FLAG</code></a> — 将自定义标志传递给二进制 <code>BIN</code> 的链接器。</li>
<li><a href="#rustc-link-arg-bins"><code>cargo:rustc-link-arg-bins=FLAG</code></a> — 将自定义标志传递给二进制文件的链接器。</li>
<li><a href="#rustc-link-arg-tests"><code>cargo:rustc-link-arg-tests=FLAG</code></a> —  将自定义标志传递给链接器进行测试。</li>
<li><a href="#rustc-link-arg-examples"><code>cargo:rustc-link-arg-examples=FLAG</code></a> — 将自定义标志传递给链接器的例子。</li>
<li><a href="#rustc-link-arg-benches"><code>cargo:rustc-link-arg-benches=FLAG</code></a> — 将自定义的标志传递给链接器，用于基准测试。</li>
<li><a href="#rustc-link-lib"><code>cargo:rustc-link-lib=LIB</code></a> — 添加一个库到链接。</li>
<li><a href="#rustc-link-search"><code>cargo:rustc-link-search=[KIND=]PATH</code></a> — 添加到库的搜索路径。</li>
<li><a href="#rustc-flags"><code>cargo:rustc-flags=FLAGS</code></a> — 将特定标志传递给编译器。</li>
<li><a href="#rustc-cfg"><code>cargo:rustc-cfg=KEY[=&quot;VALUE&quot;]</code></a> — 启用编译时的 <code>cfg</code> 设置。</li>
<li><a href="#rustc-env"><code>cargo:rustc-env=VAR=VALUE</code></a> — 设置一个环境变量。</li>
<li><a href="#rustc-cdylib-link-arg"><code>cargo:rustc-cdylib-link-arg=FLAG</code></a> — 为cdylib crate的链接器传递自定义标志。</li>
<li><a href="#cargo-warning"><code>cargo:warning=MESSAGE</code></a> — 在终端上显示一个警告。</li>
<li><a href="#the-links-manifest-key"><code>cargo:KEY=VALUE</code></a> —  <code>links</code> 脚本使用的Metadata。</li>
</ul>
<p><a id="rustc-link-arg"></a></p>
<h4 id="cargorustc-link-argflag"><a class="header" href="#cargorustc-link-argflag"><code>cargo:rustc-link-arg=FLAG</code></a></h4>
<p><code>rustc-link-arg</code> 指令告诉Cargo将 <a href="../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> 传递给编译器，但只在构建支持的目标(基准、二进制文件、 <code>cdylib</code> crate、示例和测试)时使用。
它的使用是高度平台化的。对设置共享库版本或链接器脚本很有用。</p>
<p><a id="rustc-link-arg-bin"></a></p>
<h4 id="cargorustc-link-arg-binbinflag"><a class="header" href="#cargorustc-link-arg-binbinflag"><code>cargo:rustc-link-arg-bin=BIN=FLAG</code></a></h4>
<p><code>rustc-link-arg-bin</code> 指令告诉Cargo将 <a href="../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> 传递给编译器，但只在构建名称为 <code>BIN</code> 的二进制目标时使用。
它的用法与平台高度相关。对设置链接器脚本或其他链接器选项很有用。</p>
<p><a id="rustc-link-arg-bins"></a></p>
<h4 id="cargorustc-link-arg-binsflag"><a class="header" href="#cargorustc-link-arg-binsflag"><code>cargo:rustc-link-arg-bins=FLAG</code></a></h4>
<p><code>rustc-link-arg-bins</code> 指令告诉Cargo将 <a href="../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> 传递给编译器，但只在构建二进制目标时使用。
它的用法与平台高度相关。对于设置链接器脚本或其他链接器选项很有用。</p>
<p><a id="rustc-link-lib"></a></p>
<h4 id="cargorustc-link-liblib"><a class="header" href="#cargorustc-link-liblib"><code>cargo:rustc-link-lib=LIB</code></a></h4>
<p><code>rustc-link-lib</code> 指令告诉 Cargo 使用编译器的 <a href="../../rustc/command-line-arguments.html#option-l-link-lib"><code>-l</code> flag</a> 来链接指定的库。
这通常用于使用 <a href="../../nomicon/ffi.html">FFI</a> 来链接本地库。</p>
<p><code>LIB</code> 字符串是直接传递给rustc的，所以它支持 <code>-l</code> 的任何语法。
目前， <code>LIB</code> 支持的全部语法是 <code>[KIND[:MODIFIERS]=]NAME[:RENAME]</code> 。</p>
<p><code>-l</code> 标志只传递给包的库目标，除非没有库目标，在这种情况下它会传递给所有目标。
这样做是因为所有其他目标都隐含着对库目标的依赖，而要链接的库只应该包含一次。
这意味着，如果一个包有一个库和一个二进制目标，那么 <em>库</em> 可以访问给定lib的标识符，而二进制应该通过库目标的公共API来访问它们。</p>
<p>可选的 <code>KIND</code> 可以是 <code>dylib</code> 、 <code>static</code> 或<code> framework</code> 之一。
更多细节见 <a href="../../rustc/command-line-arguments.html#option-l-link-lib">rustc book</a> 。</p>
<p><a id="rustc-link-arg-tests"></a></p>
<h4 id="cargorustc-link-arg-testsflag"><a class="header" href="#cargorustc-link-arg-testsflag"><code>cargo:rustc-link-arg-tests=FLAG</code></a></h4>
<p><code>rustc-link-arg-tests</code> 指令告诉Cargo将 <a href="../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> 传递给编译器，但只在构建测试目标时使用。</p>
<p><a id="rustc-link-arg-examples"></a></p>
<h4 id="cargorustc-link-arg-examplesflag"><a class="header" href="#cargorustc-link-arg-examplesflag"><code>cargo:rustc-link-arg-examples=FLAG</code></a></h4>
<p><code>rustc-link-arg-examples</code> 指令告诉Cargo将 <a href="../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> 传递给编译器，但只在构建实例目标时传递。</p>
<p><a id="rustc-link-arg-benches"></a></p>
<h4 id="cargorustc-link-arg-benchesflag"><a class="header" href="#cargorustc-link-arg-benchesflag"><code>cargo:rustc-link-arg-benches=FLAG</code></a></h4>
<p><code>rustc-link-arg-benches</code> 指令告诉Cargo将 <a href="../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> 传递给编译器，但只在构建基准目标时使用。</p>
<p><a id="rustc-link-search"></a></p>
<h4 id="cargorustc-link-searchkindpath"><a class="header" href="#cargorustc-link-searchkindpath"><code>cargo:rustc-link-search=[KIND=]PATH</code></a></h4>
<p><code>rustc-link-search</code> 指令告诉Cargo将 <a href="../../rustc/command-line-arguments.html#option-l-search-path"><code>-L</code> flag</a> 传递给编译器，在库搜索路径中添加一个目录。</p>
<p>可选的 <code>KIND</code> 可以是 <code>dependency</code> 、 <code>crate</code> 、 <code>native</code> 、 <code>framework</code> 、 <code>all</code> 之一。更多细节见 <a href="../../rustc/command-line-arguments.html#option-l-search-path">rustc book</a> 。</p>
<p>如果这些路径在 <code>OUT_DIR</code> 内，它们也会被添加到 <a href="environment-variables.html#dynamic-library-paths">动态库搜索路径环境变量</a> 。
不鼓励依赖这种行为，因为这使得，使用产生的二进制文件很困难。一般来说，最好避免在构建脚本中创建动态库(使用现有的系统库就可以了)。</p>
<p><a id="rustc-flags"></a></p>
<h4 id="cargorustc-flagsflags"><a class="header" href="#cargorustc-flagsflags"><code>cargo:rustc-flags=FLAGS</code></a></h4>
<p><code>rustc-flags</code> 指令告诉Cargo将给定的以空格分隔的标志传递给编译器。
只允许使用 <code>-l </code>和 <code>-L</code> 标志，相当于使用 <a href="#rustc-link-lib"><code>rustc-link-lib</code></a> 和 <a href="#rustc-link-search"><code>rustc-link-search</code></a> 。</p>
<p><a id="rustc-cfg"></a></p>
<h4 id="cargorustc-cfgkeyvalue"><a class="header" href="#cargorustc-cfgkeyvalue"><code>cargo:rustc-cfg=KEY[=&quot;VALUE&quot;]</code></a></h4>
<p><code>rustc-cfg</code> 指令告诉Cargo将给定的<a href="../../rustc/command-line-arguments.html#option-cfg"><code>--cfg</code> flag</a> 的值传递给编译器。
这可用于编译时检测功能，以启用 <a href="../../reference/conditional-compilation.html">条件编译</a> 。</p>
<p>请注意，这并 <em>不</em> 影响Cargo的依赖解析。
这不能用来启用一个可选的依赖，或启用其他Cargo特性。</p>
<p>请注意，<a href="features.html">Cargo features</a>使用的是 <code>feature=&quot;foo&quot;</code> 的形式。
用这个标志传递的 <code>cfg</code> 值不限于这种形式，可以只提供一个标识符，或任意的键值对。例如，发送 <code>cargo:rustc-cfg=abc</code> 将允许代码使用 <code>#[cfg(abc)]</code> (注意缺少 <code>feature=</code> )。
或者可以使用一个任意的键值对与一个 <code>=</code> 号，如<code>cargo:rustc-cfg=my_component=&quot;foo&quot;</code>。
键应该是一个Rust标识符，值应该是一个字符串。</p>
<p><a id="rustc-env"></a></p>
<h4 id="cargorustc-envvarvalue"><a class="header" href="#cargorustc-envvarvalue"><code>cargo:rustc-env=VAR=VALUE</code></a></h4>
<p><code>rustc-env</code> 指令告诉Cargo在编译包的时候设置指定的环境变量。
然后可以通过编译后的crate中的<a href="../../std/macro.env.html"><code>env!</code> macro</a>来检索该值。
这对于在crate的代码中嵌入额外的元数据很有用，例如git HEAD的哈希值或持续集成服务器的唯一标识符。</p>
<p>参阅 <a href="environment-variables.html#environment-variables-cargo-sets-for-crates">Cargo自动包含环境变量</a>。</p>
<blockquote>
<p><strong>注意</strong>: 当用 <code>cargo run</code> 或 <code>cargo test</code> 运行可执行文件时，也会设置这些环境变量。
然而，不鼓励这种用法，因为它将可执行文件与Cargo的执行环境关联在一起。
通常情况下，这些环境变量应该只在编译时用 <code>env!</code> 宏来检查。</p>
</blockquote>
<p><a id="rustc-cdylib-link-arg"></a></p>
<h4 id="cargorustc-cdylib-link-argflag"><a class="header" href="#cargorustc-cdylib-link-argflag"><code>cargo:rustc-cdylib-link-arg=FLAG</code></a></h4>
<p><code>rustc-dylib-link-arg</code> 指令告诉Cargo将 <a href="../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> 传递给编译器，但只在构建 <code>cdylib</code> 库目标时使用。
它的使用是高度平台特定的。对于设置共享库的版本或运行时路径很有用。</p>
<p><a id="cargo-warning"></a></p>
<h4 id="cargowarningmessage"><a class="header" href="#cargowarningmessage"><code>cargo:warning=MESSAGE</code></a></h4>
<p><code>warning</code> 指令告诉Cargo在构建脚本运行完毕后显示一个警告。
警告只针对 <code>path</code> 依赖(也就是你在本地的那些依赖)，所以比如在<a href="https://crates.io/">crates.io</a>crate中打印出来的警告，默认是不会发送的。
<code>-vv</code> &quot;very verbose&quot; 标志可以用来让Cargo显示所有crate的警告。</p>
<h3 id="构建依赖"><a class="header" href="#构建依赖">构建依赖</a></h3>
<p>构建脚本也可以依赖其他基于Cargo的crate。
依赖是通过配置清单中的 <code>build-dependencies</code> 部分来声明的。</p>
<pre><code class="language-toml">[build-dependencies]
cc = &quot;1.0.46&quot;
</code></pre>
<p>构建脚本 <em>不</em> 访问列在 <code>dependencies</code> 或 <code>dev-dependencies</code> 部分的依赖项(它们还没有被构建！)。
另外，除非在 <code>[dependencies]</code> 表中明确添加，否则构建的依赖项对包本身是不可用的。</p>
<p>建议仔细考虑你添加的每个依赖，权衡对编译时间、许可、维护等的影响。
如果一个依赖是在构建依赖和正常依赖之间共享的，Cargo会尝试重用它。然而，这并不总是能用，例如在交叉编译时，所以要考虑到对编译时间的影响。</p>
<h3 id="变化检测"><a class="header" href="#变化检测">变化检测</a></h3>
<p>当重建包时，Cargo不一定知道是否需要再次运行构建脚本。
默认情况下，它采取一种保守的方法，即如果包中的任意文件被改变(或由 <a href="manifest.html#the-exclude-and-include-fields"><code>exclude</code> 和 <code>include</code> 字段</a> 控制的文件列表被改变)，则总是重新运行构建脚本。
在大多数情况下，这不是一个好的选择，所以建议每个构建脚本至少发出一个 <code>rerun-if</code> 指令(如下所述)。
如果发出了这些指令，那么Cargo只会在给定值发生变化时重新运行脚本。
如果Cargo重新运行你自己的crate或依赖的构建脚本，而你又不知道为什么，请参见FAQ中的<a href=".../faq.html#why-is-cargo-rebuilding-my-code">&quot;为什么Cargo要重新构建我的代码？&quot;</a>。</p>
<p><a id="rerun-if-changed"></a></p>
<h4 id="cargorerun-if-changedpath"><a class="header" href="#cargorerun-if-changedpath"><code>cargo:rerun-if-changed=PATH</code></a></h4>
<p><code>rerun-if-changed</code> 指令告诉Cargo在指定路径的文件发生变化时重新运行构建脚本。
目前，Cargo只使用文件系统最后修改的 &quot;mtime&quot; 时间戳来确定文件是否有变化。
它与内部缓存的构建脚本最后运行的时间戳进行比较。</p>
<p>如果路径指向一个目录，它将扫描整个目录的任何修改。</p>
<p>如果构建脚本在任何情况下都不需要重新运行，那么发送 <code>cargo:rerun-if-changed=build.rs</code> 防止其重新运行(否则，如果没有发送 <code>rerun-if</code> 指令，则默认为扫描整个包目录的变化)。
Cargo会自动处理脚本本身是否需要重新编译，当然，脚本在重新编译后会重新运行。否则，没有必要指定 <code>build.rs</code> 。</p>
<p><a id="rerun-if-env-changed"></a></p>
<h4 id="cargorerun-if-env-changedname"><a class="header" href="#cargorerun-if-env-changedname"><code>cargo:rerun-if-env-changed=NAME</code></a></h4>
<p><code>rerun-if-env-changed</code> 指令告诉Cargo，如果给定名称的环境变量值发生变化，则重新运行构建脚本。</p>
<p>注意，这里的环境变量是针对全局环境变量如 <code>CC</code> 之类的，对于Cargo设置的 <code>TARGET</code> 之类的环境变量没有必要使用这个。</p>
<h3 id="links-配置清单key"><a class="header" href="#links-配置清单key"><code>links</code> 配置清单Key</a></h3>
<p><code>package.links</code> 键可以在 <code>Cargo.toml</code> 清单中设置，以声明该包与给定的本地库相链接。
这个清单键的目的是让Cargo了解一个包的本地依赖，以及提供在包构建脚本之间传递元数据的有条理的系统。</p>
<pre><code class="language-toml">[package]
# ...
links = &quot;foo&quot;
</code></pre>
<p>该清单表明，该包链接到 <code>libfoo</code> 本地库。
当使用 <code>links</code> 键时，包必须有一个构建脚本，而构建脚本应该使用 <a href="#rustc-link-lib"><code>rustc-link-lib</code>指令</a> 来链接该库。</p>
<p>主要的是，Cargo要求每个 <code>links</code> 值最多只能有一个包。
换句话说，禁止让两个包链接到同一个本地库。
这有助于防止crate之间的重复符号。注意，有一些<a href="#-sys-packages">已有的惯例</a>可以缓解这个问题。</p>
<p>如上文在输出格式中提到的，每个构建脚本可以以键值对的形式生成一组任意的元数据。
这些元数据被传递给 <strong>依赖的</strong> 包的构建脚本。
例如，如果包 <code>bar</code> 依赖于 <code>foo</code> ，那么如果 <code>foo</code> 生成 <code>key=value</code> 作为其构建脚本元数据的一部分，那么 <code>bar</code> 的构建脚本将有 <code>DEP_FOO_KEY=value</code> 的环境变量。
参见 <a href="build-script-examples.html#using-another-sys-crate">&quot;使用另一个 <code>sys</code> crate&quot;</a>，以了解如何使用这个例子。</p>
<p>请注意，元数据只传递给直接依赖，而不传递给过渡依赖。</p>
<h3 id="-sys-包"><a class="header" href="#-sys-包"><code>*-sys</code> 包</a></h3>
<p>一些链接到系统库的Cargo包有后缀为 <code>-sys</code> 的命名惯例。
任何名为 <code>foo-sys</code> 的包都应该提供两个主要功能:</p>
<ul>
<li>库crate应该链接到本地库 <code>libfoo</code> 。这通常会在从源代码构建之前探测当前系统中的 <code>libfoo</code> 。</li>
<li>这个库应该为 <code>libfoo</code> 中的类型和函数提供 <strong>声明</strong>，而<strong>不是</strong>更高级别的抽象。</li>
</ul>
<p><code>*-sys</code> 包的集合为连接本地库提供了通用的依赖。
有了这个本地库相关包的惯例，带来许多好处。</p>
<ul>
<li>对 <code>foo-sys</code> 的共同依赖简便了对于每个 <code>links</code> 值一个包的规则。</li>
<li>其他 <code>sys</code> 包可以利用 <code>DEP_NAME_KEY=value</code> 环境变量的优势，更好地与其他包集成。参见 <a href="build-script-examples.html#using-another-sys-crate">&quot;使用另一个 <code>sys</code> crate&quot;</a> 例子。</li>
<li>一个共同的依赖允许将逻辑集中在发现 <code>libfoo</code> 本身(或从源代码构建它)。</li>
<li>这些依赖很容易被 <a href="#overriding-build-scripts">覆盖</a> 。</li>
</ul>
<p>通常会有一个没有 <code>-sys</code> 后缀的配套包，在sys包的基础上提供安全的高级抽象。
例如，<a href="https://crates.io/crates/git2"><code>git2</code> crate</a> 为 <a href="https://crates.io/crates/libgit2-sys"><code>libgit2-sys</code> crate</a> 提供了一个高级接口。</p>
<h3 id="覆盖构建脚本"><a class="header" href="#覆盖构建脚本">覆盖构建脚本</a></h3>
<p>如果配置清单中包含 <code>links</code> 键，那么Cargo支持用自定义库覆盖指定的构建脚本。
这一功能的目的是为了防止完全运行相关的构建脚本，而是提前提供元数据。</p>
<p>要覆盖一个构建脚本，在任意允许的 <a href="config.html"><code>config.toml</code></a> 文件中放置以下配置。</p>
<pre><code class="language-toml">[target.x86_64-unknown-linux-gnu.foo]
rustc-link-lib = [&quot;foo&quot;]
rustc-link-search = [&quot;/path/to/foo&quot;]
rustc-flags = &quot;-L /some/path&quot;
rustc-cfg = ['key=&quot;value&quot;']
rustc-env = {key = &quot;value&quot;}
rustc-cdylib-link-arg = [&quot;…&quot;]
metadata_key1 = &quot;value&quot;
metadata_key2 = &quot;value&quot;
</code></pre>
<p>在这种配置下，如果包声明它链接到 <code>foo</code> ，那么构建脚本将 <strong>不</strong> 被编译或运行，而将使用指定的元数据。</p>
<p>不应使用 <code>warning</code> 、 <code>rerun-if-changed</code> 和 <code>rerun-if-env-changed</code> 键，将忽略它们。</p>
<h3 id="jobserver"><a class="header" href="#jobserver">Jobserver</a></h3>
<p>Cargo和 <code>rustc</code> 使用为GNU制作开发的<a href="http://make.mad-scientist.net/papers/jobserver-implementation/">jobserver 协议</a>来协调进程间的并发。
它本质上是信号，控制同时运行的作业数量。
并发性可以用 <code>--jobs</code> 标志来设置，默认为逻辑CPU的数量。</p>
<p>每个构建脚本都从Cargo那里继承一个作业槽，并试图运行时只使用一个CPU。
如果脚本想并行使用更多的CPU，应该使用<a href="https://crates.io/crates/jobserver"><code>jobserver</code> crate</a>来与Cargo协调。</p>
<p>举例来说，<a href="https://crates.io/crates/cc"><code>cc</code> crate</a> 可以启用可选的 <code>parallel</code> 特性，它将使用jobserver协议尝试同时构建多个C文件。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../reference/environment-variables.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../reference/build-script-examples.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../reference/environment-variables.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../reference/build-script-examples.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
