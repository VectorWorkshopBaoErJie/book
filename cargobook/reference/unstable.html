<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>不稳定特性 - The Cargo Book</title>


        <!-- Custom HTML head -->
        <style>
            dd {
                margin-bottom: 1em;
            }
        </style>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">简介</a></li><li class="chapter-item expanded "><a href="../getting-started/index.html"><strong aria-hidden="true">1.</strong> 入门指南</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-started/installation.html"><strong aria-hidden="true">1.1.</strong> 安装</a></li><li class="chapter-item expanded "><a href="../getting-started/first-steps.html"><strong aria-hidden="true">1.2.</strong> Cargo起步</a></li></ol></li><li class="chapter-item expanded "><a href="../guide/index.html"><strong aria-hidden="true">2.</strong> Cargo指南</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guide/why-cargo-exists.html"><strong aria-hidden="true">2.1.</strong> 为何有Cargo</a></li><li class="chapter-item expanded "><a href="../guide/creating-a-new-project.html"><strong aria-hidden="true">2.2.</strong> 创建新包</a></li><li class="chapter-item expanded "><a href="../guide/working-on-an-existing-project.html"><strong aria-hidden="true">2.3.</strong> 让包工作</a></li><li class="chapter-item expanded "><a href="../guide/dependencies.html"><strong aria-hidden="true">2.4.</strong> 依赖</a></li><li class="chapter-item expanded "><a href="../guide/project-layout.html"><strong aria-hidden="true">2.5.</strong> 包的设计</a></li><li class="chapter-item expanded "><a href="../guide/cargo-toml-vs-cargo-lock.html"><strong aria-hidden="true">2.6.</strong> Cargo.toml vs Cargo.lock</a></li><li class="chapter-item expanded "><a href="../guide/tests.html"><strong aria-hidden="true">2.7.</strong> 测试</a></li><li class="chapter-item expanded "><a href="../guide/continuous-integration.html"><strong aria-hidden="true">2.8.</strong> 持续集成</a></li><li class="chapter-item expanded "><a href="../guide/cargo-home.html"><strong aria-hidden="true">2.9.</strong> Cargo主页</a></li><li class="chapter-item expanded "><a href="../guide/build-cache.html"><strong aria-hidden="true">2.10.</strong> 构建缓存</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/index.html"><strong aria-hidden="true">3.</strong> Cargo参考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/specifying-dependencies.html"><strong aria-hidden="true">3.1.</strong> 指定依赖</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/overriding-dependencies.html"><strong aria-hidden="true">3.1.1.</strong> 覆盖依赖</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/manifest.html"><strong aria-hidden="true">3.2.</strong> 配置格式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/cargo-targets.html"><strong aria-hidden="true">3.2.1.</strong> Cargo目标</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/workspaces.html"><strong aria-hidden="true">3.3.</strong> 工作空间</a></li><li class="chapter-item expanded "><a href="../reference/features.html"><strong aria-hidden="true">3.4.</strong> 特性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/features-examples.html"><strong aria-hidden="true">3.4.1.</strong> 特性示例</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/profiles.html"><strong aria-hidden="true">3.5.</strong> 编译设置</a></li><li class="chapter-item expanded "><a href="../reference/config.html"><strong aria-hidden="true">3.6.</strong> 配置</a></li><li class="chapter-item expanded "><a href="../reference/environment-variables.html"><strong aria-hidden="true">3.7.</strong> 环境变量</a></li><li class="chapter-item expanded "><a href="../reference/build-scripts.html"><strong aria-hidden="true">3.8.</strong> 构建脚本</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/build-script-examples.html"><strong aria-hidden="true">3.8.1.</strong> 构建脚本示例</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/publishing.html"><strong aria-hidden="true">3.9.</strong> 发布到crates.io</a></li><li class="chapter-item expanded "><a href="../reference/pkgid-spec.html"><strong aria-hidden="true">3.10.</strong> 包ID规范</a></li><li class="chapter-item expanded "><a href="../reference/source-replacement.html"><strong aria-hidden="true">3.11.</strong> 源替换</a></li><li class="chapter-item expanded "><a href="../reference/external-tools.html"><strong aria-hidden="true">3.12.</strong> 插件</a></li><li class="chapter-item expanded "><a href="../reference/registries.html"><strong aria-hidden="true">3.13.</strong> 注册中心</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/running-a-registry.html"><strong aria-hidden="true">3.13.1.</strong> 运行注册中心</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/registry-index.html"><strong aria-hidden="true">3.13.1.1.</strong> 注册中心索引</a></li><li class="chapter-item expanded "><a href="../reference/registry-web-api.html"><strong aria-hidden="true">3.13.1.2.</strong> 注册中心Web API</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../reference/resolver.html"><strong aria-hidden="true">3.14.</strong> 依赖解析</a></li><li class="chapter-item expanded "><a href="../reference/semver.html"><strong aria-hidden="true">3.15.</strong> 语义化兼容</a></li><li class="chapter-item expanded "><a href="../reference/future-incompat-report.html"><strong aria-hidden="true">3.16.</strong> 未来不兼容报告</a></li><li class="chapter-item expanded "><a href="../reference/timings.html"><strong aria-hidden="true">3.17.</strong> 报告构建时间</a></li><li class="chapter-item expanded "><a href="../reference/unstable.html" class="active"><strong aria-hidden="true">3.18.</strong> 不稳定特性</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/index.html"><strong aria-hidden="true">4.</strong> Cargo命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/general-commands.html"><strong aria-hidden="true">4.1.</strong> 常用命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo.html"><strong aria-hidden="true">4.1.1.</strong> cargo</a></li><li class="chapter-item expanded "><a href="../commands/cargo-help.html"><strong aria-hidden="true">4.1.2.</strong> cargo help</a></li><li class="chapter-item expanded "><a href="../commands/cargo-version.html"><strong aria-hidden="true">4.1.3.</strong> cargo version</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/build-commands.html"><strong aria-hidden="true">4.2.</strong> 构建命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo-bench.html"><strong aria-hidden="true">4.2.1.</strong> cargo bench</a></li><li class="chapter-item expanded "><a href="../commands/cargo-build.html"><strong aria-hidden="true">4.2.2.</strong> cargo build</a></li><li class="chapter-item expanded "><a href="../commands/cargo-check.html"><strong aria-hidden="true">4.2.3.</strong> cargo check</a></li><li class="chapter-item expanded "><a href="../commands/cargo-clean.html"><strong aria-hidden="true">4.2.4.</strong> cargo clean</a></li><li class="chapter-item expanded "><a href="../commands/cargo-doc.html"><strong aria-hidden="true">4.2.5.</strong> cargo doc</a></li><li class="chapter-item expanded "><a href="../commands/cargo-fetch.html"><strong aria-hidden="true">4.2.6.</strong> cargo fetch</a></li><li class="chapter-item expanded "><a href="../commands/cargo-fix.html"><strong aria-hidden="true">4.2.7.</strong> cargo fix</a></li><li class="chapter-item expanded "><a href="../commands/cargo-run.html"><strong aria-hidden="true">4.2.8.</strong> cargo run</a></li><li class="chapter-item expanded "><a href="../commands/cargo-rustc.html"><strong aria-hidden="true">4.2.9.</strong> cargo rustc</a></li><li class="chapter-item expanded "><a href="../commands/cargo-rustdoc.html"><strong aria-hidden="true">4.2.10.</strong> cargo rustdoc</a></li><li class="chapter-item expanded "><a href="../commands/cargo-test.html"><strong aria-hidden="true">4.2.11.</strong> cargo test</a></li><li class="chapter-item expanded "><a href="../commands/cargo-report.html"><strong aria-hidden="true">4.2.12.</strong> cargo report</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/manifest-commands.html"><strong aria-hidden="true">4.3.</strong> 配置命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo-add.html"><strong aria-hidden="true">4.3.1.</strong> cargo add</a></li><li class="chapter-item expanded "><a href="../commands/cargo-generate-lockfile.html"><strong aria-hidden="true">4.3.2.</strong> cargo generate-lockfile</a></li><li class="chapter-item expanded "><a href="../commands/cargo-locate-project.html"><strong aria-hidden="true">4.3.3.</strong> cargo locate-project</a></li><li class="chapter-item expanded "><a href="../commands/cargo-metadata.html"><strong aria-hidden="true">4.3.4.</strong> cargo metadata</a></li><li class="chapter-item expanded "><a href="../commands/cargo-pkgid.html"><strong aria-hidden="true">4.3.5.</strong> cargo pkgid</a></li><li class="chapter-item expanded "><a href="../commands/cargo-remove.html"><strong aria-hidden="true">4.3.6.</strong> cargo remove</a></li><li class="chapter-item expanded "><a href="../commands/cargo-tree.html"><strong aria-hidden="true">4.3.7.</strong> cargo tree</a></li><li class="chapter-item expanded "><a href="../commands/cargo-update.html"><strong aria-hidden="true">4.3.8.</strong> cargo update</a></li><li class="chapter-item expanded "><a href="../commands/cargo-vendor.html"><strong aria-hidden="true">4.3.9.</strong> cargo vendor</a></li><li class="chapter-item expanded "><a href="../commands/cargo-verify-project.html"><strong aria-hidden="true">4.3.10.</strong> cargo verify-project</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/package-commands.html"><strong aria-hidden="true">4.4.</strong> 包命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo-init.html"><strong aria-hidden="true">4.4.1.</strong> cargo init</a></li><li class="chapter-item expanded "><a href="../commands/cargo-install.html"><strong aria-hidden="true">4.4.2.</strong> cargo install</a></li><li class="chapter-item expanded "><a href="../commands/cargo-new.html"><strong aria-hidden="true">4.4.3.</strong> cargo new</a></li><li class="chapter-item expanded "><a href="../commands/cargo-search.html"><strong aria-hidden="true">4.4.4.</strong> cargo search</a></li><li class="chapter-item expanded "><a href="../commands/cargo-uninstall.html"><strong aria-hidden="true">4.4.5.</strong> cargo uninstall</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/publishing-commands.html"><strong aria-hidden="true">4.5.</strong> 发布命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo-login.html"><strong aria-hidden="true">4.5.1.</strong> cargo login</a></li><li class="chapter-item expanded "><a href="../commands/cargo-owner.html"><strong aria-hidden="true">4.5.2.</strong> cargo owner</a></li><li class="chapter-item expanded "><a href="../commands/cargo-package.html"><strong aria-hidden="true">4.5.3.</strong> cargo package</a></li><li class="chapter-item expanded "><a href="../commands/cargo-publish.html"><strong aria-hidden="true">4.5.4.</strong> cargo publish</a></li><li class="chapter-item expanded "><a href="../commands/cargo-yank.html"><strong aria-hidden="true">4.5.5.</strong> cargo yank</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">5.</strong> 常见问题</a></li><li class="chapter-item expanded "><a href="../appendix/glossary.html"><strong aria-hidden="true">6.</strong> 附录: 词汇表</a></li><li class="chapter-item expanded "><a href="../appendix/git-authentication.html"><strong aria-hidden="true">7.</strong> 附录: Git认证</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cargo Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/cargo/tree/master/src/doc/src" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/cargo/edit/master/src/doc/src/reference/unstable.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="不稳定的特性"><a class="header" href="#不稳定的特性">不稳定的特性</a></h2>
<p>实验性的Cargo 特性只在<a href="../../book/appendix-07-nightly-rust.html">nightly channel</a>&quot;每日构建&quot;中提供。我们鼓励你尝试使用这些特性，看看它们是否符合你的需求，以及是否有问题或难题。请查看下面列出的链接的问题跟踪，了解更多关于该特性的信息，如果你想获得未来的更新，请点击GitHub订阅按钮。</p>
<p>经过一段时间后，如果该特性没有任何重大问题，它可以被<a href="https://doc.crates.io/contrib/process/unstable.html#stabilization">stabilized</a>，这将使它在当前每日构建发布的版本到达稳定通道后，就可以在稳定版上使用(6到12周不等)。</p>
<p>根据特性的工作方式，有三种不同的方式可以启用不稳定的特性。</p>
<ul>
<li>
<p>按照 <code>Cargo.toml</code> 新语法，在顶部任意表之前设置 <code>cargo-features</code> 键。例如:</p>
<pre><code class="language-toml"># 这里指定启用哪些新的 Cargo.toml 特性。
cargo-features = [&quot;test-dummy-unstable&quot;]

[package]
name = &quot;my-package&quot;
version = &quot;0.1.0&quot;
im-a-teapot = true  # 这是由 test-dummy-unstable 启用的新选项。
</code></pre>
</li>
<li>
<p>新的命令行标志、选项和子命令需要同时包含 <code>-Z unstable-options</code> CLI选项。
例如，新的 <code>--out-dir</code> 选项只在每日构建中可用。</p>
<p><code>cargo +nightly build --out-dir=out -Z unstable-options</code></p>
</li>
<li>
<p><code>-Z</code>命令行标志用于启用可能没有接口的新功能，或者接口还没有设计好，或者用于影响Cargo多个部分的更复杂功能。例如，<a href="#mime-on-use">mime-on-use</a>功能可以用以下方式启用:</p>
<p><code>cargo +nightly build -Z mtime-on-use</code></p>
<p>运行 <code>cargo -Z help</code> 可以查看可用的标志列表。</p>
<p>可以用 <code>-Z</code> 标志配置的内容也可以在cargo <a href="config.html">config file</a> (<code>.cargo/config.toml</code>)的 <code>unstable</code> 表中设置。比如说:</p>
<pre><code class="language-toml">[unstable]
mtime-on-use = true
build-std = [&quot;core&quot;, &quot;alloc&quot;]
</code></pre>
</li>
</ul>
<p>下面描述的每个新特性都将解释如何使用它。</p>
<h3 id="不稳定特性列表"><a class="header" href="#不稳定特性列表">不稳定特性列表</a></h3>
<ul>
<li>不稳定特定特性
<ul>
<li><a href="#allow-features">-Z allow-features</a> — 提供了一种限制使用哪些不稳定特性的方法。</li>
</ul>
</li>
<li>构建脚本和链接
<ul>
<li><a href="#metabuild">Metabuild</a> — 提供声明式的构建脚本。</li>
</ul>
</li>
<li>解析器和特性
<ul>
<li><a href="#no-index-update">no-index-update</a> — 防止cargo更新索引缓存。</li>
<li><a href="#avoid-dev-deps">avoid-dev-deps</a> — 防止解析器在解析过程中包含 dev-依赖。</li>
<li><a href="#minimal-versions">minimal-versions</a> — 强制解析器使用最低的兼容版本，而不是最高的版本。</li>
<li><a href="#public-dependency">public-dependency</a> — 允许将依赖分类为公共或私有。</li>
</ul>
</li>
<li>输出行为
<ul>
<li><a href="#out-dir">out-dir</a> — 添加一个目录，将制品复制到该目录。</li>
<li><a href="#different-binary-name">Different binary name</a> — 为构建的二进制文件指定一个与crate名称分开的名称。</li>
</ul>
</li>
<li>编译行为
<ul>
<li><a href="#mtime-on-use">mtime-on-use</a> — 在每次使用依赖时，更新其最后修改的时间戳，以提供一种机制来删除未使用的制品。</li>
<li><a href="#doctest-xcompile">doctest-xcompile</a> — 支持运行带有 <code>--target</code> 标志的文档测试。</li>
<li><a href="#build-std">build-std</a> — 构建标准库而不是使用预先构建的二进制文件。</li>
<li><a href="#build-std-features">build-std-features</a> — 设置与标准库一起使用的特性。</li>
<li><a href="#binary-dep-depinfo">binary-dep-depinfo</a> — 致使dep-info文件跟踪二进制文件的依赖。</li>
<li><a href="#panic-abort-tests">panic-abort-tests</a> — 允许用 &quot;中止&quot; 恐慌策略运行测试。</li>
<li><a href="#crate-type">crate-type</a> — 支持向编译器传递crate类型。</li>
<li><a href="#keep-going">keep-going</a> — 尽可能多地构建，而不是在第一个错误时就中止。</li>
</ul>
</li>
<li>rustdoc
<ul>
<li><a href="#doctest-in-workspace"><code>doctest-in-workspace</code></a> — 修复文档测试时与工作空间相对路径。</li>
<li><a href="#rustdoc-map">rustdoc-map</a> —提供文档的映射，以链接到外部网站，如 <a href="https://docs.rs/">docs.rs</a> 。</li>
</ul>
</li>
<li><code>Cargo.toml</code> 扩展
<ul>
<li><a href="#profile-rustflags-option">Profile <code>rustflags</code> option</a> — 直接传递给rustc。</li>
<li><a href="#per-package-target">per-package-target</a> — 设置每个独立包的 <code>--target</code> 。</li>
<li><a href="#artifact-dependencies">artifact dependencies</a> - 允许将构建制品包含到其他构建制品中，并为不同的目标构建。</li>
</ul>
</li>
<li>信息和元数据
<ul>
<li><a href="#build-plan">Build-plan</a> — 发送关于哪些命令将被运行的JSON信息。</li>
<li><a href="#unit-graph">unit-graph</a> — 为Cargo的内部图结构发送JSON。</li>
<li><a href="#rustc---print"><code>cargo rustc --print</code></a> — 用 <code>--print</code> 调用rustc，以显示来自 rustc 的信息。</li>
</ul>
</li>
<li>配置
<ul>
<li><a href="#config-include">config-include</a> — 增加配置文件包含其他文件的能力。</li>
<li><a href="#cargo-config"><code>cargo config</code></a> — 增加新的子命令用于查看配置文件。</li>
</ul>
</li>
<li>注册中心
<ul>
<li><a href="#credential-process">credential-process</a> — 增加对从外部认证程序获取注册中心令牌的支持。</li>
<li><a href="#cargo-logout"><code>cargo logout</code></a> — 添加 <code>logout</code> 命令，以删除当前保存的注册中心令牌。</li>
<li><a href="#sparse-registry">sparse-registry</a> — 增加从静态文件HTTP注册中心获取的支持(<code>sparse+</code>)。</li>
<li><a href="#publish-timeout">publish-timeout</a> — 控制上传crate和在索引中可用之间的超时。</li>
<li><a href="#registry-auth">registry-auth</a> — 增加对认证注册的支持，并使用非对称加密生成注册中心认证令牌。</li>
</ul>
</li>
</ul>
<h3 id="接受特性"><a class="header" href="#接受特性">接受特性</a></h3>
<p>这个永久不稳定的标志使得可以使用只有列出的一组不稳定的特性。具体来说，如果你传递了 <code>-Zallow-features=foo,bar</code> ，你将继续能够向 <code>cargo</code> 传递 <code>-Zfoo</code> 和 <code>-Zbar</code> ，但将无法传递 <code>-Zbaz</code> 。你可以传递一个空字符串(<code>-Zallow-features=</code>)来禁止所有不稳定的特性。</p>
<p><code>-Zallow-features</code>也限制了哪些不稳定的特性可以被传递给 <code>Cargo.toml</code> 中的 <code>cargo-features</code> 条目。例如，如果你想接受</p>
<pre><code class="language-toml">cargo-features = [&quot;test-dummy-unstable&quot;]
</code></pre>
<p>如果 <code>test-dummy-unstable</code> 是不稳定的，那么 <code>-Zallow-features=</code> 也不接受该特性，而 <code>-Zallow-features=test-dummy-unstable</code> 则接受。</p>
<p>传递给cargo的 <code>-Zallow-features</code> 的特性列表也会传递给cargo最终调用的任何Rust工具(如 <code>rustc</code> 或 <code>rustdoc</code> )。因此，如果你运行 <code>cargo -Zallow-features=</code> ，就不能使用不稳定的Cargo_或Rust特性。</p>
<h3 id="no-index-update"><a class="header" href="#no-index-update">no-index-update</a></h3>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/3479">#3479</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/7404">#7404</a></li>
</ul>
<p><code>-Z no-index-update</code> 标志确保Cargo不会尝试更新注册中心索引。这是为Crater等工具准备的，这些工具会发布很多Cargo命令，你想避免每次更新索引的网络潜在行为。</p>
<h3 id="mtime-on-use"><a class="header" href="#mtime-on-use">mtime-on-use</a></h3>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/pull/6477">#6477</a></li>
<li>Cache usage meta tracking issue: <a href="https://github.com/rust-lang/cargo/issues/7150">#7150</a></li>
</ul>
<p><code>-Z mtime-on-use</code> 标志是一个实验性的，让Cargo更新使用过的文件的时间戳，以便像cargo-sweep这样的工具更容易发现哪些文件是过时的。对于许多工作流程来说，这需要在 <em>所有</em> cargo的调用中进行设置。为了更实用，在 <code>.cargo/config.toml</code> 中设置 <code>unstable.mtime_on_use</code> 标志或相应的环境变量，将对所有每日构建cargo的调用应用 <code>-Z mtime-on-use</code> 。(config标志在稳定版本中被忽略) </p>
<h3 id="avoid-dev-deps"><a class="header" href="#avoid-dev-deps">avoid-dev-deps</a></h3>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/4988">#4988</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/5133">#5133</a></li>
</ul>
<p>当运行 <code>cargo install</code> 或 <code>cargo build</code> 等命令时，Cargo目前需要下载 dev-依赖，即使它们不被使用。
<code>-Z avoid-dev-deps</code>标志允许Cargo在不需要dev-依赖时避免下载它们。如果跳过了dev-依赖，将不会生成 <code>Cargo.lock</code> 文件。</p>
<h3 id="minimal-versions"><a class="header" href="#minimal-versions">minimal-versions</a></h3>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/4100">#4100</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/5657">#5657</a></li>
</ul>
<blockquote>
<p>注意: 不建议使用这个功能。因为它为所有的横向依赖强制执行最小版本，它的作用是有限的，因为不是所有的外部依赖都声明适当的版本下限。
我们打算在未来对其进行修改，只对直接依赖执行最小版本。</p>
</blockquote>
<p>当生成 <code>Cargo.lock</code> 文件时， <code>-Z minimal-versions</code> 标志将把依赖解析为能满足要求的最小语义化版本(而不是最高版本)。</p>
<p>这个标志的用途是在持续集成过程中检查 Cargo.toml 中指定的版本是否正确反映了你实际使用的最小版本。
也就是说，如果 Cargo.toml 说明 <code>foo = &quot;1.0.0&quot;</code>，就不会意外地依赖 <code>foo 1.5.0</code> 中增加的特性。</p>
<h3 id="out-dir"><a class="header" href="#out-dir">out-dir</a></h3>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/4875">#4875</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/6790">#6790</a></li>
</ul>
<p>这个特性允许你指定制品在构建后将被复制到的目录。通常，制品只被写入 <code>target/release</code> 或 <code>target/debug</code> 目录。然而，确定确切的文件名可能很棘手，因为你需要解析JSON输出。<code>--out-dir</code> 标志使其更容易预计访问制品。注意，制品是复制的，所以原件仍然在 <code>target</code> 目录中。例子:</p>
<pre><code class="language-sh">cargo +nightly build --out-dir=out -Z unstable-options
</code></pre>
<p>这也可以在 <code>.cargo/config.toml</code> 文件中指定。</p>
<pre><code class="language-toml">[build]
out-dir = &quot;out&quot;
</code></pre>
<h3 id="doctest-xcompile"><a class="header" href="#doctest-xcompile">doctest-xcompile</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/7040">#7040</a></li>
<li>Tracking Rustc Issue: <a href="https://github.com/rust-lang/rust/issues/64245">#64245</a></li>
</ul>
<p>这个标志改变了 <code>cargo test</code> 在传递目标时处理文档测试的行为。目前，如果传递的目标与主机不同，cargo将直接跳过文档测试。如果有这个标志，cargo将继续正常工作，将测试传给文档测试，同时也将 <code>--target</code> 选项传给它，以及启用 <code>-Zunstable-features --enable-per-target-ignores</code>，并将 <code>.cargo/config.toml</code> 的信息传给它。更多信息请参见 rustc issue。</p>
<pre><code class="language-sh">cargo test --target foo -Zdoctest-xcompile
</code></pre>
<h4 id="新的-dir-name-属性"><a class="header" href="#新的-dir-name-属性">新的 <code>dir-name</code> 属性</a></h4>
<p>在 <code>target/</code> 下生成的一些路径是约定俗成的 &quot;构建协议&quot; ， 被 <code>cargo</code> 作为更大的项目构建的一部分来调用。
因此，为了保留现有的行为，还有一个新的属性 <code>dir-name</code> ，当没有指定时，默认为配置文件的名称。比如说:</p>
<pre><code class="language-toml">[profile.release-lto]
inherits = &quot;release&quot;
dir-name = &quot;lto&quot;  # 发送到target/lto，而不是target/release-lto
lto = true
</code></pre>
<h3 id="build-plan"><a class="header" href="#build-plan">Build-plan</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/5579">#5579</a></li>
</ul>
<p><code>build</code> 命令的 <code>--build-plan</code> 参数将输出JSON信息，说明哪些命令将被运行，而不需要实际执行。这在与其他构建工具集成时很有用。
例子:</p>
<pre><code class="language-sh">cargo +nightly build --build-plan -Z unstable-options
</code></pre>
<h3 id="metabuild"><a class="header" href="#metabuild">Metabuild</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/49803">rust-lang/rust#49803</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/blob/master/text/2196-metabuild.md">#2196</a></li>
</ul>
<p>Metabuild是声明式构建脚本的特性。你不用写 <code>build.rs</code> 脚本，而是在 <code>Cargo.toml</code> 中的 <code>metabuild</code> 键中指定一个构建依赖项列表。
构建脚本会自动生成，按顺序运行每个构建依赖项。Metabuild包可以从 <code>Cargo.toml</code> 中读取元数据以指定其行为。</p>
<p>在 <code>Cargo.toml</code> 的顶部包含 <code>cargo-features</code> ，在 <code>package</code> 中包含 <code>metabuild</code> 键，
在 <code>build-dependencies</code> 中列出依赖项，并在 <code>package.metadata</code> 中添加metabuild包需要的元数据。
例子:</p>
<pre><code class="language-toml">cargo-features = [&quot;metabuild&quot;]

[package]
name = &quot;mypackage&quot;
version = &quot;0.0.1&quot;
metabuild = [&quot;foo&quot;, &quot;bar&quot;]

[build-dependencies]
foo = &quot;1.0&quot;
bar = &quot;1.0&quot;

[package.metadata.foo]
extra-info = &quot;qwerty&quot;
</code></pre>
<p>Metabuild包应该有一个名为 <code>metabuild</code> 的公共函数，执行与普通 <code>build.rs</code> 脚本相同的动作。</p>
<h3 id="public-dependency"><a class="header" href="#public-dependency">public-dependency</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/44663">#44663</a></li>
</ul>
<p>'public-dependency' 特性允许将依赖标记为 'public' 或 'private' 。当这个特性被启用时，附加的信息会传递给 rustc，以使 'exported_private_dependencies' 链接项能够正常工作。</p>
<p>这需要在 <code>cargo-features</code> 中设置适当的键。</p>
<pre><code class="language-toml">cargo-features = [&quot;public-dependency&quot;]

[dependencies]
my_dep = { version = &quot;1.2.3&quot;, public = true }
private_dep = &quot;2.0.0&quot; # 默认情况下，将是 'private' 。
</code></pre>
<h3 id="build-std"><a class="header" href="#build-std">build-std</a></h3>
<ul>
<li>Tracking Repository: <a href="https://github.com/rust-lang/wg-cargo-std-aware">https://github.com/rust-lang/wg-cargo-std-aware</a></li>
</ul>
<p><code>build-std</code> 特性使Cargo能够自己编译标准库，作为crate图编译的一部分。这个功能曾称为 &quot;std-aware Cargo&quot;。
这个功能仍处于开发的早期阶段，也是Cargo可能增加的重要特性。这是大的特性文档，即使现在以最小形式存在，
如果想保持最新，请关注<a href="https://github.com/rust-lang/wg-cargo-std-aware">跟踪仓库</a>和issues。</p>
<p>目前实现的功能是在名为 <code>-Z build-std</code> 的标志后。这个标志表明，Cargo应该使用与主构建本身相同的配置文件从源代码中编译标准库。
请注意，要实现这个功能，你需要有标准库的源代码，目前唯一支持的方法是添加 <code>rust-src</code> rust rustup组件。</p>
<pre><code class="language-console">$ rustup component add rust-src --toolchain nightly
</code></pre>
<p>现在还要求 <code>-Z build-std</code> 标志与 <code>--target</code> 标志组合。请注意，并不是强制进行交叉编译，只是要求以某种形式传递 <code>--target</code> 。</p>
<p>使用方法如下:</p>
<pre><code class="language-console">$ cargo new foo
$ cd foo
$ cargo +nightly run -Z build-std --target x86_64-unknown-linux-gnu
   Compiling core v0.0.0 (...)
   ...
   Compiling foo v0.1.0 (...)
    Finished dev [unoptimized + debuginfo] target(s) in 21.00s
     Running `target/x86_64-unknown-linux-gnu/debug/foo`
Hello, world!
</code></pre>
<p>这里，在调试模式下重新编译了标准库，并带有调试断言(就像 <code>src/main.rs</code> 被编译一样) ，最后所有内容都被连接在一起。</p>
<p>使用 <code>-Z build-std</code> 将隐式地编译稳定版本 crate <code>core</code> 、 <code>std</code> 、 <code>alloc</code> 和 <code>proc_macro</code> 。
如果你使用 <code>cargo test</code> ，它也将编译 <code>test</code> crate。如果你的工作环境不支持其中的一些crate，那么可以向 <code>-Zbuild-std</code> 传递参数。</p>
<pre><code class="language-console">$ cargo +nightly build -Z build-std=core,alloc
</code></pre>
<p>这里的值是以逗号分隔的要构建的标准库crate的列表。</p>
<h4 id="要求"><a class="header" href="#要求">要求</a></h4>
<p>总结起来，使用 <code>-Z build-std</code> 的需求清单是:</p>
<ul>
<li>你必须通过 <code>rustup component add rust-src</code> 安装libstd的源代码。</li>
<li>你必须传递 <code>--target</code> 。</li>
<li>你必须同时使用每日构建 Cargo 和 Rustc</li>
<li><code>-Z build-std</code> 标志必须传递给所有 <code>cargo</code> 调用。</li>
</ul>
<h4 id="报告错误并提供帮助"><a class="header" href="#报告错误并提供帮助">报告错误并提供帮助</a></h4>
<p><code>-Z build-std</code> 特性正处于开发的早期阶段! Cargo的这项功能有非常长的历史，范围也非常大，而这只是一个开始。如果你想报告bug，请把它们报告给:</p>
<ul>
<li>Cargo - <a href="https://github.com/rust-lang/cargo/issues/new">https://github.com/rust-lang/cargo/issues/new</a> - for implementation bugs</li>
<li>The tracking repository -
<a href="https://github.com/rust-lang/wg-cargo-std-aware/issues/new">https://github.com/rust-lang/wg-cargo-std-aware/issues/new</a> - for larger design
questions.</li>
</ul>
<p>此外，如果你想查看尚未实现的特性，或者如果某些内容没有完全按照你希望的方式工作，
请随时查看库的<a href="https://github.com/rust-lang/wg-cargo-std-aware/issues">问题跟踪</a>，如果那里没有，请提交新问题！</p>
<h3 id="build-std-features"><a class="header" href="#build-std-features">build-std-features</a></h3>
<ul>
<li>Tracking Repository: <a href="https://github.com/rust-lang/wg-cargo-std-aware">https://github.com/rust-lang/wg-cargo-std-aware</a></li>
</ul>
<p>这个标志是 <code>-Zbuild-std</code> 特性标志的成员。这将配置在构建标准库时为标准库本身启用的特性。
目前默认启用的特性是 <code>backtrace</code> 和 <code>panic_unwind</code> 。这个标志期望逗号分隔的列表，如果提供的话，将覆盖默认启用的特性列表。</p>
<h3 id="binary-dep-depinfo"><a class="header" href="#binary-dep-depinfo">binary-dep-depinfo</a></h3>
<ul>
<li>Tracking rustc issue: <a href="https://github.com/rust-lang/rust/issues/63012">#63012</a></li>
</ul>
<p><code>-Z binary-dep-depinfo</code> 标志使 Cargo 将同样的标志转发给 <code>rustc</code> ，这将使 <code>rustc</code> 在 &quot;dep info&quot; 文件(扩展名为 <code>.d</code> )中包含所有二进制依赖的路径。
Cargo会使用这些信息进行变化检测(如果有任何二进制的依赖发生变化，那么crate就会被重新构建)。
主要的用例是编译器本身，它对标准库有隐含的依赖，否则就不会追踪到变化检测。</p>
<h3 id="panic-abort-tests"><a class="header" href="#panic-abort-tests">panic-abort-tests</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/67650">#67650</a></li>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/7460">#7460</a></li>
</ul>
<p><code>-Z panic-abort-tests</code> 标志将启用每日构建支持，以 <code>-Cpanic=abort</code> 编译测试连接crate。如果没有这个标志，Cargo会用 <code>-Cpanic=unwind</code> 来编译测试，
以及所有依赖，因为这是 <code>test</code>-the-rate 知道如何操作的唯一方式。然而，从<a href="https://github.com/rust-lang/rust/pull/64158">rust-lang/rust#64158</a>开始，<code>test</code>-crate 支持 <code>-C panic=abort</code> ，并支持每个进程的测试，可以帮助避免多次编译crate图。</p>
<p>目前还不清楚如何在Cargo中稳定这一特性，但我们希望能以某种方式稳定下来。</p>
<h3 id="keep-going"><a class="header" href="#keep-going">keep-going</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/10496">#10496</a></li>
</ul>
<p><code>cargo build --keep-going</code> (以及类似的 <code>check</code> 、 <code>test</code> 等)将尽可能多地构建依赖图中的crate，而不是在第一个失败的crate中止构建。</p>
<p>例如，如果当前包依赖于 <code>fails</code> 和 <code>works</code> 两个依赖项，其中一个构建失败，<code>cargo check -j1</code> 可能也可能不会构建成功(取决于Cargo选择先运行哪一个构建)，而 <code>cargo check -j1 --keep-going</code> 肯定会同时运行两个构建，即使先运行的那个构建失败。</p>
<p>必须使用 <code>-Z unstable-options</code> 命令行选项，以便在尚未稳定时使用 <code>--keep-going</code> 。</p>
<pre><code class="language-console">cargo check --keep-going -Z unstable-options
</code></pre>
<h3 id="config-include"><a class="header" href="#config-include">config-include</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/7723">#7723</a></li>
</ul>
<p>配置文件中的 <code>include</code> 键可以用来加载另一个配置文件。它需要相对于配置文件的另一个文件路径的字符串，或者字符串列表。需要 <code>-Zconfig-include</code> 命令行选项。</p>
<pre><code class="language-toml"># .cargo/config
include = '../../some-common-config.toml'
</code></pre>
<p>配置文件的值首先从包含路径中加载，然后在其上合并配置文件本身的值。</p>
<p>这可以与<a href="#config-cli">config-cli</a>搭配使用，以指定从命令行加载的文件。传递一个配置文件的路径作为 <code>--config</code> 的参数:</p>
<pre><code class="language-console">cargo +nightly -Zunstable-options -Zconfig-include --config somefile.toml build
</code></pre>
<p>CLI路径是相对于当前工作目录的。</p>
<h3 id="target-applies-to-host"><a class="header" href="#target-applies-to-host">target-applies-to-host</a></h3>
<ul>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/9322">#9322</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9453">#9453</a></li>
</ul>
<p>曾经，Cargo对环境变量中的 <code>linker</code> 和 <code>rustflags</code> 配置选项以及 <code>[target]</code> 是否遵从构建脚本、插件和其他始终为主机平台构建的制品的行为有些不一致。当 <code>--target</code> 没有通过时，Cargo会遵从构建脚本的 <code>linker</code> 和 <code>rustflags</code> ，与所有其他编译制品相同。然而，当 <code>--target</code> 通过时，Cargo遵从 <code>[target.&lt;host triple&gt;]</code> 的 <code>linker</code> ，而不接受任何 <code>rustflags</code> 配置。这种双重行为让人困惑，也让人难以正确地配置构建，在这种情况下，主机三元组和目标三元组恰好是相同的，但打算在构建主机上运行的制品仍应以不同方式配置。</p>
<p><code>-Ztarget-applies-to-host</code> 在Cargo配置文件中启用顶层的 <code>target-applies-to-host</code> 设置，允许用户为这些属性选择不同(和更一致)的行为。当 <code>target-applies-to-host</code>  在配置文件中未设置或设置为 <code>true</code> 时，现有的Cargo行为将被保留(不过请查看 <code>-Zhost-config</code> ，它改变了这个默认值)。当它被设置为 <code>false</code> 时，无论 <code>--target</code> 是否被传递给Cargo， <code>[target.&lt;host triple&gt;]</code> 、 <code>RUSTFLAGS</code> 或 <code>[build]</code> 的选项都不会被主机制品所尊从。要定制打算在主机上运行的制品，请使用 <code>[host]</code> (<a href="#host-config"><code>host-config</code></a>)。</p>
<p>将来， <code>target- appliesto -host</code> 可能最终会默认为 <code>false</code> ，以提供更健全和一致的默认行为。</p>
<pre><code class="language-toml"># config.toml
target-applies-to-host = false
</code></pre>
<pre><code class="language-console">cargo +nightly -Ztarget-applies-to-host build --target x86_64-unknown-linux-gnu
</code></pre>
<h3 id="host-config"><a class="header" href="#host-config">host-config</a></h3>
<ul>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/9322">#9322</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9452">#9452</a></li>
</ul>
<p>配置文件中的 <code>host</code> 键可以用来向主机构建目标传递标志，比如交叉编译时必须在主机系统而不是目标系统上运行的构建脚本。
它同时支持通用的和特定于主机架构的表。匹配的host arch表优先于通用的host表。</p>
<p>它需要设置 <code>-Zhost-config</code> 和 <code>-Ztarget-applies-to-host</code> 命令行选项，并且在Cargo配置文件中设置 <code>target-applies-to-host = false</code> 。</p>
<pre><code class="language-toml"># config.toml
[host]
linker = &quot;/path/to/host/linker&quot;
[host.x86_64-unknown-linux-gnu]
linker = &quot;/path/to/host/arch/linker&quot;
rustflags = [&quot;-Clink-arg=--verbose&quot;]
[target.x86_64-unknown-linux-gnu]
linker = &quot;/path/to/target/linker&quot;
</code></pre>
<p>在 <code>x86_64-unknown-linux-gnu</code> 主机上构建时，上面的通用 <code>host</code> 表将被完全忽略，因为 <code>host.x86_64-unknown-linux-gnu</code> 表具有优先权。</p>
<p>设置 <code>-Zhost-config</code> 将 <code>target-applies-to-host</code> 的默认值从 <code>true</code> 改为 <code>false</code> 。</p>
<pre><code class="language-console">cargo +nightly -Ztarget-applies-to-host -Zhost-config build --target x86_64-unknown-linux-gnu
</code></pre>
<h3 id="unit-graph"><a class="header" href="#unit-graph">unit-graph</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/8002">#8002</a></li>
</ul>
<p><code>--unit-graph</code> 标志可以传递给任何构建命令(<code>build</code>、<code>check</code>、<code>run</code>、<code>test</code>、<code>bench</code>、<code>doc</code>等)，
以向标准输出发送JSON对象，表示Cargo的内部单元图。实际上没有任何内容被构建，
命令在打印后立即返回。每个 &quot;单元&quot; 对应于编译器的一次执行。这些对象还包含每个单元所依赖的单元。</p>
<pre><code>cargo +nightly build --unit-graph -Z unstable-options
</code></pre>
<p>这种结构提供了Cargo所看到的更完整的依赖的视图。特别是，&quot;features&quot; 字段支持新的特性解析器，
依赖可以用不同的特性构建多次。 <code>cargo metadata</code> 从根本上不能表示不同依赖种类之间的特性关系，
当前特性取决于运行哪个命令，选择哪个包和目标。此外，它还可以提供包内依赖的细节，如构建脚本或测试。</p>
<p>下面是对JSON结构的描述:</p>
<pre><code class="language-javascript">{
  /* 是JSON输出结构的版本。如果有向后不兼容的变化，这个值将增加。 */
  &quot;version&quot;: 1,
  /* 所有构建单位的数组。 */
  &quot;units&quot;: [
    {
      /* 一个不透明的字符串，表示该包。关于包的信息可以从 `cargo metadata` 中获得。 */
      &quot;pkg_id&quot;: &quot;my-package 0.1.0 (path+file:///path/to/my-package)&quot;,
      /* Cargo目标。关于这些字段的更多信息，请参见 `cargo metadata` 文档。 https://doc.rust-lang.org/cargo/commands/cargo-metadata.html */
      &quot;target&quot;: {
        &quot;kind&quot;: [&quot;lib&quot;],
        &quot;crate_types&quot;: [&quot;lib&quot;],
        &quot;name&quot;: &quot;my-package&quot;,
        &quot;src_path&quot;: &quot;/path/to/my-package/src/lib.rs&quot;,
        &quot;edition&quot;: &quot;2018&quot;,
        &quot;test&quot;: true,
        &quot;doctest&quot;: true
      },
      /* 本单元的配置文件设置。这些值可能与配置清单中定义的配置文件不一致。
         单位可以使用修改的配置文件设置。例如，&quot;panic&quot; 设置可以被覆盖，用于测试，以迫使它 &quot;unwind&quot; 。 */
      &quot;profile&quot;: {
        /* 这些设置是由配置文件名称衍生而来。 */
        &quot;name&quot;: &quot;dev&quot;,
        /* 字符串表示的优化级别。 */
        &quot;opt_level&quot;: &quot;0&quot;,
        /* 字符串表示的LTO设置。 */
        &quot;lto&quot;: &quot;false&quot;,
        /* 编码单位是一个整数。 `null` 表示它应该使用编译器的默认值。 */
        &quot;codegen_units&quot;: null,
        /* 整数表示的调试信息等级。 `null` 表示它应该使用编译器的默认值 (0) 。 */
        &quot;debuginfo&quot;: 2,
        /* 是否启用了调试断言。 */
        &quot;debug_assertions&quot;: true,
        /* 是否启用了溢出检查。 */
        &quot;overflow_checks&quot;: true,
        /* 是否启用了rpath。 */
        &quot;rpath&quot;: false,
        /* 是否启用了增量编译。 */
        &quot;incremental&quot;: true,
        /* 恐慌的策略，&quot;unwind&quot; 或 &quot;abort&quot; 。 */
        &quot;panic&quot;: &quot;unwind&quot;
      },
      /* 为哪个平台建立的目标。如果值为 `null` ，则表明它是为主机建立的。
         否则，它是目标三元组的字符串(如 &quot;x86_64-unknown-linux-gnu&quot; )。 */
      &quot;platform&quot;: null,
      /* 该单元的 &quot;mode&quot; 。有效值:

         * &quot;test&quot; — 使用 `rustc` 作为测试来构建。
         * &quot;build&quot; — 使用 `rustc` 构建。
         * &quot;check&quot; — 在 &quot;check&quot; 模式下使用 `rustc` 构建。
         * &quot;doc&quot; — 使用 `rustdoc` 构建。
         * &quot;doctest&quot; — 使用 `rustdoc` 进行测试。
         * &quot;run-custom-build&quot; — 表示构建脚本的执行。
      */
      &quot;mode&quot;: &quot;build&quot;,
      /* 在这个单元上启用的特性数组字符串。 */
      &quot;features&quot;: [&quot;somefeat&quot;],
      /* 这是否是一个标准库单元，是不稳定的 build-std 功能的一部分。如果没有设置，视为 `false` 。 */
      &quot;is_std&quot;: false,
      /* 该单元的依赖数组。 */
      &quot;dependencies&quot;: [
        {
          /* 依赖的 &quot;单位&quot; 数组中的索引。 */
          &quot;index&quot;: 1,
          /* 此依赖项将被称为的名称。 */
          &quot;extern_crate_name&quot;: &quot;unicode_xid&quot;,
          /* 这个依赖是否是 &quot;public&quot; 的，是不稳定的公共依赖特性的一部分。如果没有设置，则不启用公共依赖特性。*/
          &quot;public&quot;: false,
          /* 该依赖是否被注入到 prelude 中，目前由 build-std 功能使用。如果没有设置，视为 `false` 。 */
          &quot;noprelude&quot;: false
        }
      ]
    },
    // ...
  ],
  /* &quot;单位&quot; 数组中作为依赖图 &quot;根&quot; 的索引数组。 */
  &quot;roots&quot;: [0],
}
</code></pre>
<h3 id="profile-rustflags-option"><a class="header" href="#profile-rustflags-option">Profile <code>rustflags</code> option</a></h3>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/7878">rust-lang/cargo#7878</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/10271">rust-lang/cargo#10271</a></li>
</ul>
<p>这个特性在 &quot;[profile]&quot; 部分提供了新的选项，用来指定直接传递给rustc的标志。可以像这样启用:</p>
<pre><code class="language-toml">cargo-features = [&quot;profile-rustflags&quot;]

[package]
# ...

[profile.release]
rustflags = [ &quot;-C&quot;, &quot;...&quot; ]
</code></pre>
<h3 id="rustdoc-map"><a class="header" href="#rustdoc-map">rustdoc-map</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/8296">#8296</a></li>
</ul>
<p>这个特性增加了传递给 <code>rustdoc</code> 的配置，这样它就可以在依赖没有文档的情况下，
生成指向文档托管在其他地方的依赖的链接。首先，将其添加到 <code>.cargo/config</code> 中。</p>
<pre><code class="language-toml">[doc.extern-map.registries]
crates-io = &quot;https://docs.rs/&quot;
</code></pre>
<p>然后，在构建文档时，使用以下标志，使链接的依赖链接到 <a href="https://docs.rs/">docs.rs</a> 。</p>
<pre><code>cargo +nightly doc --no-deps -Zrustdoc-map
</code></pre>
<p><code>registries</code> 表包含了注册中心名称与要链接的URL的映射。URL可以有 <code>{pkg_name}</code> 和 <code>{version}</code> 的标记，
这些标记会被替换成相应的值。如果两者都没有指定，那么Cargo默认会在URL的末尾添加 <code>{pkg_name}/{version}/</code> 。</p>
<p>另一个配置设置可用于重定向标准库链接。默认情况下，rustdoc 创建链接到 <a href="https://doc.rust-lang.org/nightly/">https://doc.rust-lang.org/nightly/</a> 。
要改变这种行为，请使用 <code>doc.extern-map.std</code> 设置。</p>
<pre><code class="language-toml">[doc.extern-map]
std = &quot;local&quot;
</code></pre>
<p>值为 <code>&quot;local&quot;</code> 意味着链接到在 <code>rustc</code> 系统根中找到的文档。如果你使用的是rustup，这个文档可以用 <code>rustup component add rust-docs</code> 来安装。</p>
<p>默认值是 <code>&quot;remote&quot;</code> 。</p>
<p>该值也可以接受一个自定义位置的URL。</p>
<h3 id="per-package-target"><a class="header" href="#per-package-target">per-package-target</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/pull/9406">#9406</a></li>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/9030">#9030</a></li>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/pull/7004">#7004</a></li>
</ul>
<p><code>per-package-target</code> 特性在配置清单中增加了两个键：<code>package.default-target</code> 和  <code>package.forced-target</code> 。
第一个键使包在默认情况下 (即没有传递 <code>--target</code> 参数时)为某个目标进行编译。第二种是使包总是为该目标编译。</p>
<p>Example:</p>
<pre><code class="language-toml">[package]
forced-target = &quot;wasm32-unknown-unknown&quot;
</code></pre>
<p>在这个例子中，crate总是为 <code>wasm32-unknown-unknown</code> 构建的，例如，因为它将被用作运行在主机(或在命令行上提供)目标上的主程序的插件。</p>
<h3 id="artifact-dependencies"><a class="header" href="#artifact-dependencies">artifact-dependencies</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/pull/9096">#9096</a></li>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/9992">#9992</a></li>
</ul>
<p>允许 Cargo 包依赖 <code>bin</code> 、 <code>cdylib</code> 和 <code>staticlib</code> crate，并在编译时使用这些crate构建的制品。</p>
<p>使用 <code>-Z bindeps</code> 运行 <code>cargo</code> 来启用这一功能。</p>
<p><strong>示例:</strong> 在构建脚本中使用 <em>cdylib</em> 制品</p>
<p>消耗包中的 <code>Cargo.toml</code> ，为特定的构建目标将 <code>bar</code> 库构建为 <code>cdylib</code> </p>
<pre><code class="language-toml">[build-dependencies]
bar = { artifact = &quot;cdylib&quot;, version = &quot;1.0&quot;, target = &quot;wasm32-unknown-unknown&quot; }
</code></pre>
<p>和 <code>build.rs</code> 中的构建脚本一起。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  wasm::run_file(std::env::var(&quot;CARGO_CDYLIB_FILE_BAR&quot;).unwrap());
}</code></pre></pre>
<p><strong>示例:</strong> 在二进制文件中使用 <em>binary</em> 制品和它的库。</p>
<p>消耗包中的 <code>Cargo.toml</code> ，构建 <code>bar</code> 二进制文件作为制品，同时将其作为库提供…</p>
<pre><code class="language-toml">[dependencies]
bar = { artifact = &quot;bin&quot;, version = &quot;1.0&quot;, lib = true }
</code></pre>
<p>与可执行文件一起使用 <code>main.rs</code> 。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  bar::init();
  command::run(env!(&quot;CARGO_BIN_FILE_BAR&quot;));
}</code></pre></pre>
<h3 id="sparse-registry"><a class="header" href="#sparse-registry">sparse-registry</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9069">9069</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/2789">#2789</a></li>
</ul>
<p><code>sparse-registry</code> 特性允许cargo与通过普通HTTP而不是git提供的远程注册中心进行交互。这些注册中心可以通过以 <code>sparse+http://</code> 或 <code>sparse+https://</code> 开头的URL识别。</p>
<p>当通过HTTP获取索引元数据时，Cargo 只下载相关crate的元数据，这可以节省大量时间和带宽。</p>
<p>sparse索引格式与基于git的索引的签出是一样的。</p>
<p><code>registries.crates-io.protocol</code> 配置选项可以用来设置 crates.io 的默认协议。这个选项需要启用 <code>-Z sparse-registry</code> 。</p>
<ul>
<li><code>sparse</code> — 使用 sparse 索引。</li>
<li><code>git</code> — 使用 git 索引。</li>
<li>如果选项没有设置，若启用 <code>-Z sparse-registry</code> ，它将是sparse索引，否则它将是git索引。</li>
</ul>
<p>Cargo在本地缓存crate元数据文件，并从服务器上捕获每个条目的 <code>ETag</code> 或 <code>Last-Modified</code> HTTP头。
当刷新crate元数据时，Cargo会发送 <code>If-None-Match</code> 或 <code>If-Modified-Since</code> 头，如果本地缓存有效，则允许服务器以HTTP 304响应，以节省时间和带宽。</p>
<h3 id="publish-timeout"><a class="header" href="#publish-timeout">publish-timeout</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/11222">11222</a></li>
</ul>
<p>配置文件中的 <code>publish.timeout</code> 键可以用来控制 <code>cargo publish</code> 在将包发布到注册中心和它在本地索引中可用之间的等待时间。</p>
<p>如果超时为 <code>0</code> 就不会发生任何检查。</p>
<p>它需要设置 <code>-Zpublish-timeout</code> 命令行选项。</p>
<pre><code class="language-toml"># config.toml
[publish]
timeout = 300  # 按秒
</code></pre>
<h3 id="registry-auth"><a class="header" href="#registry-auth">registry-auth</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/10474">10474</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3139">#3139</a></li>
</ul>
<p>通过在注册中心索引的config.json中添加配置选项，使Cargo在API请求、crate下载和sparse索引更新中包含授权令牌。</p>
<p>要使用这个特性，注册中心服务器必须在 <code>config.json</code> 中包含 <code>&quot;auth-required&quot;: true</code> ，并且必须在Cargo命令行中传递 <code>-Z registry-auth</code> 标志。</p>
<p>当使用sparse协议时，Cargo会在获取任何其他文件之前尝试获取 <code>config.json</code> 文件。
如果服务器的回应是HTTP 401，那么Cargo将认为注册中心需要认证，并重新尝试请求 <code>config.json</code> ，其中包含认证令牌。</p>
<p>在认证失败 (或缺少认证令牌) 时，服务器可能包括 <code>WWW-Authenticate</code> 头和 <code>Cargo login_url</code> 信息，以表明用户可以去哪里获得令牌。</p>
<pre><code>WWW-Authenticate: Cargo login_url=&quot;https://test-registry-login/me
</code></pre>
<p>This same flag is also used to enable asymmetric authentication tokens.</p>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/10519">10519</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3231">#3231</a></li>
</ul>
<p>增加对Cargo的支持，以便在不通过网络发送私密信息的情况下对用户进行认证。</p>
<p>在 <a href="config.html"><code>config.toml</code></a> 和 <code>credentials.toml</code> 文件中，有名为 <code>private-key</code> 的字段，它是以秘密的 <a href="https://github.com/paseto-standard/paserk/blob/master/types/secret.md">subset of <code>PASERK</code></a>格式的私钥，用于签署非对称令牌。</p>
<p>可以用 <code>cargo login --generate-keypair</code> 生成密钥对，这将:</p>
<ul>
<li>以目前推荐的方式生成公钥/私钥对。</li>
<li>保存私钥在 <code>credentials.toml</code> 。</li>
<li>格式打印公钥 <a href="https://github.com/paseto-standard/paserk/blob/master/types/public.md">PASERK public</a> 。</li>
</ul>
<p>建议将 <code>private-key</code> 保存在 <code>credentials.toml</code> 中。在 <code>config.toml</code> 中也支持，主要是为了使用相关的环境变量来设置，这也是在CI背景下提供的推荐方式。这种设置就是为 <code>token</code> 字段设置秘密令牌的方式。</p>
<p>还有可选字段 <code>private-key-subject</code> ，是由注册中心选择的字符串。
这个字符串将作为非对称令牌的一部分，不应该是秘密的。
是为 &quot;中央CA服务器授权此行为的加密证明&quot; 这样的极少用例准备的。
Cargo要求它为非空格可打印的ASCII。需要非ASCII数据的注册中心应该对其进行base64编码。 </p>
<p>这两个字段都可以用 <code>cargo login --registry=name --private-key --private-key-subject=&quot;subject&quot;</code> 来设置，它将提示你输入密钥值。</p>
<p>注册中心最多可以设置  <code>private-key</code> 、<code>token</code> 、 <code>credential-process</code> 之一。</p>
<p>所有PASETO将包含  <code>iat</code> ，即ISO 8601格式的当前时间。Cargo将酌情包含以下内容:</p>
<ul>
<li><code>sub</code>一个可选的、非秘密的字符串，由注册中心选择，预期在每次请求时都会被取得。该值将是 <code>config.toml</code> 文件中的 <code>private-key-subject</code> 。</li>
<li><code>mutation</code> 如果存在, 表示该请求是一个改变操作(如果不存在，则是一个只读操作)，必须是字符串 <code>publish</code> 、 <code>yank</code> 、 <code>unyank</code> 之一。
<ul>
<li><code>name</code> 与此请求有关的crate的名称。</li>
<li><code>vers</code> 与此请求相关的包的版本字符串。</li>
<li><code>cksum</code> 箱子内容的SHA256哈希值，是由64个小写的十六进制数字组成的字符串，只有当 <code>mutation</code> 等于 <code>publish</code> 时才必须出现。 </li>
</ul>
</li>
<li><code>challenge</code> 从该服务器的session 401/403中收到的质询字符串。发出质询的注册中心必须跟踪哪些质询已经 issued/used ，并且在同一有效期内不接受特定的质询超过一次(避免跟踪每一个曾经发出的质询)。</li>
</ul>
<p>&quot;footer&quot; (这是签名的一部分)将是一个UTF-8格式的JSON字符串，包括:</p>
<ul>
<li><code>url</code> 符合RFC 3986标准的URL，cargo从那里得到config.json文件。
<ul>
<li>如果这是有HTTP索引的注册中心，那么这就是所有索引查询相对的基本URL。</li>
<li>如果这是有GIT索引的注册中心，它是Cargo用来克隆索引的URL。</li>
</ul>
</li>
<li><code>kid</code> 用于签署请求的私钥的标识，使用<a href="https://github.com/paseto-standard/paserk/blob/master/operations/ID.md">PASERK IDs</a> 标准。</li>
</ul>
<p>PASETO包括被签名的信息，因而服务器不必为了检查签名而从请求中重构确切字符串。
服务器需要检查签名比对PASETO中的字符串是否有效，以及该字符串的内容是否与请求相符。
如果该请求应该有一个声明，但在PASETO中没有，那么该请求必须被拒绝。</p>
<h3 id="credential-process"><a class="header" href="#credential-process">credential-process</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/8933">#8933</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/2730">#2730</a></li>
</ul>
<p><code>credential-process</code> 特性增加了一个配置设置，通过调用一个外部进程来获取注册中心认证令牌。</p>
<p>Token认证被 <a href="../commands/cargo-login.html"><code>cargo login</code></a> 、 <a href="../commands/cargo-publish.html"><code>cargo publish</code></a> 、 <a href="../commands/cargo-owner.html"><code>cargo owner</code></a> 和 <a href="../commands/cargo-yank.html"><code>cargo yank</code></a> 命令所使用。此外，该特性增加新的 <code>cargo logout</code> 命令。</p>
<p>要使用这个特性，你必须在命令行中传递 <code>-Z credential-process</code> 标志。
此外，你必须删除当前保存在 <a href="config.html#credentials"><code>credentials</code> file</a> 中的任何当前令牌(这可以通过新的 <code>logout</code> 命令来完成)。</p>
<h4 id="credential-process-配置"><a class="header" href="#credential-process-配置"><code>credential-process</code> 配置</a></h4>
<p>要配置运行哪个进程来获取令牌，在 <a href="config.html">config file</a> 的 <code>registry</code> 表中指定进程:</p>
<pre><code class="language-toml">[registry]
credential-process = &quot;/usr/bin/cargo-creds&quot;
</code></pre>
<p>如果你想对一个特定的注册中心使用不同的进程，可以在 <code>registries</code> 表中指定。</p>
<pre><code class="language-toml">[registries.my-registry]
credential-process = &quot;/usr/bin/cargo-creds&quot;
</code></pre>
<p>该值可以是用空格分隔参数的字符串，也可以是TOML字符串数组。</p>
<p>命令行参数允许特殊的占位符，这些占位符将被替换成相应的值:</p>
<ul>
<li><code>{name}</code> — 注册中心的名称。</li>
<li><code>{api_url}</code> —  注册中心 API 端点的基本URL。</li>
<li><code>{action}</code> — 认证动作(如下所述)。</li>
</ul>
<p>带有 <code>cargo:</code> 前缀的进程名称会从cargo下的 <code>libexec</code> 目录中加载。Cargo中包含了几个实验性的证书包装器，以提供对它们的便利访问:</p>
<pre><code class="language-toml">[registry]
credential-process = &quot;cargo:macos-keychain&quot;
</code></pre>
<p>目前的包装器是:</p>
<ul>
<li><code>cargo:macos-keychain</code>: 使用macOS Keychain来存储令牌。</li>
<li><code>cargo:wincred</code>: 使用Windows证书管理器来存储令牌。</li>
<li><code>cargo:1password</code>: 使用1password <code>op</code> CLI来存储令牌。你必须从 <a href="https://1password.com/downloads/command-line/">1password 网站</a>安装 <code>op</code> CLI。你必须至少运行一次<code>op signin</code>，并加上适当的参数(如 <code>op signin my.1password.com user@example.com</code> )，除非你提供地址和电子邮件参数。除非设置了适当的 <code>OP_SESSION</code> 环境变量，否则每次请求时都需要主密码。它支持以下命令行参数。
<ul>
<li><code>--account</code>: 使用的账户简写名称。</li>
<li><code>--vault</code>:  使用的保险名称。</li>
<li><code>--sign-in-address</code>: 登录地址，是一个网址，如 <code>my.1password.com</code> 。</li>
<li><code>--email</code>: 用来登录的电子邮件地址。</li>
</ul>
</li>
</ul>
<p>GNOME <a href="https://wiki.gnome.org/Projects/Libsecret">libsecret</a> 有包装器，可以在Linux系统上存储令牌。由于构建的限制，这个包装器不能作为预编译的二进制文件使用。
这可以手动构建和安装。首先，使用你的系统包管理器安装 libsecret (例如，<code>sudo apt install libsecret-1-dev</code>)。
然后用<code>cargo install cargo-credential-gnome-secret</code> 构建并安装包装器。在配置中，使用二进制文件的路径，如下所示:</p>
<pre><code class="language-toml">[registry]
credential-process = &quot;cargo-credential-gnome-secret {action}&quot;
</code></pre>
<h4 id="credential-process-接口"><a class="header" href="#credential-process-接口"><code>credential-process</code> 接口</a></h4>
<p>Cargo支持两种不同的token进程。简单的 &quot;basic&quot; 类型只在Cargo需要令牌时才会被调用。
这是为了与密码管理器进行简单而方便的集成，通常可以使用已有的工具。
更高级的 &quot;Cargo&quot; 类型支持作为命令行参数传递的不同动作。
这样做的目的是为了获得更好的集成体验，代价是需要一个Cargo特定的进程来粘合到密码管理器上。
Cargo会根据 &quot;credential-process&quot; 的定义来决定支持哪种类型。
如果它包含 <code>{action}</code> 参数，那么它就会使用高级样式，否则它就假定它只支持 &quot;basic&quot; 样式。</p>
<h5 id="基础认证器"><a class="header" href="#基础认证器">基础认证器</a></h5>
<p>基础认证器是在stdout上返回一个令牌的进程。新行将被修整。该进程继承了用户的 stdin 和 stderr 。它应在成功时退出0，在错误时退出非零。</p>
<p>在这种形式下，不支持 <a href="../commands/cargo-login.html"><code>cargo login</code></a> 和 <code>cargo logout</code> ，如果使用，会返回一个错误。</p>
<h5 id="cargo认证器"><a class="header" href="#cargo认证器">Cargo认证器</a></h5>
<p>Cargo和进程之间的协议是非常基本的，目的是确保认证过程尽可能简单。
Cargo将执行进程，其 <code>{action}</code> 参数表明要执行的动作。</p>
<ul>
<li><code>store</code> — 将给定令牌可靠存储。</li>
<li><code>get</code> —从存储中获取令牌。</li>
<li><code>erase</code> — 从存储中移除令牌。</li>
</ul>
<p><code>cargo login</code> 命令使用 <code>store</code> 来保存令牌。需要认证的命令，如 <code>cargo publish</code> ，使用 <code>get</code> 检索令牌。 <code>cargo logout</code> 使用 <code>erase</code> 命令来删除令牌。</p>
<p>进程继承了用户的stderr，所以进程可以显示信息。
有些值是通过环境变量传递进来(见下文)。预期的交互作用是:</p>
<ul>
<li>
<p><code>store</code> — 令牌被发送到进程的stdin中，以换行结束。进程应该根据注册中心的名称来存储令牌。如果进程失败，它应该以非零的退出状态退出。</p>
</li>
<li>
<p><code>get</code> — 进程应将令牌发送到其stdout(尾部的换行将被修整)。进程继承用户的stdin，如果它需要接收输入的话。</p>
<p>如果进程无法完成请求，它应该以非零退出代码退出。</p>
</li>
<li>
<p><code>erase</code> — 该进程应该删除与注册中心名称相关联的令牌。如果没有找到令牌，进程应该以0状态退出。</p>
</li>
</ul>
<h5 id="环境"><a class="header" href="#环境">环境</a></h5>
<p>以下环境变量提供给被执行的命令:</p>
<ul>
<li><code>CARGO</code> — 执行命令的 <code>cargo</code> 二进制文件的路径。</li>
<li><code>CARGO_REGISTRY_INDEX_URL</code> — 注册中心索引的URL。</li>
<li><code>CARGO_REGISTRY_NAME_OPT</code> — 注册中心的可选名称。不应作为存储键使用。并不总是可用的。</li>
</ul>
<h4 id="cargo-logout"><a class="header" href="#cargo-logout"><code>cargo logout</code></a></h4>
<p>增加新的 <code>cargo logout</code> 命令，使其更容易从存储中删除令牌。这同时支持 <a href="config.html#credentials"><code>credentials</code> file</a> 令牌和 <code>credential-process</code> 令牌。</p>
<p>当与 <code>credentials</code> 文件令牌一起使用时，它需要 <code>-Z unstable-options</code> 命令行选项:</p>
<pre><code class="language-console">cargo logout -Z unstable-options
</code></pre>
<p>当与 <code>credential-process</code> 配置一起使用时，使用 <code>-Z credential-process</code> 命令行选项:</p>
<pre><code class="language-console">cargo logout -Z credential-process
</code></pre>
<h3 id="cargo-config"><a class="header" href="#cargo-config"><code>cargo config</code></a></h3>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/2362">#2362</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9301">#9301</a></li>
</ul>
<p><code>cargo config</code> 子命令提供了一种显示cargo加载的配置文件的方法。
它目前包括 <code>get</code> 子命令，可以接受可选的配置文件来显示。</p>
<pre><code class="language-console">cargo +nightly -Zunstable-options config get build.rustflags
</code></pre>
<p>如果不包含配置值，它将显示所有的配置值。参见 <code>--help</code> 输出，了解更多可用的选项。</p>
<h3 id="doctest-in-workspace"><a class="header" href="#doctest-in-workspace"><code>doctest-in-workspace</code></a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9427">#9427</a></li>
</ul>
<p><code>-Z doctest-in-workspace</code> 标志改变了运行文档测试时使用的当前工作目录的行为。
曾经，Cargo运行 <code>rustdoc --test</code> 时是相对于包的根目录，路径相对于根目录。
然而，这与 <code>rustc</code> 和 <code>rustdoc</code> 在工作空间的正常运行方式不一致，它们是相对于工作空间根目录运行。
这种不一致会导致各种问题，比如在传递 RUSTDOCFLAGS 时，使用相对路径，或者处理诊断输出。</p>
<p><code>-Z doctest-in-workspace</code> 标志使cargo切换到从工作空间的根运行 <code>rustdoc</code> 。
它还将 <code>--test-run-directory</code> 传递给 <code>rustdoc</code> ，以便在<em>运行</em>测试时，从包的根目录运行。
这保留了向后的兼容性，并且与正常的单元测试的运行方式一致。</p>
<h3 id="rustc---print"><a class="header" href="#rustc---print">rustc <code>--print</code></a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9357">#9357</a></li>
</ul>
<p><code>cargo rustc --print=VAL</code> 将 <code>--print</code> 标志转发给 <code>rustc</code> ，以便从 <code>rustc</code> 中提取信息。
在运行 <code>rustc</code> 时，会有相应的 <a href="https://doc.rust-lang.org/rustc/command-line-arguments.html#--print-print-compiler-information"><code>--print</code></a> 标志，
然后立即退出，不进行编译。将其作为cargo标志暴露，允许cargo根据当前配置注入正确的目标和RUSTFLAGS。</p>
<p>主要的使用情况是运行 <code>cargo rustc --print=cfg</code> 来获得相应目标的配置值，并受到任何其他RUSTFLAGS的影响。 </p>
<h3 id="不同的二进制名称"><a class="header" href="#不同的二进制名称">不同的二进制名称</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9778">#9778</a></li>
<li>PR: <a href="https://github.com/rust-lang/cargo/pull/9627">#9627</a></li>
</ul>
<p><code>different-binary-name</code> 特性允许设置二进制文件的文件名，而不必遵守对crate名称的限制。比如，crate名称只能使用 <code>alphanumeric</code> 字符或 <code>-</code> 或 <code>_</code> ，并且不能为空。</p>
<p><code>filename</code> 参数 <strong>不</strong> 包含二进制扩展名，<code>cargo</code> 将计算出适当的扩展名并将其用于二进制文件。</p>
<p>参数 <code>filename</code> 只在配置清单的 <code>[[bin]]</code> 部分可用。</p>
<pre><code class="language-toml">cargo-features = [&quot;different-binary-name&quot;]

[package]
name =  &quot;foo&quot;
version = &quot;0.0.1&quot;

[[bin]]
name = &quot;foo&quot;
filename = &quot;007bar&quot;
path = &quot;src/main.rs&quot;
</code></pre>
<h3 id="scrape-examples"><a class="header" href="#scrape-examples">scrape-examples</a></h3>
<ul>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3123">#3123</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9910">#9910</a></li>
</ul>
<p><code>-Z rustdoc-scrape-examples</code> 标志告诉 Rustdoc 在当前工作空间中搜索crate的函数调用。
然后，这些调用点会被包含在文档中。你可以像这样使用该标志:</p>
<pre><code>cargo doc -Z unstable-options -Z rustdoc-scrape-examples
</code></pre>
<p>默认情况下，Cargo会从记录的包的例子目标中抓取实例。
你可以用 <code>doc-scrape-examples</code> 标志单独启用或禁用目标，例如:</p>
<pre><code class="language-toml"># 启用从库中抓取实例
[lib]
doc-scrape-examples = true

# 禁用从实例目标中抓取实例
[[example]]
name = &quot;my-example&quot;
doc-scrape-examples = false
</code></pre>
<p><strong>关于测试的说明:</strong> 在测试目标上启用 <code>doc-scrape-examples</code> 目前没有任何效果。从测试中抓取例子是一项正在进行的工作。</p>
<p><strong>关于dev-依赖的说明:</strong> 记录库通常不需要crate的dev-依赖。然而，示例目标需要dev-依赖。
为了向后兼容， <code>-Z rustdoc-scrape-examples</code> 将<em>不</em>为 <code>cargo doc</code> 引入dev-依赖要求。
因此，在以下情况下，将 <em>不会</em> 从示例目标中抓取示例:</p>
<ol>
<li>没有被记录的目标需要dev-依赖, AND</li>
<li>至少有一个目标被记录的crate有dev-依赖, AND</li>
<li>对于所有 <code>[[example]]</code> 目标，<code>doc-scrape-examples</code> 参数未设置或为假。</li>
</ol>
<p>如果你想让实例从实例目标中被抓取，那么你必须不满足上述条件之一。
例如，你可以为一个例子目标设置 <code>doc-scrape-examples</code> 为 true，这就向Cargo发出信号，你可以为 <code>cargo doc</code> 建立dev-依赖。</p>
<h3 id="check-cfg"><a class="header" href="#check-cfg">check-cfg</a></h3>
<ul>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3013">#3013</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/10554">#10554</a></li>
</ul>
<p><code>-Z check-cfg</code> 命令行可以在编译时检查 <code>#[cfg]</code> 、 <code>cfg!</code> 中的名称和值。
<code>#[link]</code> 和 <code>#[cfg_attr]</code> 中的名称和值，使用 <code>rustc</code> 和 <code>rustdoc</code> 不稳定的 <code>--check-cfg</code> 命令行。</p>
<p>它的值是:</p>
<ul>
<li><code>features</code>: 通过 <code>--check-cfg=values(feature, ...)</code> 启用特性检查。
注意这个命令行选项可能会成为稳定时的默认选项。</li>
<li><code>names</code>: 通过 <code>--check-cfg=names()</code> 实现众所周知的名称检查。</li>
<li><code>values</code>: 通过 <code>--check-cfg=values()</code> 实现众所周知的值检查。</li>
<li><code>output</code>: 启用构建脚本中的 <code>rustc-check-cfg</code> 。</li>
</ul>
<p>例如:</p>
<pre><code>cargo check -Z unstable-options -Z check-cfg=features
cargo check -Z unstable-options -Z check-cfg=names
cargo check -Z unstable-options -Z check-cfg=values
cargo check -Z unstable-options -Z check-cfg=features,names,values
</code></pre>
<p>Or for <code>output</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// build.rs
println!(&quot;cargo:rustc-check-cfg=names(foo, bar)&quot;);
<span class="boring">}</span></code></pre></pre>
<pre><code>cargo check -Z unstable-options -Z check-cfg=output
</code></pre>
<h3 id="cargorustc-check-cfgcheck_cfg"><a class="header" href="#cargorustc-check-cfgcheck_cfg"><code>cargo:rustc-check-cfg=CHECK_CFG</code></a></h3>
<p><code>rustc-check-cfg</code> 指令告诉Cargo将给定的值传递给编译器 <code>--check-cfg</code> 标志。
这可用于编译时检测意外的条件编译名称或值。</p>
<p>这只能与 <code>-Zcheck-cfg=output</code> 结合使用，否则会被忽略并发出警告。</p>
<p>如果你想集成Cargo的特性，请使用 <code>-Zcheck-cfg=features</code> ，而不是试图用这个选项手动完成。</p>
<h2 id="稳定和删除特性"><a class="header" href="#稳定和删除特性">稳定和删除特性</a></h2>
<h3 id="编译进度"><a class="header" href="#编译进度">编译进度</a></h3>
<p>编译进度功能在1.30版本中得到了稳定。进度条现在是默认启用的。
参见 <a href="config.html#termprogresswhen"><code>term.progress</code></a> 了解更多关于控制该特性的信息。</p>
<h3 id="版次"><a class="header" href="#版次">版次</a></h3>
<p>在 <code>Cargo.toml</code> 中指定 <code>edition</code> 已在1.31版本中得到稳定。
请参阅 <a href="manifest.html#the-edition-field">the edition field</a> 以了解有关指定该字段的更多信息。</p>
<h3 id="重命名依赖"><a class="header" href="#重命名依赖">重命名依赖</a></h3>
<p>在 <code>Cargo.toml</code> 中指定重命名依赖，在1.31版本中已经稳定。
参见 <a href="specifying-dependencies.html#renaming-dependencies-in-cargotoml">renaming dependencies</a> 了解更多关于重命名依赖的信息。</p>
<h3 id="备用注册中心"><a class="header" href="#备用注册中心">备用注册中心</a></h3>
<p>在1.34版本中，对备用注册中心的支持已经稳定下来了。
请参阅 <a href="registries.html">Registries chapter</a> 了解更多关于备用注册中心的信息。</p>
<h3 id="脱机模式"><a class="header" href="#脱机模式">脱机模式</a></h3>
<p>脱机功能在1.36版本中已经稳定下来了。
参见 <a href="../commands/cargo.html#option-cargo---offline"><code>--offline</code> flag</a>，了解更多关于使用脱机模式的信息。</p>
<h3 id="发表锁定文件"><a class="header" href="#发表锁定文件">发表锁定文件</a></h3>
<p>1.37版本中删除了 <code>publish-lockfile</code> 功能。如果包包含二进制目标，则在发布包时总是包括 <code>Cargo.lock</code> 文件。 <code>cargo install</code> 需要 <code>--locked</code> 标志来使用 <code>Cargo.lock</code> 文件。
更多信息见 <a href="../commands/cargo-package.html"><code>cargo package</code></a> 和 <a href="../commands/cargo-install.html"><code>cargo install</code></a> 。</p>
<h3 id="默认运行"><a class="header" href="#默认运行">默认运行</a></h3>
<p><code>default-run</code> 功能在1.37版本中已经稳定下来。参见 <a href="manifest.html#the-default-run-field">the `default-run'field</a> 以了解更多关于指定默认运行目标的信息。</p>
<h3 id="缓存信息"><a class="header" href="#缓存信息">缓存信息</a></h3>
<p>编译器信息缓存在1.40版本中得到了稳定。编译器警告现在被默认缓存，并在重新运行Cargo时自动回放。</p>
<h3 id="安装升级"><a class="header" href="#安装升级">安装升级</a></h3>
<p><code>install-upgrade</code> 特性在1.41版本中得到了稳定。<a href="../commands/cargo-install.html"><code>cargo install</code></a>现在会在包出现过期时自动升级。更多信息请参见 <a href="../commands/cargo-install.html"><code>cargo install</code></a> 文档。</p>
<h3 id="profile覆盖"><a class="header" href="#profile覆盖">Profile覆盖</a></h3>
<p>Profile 覆盖已经在1.41版本中得到稳定。请参阅<a href="profiles.html#overrides">Profile Overrides</a>以了解更多关于使用覆盖的信息。</p>
<h3 id="config-profiles"><a class="header" href="#config-profiles">Config Profiles</a></h3>
<p>在Cargo 配置文件和环境变量中指定配置文件的做法在1.43版本中已经稳定下来。
参见 <a href="config.html#profile">config <code>[profile]</code> table</a> 以了解更多关于在配置文件中指定 <a href="profiles.html">profile</a> 的信息。</p>
<h3 id="crate版本"><a class="header" href="#crate版本">crate版本</a></h3>
<p><code>-Z crate-versions</code> 标志在1.47版本中已经稳定。
crate版本现在自动包含在 <a href="../commands/cargo-doc.html"><code>cargo doc</code></a> 文档中。</p>
<h3 id="特性"><a class="header" href="#特性">特性</a></h3>
<p>在1.51版本中，<code>-Z features</code> 标志已经稳定下来。参见 <a href="feature.html#feature-resolver-version-2">feature resolver version 2</a> 以了解更多关于使用新特性解析器的信息。</p>
<h3 id="包特性"><a class="header" href="#包特性">包特性</a></h3>
<p><code>-Z package-features</code> 标志在1.51版本中已经稳定了。
参见 <a href="features.html#resolver-version-2command-line-flags">resolver version 2 command-line flags</a> 以了解更多关于使用特性 CLI 选项的信息。</p>
<h3 id="解析器"><a class="header" href="#解析器">解析器</a></h3>
<p><code>Cargo.toml</code> 中的 <code>Cargo.toml</code> 特性在1.51版本中已经稳定。
请参阅 <a href="resolver.html#resolver-versions">resolver versions</a> 以了解有关指定解析器的更多信息。</p>
<h3 id="extra-link-arg"><a class="header" href="#extra-link-arg">extra-link-arg</a></h3>
<p>在1.56版本中，用于在构建脚本中指定额外链接器参数的 <code>extra-link-arg</code> 功能已经稳定了。
请参阅 <a href="build-scripts.html#outputs-the-build-script">build script documentation</a> 以了解更多关于指定额外链接器参数的信息。</p>
<h3 id="configurable-env"><a class="header" href="#configurable-env">configurable-env</a></h3>
<p>在Cargo配置中指定环境变量的 <code>configurable-env</code> 功能在1.56版本中已经稳定下来。
关于配置环境变量的更多信息，请参见 <a href="config.html#env">config documentation</a> 。</p>
<h3 id="rust-version"><a class="header" href="#rust-version">rust-version</a></h3>
<p><code>Cargo.toml</code> 中的 <code>rust-version</code> 字段在1.56版本中已经稳定。
请参阅 <a href="manifest.html#the-rust-version-field">rust-version field</a> 以了解更多关于使用 <code>rust-version</code> 字段和 <code>-ignore-rust-version</code> 选项的信息。</p>
<h3 id="codegen-backend"><a class="header" href="#codegen-backend">codegen-backend</a></h3>
<p><code>codegen-backend</code> 特性使我们有可能使用配置文件来选择rustc使用的codegen后端。</p>
<p>Example:</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;

[dependencies]
serde = &quot;1.0.117&quot;

[profile.dev.package.foo]
codegen-backend = &quot;cranelift&quot;
</code></pre>
<h3 id="patch-in-config"><a class="header" href="#patch-in-config">patch-in-config</a></h3>
<p><code>-Z patch-in-config</code> 标志，以及对Cargo配置文件中 <code>[patch]</code> 部分的相应支持，在1.56版本中已经稳定下来。更多信息请参见 <a href="config.html#patch">patch field</a> 。</p>
<h3 id="edition-2021"><a class="header" href="#edition-2021">edition 2021</a></h3>
<p>2021 版次在1.56版本中已经稳定下来了。
参见<a href="manifest.html#the-edition-field"><code>edition</code> field</a>，了解更多关于设置版次的信息。
参见<a href=".../commands/cargo-fix.html"><code>cargo fix --edition</code></a>和<a href=".../.../edition-guide/index.html">The Edition Guide</a>了解更多关于迁移现有项目的信息。</p>
<h3 id="自定义命名的配置文件"><a class="header" href="#自定义命名的配置文件">自定义命名的配置文件</a></h3>
<p>自定义命名的配置文件已经在1.57版本中得到稳定。请参阅 <a href="profiles.html#custom-profiles">profiles chapter</a> 了解更多信息。</p>
<h3 id="profile-strip-option"><a class="header" href="#profile-strip-option">Profile <code>strip</code> option</a></h3>
<p>配置文件 <code>strip</code> 选项在1.59版本中已经稳定了。更多信息请参见 <a href="profiles.html#strip">profiles chapter</a> 。</p>
<h3 id="未来不兼容报告"><a class="header" href="#未来不兼容报告">未来不兼容报告</a></h3>
<p>在1.59版本中，对生成未来不兼容报告的支持已经稳定下来了。
更多信息请参见 <a href="future-incompat-report.html">future incompat report chapter</a>。</p>
<h3 id="名称空间特性"><a class="header" href="#名称空间特性">名称空间特性</a></h3>
<p>在1.60版本中，名称空间特性已经稳定下来了。
更多信息请参见<a href="features.html#optional-dependencies">Features chapter</a>。</p>
<h3 id="弱依赖性特性"><a class="header" href="#弱依赖性特性">弱依赖性特性</a></h3>
<p>弱依赖性特性在1.60版本中已经稳定下来。
更多信息请参见<a href="features.html#dependency-features">Features chapter</a>。</p>
<h3 id="timings"><a class="header" href="#timings">timings</a></h3>
<p><code>-Ztimings</code> 选项在1.60版本中已经稳定为 <code>--timings</code> 。
( <code>--timings=html</code> 和机器可读的 <code>--timings=json</code> 输出仍然不稳定，需要 <code>--Zunstable-options</code> 。)</p>
<h3 id="config-cli"><a class="header" href="#config-cli">config-cli</a></h3>
<p><code>--config</code> CLI选项在1.63版本中已经稳定。更多信息请参见 <a href="config.html#command-line-overrides">config documentation</a>。</p>
<h3 id="multitarget"><a class="header" href="#multitarget">multitarget</a></h3>
<p><code>-Z multitarget</code> 选项在1.64版本中已经稳定了。参见 <a href="config.html#buildtarget"><code>build.target</code></a> 以了解更多关于设置默认目标平台三元组的信息。</p>
<h3 id="crate-type"><a class="header" href="#crate-type">crate-type</a></h3>
<p>在1.64版本中，<code>cargo rustc</code> 的 <code>--crate-type</code> 标志已经稳定。更多信息请参见 <a href="../commands/cargo-rustc.html"><code>cargo rustc</code> documentation</a> 。</p>
<h3 id="工作空间继承"><a class="header" href="#工作空间继承">工作空间继承</a></h3>
<p>工作空间继承在1.64版本中得到了稳定。
参见 <a href="workspaces.html#the-package-table">workspace.package</a>,<a href="workspaces.html#the-dependencies-table">workspace.dependencies</a>,和 <a href="specifying-dependencies.html#inheriting-a-dependency-from-a-workspace">inheriting-a-dependency-from-a-workspace</a> 获得更多信息。</p>
<h3 id="terminal-width"><a class="header" href="#terminal-width">terminal-width</a></h3>
<p>在1.68版本中， <code>-Z terminal-width</code> 选项已经稳定了。当从Cargo可以自动检测宽度的终端运行时，终端宽度总是被传递给编译器。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../reference/timings.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../commands/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../reference/timings.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../commands/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
