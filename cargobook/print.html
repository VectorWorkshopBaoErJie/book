<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Cargo Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        <style>
            dd {
                margin-bottom: 1em;
            }
        </style>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">简介</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">1.</strong> 入门指南</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/installation.html"><strong aria-hidden="true">1.1.</strong> 安装</a></li><li class="chapter-item expanded "><a href="getting-started/first-steps.html"><strong aria-hidden="true">1.2.</strong> Cargo起步</a></li></ol></li><li class="chapter-item expanded "><a href="guide/index.html"><strong aria-hidden="true">2.</strong> Cargo指南</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guide/why-cargo-exists.html"><strong aria-hidden="true">2.1.</strong> 为何有Cargo</a></li><li class="chapter-item expanded "><a href="guide/creating-a-new-project.html"><strong aria-hidden="true">2.2.</strong> 创建新包</a></li><li class="chapter-item expanded "><a href="guide/working-on-an-existing-project.html"><strong aria-hidden="true">2.3.</strong> 让包工作</a></li><li class="chapter-item expanded "><a href="guide/dependencies.html"><strong aria-hidden="true">2.4.</strong> 依赖</a></li><li class="chapter-item expanded "><a href="guide/project-layout.html"><strong aria-hidden="true">2.5.</strong> 包的设计</a></li><li class="chapter-item expanded "><a href="guide/cargo-toml-vs-cargo-lock.html"><strong aria-hidden="true">2.6.</strong> Cargo.toml vs Cargo.lock</a></li><li class="chapter-item expanded "><a href="guide/tests.html"><strong aria-hidden="true">2.7.</strong> 测试</a></li><li class="chapter-item expanded "><a href="guide/continuous-integration.html"><strong aria-hidden="true">2.8.</strong> 持续集成</a></li><li class="chapter-item expanded "><a href="guide/cargo-home.html"><strong aria-hidden="true">2.9.</strong> Cargo主页</a></li><li class="chapter-item expanded "><a href="guide/build-cache.html"><strong aria-hidden="true">2.10.</strong> 构建缓存</a></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">3.</strong> Cargo参考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/specifying-dependencies.html"><strong aria-hidden="true">3.1.</strong> 指定依赖</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/overriding-dependencies.html"><strong aria-hidden="true">3.1.1.</strong> 覆盖依赖</a></li></ol></li><li class="chapter-item expanded "><a href="reference/manifest.html"><strong aria-hidden="true">3.2.</strong> 配置格式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/cargo-targets.html"><strong aria-hidden="true">3.2.1.</strong> Cargo目标</a></li></ol></li><li class="chapter-item expanded "><a href="reference/workspaces.html"><strong aria-hidden="true">3.3.</strong> 工作空间</a></li><li class="chapter-item expanded "><a href="reference/features.html"><strong aria-hidden="true">3.4.</strong> 特性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/features-examples.html"><strong aria-hidden="true">3.4.1.</strong> 特性示例</a></li></ol></li><li class="chapter-item expanded "><a href="reference/profiles.html"><strong aria-hidden="true">3.5.</strong> 编译设置</a></li><li class="chapter-item expanded "><a href="reference/config.html"><strong aria-hidden="true">3.6.</strong> 配置</a></li><li class="chapter-item expanded "><a href="reference/environment-variables.html"><strong aria-hidden="true">3.7.</strong> 环境变量</a></li><li class="chapter-item expanded "><a href="reference/build-scripts.html"><strong aria-hidden="true">3.8.</strong> 构建脚本</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/build-script-examples.html"><strong aria-hidden="true">3.8.1.</strong> 构建脚本示例</a></li></ol></li><li class="chapter-item expanded "><a href="reference/publishing.html"><strong aria-hidden="true">3.9.</strong> 发布到crates.io</a></li><li class="chapter-item expanded "><a href="reference/pkgid-spec.html"><strong aria-hidden="true">3.10.</strong> 包ID规范</a></li><li class="chapter-item expanded "><a href="reference/source-replacement.html"><strong aria-hidden="true">3.11.</strong> 源替换</a></li><li class="chapter-item expanded "><a href="reference/external-tools.html"><strong aria-hidden="true">3.12.</strong> 插件</a></li><li class="chapter-item expanded "><a href="reference/registries.html"><strong aria-hidden="true">3.13.</strong> 注册中心</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/running-a-registry.html"><strong aria-hidden="true">3.13.1.</strong> 运行注册中心</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/registry-index.html"><strong aria-hidden="true">3.13.1.1.</strong> 注册中心索引</a></li><li class="chapter-item expanded "><a href="reference/registry-web-api.html"><strong aria-hidden="true">3.13.1.2.</strong> 注册中心Web API</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="reference/resolver.html"><strong aria-hidden="true">3.14.</strong> 依赖解析</a></li><li class="chapter-item expanded "><a href="reference/semver.html"><strong aria-hidden="true">3.15.</strong> 语义化兼容</a></li><li class="chapter-item expanded "><a href="reference/future-incompat-report.html"><strong aria-hidden="true">3.16.</strong> 未来不兼容报告</a></li><li class="chapter-item expanded "><a href="reference/timings.html"><strong aria-hidden="true">3.17.</strong> 报告构建时间</a></li><li class="chapter-item expanded "><a href="reference/unstable.html"><strong aria-hidden="true">3.18.</strong> 不稳定特性</a></li></ol></li><li class="chapter-item expanded "><a href="commands/index.html"><strong aria-hidden="true">4.</strong> Cargo命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/general-commands.html"><strong aria-hidden="true">4.1.</strong> 常用命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/cargo.html"><strong aria-hidden="true">4.1.1.</strong> cargo</a></li><li class="chapter-item expanded "><a href="commands/cargo-help.html"><strong aria-hidden="true">4.1.2.</strong> cargo help</a></li><li class="chapter-item expanded "><a href="commands/cargo-version.html"><strong aria-hidden="true">4.1.3.</strong> cargo version</a></li></ol></li><li class="chapter-item expanded "><a href="commands/build-commands.html"><strong aria-hidden="true">4.2.</strong> 构建命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/cargo-bench.html"><strong aria-hidden="true">4.2.1.</strong> cargo bench</a></li><li class="chapter-item expanded "><a href="commands/cargo-build.html"><strong aria-hidden="true">4.2.2.</strong> cargo build</a></li><li class="chapter-item expanded "><a href="commands/cargo-check.html"><strong aria-hidden="true">4.2.3.</strong> cargo check</a></li><li class="chapter-item expanded "><a href="commands/cargo-clean.html"><strong aria-hidden="true">4.2.4.</strong> cargo clean</a></li><li class="chapter-item expanded "><a href="commands/cargo-doc.html"><strong aria-hidden="true">4.2.5.</strong> cargo doc</a></li><li class="chapter-item expanded "><a href="commands/cargo-fetch.html"><strong aria-hidden="true">4.2.6.</strong> cargo fetch</a></li><li class="chapter-item expanded "><a href="commands/cargo-fix.html"><strong aria-hidden="true">4.2.7.</strong> cargo fix</a></li><li class="chapter-item expanded "><a href="commands/cargo-run.html"><strong aria-hidden="true">4.2.8.</strong> cargo run</a></li><li class="chapter-item expanded "><a href="commands/cargo-rustc.html"><strong aria-hidden="true">4.2.9.</strong> cargo rustc</a></li><li class="chapter-item expanded "><a href="commands/cargo-rustdoc.html"><strong aria-hidden="true">4.2.10.</strong> cargo rustdoc</a></li><li class="chapter-item expanded "><a href="commands/cargo-test.html"><strong aria-hidden="true">4.2.11.</strong> cargo test</a></li><li class="chapter-item expanded "><a href="commands/cargo-report.html"><strong aria-hidden="true">4.2.12.</strong> cargo report</a></li></ol></li><li class="chapter-item expanded "><a href="commands/manifest-commands.html"><strong aria-hidden="true">4.3.</strong> 配置命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/cargo-add.html"><strong aria-hidden="true">4.3.1.</strong> cargo add</a></li><li class="chapter-item expanded "><a href="commands/cargo-generate-lockfile.html"><strong aria-hidden="true">4.3.2.</strong> cargo generate-lockfile</a></li><li class="chapter-item expanded "><a href="commands/cargo-locate-project.html"><strong aria-hidden="true">4.3.3.</strong> cargo locate-project</a></li><li class="chapter-item expanded "><a href="commands/cargo-metadata.html"><strong aria-hidden="true">4.3.4.</strong> cargo metadata</a></li><li class="chapter-item expanded "><a href="commands/cargo-pkgid.html"><strong aria-hidden="true">4.3.5.</strong> cargo pkgid</a></li><li class="chapter-item expanded "><a href="commands/cargo-remove.html"><strong aria-hidden="true">4.3.6.</strong> cargo remove</a></li><li class="chapter-item expanded "><a href="commands/cargo-tree.html"><strong aria-hidden="true">4.3.7.</strong> cargo tree</a></li><li class="chapter-item expanded "><a href="commands/cargo-update.html"><strong aria-hidden="true">4.3.8.</strong> cargo update</a></li><li class="chapter-item expanded "><a href="commands/cargo-vendor.html"><strong aria-hidden="true">4.3.9.</strong> cargo vendor</a></li><li class="chapter-item expanded "><a href="commands/cargo-verify-project.html"><strong aria-hidden="true">4.3.10.</strong> cargo verify-project</a></li></ol></li><li class="chapter-item expanded "><a href="commands/package-commands.html"><strong aria-hidden="true">4.4.</strong> 包命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/cargo-init.html"><strong aria-hidden="true">4.4.1.</strong> cargo init</a></li><li class="chapter-item expanded "><a href="commands/cargo-install.html"><strong aria-hidden="true">4.4.2.</strong> cargo install</a></li><li class="chapter-item expanded "><a href="commands/cargo-new.html"><strong aria-hidden="true">4.4.3.</strong> cargo new</a></li><li class="chapter-item expanded "><a href="commands/cargo-search.html"><strong aria-hidden="true">4.4.4.</strong> cargo search</a></li><li class="chapter-item expanded "><a href="commands/cargo-uninstall.html"><strong aria-hidden="true">4.4.5.</strong> cargo uninstall</a></li></ol></li><li class="chapter-item expanded "><a href="commands/publishing-commands.html"><strong aria-hidden="true">4.5.</strong> 发布命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/cargo-login.html"><strong aria-hidden="true">4.5.1.</strong> cargo login</a></li><li class="chapter-item expanded "><a href="commands/cargo-owner.html"><strong aria-hidden="true">4.5.2.</strong> cargo owner</a></li><li class="chapter-item expanded "><a href="commands/cargo-package.html"><strong aria-hidden="true">4.5.3.</strong> cargo package</a></li><li class="chapter-item expanded "><a href="commands/cargo-publish.html"><strong aria-hidden="true">4.5.4.</strong> cargo publish</a></li><li class="chapter-item expanded "><a href="commands/cargo-yank.html"><strong aria-hidden="true">4.5.5.</strong> cargo yank</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">5.</strong> 常见问题</a></li><li class="chapter-item expanded "><a href="appendix/glossary.html"><strong aria-hidden="true">6.</strong> 附录: 词汇表</a></li><li class="chapter-item expanded "><a href="appendix/git-authentication.html"><strong aria-hidden="true">7.</strong> 附录: Git认证</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cargo Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/cargo/tree/master/src/doc/src" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>Cargo之书</p>
<p><img src="images/Cargo-Logo-Small.png" alt="Cargo Logo" /></p>
<p>Cargo是 <a href="https://www.rust-lang.org/">Rust</a> <a href="./appendix/glossary.html#package-manager" title="&quot;package manager&quot; (glossary entry)"><em>包管理器</em></a>. Cargo下载你的Rust所依赖的包 <a href="./appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">package</a>,
编译你的包, 制作可分享包，并上传到<a href="https://crates.io/">crates.io</a>, 它是Rust <a href="./appendix/glossary.html#package-registry" title="&quot;package registry&quot; (glossary entry)"><em>包注册</em></a> 社区. 
你可以在 <a href="https://github.com/rust-lang/cargo/tree/master/src/doc">GitHub</a> 为本书做出贡献.</p>
<h3 id="章节"><a class="header" href="#章节">章节</a></h3>
<p><strong><a href="getting-started/index.html">入门指南</a></strong></p>
<p>开始使用Cargo，请安装Cargo和Rust并设置您的第一个<a href="./appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)"><em>crate</em></a>。</p>
<p><strong><a href="guide/index.html">Cargo指南</a></strong></p>
<p>该指南将为您提供有关如何使用Cargo开发Rust包所需的所有知识。</p>
<p><strong><a href="reference/index.html">Cargo参考</a></strong></p>
<p>参考涵盖了Cargo的各个方面的细节。</p>
<p><strong><a href="commands/index.html">Cargo 命令</a></strong></p>
<p>这些命令将允许您使用其命令行界面与Cargo交互。</p>
<p><strong><a href="faq.html">常见问题</a></strong></p>
<p><strong>附:</strong></p>
<ul>
<li><a href="appendix/glossary.html">词汇表</a></li>
<li><a href="appendix/git-authentication.html">Git 身份验证</a></li>
</ul>
<p><strong>其他文档:</strong></p>
<ul>
<li><a href="https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md">更新日志</a> —
关于每个版本中Cargo更改的详细说明。</li>
<li><a href="https://doc.rust-lang.org/">Rust 文档网站</a> —
Rust官方文档和工具的链接.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="入门指南"><a class="header" href="#入门指南">入门指南</a></h2>
<p>开始使用Cargo,安装Cargo和Rust，配置你的第一个<a href="getting-started/../appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)"><em>crate</em></a></p>
<ul>
<li><a href="getting-started/installation.html">Installation</a></li>
<li><a href="getting-started/first-steps.html">First steps with Cargo</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<h3 id="安装-rust-和-cargo"><a class="header" href="#安装-rust-和-cargo">安装 Rust 和 Cargo</a></h3>
<p>获得Cargo的最简单的方法是通过<a href="https://rustup.rs/">rustup</a>来安装当前<a href="https://www.rust-lang.org/">Rust</a>稳定版本。
<code>rustup</code> 安装Rust时也会安装 <code>cargo</code> 。</p>
<p>在Linux和macOS系统上，可以这样:</p>
<pre><code class="language-console">curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>它将下载一个脚本，并开始安装。如果一切顺利，你会看到:</p>
<pre><code class="language-console">Rust is installed now. Great!
</code></pre>
<p>在Windows操作系统下，下载并运行 <a href="https://win.rustup.rs/">rustup-init.exe</a> 。它将在控制台中开始安装，并在成功时显示上述消息。</p>
<p>之后，就可以使用 <code>rustup</code> 命令来安装 Rust 或 Cargo  <code>beta</code> &quot;测试&quot; 或 <code>nightly</code> &quot;每日&quot; 版本。</p>
<p>关于其他安装选项和信息，请访问 Rust 网站的 <a href="https://www.rust-lang.org/tools/install">install</a> 页面。</p>
<h3 id="从源代码构建和安装cargo"><a class="header" href="#从源代码构建和安装cargo">从源代码构建和安装Cargo</a></h3>
<p>做为选择，你可以<a href="https://github.com/rust-lang/cargo#compiling-from-source">从源代码构建Cargo</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo起步"><a class="header" href="#cargo起步">Cargo起步</a></h2>
<p>本节提供对 <code>cargo</code> 命令行工具的快速一览。展示其生成新 <a href="getting-started/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)"><em><strong>package</strong></em></a> 的功能，
其在包内编译 <a href="getting-started/../appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)"><em><strong>crate</strong></em></a> 的能力，以及运行所生成程序的功能。</p>
<p>使用 <code>cargo new</code> 可创建新包。</p>
<pre><code class="language-console">$ cargo new hello_world
</code></pre>
<p>Cargo 默认为 <code>--bin</code> 来构建二进制程序，通过 <code>--lib</code> 来构建库。</p>
<p>让我们来查看 Cargo 所生成的:</p>
<pre><code class="language-console">$ cd hello_world
$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
</code></pre>
<p>这就是创建的全部内容。先来查看一下 <code>Cargo.toml</code> :</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
</code></pre>
<p>它被称为<a href="getting-started/../appendix/glossary.html#manifest" title="&quot;manifest&quot; (glossary entry)"><em><strong>manifest</strong></em></a> &quot;配置清单&quot;，它包含Cargo编译包所需的所有元数据。</p>
<p>以下<code>src/main.rs</code> 的内容:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}</code></pre></pre>
<p>Cargo 为我们生成了一个 “hello world” 程序，也就是<a href="getting-started/../appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)"><em><strong>binary crate</strong></em></a> &quot;二进制crate&quot;。
编译这个程序:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
</code></pre>
<p>然后运行程序:</p>
<pre><code class="language-console">$ ./target/debug/hello_world
Hello, world!
</code></pre>
<p>可以使用 <code>cargo run</code> 来编译后运行，来一步完成:</p>
<pre><code class="language-console">$ cargo run
     Fresh hello_world v0.1.0 (file:///path/to/package/hello_world)
   Running `target/hello_world`
Hello, world!
</code></pre>
<h3 id="进一步"><a class="header" href="#进一步">进一步</a></h3>
<p>关于Cargo的更多细节，查阅 <a href="getting-started/../guide/index.html">Cargo 指南</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-指南"><a class="header" href="#cargo-指南">Cargo 指南</a></h2>
<p>本文档会展示如何使用 Cargo 开发 Rust 包。</p>
<ul>
<li><a href="guide/why-cargo-exists.html">Why Cargo Exists</a></li>
<li><a href="guide/creating-a-new-project.html">Creating a New Package</a></li>
<li><a href="guide/working-on-an-existing-project.html">Working on an Existing Cargo Package</a></li>
<li><a href="guide/dependencies.html">Dependencies</a></li>
<li><a href="guide/project-layout.html">Package Layout</a></li>
<li><a href="guide/cargo-toml-vs-cargo-lock.html">Cargo.toml vs Cargo.lock</a></li>
<li><a href="guide/tests.html">Tests</a></li>
<li><a href="guide/continuous-integration.html">Continuous Integration</a></li>
<li><a href="guide/cargo-home.html">Cargo Home</a></li>
<li><a href="guide/build-cache.html">Build Cache</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-为何存在"><a class="header" href="#cargo-为何存在">Cargo 为何存在</a></h2>
<h3 id="前言"><a class="header" href="#前言">前言</a></h3>
<p>在 Rust 中，一个类库或可执行程序称为一个 <a href="guide/../appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)"><em>crate</em></a> 。
Crate 是使用 Rust 编译器 <code>rustc</code> 编译的。
刚开始学习 Rust 时，大多数人上手的代码便是经典的 &quot;hello world&quot; 程序，它可以通过 <code>rustc</code> 直接编译:</p>
<pre><code class="language-console">$ rustc hello.rs
$ ./hello
Hello, world!
</code></pre>
<p>请注意，上面的命令需要我们显式指定文件名。
如果我们直接使用 <code>rustc</code> 编译一个不同的程序，因为文件不同了，那就需要执行不同的命令了。
如果我们指定任何编译选项或者包含外部依赖，那需要执行的命令便更加具体(和复杂)。</p>
<p>更进一步来说，大多数程序会有额外的外部依赖，这些外部依赖又会有其他依赖。
那么手动维护必要依赖的正确版本并保持依赖的版本更新便是一件费力不讨好的事。</p>
<p>相较于直接跟 crate 和 <code>rustc</code> 打交道，
我们可以通过引入更高层的 <a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">&quot;<em>包(package)</em>&quot;</a> 抽象概念
并使用 <a href="guide/../appendix/glossary.html#package-manager" title="&quot;package manager&quot; (glossary entry)"><em>包管理器</em></a> 来避免这些手动的乏味工作。</p>
<h3 id="走进-cargo"><a class="header" href="#走进-cargo">走进 Cargo</a></h3>
<p><em>Cargo</em> 是 Rust 的包管理器。它是让 Rust 的 <a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)"><em>packages</em></a> 声明不同的依赖并保证可重复构建的工具</p>
<p>Cargo 做了以下四件事来实现这个目标:</p>
<ul>
<li>引入两个包含多种包信息的元数据文件。</li>
<li>下载并构建包的依赖。</li>
<li>调用 <code>rustc</code> 或其他构建工具以及正确的参数来构建包。</li>
<li>引入规范令我们与 Rust 的包的工作更简单。</li>
</ul>
<p>Cargo 在很大程度上标准化了构建程序或包的命令；这仅是上述规范的一个方面。
下文中我们可以看到，相同的命令可以用于构建不同的 <a href="guide/../appendix/glossary.html#artifact" title="&quot;artifact&quot; (glossary entry)"><em>artifacts</em></a> 即使它们的名称不同。
相较于直接调用 <code>rustc</code> ，我们可以调用 <code>cargo build</code> 等更加通用的命令，让 cargo 解决构建正确的 <code>rustc</code> 调用。
更进一步，Cargo 可以自动从 <a href="guide/../appendix/glossary.html#registry" title="&quot;registry&quot; (glossary entry)"><em>registry</em></a> 下载我们为 artifact 定义的任何依赖，并将依赖合并在构建中。</p>
<p>夸张一点说，一旦你学会使用 Cargo 构建项目，你也学会了使用 <em>所有</em> 包管理器构建项目。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="创一个建新的包"><a class="header" href="#创一个建新的包">创一个建新的包</a></h2>
<p>使用 <code>cargo new</code> 命令创建一个新的 <a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">package</a> :</p>
<pre><code class="language-console">$ cargo new hello_world --bin
</code></pre>
<p>因为我们创建的是二进制程序，所以我们传递 <code>--bin</code> 参数:
如果我们创建的是类库，我们需要传递 <code>--lib</code> 。
这也会默认初始化一个 <code>git</code> 仓库。如果不需要创建代码仓库，你可以传递 <code>--vcs none</code> 。</p>
<p>让我们看看 Cargo 为我们生成的文件:</p>
<pre><code class="language-console">$ cd hello_world
$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1个目录, 2个文件
</code></pre>
<p>让我们看看 <code>Cargo.toml</code> 文件:</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]

</code></pre>
<p>这是 <a href="guide/../appendix/glossary.html#manifest" title="&quot;manifest&quot; (glossary entry)"><em><strong>manifest</strong></em></a> ，它包含所有Cargo编译所需的元数据。
此文件采用 <a href="https://toml.io/">TOML</a> (发音为 /tɑməl/) 格式书写。</p>
<p>这是 <code>src/main.rs</code> 的内容:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}</code></pre></pre>
<p>Cargo 生成了一个 &quot;hello world&quot; 程序，也被称为一个 <a href="guide/../appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)"><em>binary crate</em></a></p>
<pre><code class="language-console">$ cargo build
   Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
</code></pre>
<p>然后运行:</p>
<pre><code class="language-console">$ ./target/debug/hello_world
Hello, world!
</code></pre>
<p>我们也可以使用 <code>cargo run</code> 命令来编译并运行，将编译与运行合成一步
(如果相较上次编译没有进行过改动，不会看到 <code>Compiling</code> 信息输出):</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
     Running `target/debug/hello_world`
Hello, world!
</code></pre>
<p>你会注意到一个名为 <code>Cargo.lock</code> 的新文件出现了。它包含依赖的相关信息。
当下我们并没有任何依赖，所以它现在并没有很多有用的信息。</p>
<p>当你准备好要发布程序，你可以使用 <code>cargo build --release</code> 命令来编译你的文件(使用此选项会启用编译优化):</p>
<pre><code class="language-console">$ cargo build --release
   Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
</code></pre>
<p><code>cargo build --release</code> 命令会将二进制生成物放在 <code>target/release</code> 目录，而非 <code>target/debug</code> 。</p>
<p>开发过程中，编译会默认在调试模式(debug mode)下进行。
由于编译器没有进行编译优化，编译耗时会缩短，但代码会运行地更慢。
发布模式(release mode)下的编译耗时更长但是代码会运行地更快。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="接手已有的-cargo-包"><a class="header" href="#接手已有的-cargo-包">接手已有的 Cargo 包</a></h2>
<p>使用 Cargo 下载已有的 <a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">package</a> 非常简单。</p>
<p>首先，获取到包的代码。比如使用从 GitHub 克隆的 <code>regex</code> 包。</p>
<pre><code class="language-console">$ git clone https://github.com/rust-lang/regex.git
$ cd regex
</code></pre>
<p>使用 <code>cargo build</code> 命令构建包:</p>
<pre><code class="language-console">$ cargo build
   Compiling regex v1.5.0 (file:///path/to/package/regex)
</code></pre>
<p>这会下载并构建所有的依赖和包。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="依赖"><a class="header" href="#依赖">依赖</a></h2>
<p><a href="https://crates.io/">crates.io</a> 是 Rust 社区的中央 <a href="guide/../appendix/glossary.html#package-registry" title="&quot;package-registry&quot; (glossary entry)"><em>package registry</em></a> 。
它用作搜索和下载 <a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">packages</a> 的仓库。 <code>cargo</code> 默认使用这个地址来搜索所需的包。</p>
<p>要添加 <a href="https://crates.io/">crates.io</a> 上托管的依赖库，将它添加到你的 <code>Cargo.toml</code> 。</p>
<h3 id="添加依赖"><a class="header" href="#添加依赖">添加依赖</a></h3>
<p>如果你的 <code>Cargo.toml</code> 还没有 <code>[dependencies]</code> 部分，添加上这个标记，
然后在标记下方列出你需要使用的 <a href="guide/../appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)">crate</a> 的名称和版本。
下面这个例子展示了如何添加 <code>time</code> 依赖:</p>
<pre><code class="language-toml">[dependencies]
time = &quot;0.1.12&quot;
</code></pre>
<p>版本字符串要求使用 <a href="https://semver.org">SemVer</a>。<a href="guide/../reference/specifying-dependencies.html">specifying dependencies</a> 部分对此有更多信息。</p>
<p>如果我们想添加一个 <code>regex</code> 依赖，我们不需要为每个依赖都添加 <code>[dependencies]</code> 。
下面是添加了 <code>time</code> 和 <code>regex</code> 依赖的 <code>Cargo.toml</code> 文件应该有的样子:</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
time = &quot;0.1.12&quot;
regex = &quot;0.1.41&quot;
</code></pre>
<p>重新执行 <code>cargo build</code> 命令，Cargo 会下载新的依赖以及它们本身所需的依赖，
将它们全部编译，并更新 <code>Cargo.lock</code> 文件:</p>
<pre><code class="language-console">$ cargo build
      Updating crates.io index
   Downloading memchr v0.1.5
   Downloading libc v0.1.10
   Downloading regex-syntax v0.2.1
   Downloading memchr v0.1.5
   Downloading aho-corasick v0.3.0
   Downloading regex v0.1.41
     Compiling memchr v0.1.5
     Compiling libc v0.1.10
     Compiling regex-syntax v0.2.1
     Compiling memchr v0.1.5
     Compiling aho-corasick v0.3.0
     Compiling regex v0.1.41
     Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
</code></pre>
<p><code>Cargo.lock</code> 文件包含着所有依赖的准确版本信息</p>
<p>如果 <code>regex</code> 依赖升级了，我们依然会使用当前的版本进行构建，除非我们手动执行 <code>cargo update</code> 命令。</p>
<p>现在可以在 <code>main.rs</code> 中使用 <code>regex</code> 库了。</p>
<pre><code class="language-rust ignore">use regex::Regex;

fn main() {
    let re = Regex::new(r&quot;^\d{4}-\d{2}-\d{2}$&quot;).unwrap();
    println!(&quot;Did our date match? {}&quot;, re.is_match(&quot;2014-01-01&quot;));
}</code></pre>
<p>运行它会输出:</p>
<pre><code class="language-console">$ cargo run
   Running `target/hello_world`
Did our date match? true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="项目结构"><a class="header" href="#项目结构">项目结构</a></h2>
<p>Cargo在文件布局上使用一系列约定，从而可以很容易地创建一个新的包:</p>
<pre><code class="language-text">.
├── Cargo.lock
├── Cargo.toml
├── src/
│   ├── lib.rs
│   ├── main.rs
│   └── bin/
│       ├── named-executable.rs
│       ├── another-executable.rs
│       └── multi-file-executable/
│           ├── main.rs
│           └── some_module.rs
├── benches/
│   ├── large-input.rs
│   └── multi-file-bench/
│       ├── main.rs
│       └── bench_module.rs
├── examples/
│   ├── simple.rs
│   └── multi-file-example/
│       ├── main.rs
│       └── ex_module.rs
└── tests/
    ├── some-integration-tests.rs
    └── multi-file-test/
        ├── main.rs
        └── test_module.rs
</code></pre>
<ul>
<li><code>Cargo.toml</code> 和 <code>Cargo.lock</code> 保存在你包的根目录。</li>
<li>源代码放在<code>src</code>。</li>
<li>默认的库crate根文件是 <code>src/lib.rs</code> 。</li>
<li>默认的可执行crate根文件是 <code>src/main.rs</code> 。
<ul>
<li>其他可执行crate文件可以放在 <code>src/bin/</code> 目录。</li>
</ul>
</li>
<li>Benchmarks放在 <code>benches</code> 目录。</li>
<li>Examples放在 <code>examples</code> 目录.</li>
<li>集成测试文件放在 <code>tests</code> 目录.</li>
</ul>
<p>如果一个binary、example、bench 或集成测试具有多个源文件，把 <code>main.rs</code> 和和其他模块(<a href="guide/../appendix/glossary.html#module" title="&quot;module&quot; (glossary entry)"><em>modules</em></a>)一起放在原目录( <code>src/bin</code> 、<code>examples</code> 、<code>benches</code> 或 <code>tests</code> )的一个子目录下，可执行crate的名字就是该子目录的名字。</p>
<p>你可以在<a href="guide/../../book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">the book</a>中了解更多关于Rust模块系统的知识。</p>
<p>见<a href="guide/../reference/cargo-targets.html#configuring-a-target">Configuring a target</a>一节中更多关于手动设置编译目标的细节。
见<a href="guide/../reference/cargo-targets.html#target-auto-discovery">Target auto-discovery</a>一节中更多关于控制Cargo如何自动推断目标名的知识。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargotoml-和-cargolock"><a class="header" href="#cargotoml-和-cargolock">Cargo.toml 和 Cargo.lock</a></h2>
<p><code>Cargo.toml</code> 和 <code>Cargo.lock</code> 具有不同的用途。在讨论它们之前，先做一个总结：</p>
<ul>
<li><code>Cargo.toml</code> 用于宽泛地描述包的依赖，这个文件是由你来写的。</li>
<li><code>Cargo.lock</code> 包含依赖项的额外信息。这个文件由Cargo来维护，不应该被手动编辑。</li>
</ul>
<p>如果你构建的是一个非末端产品，比如一个其他rust<a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">包</a>会依赖的库，那么把 <code>Cargo.lock</code> 放进 <code>.gitignore</code>。如果你构建是一个末端产品，比如像命令行工具或桌面应用这样的可执行程序，或者是一个系统库(crate-type字段为 <code>staticlib</code> 或 <code>cdylib</code>)，那么就应该将 <code>Cargo.lock</code> 加入git。想了解为什么要这样做，参考<a href="guide/../faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries">FAQ中的&quot;为什么binary的版本控制中有 <code>Cargo.lock</code> ，library却没有？&quot;</a>一节。</p>
<p>让我们更深入一点。</p>
<p><code>Cargo.toml</code> 是一个<a href="guide/../appendix/glossary.html#manifest" title="&quot;manifest&quot; (glossary entry)"><strong>清单</strong></a>文件，其中包含了一系列该包的元数据。比如，我们可以声明该包依赖另一个包:</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;

[dependencies]
regex = { git = &quot;https://github.com/rust-lang/regex.git&quot; }
</code></pre>
<p>这个包只依赖了一个 <code>regex</code> 库。在这个例子中，我们声明我们的包依赖了一个github上的仓库。因为我们没有提供其他信息，Cargo会假定我们想要使用该仓库 <code>master</code> 分支的最新commit来构建我们的包。</p>
<p>听起来不错？但是这里有一个问题：如果你今天构建了这个包，然后把代码复制一份发给了我，然后我第二天才去构建这个包，这时就可能有坏事发生。 在这期间，<code>regex</code> 库可能产生了更多的commit，我构建时新的commit也会被加入进来，而这些内容在你的构建中是没有的。因此，我们会得到不同的构建结果。这可能很糟糕，因为我们希望构建操作是可重复的。</p>
<p>我们可以在 <code>Cargo.toml</code> 中定义一个 <code>rev</code> 字段，这样Cargo就会知道构建包时应该使用哪个具体的修订版本(revision)了。</p>
<pre><code class="language-toml">[dependencies]
regex = { git = &quot;https://github.com/rust-lang/regex.git&quot;, rev = &quot;9f9f693&quot; }
</code></pre>
<p>现在我们两个的构建结果又一致了。但是这种方式有个很大的缺点：现在我们每次想更新库的时候，都必须手动来调整SHA-1串。这件事既无聊又容易搞出错来。</p>
<p>于是 <code>Cargo.lock</code> 应运而生。因为它的存在，我们无需手动跟踪具体的修订版本。Cargo会帮我们做这件事。当我们有这样一个清单文件:</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;

[dependencies]
regex = { git = &quot;https://github.com/rust-lang/regex.git&quot; }
</code></pre>
<p>在我们第一次构建的时候，Cargo 会获取最新的commit并将信息写入<code>Cargo.lock</code>文件。<code>Cargo.lock</code>的内容如下:</p>
<pre><code class="language-toml">[[package]]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
dependencies = [
 &quot;regex 1.5.0 (git+https://github.com/rust-lang/regex.git#9f9f693768c584971a4d53bc3c586c33ed3a6831)&quot;,
]

[[package]]
name = &quot;regex&quot;
version = &quot;1.5.0&quot;
source = &quot;git+https://github.com/rust-lang/regex.git#9f9f693768c584971a4d53bc3c586c33ed3a6831&quot;
</code></pre>
<p>可以看到这个文件中有更多的信息，包括我们构建中使用的包的具体修订版本。现在当你把你的包发给其他人时，他们会使用完全相同的SHA，即使我们并没有在 <code>Cargo.toml</code> 中标注版本号。</p>
<p>当我们准备切换到库的新版本时，Cargo可以重新计算依赖并帮我们更新。</p>
<pre><code class="language-console">$ cargo update            # 更新全部依赖项
$ cargo update -p regex   # 只更新 “regex”
</code></pre>
<p>这会将新的版本信息覆写进 <code>Cargo.lock</code> 。注意， <code>cargo update</code> 的参数实际上是一个<a href="guide/../reference/pkgid-spec.html">Package ID Specification</a>， <code>regex</code> 只是一个简写。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="测试"><a class="header" href="#测试">测试</a></h2>
<p>可以使用 <code>cargo test</code> 命令来运行你的测试(test)。Cargo 在两个地方查找测试内容： 1. <code>src</code> 中的每个文件；2.  <code>test</code> 目录中的测试项目。 <code>src</code> 中的测试是单元测试和文档测试(<a href="guide/../../rustdoc/write-documentation/documentation-tests.html">documentation tests</a>)。 <code>tests</code> 中的测试是集成测试，因此你需要把crate导入(import)到 <code>tests</code>中的文件。</p>
<p>下面的例子里对我们的<a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">包</a>执行 <code>cargo test</code>，目前这个包里还没有任何测试项。</p>
<pre><code class="language-console">$ cargo test
   Compiling regex v1.5.0 (https://github.com/rust-lang/regex.git#9f9f693)
   Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
     Running target/test/hello_world-9c2b65bbb79eabce

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>如果我们的包中有测试项，就可以看到更多数输出内容。</p>
<p>你也可以通过提供一个过滤器，来运行指定的测试:</p>
<pre><code class="language-console">$ cargo test foo
</code></pre>
<p>这种情况下会执行所有名字中包含 <code>foo</code> 的测试。</p>
<p><code>cargo test</code> 会进行额外的检查。Cargo会编译你的每一个example，确保它们可以通过编译。同时也会运行文档测试来确保文档中的代码样例可以通过编译。Rust文档中的<a href="guide/../../book/ch11-00-testing.html">testing guide</a>部分可以获取更多关于组织测试的知识。<a href="guide/../reference/cargo-targets.html#tests">Cargo Targets: Tests</a>中可以学到Cargo中更多不同的测试种类。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="持续集成"><a class="header" href="#持续集成">持续集成</a></h2>
<h3 id="travis-ci"><a class="header" href="#travis-ci">Travis CI</a></h3>
<p>为了在 Travis CI 测试你的包，这里有一个样例配置文件 <code>.travis.yml</code> :</p>
<pre><code class="language-yaml">language: rust
rust:
  - stable
  - beta
  - nightly
matrix:
  allow_failures:
    - rust: nightly
</code></pre>
<p>这将同时测试三个release channel，但是nightly中的问题不会导致整个构建的失败。查看<a href="https://docs.travis-ci.com/user/languages/rust/">Travis CI Rust documentation</a>获得更多信息。</p>
<h3 id="github-actions"><a class="header" href="#github-actions">GitHub Actions</a></h3>
<p>为在Github Actions中测试你的包，这里有一个样例配置文件 <code>.github/workflows/ci.yml</code> :</p>
<pre><code class="language-yaml">name: Cargo Build &amp; Test

on:
  push:
  pull_request:

env: 
  CARGO_TERM_COLOR: always

jobs:
  build_and_test:
    name: Rust project - latest
    runs-on: ubuntu-latest
    strategy:
      matrix:
        toolchain:
          - stable
          - beta
          - nightly
    steps:
      - uses: actions/checkout@v3
      - run: rustup update ${{ matrix.toolchain }} &amp;&amp; rustup default ${{ matrix.toolchain }}
      - run: cargo build --verbose
      - run: cargo test --verbose
  
</code></pre>
<p>这将测试全部的三个release channel(注意任意toolchain版本的失败会导致整个流程的失败)。你也可以在Github界面中点击 <code>&quot;Actions&quot; &gt; &quot;new workflow&quot;</code>，并在其中选择Rust来为你的库添加<a href="https://github.com/actions/starter-workflows/blob/main/ci/rust.yml">默认设置</a>。访问<a href="https://docs.github.com/en/actions">GitHub Actions documentation</a>以获得更多信息。</p>
<h3 id="gitlab-ci"><a class="header" href="#gitlab-ci">GitLab CI</a></h3>
<p>为在GitLab CI测试你的包，这里有一个样例配置文件 <code>.gitlab-ci.yml</code> :</p>
<pre><code class="language-yaml">stages:
  - build

rust-latest:
  stage: build
  image: rust:latest
  script:
    - cargo build --verbose
    - cargo test --verbose

rust-nightly:
  stage: build
  image: rustlang/rust:nightly
  script:
    - cargo build --verbose
    - cargo test --verbose
  allow_failure: true
</code></pre>
<p>这将测试 stable channel 和 nightly channel，但nightly中的任何失败不会导致整个构建的失败。请查看<a href="https://docs.gitlab.com/ce/ci/yaml/index.html">GitLab CI documentation</a>获取更多信息。</p>
<h3 id="buildssrht"><a class="header" href="#buildssrht">builds.sr.ht</a></h3>
<p>为在 sr.ht 测试你的包，这里有一个样例设置文件 <code>.build.yml</code> 。
注意将 <code>&lt;your repo&gt;</code> 和 <code>&lt;your project&gt;</code> 修改为你要clone的库以及其被clone到的目录。</p>
<pre><code class="language-yaml">image: archlinux
packages:
  - rustup
sources:
  - &lt;your repo&gt;
tasks:
  - setup: |
      rustup toolchain install nightly stable
      cd &lt;your project&gt;/
      rustup run stable cargo fetch
  - stable: |
      rustup default stable
      cd &lt;your project&gt;/
      cargo build --verbose
      cargo test --verbose
  - nightly: |
      rustup default nightly
      cd &lt;your project&gt;/
      cargo build --verbose ||:
      cargo test --verbose  ||:
  - docs: |
      cd &lt;your project&gt;/
      rustup run stable cargo doc --no-deps
      rustup run nightly cargo doc --no-deps ||:
</code></pre>
<p>这将为stable channel和nightly channel进行测试和构建文档，nightly上的问题不会导致整个构建的失败。请查看<a href="https://man.sr.ht/builds.sr.ht/">builds.sr.ht documentation</a>以获取更多信息。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-home"><a class="header" href="#cargo-home">Cargo Home</a></h2>
<p>”Cargo home“功能为下载和源代码提供缓存。
当构建一个crate时，Cargo会将下载的构建依赖保存在Cargo home中。你可以通过设置 <code>CARGO_HOME</code> <a href="guide/../reference/environment-variables.html">环境变量</a>来修改Cargo home的位置。
如果你需要在自己的crate中获取这个位置，<a href="https://crates.io/crates/home">home</a> crate 提供了相关的API。</p>
<p>注意，Cargo home的内部结构规范还未稳定下来，可能会在任何时候改变。</p>
<p>Cargo home由以下几个部分构成:</p>
<h2 id="文件"><a class="header" href="#文件">文件:</a></h2>
<ul>
<li>
<p><code>config.toml</code>
Cargo 的全局配置文件，见<a href="guide/../reference/config.html">config entry in the reference</a>。</p>
</li>
<li>
<p><code>credentials.toml</code>
<a href="guide/../commands/cargo-login.html"><code>cargo login</code></a>的私人登陆凭证，用于登陆某个<a href="guide/../appendix/glossary.html#registry" title="&quot;registry&quot; (glossary entry)">registry</a>.</p>
</li>
<li>
<p><code>.crates.toml</code>, <code>.crates2.json</code>
这些隐藏文件包含通过<a href="guide/../commands/cargo-install.html"><code>cargo install</code></a>下载的<a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">包</a>的信息。不要手动修改这些文件！</p>
</li>
</ul>
<h2 id="目录"><a class="header" href="#目录">目录:</a></h2>
<ul>
<li>
<p><code>bin</code>
bin目录中保存通过<a href="guide/../commands/cargo-install.html"><code>cargo install</code></a>或<a href="https://rust-lang.github.io/rustup/"><code>rustup</code></a>下载的可执行文件。方便在终端中直接使用这些二进制文件，可以把该目录添加到你的 <code>$PATH</code> 环境变量。</p>
</li>
<li>
<p><code>git</code>
Git源代码保存在这里:</p>
<ul>
<li>
<p><code>git/db</code>
当一个crate的依赖是一个git仓库，Cargo会将这个仓库clone到该目录下作为一个裸仓库(只有<code>.git</code>文件夹中的内容)，并在必要时更新该仓库。</p>
</li>
<li>
<p><code>git/checkouts</code>
如果某个git源的代码被用到，实际的代码会从<code>git/db</code>内的裸仓库中checkout出来，保存在该目录下。
这个功能可以为编译器提供依赖指定的<em>特定commit</em>的文件。
只需一个仓库，就可以checkout出不同commit版本的代码。</p>
</li>
</ul>
</li>
<li>
<p><code>registry</code>
crate注册机构(比如<a href="https://crates.io/">crates.io</a>)的元数据和从这些机构下载的包保存在这个文件夹中。</p>
<ul>
<li>
<p><code>registry/index</code>
index是一个裸仓库，其中包含着一个注册机构中所有可用crate的元数据(版本、依赖等)。</p>
</li>
<li>
<p><code>registry/cache</code>
下载下来的依赖项源代码被保存在cache目录中。这些crate被压缩为gzip文件，以<code>.crate</code>为后缀。</p>
</li>
<li>
<p><code>registry/src</code>
如果一个已下载的 <code>.crate</code> 压缩文件被某个包所需要，该文件会被解压到 <code>registry/src</code> 目录，好让rustc能找到相应的<code>.rs</code>文件。</p>
</li>
</ul>
</li>
</ul>
<h2 id="在ci中缓存cargo-home"><a class="header" href="#在ci中缓存cargo-home">在CI中缓存Cargo home</a></h2>
<p>为避免在持续集成时重复下载所有crate依赖，你可以对 <code>$CARGO_HOME</code> 目录进行缓存。
但是，缓存整个Cargo home目录往往很低效，因为它会把相同的代码保存两遍。如果我们依赖一个crate叫做 <code>serde 1.0.92</code> 而且缓存了整个 <code>$CARGO_HOME</code>，我们会把源代码存两遍( <code>registry/cache</code> 中的 <code>serde-1.0.92.crate</code> 以及解压到 <code>registry/src</code> 的<code>.rs</code>文件)。
这会没必要地拖慢构建过程，下载、解压、压缩和重新上传cache到CI服务器都会消耗时间。</p>
<p>只需缓存以下的文件夹就足够了:</p>
<ul>
<li><code>bin/</code></li>
<li><code>registry/index/</code></li>
<li><code>registry/cache/</code></li>
<li><code>git/db/</code></li>
</ul>
<h2 id="打包缓存项目的所有依赖"><a class="header" href="#打包缓存项目的所有依赖">打包缓存项目的所有依赖</a></h2>
<p>见 <a href="guide/../commands/cargo-vendor.html"><code>cargo vendor</code></a> 子命令。</p>
<p>译者注：“vendor”这个词本身是个名词，意为”小贩、销售商“，没有动词含义。但是有一些软件领域的文章将其作为一个动词使用，表示”将源代码和其所依赖的第三方库一起打包起来“这么一个意思。就像是npm的 <code>node_modules</code> 。 参考来源是<a href="https://en.wiktionary.org/wiki/vendor">wiktionary-vendor</a></p>
<h2 id="清除缓存"><a class="header" href="#清除缓存">清除缓存</a></h2>
<p>理论上，你可以删除cache的任何一部分，当一个crate需要某些源码时，Cargo会尽力帮你恢复，要么是解压已有的压缩文件或从一个裸仓库中checkout出来，要么是从网上重新下载源文件。</p>
<p>另一种方法是，<a href="https://crates.io/crates/cargo-cache">cargo-cache</a> crate 提供了一个CLI工具来只清除cache中选中的部分和显示cache组成各部分所占的空间大小。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="构建缓存"><a class="header" href="#构建缓存">构建缓存</a></h2>
<p>Cargo会把构建输出保存在“target”文件夹中。默认情况下这个文件夹是你<a href="guide/../appendix/glossary.html#workspace" title="&quot;workspace&quot; (glossary entry)"><em>workspace</em></a>根目录下的 <code>target</code>文件夹。如果要改变输出位置，可以设置 <code>CARGO_TARGET_DIR</code> <a href="guide/../reference/environment-variables.html">环境变量</a>， <a href="guide/../reference/config.html#buildtarget-dir"><code>build.target-dir</code></a> config参数，或者 <code>--target-dir</code> 命令行标志(flag)。</p>
<p>这个文件夹的布局取决于你是否使用 <code>--target</code> 标志来为特定平台构建。如果没有设置 <code>--target</code> 标志，Cargo 会为宿主架构进行构建。输出文件保存在target文件夹，每个特定编译预设(<a href="guide/../reference/profiles.html">profile</a>)的输出文件会在放在单独的子文件夹中。</p>
<div class="table-wrapper"><table><thead><tr><th>文件夹</th><th>描述</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">target/debug/</code></td><td>包含 <code>dev</code> 预设的输出文件。</td></tr>
<tr><td><code style="white-space: nowrap">target/release/</code></td><td>包含 <code>release</code> 预设 (构建时带 <code>--release</code> 选项) 的输出文件。</td></tr>
<tr><td><code style="white-space: nowrap">target/foo/</code></td><td>包含 <code>foo</code> 预设 (构建时带 <code>--profile=foo</code> 选项) 的输出文件。</td></tr>
</tbody></table>
</div>
<p>由于历史原因， <code>dev</code> 和 <code>test</code> 预设的输出文件被放在 <code>debug</code> 文件夹中， <code>release</code> 和 <code>bench</code> 预设的输出文件被放在 <code>release</code> 文件夹。用户自定义预设的输出文件被放在同名的文件夹中。</p>
<p>当为另一种架构 (非宿主架构，命令行了带 <code>--target</code> 参数) 而构建，输出文件会放在带有目标架构名字的文件夹中:</p>
<div class="table-wrapper"><table><thead><tr><th>文件夹</th><th>例子</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">target/&lt;triple&gt;/debug/</code></td><td><code style="white-space: nowrap">target/thumbv7em-none-eabihf/debug/</code></td></tr>
<tr><td><code style="white-space: nowrap">target/&lt;triple&gt;/release/</code></td><td><code style="white-space: nowrap">target/thumbv7em-none-eabihf/release/</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>注意</strong>: 如果没有使用 <code>--target</code>，Cargo会把你的依赖共享给构建脚本(build scripts)和过程宏(proc macros)使用。
<a href="guide/../reference/config.html#buildrustflags"><code>RUSTFLAGS</code></a> 会在每次 <code>rustc</code> 调用时被使用。
如果使用了 <code>--target</code> 标志，构建脚本和过程宏会为宿主架构单独构建，不会获取 <code>RUSTFLAGS</code> 中的参数。</p>
</blockquote>
<p>在每个预设(profile)的输出文件夹中（比如 <code>debug</code> 或 <code>release</code>），构建产物会被放在以下几个文件夹中:</p>
<div class="table-wrapper"><table><thead><tr><th>文件夹</th><th>描述</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">target/debug/</code></td><td>包含该包的构建产品 (<a href="guide/../reference/cargo-targets.html#binaries">二进制可执行文件</a> 和 <a href="guide/../reference/cargo-targets.html#library">库文件</a>).</td></tr>
<tr><td><code style="white-space: nowrap">target/debug/examples/</code></td><td>包含examples 的构建产品 <a href="guide/../reference/cargo-targets.html#examples">example targets</a>.</td></tr>
</tbody></table>
</div>
<p>一些命令会把生成文件放在 <code>target</code>目录的顶层:</p>
<div class="table-wrapper"><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">target/doc/</code></td><td>包含 rustdoc 生成的文档 (<a href="guide/../commands/cargo-doc.html"><code>cargo doc</code></a> 命令)。</td></tr>
<tr><td><code style="white-space: nowrap">target/package/</code></td><td>包含 <a href="guide/../commands/cargo-package.html"><code>cargo package</code></a> 和 <a href="guide/../commands/cargo-publish.html"><code>cargo publish</code></a> 命令生成的文件。</td></tr>
</tbody></table>
</div>
<p>Cargo还会生成构建过程需要的其他文件和文件夹，它们的组织结构被Cargo看做是内部信息，可能会被更改。其中几个文件夹:</p>
<div class="table-wrapper"><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">target/debug/deps/</code></td><td>依赖项以及其他产物。</td></tr>
<tr><td><code style="white-space: nowrap">target/debug/incremental/</code></td><td><code>rustc</code> <a href="guide/../reference/profiles.html#incremental">增量编译输出</a>，用来加速之后构建过程的一些缓存文件。</td></tr>
<tr><td><code style="white-space: nowrap">target/debug/build/</code></td><td><a href="guide/../reference/build-scripts.html">构建脚本</a> 的生成内容。</td></tr>
</tbody></table>
</div>
<h3 id="dep-info-files"><a class="header" href="#dep-info-files">Dep-info files</a></h3>
<p>还有一个后缀为 <code>.d</code> 的”依赖信息“文件(dep info)，类似Makefile，记录了再次构建所需的文件依赖。这个文件用于提供给外部的构建系统，判断是否需要再次执行Cargo。文件中的文件路径在默认情况下都是绝对路径。如何设置为相对路径见 <a href="guide/../reference/config.html#builddep-info-basedir"><code>build.dep-info-basedir</code></a>。</p>
<pre><code class="language-Makefile"># dep-info 文件的一个例子: target/debug/foo.d
/path/to/myproj/target/debug/foo: /path/to/myproj/src/lib.rs /path/to/myproj/src/main.rs
</code></pre>
<h3 id="共享缓存"><a class="header" href="#共享缓存">共享缓存</a></h3>
<p>一个第三方工具 <a href="https://github.com/mozilla/sccache">sccache</a> 可以跨workspace共享构建依赖。</p>
<p>通过 <code>cargo install sccache</code> 下载 <code>sccache</code>。在执行Cargo前，将 <code>RUSTC_WRAPPER</code> 环境变量设置为 <code>sccache</code>。如果你用的是bash，那么可以把<code>export RUSTC_WRAPPER=sccache</code> 添加到 <code>.bashrc</code> 。或者你可以在 <a href="guide/../reference/config.html">Cargo配置文件</a> 中设置 <a href="guide/../reference/config.html#buildrustc-wrapper"><code>build.rustc-wrapper</code></a> 。查看sccache的文档来获取更多细节。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-参考"><a class="header" href="#cargo-参考">Cargo 参考</a></h2>
<p>参考涵盖Cargo各个领域的细节。</p>
<ul>
<li><a href="reference/specifying-dependencies.html">指定依赖</a>
<ul>
<li><a href="reference/overriding-dependencies.html">覆盖依赖</a></li>
</ul>
</li>
<li><a href="reference/manifest.html">配置清单</a>
<ul>
<li><a href="reference/cargo-targets.html">Cargo目标</a></li>
</ul>
</li>
<li><a href="reference/workspaces.html">工作空间</a></li>
<li><a href="reference/features.html">特性</a>
<ul>
<li><a href="reference/features-examples.html">特性实例</a></li>
</ul>
</li>
<li><a href="reference/profiles.html">配置文件</a></li>
<li><a href="reference/config.html">配置</a></li>
<li><a href="reference/environment-variables.html">环境变量</a></li>
<li><a href="reference/build-scripts.html">构建脚本</a>
<ul>
<li><a href="reference/build-script-examples.html">构建脚本实例</a></li>
</ul>
</li>
<li><a href="reference/publishing.html">发布到crates.io</a></li>
<li><a href="reference/pkgid-spec.html">包ID说明</a></li>
<li><a href="reference/source-replacement.html">源替代</a></li>
<li><a href="reference/external-tools.html">外部工具</a></li>
<li><a href="reference/registries.html">注册中心</a></li>
<li><a href="reference/resolver.html">依赖解析</a></li>
<li><a href="reference/semver.html">语义化版本兼容性</a></li>
<li><a href="reference/future-incompat-report.html">未来不兼容报告</a></li>
<li><a href="reference/timings.html">构建时报告</a></li>
<li><a href="reference/unstable.html">不稳定特性</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="指定依赖项"><a class="header" href="#指定依赖项">指定依赖项</a></h2>
<p>你的crate可以依赖另一个库，这个库可以来自 <a href="https://crates.io/">crates.io</a> 或者其他 registry、git 仓库或者你文件系统中的一个子目录。你也可以暂时覆盖某个依赖的路径，这样就可以在本地检查和修复某个依赖项的bug。你可以对不同目标平台指定不同的依赖，也可以指定仅仅在开发阶段使用某个依赖。让我们来看看具体应该怎么做。</p>
<h3 id="指定一个-crateio-上的依赖"><a class="header" href="#指定一个-crateio-上的依赖">指定一个 crate.io 上的依赖</a></h3>
<p>默认情况下，Cargo被设置为从 <a href="https://crates.io/">crates.io</a> 中查找依赖。之前在 <a href="reference/../guide/index.html">the cargo guide</a> 里我们指定了 <code>time</code> crate 作为依赖: </p>
<pre><code class="language-toml">[dependencies]
time = &quot;0.1.12&quot;
</code></pre>
<p><code>&quot;0.1.12&quot;</code> 这个字符串表示请求的版本。虽然它看起来表示一个具体的 <code>time</code> 版本，但实际上它表示一个范围，允许与 <a href="https://semver.org">SemVer</a> 兼容的更新。具体来说，不改变 <code>主版本号.次版本号.修订号</code> 中<strong>第一个非零数字</strong>的所有更新都是允许的。如果我们运行 <code>cargo update -p time</code> ，Cargo 会把 <code>time</code> 更新到 <code>0.1.13</code> (假设这是形如 <code>0.1.z</code> 的最新版本)，但不会更新到 <code>0.2.0</code>。 如果我们指定版本为 <code>1.0</code>，那么Cargo 会将其更新到 <code>1.1</code> (假设这是最新的 <code>1.y</code> 版本)，但绝不会更新到 <code>2.0</code>。<code>0.0.x</code> 这个版本和任何其他版本都不兼容。</p>
<p>下面是一些书写版本的例子以及符合要求的版本范围:</p>
<pre><code class="language-notrust">1.2.3  :=  &gt;=1.2.3, &lt;2.0.0
1.2    :=  &gt;=1.2.0, &lt;2.0.0
1      :=  &gt;=1.0.0, &lt;2.0.0
0.2.3  :=  &gt;=0.2.3, &lt;0.3.0
0.2    :=  &gt;=0.2.0, &lt;0.3.0
0.0.3  :=  &gt;=0.0.3, &lt;0.0.4
0.0    :=  &gt;=0.0.0, &lt;0.1.0
0      :=  &gt;=0.0.0, &lt;1.0.0
</code></pre>
<p>这种兼容规则与SemVer有些不同，SemVer认为在1.0.0之前没有任何兼容性，而Cargo认为 <code>0.x.y</code> 是与 <code>0.x.z</code>兼容的 (只要 <code>y ≥ z</code> 且 <code>x &gt; 0</code>)。</p>
<p>可以通过一些特殊操作符来调整选择兼容版本的逻辑，但在大多数时候都不需要。</p>
<h3 id="使用--符号"><a class="header" href="#使用--符号">使用 <code>^</code> 符号</a></h3>
<p><code>^</code> 符号是默认策略的另一种写法，<code>^1.2.3</code> 和 <code>1.2.3</code> 的意义是一样的。</p>
<h3 id="使用--符号-1"><a class="header" href="#使用--符号-1">使用 <code>~</code> 符号</a></h3>
<p><code>~</code> 符号表示在某个最小版本的基础上可以做一定的更新。如果你指定了一个形如 <code>主.次.修</code> 或者 <code>主.次</code> 的版本，那么修订号是可以变的。如果是只指定了主版本号，那么次版本号和修订号都是都可以改变。</p>
<p><code>~1.2.3</code> 的例子:</p>
<pre><code class="language-notrust">~1.2.3  := &gt;=1.2.3, &lt;1.3.0
~1.2    := &gt;=1.2.0, &lt;1.3.0
~1      := &gt;=1.0.0, &lt;2.0.0
</code></pre>
<h3 id="通配符-"><a class="header" href="#通配符-">通配符 <code>*</code></a></h3>
<p>通配符出现的地方可以表示任意的数字。</p>
<p>比如 <code>*</code>、<code>1.*</code>、 <code>1.2.*</code>。</p>
<pre><code class="language-notrust">*     := &gt;=0.0.0
1.*   := &gt;=1.0.0, &lt;2.0.0
1.2.* := &gt;=1.2.0, &lt;1.3.0
</code></pre>
<blockquote>
<p><strong>注意</strong>: <a href="https://crates.io/">crates.io</a> 不允许只写一个单独的 <code>*</code>。</p>
</blockquote>
<h3 id="使用比较符号"><a class="header" href="#使用比较符号">使用比较符号</a></h3>
<p>使用比较符号可以手动指定一个版本范围或一个具体的版本。</p>
<p>下面是一些例子:</p>
<pre><code class="language-notrust">&gt;= 1.2.0
&gt; 1
&lt; 2
= 1.2.3
</code></pre>
<h3 id="多重约束"><a class="header" href="#多重约束">多重约束</a></h3>
<p>就像上面的例子中一样，多个版本约束可以用逗号分隔，如 <code>&gt;= 1.2, &lt; 1.5</code>。</p>
<h3 id="指定来自其他registry的依赖"><a class="header" href="#指定来自其他registry的依赖">指定来自其他registry的依赖</a></h3>
<p>为了指定一个非 <a href="https://crates.io/">crates.io</a> 的依赖，首先这个registry必须在 <code>.cargo/config.toml</code> 中设置，参见 <a href="reference/registries.html">registries documentation</a>。在依赖项中，将 <code>registry</code> 字段设置为你想用的registry。</p>
<pre><code class="language-toml">[dependencies]
some-crate = { version = &quot;1.0&quot;, registry = &quot;my-registry&quot; }
</code></pre>
<blockquote>
<p><strong>注意</strong>: <a href="https://crates.io/">crates.io</a> 不允许发布带着其他registry依赖的包。</p>
</blockquote>
<h3 id="指定来自-git-的依赖"><a class="header" href="#指定来自-git-的依赖">指定来自 <code>git</code> 的依赖</a></h3>
<p>要指定位于某个 <code>git</code> 仓库的依赖库，需要的最小信息是在 <code>git</code> 字段中写出该仓库的位置:</p>
<pre><code class="language-toml">[dependencies]
regex = { git = &quot;https://github.com/rust-lang/regex.git&quot; }
</code></pre>
<p>Cargo 会 fetch 这个 <code>git</code> 仓库，并在仓库中查找与所需crate对应的 <code>Cargo.toml</code> 文件(这个文件不要求必须在地址根目录下，比如说指定的是某个workspace的一个成员crate，这时 <code>git</code> 字段只需写workspace的地址就可以)。</p>
<p>因为我们没有指定其他信息，Cargo假设我们想用的是该仓库主分支的最新commit。你也可以在 <code>git</code>字段后加上 <code>rev</code>、<code>tag</code> 或 <code>branch</code> 这些字段，来指定你想要的commit。下面是一个指定 <code>next</code> 分支上的最新commit的例子:</p>
<pre><code class="language-toml">[dependencies]
regex = { git = &quot;https://github.com/rust-lang/regex.git&quot;, branch = &quot;next&quot; }
</code></pre>
<p>如果想要指定的依赖版本不是某个branch的头，也没有标记tag，那么就需要用 <code>rev</code> 来指定。<code>rev</code> 字段可以是像 <code>rev = &quot;4c59b707&quot;</code> 这样的 commit hash 值，也可以是像 <code>rev = &quot;refs/pull/493/head&quot;</code> 这样的命名引用。哪些引用是合法的取决于这个git仓库具体的管理机构。Github 暴露出了每个pull requeset 最新commit的引用，其他git机构一般也提供了类似的，只是可能有不同的命名规则。</p>
<p>一旦某个 <code>git</code> 依赖被添加，Cargo会立刻锁定该依赖到当前最新的commit。之后即使有新的commit被提交，Cargo也不会再自动拉取。不过，你可以通过 <code>cargo update</code> 命令来手动拉取。</p>
<p>对于私有仓库的身份验证，参考 <a href="reference/../appendix/git-authentication.html">Git 身份验证</a>。</p>
<blockquote>
<p><strong>注意</strong>: <a href="https://crates.io/">crates.io</a> 不允许发布带 <code>git</code> 依赖的包( <code>git</code> <a href="reference/specifying-dependencies.html#development-dependencies">dev-dependencies</a> 除外)。对于备用选择，参考<a href="reference/specifying-dependencies.html#multiple-locations">Multiple locations</a>。</p>
</blockquote>
<h3 id="指定路径依赖"><a class="header" href="#指定路径依赖">指定路径依赖</a></h3>
<p>经过一段时间，我们的 <code>hello_world</code> 包 (来自<a href="reference/../guide/index.html">the guide</a>) 已经变得很大了。我们可能想要把其中一部分拆出来使用。Cargo为此提供了指定路径依赖的功能，最经典的情况是一个git仓库中有很多个子crate。首先我们在 <code>hello_world</code> 项目里面创建一个新的crate:</p>
<pre><code class="language-console"># hello_world/ 目录中
$ cargo new hello_utils
</code></pre>
<p>这将创建一个新的 <code>hello_utils</code> 文件夹，其中已经设置好了 <code>Cargo.toml</code> 和 <code>src</code> 文件夹。为了让Cargo知道新crate的存在，需要在 <code>hello_world/Cargo.toml</code> 中将 <code>hello_utils</code> 添加为依赖:</p>
<pre><code class="language-toml">[dependencies]
hello_utils = { path = &quot;hello_utils&quot; }
</code></pre>
<p>这会告诉Cargo我们依赖了一个名为 <code>hello_utils</code> 的crate，其在 <code>hello_utils</code> 文件夹中(相对于刚刚被写入的 <code>Cargo.toml</code> 的位置)。</p>
<p>搞定！下次执行 <code>cargo build</code> 会自动构建 <code>hello_utils</code> 和它的所有依赖，其他包也可以使用这个crate。但是，<a href="https://crates.io/">crates.io</a> 不允许发布仅以路径指定某个依赖的包。如果我们想发布 <code>hello_world</code>，就必须把 <code>hello_utils</code> 发布到 <a href="https://crates.io/">crates.io</a>，然后在 <code>hello_word</code>的 toml 中同时指定依赖版本:</p>
<pre><code class="language-toml">[dependencies]
hello_utils = { path = &quot;hello_utils&quot;, version = &quot;0.1.0&quot; }
</code></pre>
<blockquote>
<p><strong>注意</strong>: <a href="https://crates.io/">crates.io</a> 不允许发布带 <code>path</code> 依赖的包( <code>path</code> <a href="reference/specifying-dependencies.html#development-dependencies">dev-dependencies</a> 除外)。对于备用选择，参考<a href="reference/specifying-dependencies.html#multiple-locations">Multiple locations</a>。</p>
</blockquote>
<h3 id="多依赖位置"><a class="header" href="#多依赖位置">多依赖位置</a></h3>
<p>可以对一个依赖同时指定一个registry和一个 <code>git</code> 或 <code>path</code> 位置。<code>git</code> 或 <code>path</code> 依赖项会被用于本地(此时 <code>version</code> 会与本地的拷贝进行对比)，而当发布到一个registry (比如<a href="https://crates.io/">crates.io</a>) 时，会使用 registry 上的版本。其他组合是不允许的。例如:</p>
<pre><code class="language-toml">[dependencies]
# 在本地时会使用 `my-bitflags`
# 而上传后会使用 crates.io 中的1.0 版本
bitflags = { path = &quot;my-bitflags&quot;, version = &quot;1.0&quot; }

# 在本地时会使用给定的 git 仓库
# 而上传后会使用 crates.io 中的1.0 版本
smallvec = { git = &quot;https://github.com/servo/rust-smallvec.git&quot;, version = &quot;1.0&quot; }

# 如果version没有匹配，Cargo 会编译失败！
</code></pre>
<p>一个使用的场景是当你把一个库拆分成一个工作空间(workspace)中的多个包(package)，你可以用 <code>path</code> 在开发阶段指定工作空间内的本地包做为依赖，而当你将其发布后，就可以使用 <a href="https://crates.io/">crates.io</a> 上的版本了。</p>
<h3 id="平台特定依赖"><a class="header" href="#平台特定依赖">平台特定依赖</a></h3>
<p>平台特定依赖的书写格式没什么变化，但是要列在 <code>target</code> 部分。通常使用与rust代码类似的 <a href="reference/../../reference/conditional-compilation.html"><code>#[cfg]</code> 语法</a>:</p>
<pre><code class="language-toml">[target.'cfg(windows)'.dependencies]
winhttp = &quot;0.4.0&quot;

[target.'cfg(unix)'.dependencies]
openssl = &quot;1.0.1&quot;

[target.'cfg(target_arch = &quot;x86&quot;)'.dependencies]
native-i686 = { path = &quot;native/i686&quot; }

[target.'cfg(target_arch = &quot;x86_64&quot;)'.dependencies]
native-x86_64 = { path = &quot;native/x86_64&quot; }
</code></pre>
<p>如同rust代码一样，语法支持 <code>not</code>、<code>any</code> 和 <code>all</code> 操作符，从而组合不同的cfg键值对。</p>
<p>如果你想知道自己的平台支持哪些cfg目标，可以运行 <code>rustc --print=cfg</code> 来获取。如果你想知道其他平台可用的cfg目标，可以使用 <code>rustc --print=cfg --target=x86_64-pc-windows-msvc</code>。</p>
<p>与rust代码不同，你不能使用 <code>[target.'cfg(feature = &quot;fancy-feature&quot;)'.dependencies]</code> 来根据feature指定依赖，而是应该使用 <a href="reference/features.html">features</a>。</p>
<pre><code class="language-toml">[dependencies]
foo = { version = &quot;1.0&quot;, optional = true }
bar = { version = &quot;1.0&quot;, optional = true }

[features]
fancy-feature = [&quot;foo&quot;, &quot;bar&quot;]
</code></pre>
<p>这同样也适用于 <code>cfg(debug_assertions)</code> ， <code>cfg(test)</code> 和 <code>cfg(proc_macro)</code>。这些值不会按你的预期生效，写不写结果都和默认情况(<code>rustc --print=cfg</code>返回的结果)相同。目前没有办法根据这些设置值来添加依赖。</p>
<p>除了 <code>#[cfg]</code> 标记，Cargo也支持直接写出target的全名来指定依赖:</p>
<pre><code class="language-toml">[target.x86_64-pc-windows-gnu.dependencies]
winhttp = &quot;0.4.0&quot;

[target.i686-unknown-linux-gnu.dependencies]
openssl = &quot;1.0.1&quot;
</code></pre>
<h4 id="为自定义目标指定依赖"><a class="header" href="#为自定义目标指定依赖">为自定义目标指定依赖</a></h4>
<p>如果你使用一个自定义构建目标 (比如 <code>--target foo/bar.json</code> )，使用不含 <code>.json</code> 后缀的文件名作为名字:</p>
<pre><code class="language-toml">[target.bar.dependencies]
winhttp = &quot;0.4.0&quot;

[target.my-special-i686-platform.dependencies]
openssl = &quot;1.0.1&quot;
native = { path = &quot;native/i686&quot; }
</code></pre>
<blockquote>
<p><strong>注意</strong>: 自定义目标依赖在稳定版是不支持的。</p>
</blockquote>
<h3 id="开发依赖"><a class="header" href="#开发依赖">开发依赖</a></h3>
<p>你可以在 <code>Cargo.toml</code> 中添加 <code>[dev-dependencies]</code> ，格式与 <code>[dependencies]</code> 一致:</p>
<pre><code class="language-toml">[dev-dependencies]
tempdir = &quot;0.3&quot;
</code></pre>
<p>开发依赖不会被用在构建包时，而是用在编译 tests、emamples 和 benchmarks。</p>
<p>这些依赖不会传播给依赖本包的那些包。</p>
<p>你也可以为特定目标指定开发依赖，只需要把 <code>dependencies</code> 换成 <code>dev-denpendencies</code> 。</p>
<pre><code class="language-toml">[target.'cfg(unix)'.dev-dependencies]
mio = &quot;0.0.1&quot;
</code></pre>
<blockquote>
<p><strong>注意</strong>: 当发布一个包时，只有那些以 <code>version</code> 指定的开发依赖才会被包含在发布的包中。大部分情况下，包发布后就不需要开发依赖了，但是也有一些使用者(比如操作系统打包商)希望在crate中运行一些测试，所以给开发依赖提供一个 <code>version</code> 也是有好处的。</p>
</blockquote>
<h3 id="构建依赖"><a class="header" href="#构建依赖">构建依赖</a></h3>
<p>你可以在构建脚本中依赖一些使用Cargo的crate。在清单中指定 <code>build-dependencies</code> 来声明依赖。</p>
<pre><code class="language-toml">[build-dependencies]
cc = &quot;1.0.3&quot;
</code></pre>
<p>你也可以为特定目标指定构建依赖，只需将 <code>dependencies</code> 替换为 <code>build-dependencies</code> 。例如:</p>
<pre><code class="language-toml">[target.'cfg(unix)'.build-dependencies]
cc = &quot;1.0.3&quot;
</code></pre>
<p>这样，只有当宿主平台满足指定目标要求时，相关依赖才会被构建。</p>
<p>构建脚本无法使用 <code>dependencies</code> 和 <code>dev-dependencies</code> 中列出的依赖。同样的，包也无法使用构建依赖(<code>build-dependencies</code>)，除非该依赖也被放在了 <code>dependencies</code> 中。一个包和它的构建脚本是分开各自编译的，因此它们的依赖项也不需要相同。Cargo通过对不同的目的使用各自的依赖来保持简单和简洁。</p>
<h3 id="选择特性"><a class="header" href="#选择特性">选择特性</a></h3>
<p>如果你依赖的包提供了可选的特性(feature)，你可以选择使用哪些:</p>
<pre><code class="language-toml">[dependencies.awesome]
version = &quot;1.3.5&quot;
default-features = false # 不使用默认特性
                         # 手动选择单独的特性
features = [&quot;secure-password&quot;, &quot;civet&quot;]
</code></pre>
<p>关于特性的更多信息，参考 <a href="reference/features.html#dependency-features">features chapter</a>。</p>
<h3 id="在-cargotoml-中重命名依赖"><a class="header" href="#在-cargotoml-中重命名依赖">在 <code>Cargo.toml</code> 中重命名依赖</a></h3>
<p>当你在 <code>Cargo.toml</code> 中添加 <code>[dependencies]</code> 时，给依赖项的命名就是你导入到代码中的crate名。但是在某些项目中，你可能想要用另一个名称来引用这个crate，而不是它在crates.io上的名字。例如，你可能希望:</p>
<ul>
<li>避免在代码中使用 <code>use foo as bar</code>。</li>
<li>同时使用某个crate的多个版本。</li>
<li>依赖不同registry中同名的包。</li>
</ul>
<p>Cargo 通过在 <code>[dependencies]</code> 加入<code>package</code> 字段来支持此功能。</p>
<pre><code class="language-toml">[package]
name = &quot;mypackage&quot;
version = &quot;0.0.1&quot;

[dependencies]
foo = &quot;0.1&quot;
bar = { git = &quot;https://github.com/example/project.git&quot;, package = &quot;foo&quot; }
baz = { version = &quot;0.1&quot;, registry = &quot;custom&quot;, package = &quot;foo&quot; }
</code></pre>
<p>在这个例子中，这三个crate都在代码中可用:</p>
<pre><code class="language-rust ignore">extern crate foo; // crates.io
extern crate bar; // git repository
extern crate baz; // registry `custom`</code></pre>
<p>这三个crate都在自己的 <code>Cargo.toml</code> 里名为 <code>foo</code> ，所以我们用 <code>package</code> 来声明我们想要的是那个名为 <code>foo</code> 的包，即使我们会在本地用另一个别名来称呼它。如果没有指定 <code>package</code> ，则认为其名称与指定的依赖名称一致。</p>
<p>注意如果你有一个可选依赖:</p>
<pre><code class="language-toml">[dependencies]
bar = { version = &quot;0.1&quot;, package = 'foo', optional = true }
</code></pre>
<p>你依赖的是 crates.io 上的 <code>foo</code> 包，但是你的包指定的是 <code>bar</code> feature 而不是<code>foo</code> feature。也就是说如果你给一个依赖改了名，feature 使用的是依赖的名字，而不是包原本的名字。</p>
<p>传递依赖也是如此，比如我们可以把下面的条目加入清单文件:</p>
<pre><code class="language-toml">[features]
log-debug = ['bar/log-debug'] # 用 'foo/log-debug' 会报错!
</code></pre>
<h3 id="从工作空间中继承依赖"><a class="header" href="#从工作空间中继承依赖">从工作空间中继承依赖</a></h3>
<p>可以在工作空间的 <a href="reference/workspaces.html#the-dependencies-table"><code>[workspace.dependencies]</code></a> 字段指定依赖，然后在crate的 <code>[dependencies]</code> 中添加 <code>workspace = true</code> 就可以继承这个依赖。</p>
<p>除了 <code>workspace</code> 字段，还可以加入:</p>
<ul>
<li><a href="reference/features.html#optional-dependencies"><code>optional</code></a>: 注意 <code>[workspace.dependencies]</code> 不允许使用 <code>optional</code>。</li>
<li><a href="reference/features.html"><code>features</code></a>:  这是对于 <code>[workspace.dependencies]</code> 中声明的依赖的补充。</li>
</ul>
<p>在 <code>optional</code> 和 <code>features</code> 之外，继承依赖不允许使用任何其他字段(比如 <code>version</code> 或 <code>default-features</code>)。</p>
<p><code>[dependencies]</code> 、 <code>[dev-dependencies]</code> 、 <code>[build-dependencies]</code> 和
<code>[target.&quot;...&quot;.dependencies]</code> 都可以引用 <code>[workspace.dependencies]</code> 中定义的依赖。</p>
<pre><code class="language-toml">[package]
name = &quot;bar&quot;
version = &quot;0.2.0&quot;

[dependencies]
regex = { workspace = true, features = [&quot;unicode&quot;] }

[build-dependencies]
cc.workspace = true

[dev-dependencies]
rand = { workspace = true, optional = true }
</code></pre>
<script>
(function() {
    var fragments = {
        "#overriding-dependencies": "overriding-dependencies.html",
        "#testing-a-bugfix": "overriding-dependencies.html#testing-a-bugfix",
        "#working-with-an-unpublished-minor-version": "overriding-dependencies.html#working-with-an-unpublished-minor-version",
        "#overriding-repository-url": "overriding-dependencies.html#overriding-repository-url",
        "#prepublishing-a-breaking-change": "overriding-dependencies.html#prepublishing-a-breaking-change",
        "#overriding-with-local-dependencies": "overriding-dependencies.html#paths-overrides",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<div style="break-before: page; page-break-before: always;"></div><h2 id="覆盖依赖"><a class="header" href="#覆盖依赖">覆盖依赖</a></h2>
<p>在很多场景下可能会希望覆盖一个依赖。但大部分情况都可以归结为想在一个包发布到 <a href="https://crates.io/">crates.io</a> 之前使用它。例如: </p>
<ul>
<li>你正在写的一个crate同时也被另一个更大的应用(app)使用着，而且你希望在这个app中测试对该crate的一个bug fix。</li>
<li>一个不属于你的上游crate在其git仓库的master分支增加了一些新特性，或修复了一些bug，你想要测试一下。</li>
<li>你准备给自己的crate发布一个新的主版本(major version)，但是你想先在整个包上做一下集成测试来确保正确。</li>
<li>你已经给一个上游crate提交了bug fix，但是现在想立刻让你的app使用这个修复后的crate，避免在等待这个bug fix 被 merge 期间浪费时间。</li>
</ul>
<p>这些问题都可以通过清单中的 <a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code> </a> 部分来解决。</p>
<p>本章将从几种不同使用案例出发，详细介绍各种覆盖依赖的方法。</p>
<ul>
<li>Example use cases
<ul>
<li><a href="reference/overriding-dependencies.html#testing-a-bugfix">Testing a bugfix</a></li>
<li><a href="reference/overriding-dependencies.html#working-with-an-unpublished-minor-version">Working with an unpublished minor version</a>
<ul>
<li><a href="reference/overriding-dependencies.html#overriding-repository-url">Overriding repository URL</a></li>
</ul>
</li>
<li><a href="reference/overriding-dependencies.html#prepublishing-a-breaking-change">Prepublishing a breaking change</a></li>
<li><a href="reference/overriding-dependencies.html#using-patch-with-multiple-versions">Using <code>[patch]</code> with multiple versions</a></li>
</ul>
</li>
<li>Reference
<ul>
<li><a href="reference/overriding-dependencies.html#the-patch-section">The <code>[patch]</code> section</a></li>
<li><a href="reference/overriding-dependencies.html#the-replace-section">The <code>[replace]</code> section</a></li>
<li><a href="reference/overriding-dependencies.html#paths-overrides"><code>paths</code> overrides</a></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>: 也可以参考使用多依赖位置(<a href="reference/specifying-dependencies.html#multiple-locations">multiple locations</a>)来指定一个依赖，这个方法可以在本地覆盖一个依赖的源地址。</p>
</blockquote>
<h3 id="测试一个bugfix"><a class="header" href="#测试一个bugfix">测试一个bugfix</a></h3>
<p>比方说你正在使用 <a href="https://crates.io/crates/uuid"><code>uuid</code> crate</a> 但是用着用着却在里面发现了一个bug。然而，你是一个有雄心的人，因此打算自己修复这个bug！刚开始的时候，你的清单文件长这样:</p>
<pre><code class="language-toml">[package]
name = &quot;my-library&quot;
version = &quot;0.1.0&quot;

[dependencies]
uuid = &quot;1.0&quot;
</code></pre>
<p>我们首先要做的是吧 <a href="https://github.com/uuid-rs/uuid"><code>uuid</code> 仓库</a> clone下来:</p>
<pre><code class="language-console">$ git clone https://github.com/uuid-rs/uuid.git
</code></pre>
<p>然后我们修改自己的 <code>my-library</code> 包的清单文件来包含clone下来的uuid:</p>
<pre><code class="language-toml">[patch.crates-io]
uuid = { path = &quot;../path/to/uuid&quot; }
</code></pre>
<p>这里我们声明我们在用一个新的依赖<em>覆盖</em>(<em>patching</em>) <code>crates-io</code> 源。这会将我们刚下载到本地的 <code>uuid</code> 添加到 crates.io 中(仅仅针对我们这个本地项目)。</p>
<p>接着我们我们需要保证 lock file 被更新，以保证我们使用的是下载下来的本地版 <code>uuid</code>，而不是 crates.io 上的。<code>[patch]</code> 的原理是加载位于 <code>../path/to/uuid</code> 的依赖，当需要从 crates.io 中获取 <code>uuid</code> 的某个版本时，本地的版本<em>也</em>会被返回。</p>
<p>这意味着本地版本的版本号是很重要的，这会影响到本地版本是否实际被选用。我们清单文件中声明 <code>uuid = &quot;1.0&quot;</code> ，表示我们请求 <code>&gt;= 1.0.0, &lt; 2.0.0</code> 的包，Cargo的贪婪策略意味着我们得到的会是这个范围内的最高版本(译者补充：也就是说，如果本地版本低于crates.io上的版本，那么会是crates.io上的版本被选中)。一般来说这一点不太需要关心，因为 git 仓库里的版本总是高于或者等于 crates.io 里的最高版本，但是原理要明白！</p>
<p>你现在需要做的是:</p>
<pre><code class="language-console">$ cargo build
   Compiling uuid v1.0.0 (.../uuid)
   Compiling my-library v0.1.0 (.../my-library)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>搞定了。现在构建使用的就是本地版本的 <code>uuid</code> (看括号内的文件路径)。如果你看见构建的不是本地版本，那你可能需要运行 <code>cargo update -p uuid --precise $version</code>，这里的 <code>$version</code> 是本地版本 <code>uuid</code> 的版本号。</p>
<p>当你解决了之前发现的bug，接下来要做的事可能是将其通过 pull request 提交给 <code>uuid</code> 仓库。当你做完这些后，可以更新 <code>[patch]</code> 部分。<code>[patch]</code> 中条目的功能和 <code>[dependencies]</code> 一样，当你的 pull request 被合并后，你可以把 <code>path</code> 依赖改为 <code>git</code> 依赖:</p>
<pre><code class="language-toml">[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid.git' }
</code></pre>
<h3 id="使用未发布的次版本crate"><a class="header" href="#使用未发布的次版本crate">使用未发布的次版本crate</a></h3>
<p>现在让我们从修复bug转到添加featrue。在写 <code>my-library</code> 时你发现需要在 <code>uuid</code> 里加一个新feature。你已经实现了这个feature并在本地通过 <code>[patch]</code> 进行了测试，然后提交了 pull request。现在我们看看怎么在这个crate实际发布前继续测试和使用它。</p>
<p>假设 <code>uuid</code> 目前在crates.io上的最新版为 <code>1.0.0</code>，但 git 仓库上的最新版是 <code>1.0.1</code>，也就是你之前提交的新 feature。为了使用这个版本，我们把 <code>Cargo.toml</code> 改成了这样:</p>
<pre><code class="language-toml">[package]
name = &quot;my-library&quot;
version = &quot;0.1.0&quot;

[dependencies]
uuid = &quot;1.0.1&quot;

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid.git' }
</code></pre>
<p>我们的 <code>uuid</code> 本地版本是 <code>1.0.1</code>，这也是当这个crate被发布后我们所需的版本。目前这个版本还不存在于 crates.io，所以我们需要使用 <code>[patch]</code> 来声明。</p>
<p>现在，当我们构建我们的库时，Cargo 会从git仓库fetch这个 <code>uuid</code> ，解析版本为 <code>1.0.1</code>，而不是尝试从 crates.io 下载。而当 <code>1.0.1</code> 在crates.io发布后，这个 <code>[patch]</code> 就可以删除了。</p>
<p>值得一提的是 <code>[patch]</code> 支持传递依赖。比如我们在另一个更大的包中使用了之前的 <code>my-library</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;my-binary&quot;
version = &quot;0.1.0&quot;

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = &quot;1.0&quot;

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid.git' }
</code></pre>
<p>注意，<code>[patch]</code> 是传递的，但是只能在<em>顶层</em>定义，所以作为 <code>my-library</code> 的用户我们必要时需要重复写一遍 <code>[patch]</code> 。在本例中，新的 <code>uuid</code> crate 同时作用于 <code>uuid</code> 和 <code>my-library -&gt; uuid</code> 这两个依赖。整个依赖图中，<code>uuid</code> 只使用了我们从git仓库拉下来的 <code>1.0.1</code> 这个版本。</p>
<h4 id="覆盖git仓库的url"><a class="header" href="#覆盖git仓库的url">覆盖git仓库的URL</a></h4>
<p>如果你想要覆盖的依赖不在crates.io上，那么就需要改变使用 <code>[patch]</code> 的方法。比如说一个位于git仓库的依赖，你需要这样覆盖为本地路径:</p>
<pre><code class="language-toml">[patch.&quot;https://github.com/your/repository&quot;]
my-library = { path = &quot;../my-library/path&quot; }
</code></pre>
<p>OK了。</p>
<h3 id="预发布一个破坏性更新"><a class="header" href="#预发布一个破坏性更新">预发布一个破坏性更新</a></h3>
<p>更新主版本一般来说会有破坏性的更新(breaking change)。拿之前的crate来举例，这意味着我们会创建 <code>uuid</code> 的2.0.0版。把所有改动提交给上游后，更新 <code>my-library</code> 的清单文件为:</p>
<pre><code class="language-toml">[dependencies]
uuid = &quot;2.0&quot;

[patch.crates-io]
uuid = { git = &quot;https://github.com/uuid-rs/uuid.git&quot;, branch = &quot;2.0.0&quot; }
</code></pre>
<p>很好。就像之前的例子一样，因为crates.io中实际上没有2.0.0版，我们实际上通过 <code>[patch]</code> 使用了git仓库中的版本。为了详尽地练习一下，我们再看看 <code>my-binary</code> 的清单文件:</p>
<pre><code class="language-toml">[package]
name = &quot;my-binary&quot;
version = &quot;0.1.0&quot;

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = &quot;1.0&quot;

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid.git', branch = '2.0.0' }
</code></pre>
<p>注意，这里会解析出两个版本的 <code>uuid</code>。 <code>my-binary</code> 会继续使用 <code>1.x.y</code> 版的 <code>uuid</code>，而 <code>my-library</code> 会使用 <code>2.0.0</code> 版。这种解析逻辑允许你在依赖图中逐步应用某个crate的破坏性更新，而不是强制把这个破坏性更新一次性应用到整个依赖图。</p>
<h3 id="多版本的情况下使用-patch"><a class="header" href="#多版本的情况下使用-patch">多版本的情况下使用 <code>[patch]</code></a></h3>
<p>你可以通过 <code>package</code> 重命名来对同一个crate有多个patch。比如说我们想使用 <code>serde</code> 一个 <code>1.*</code> 版的bugfix（还没发布到crates.io），同时也想使用git仓库中 <code>serde</code> 的 <code>2.0.0</code> 版来构建原型。这时可以设置:</p>
<pre><code class="language-toml">[patch.crates-io]
serde = { git = 'https://github.com/serde-rs/serde.git' }
serde2 = { git = 'https://github.com/example/serde.git', package = 'serde', branch = 'v2' }
</code></pre>
<p>第一个 <code>serde = ...</code> 命令指示从git仓库中下载 serde  <code>1.*</code> 版 (我们需要的bugfix)，第二个 <code>serde2 = ...</code> 指示从 <code>https://github.com/example/serde</code> 的 <code>v2</code> 分支中下载serde的 <code>2.0.0</code> 版 (我们假设git仓库中该分支中的 <code>Cargo.toml</code> 中声明这个crate的版本是 <code>2.0.0</code>)。</p>
<p>注意，当我们在 <code>serde2</code> 里面用了 <code>package</code> 时，实际上 <code>serde2</code> 这个标识符会被忽略。我们只是需要一个和其他patch crate不冲突的名字而已。 (译者注：这里的意思是：<code>serde</code> 和 <code>serde2</code> 其实都是针对 <code>serde</code> 的补丁，一个覆盖 <code>1.*</code> 版，另一个覆盖 <code>2.*</code> 版，在这里 <code>serde2</code> 这个名字没有什么实际用途)</p>
<h3 id="patch-部分"><a class="header" href="#patch-部分"><code>[patch]</code> 部分</a></h3>
<p><code>Cargo.toml</code> 中的 <code>[patch]</code> 部分可以用其他版本覆盖某个依赖。语法与 <a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a> 相似。</p>
<pre><code class="language-toml">[patch.crates-io]
foo = { git = 'https://github.com/example/foo.git' }
bar = { path = 'my/local/bar' }

[dependencies.baz]
git = 'https://github.com/example/baz.git'

[patch.'https://github.com/example/baz']
baz = { git = 'https://github.com/example/patched-baz.git', branch = 'my-branch' }
</code></pre>
<p><strong>注意</strong>: <code>[patch]</code> 也可以被设置为 <a href="reference/config.html">configuration option</a> ，比如 <code>.cargo/config.toml</code> 文件或者命令行选项，如 <code>--config 'patch.crates-io.rand.path=&quot;rand&quot;'</code>。这对于你不打算 commit 的本地修改，或是临时测试某个patch 很方便。(译者注：因为这样就不用写到Cargo.toml里面了，所有patch设置都在本地，不会被上传到git)。</p>
<p><code>[patch]</code> 表和 <code>dependencies</code> 表很类似。<code>[patch]</code> 的key是一个源的URL，或者是注册机构的名字。 <code>crates-io</code>  用于覆盖默认的注册机构 <a href="https://crates.io/">crates.io</a>。上面的例子里第一个 <code>[patch]</code> 用于展示对 <a href="https://crates.io/">crates.io</a> 的覆盖，第二个 <code>[patch]</code> 展示对一个git源的覆盖。</p>
<p><code>[patch]</code> 表中的条目就是普通的依赖项，与<code>[dependencies]</code> 里的一样。这些依赖项被用于覆盖 URL 指定的源中的相应crate。上面例子中覆盖了 <code>crates-io</code> 源中的 <code>foo</code> crate 和 <code>bar</code> brate。同时，其也用另一个git仓库中的 <code>my-branch</code> 分支覆盖了 <code>https://github.com/example/baz</code> 源。</p>
<p>可以对源中某个crate尚不存在的版本进行覆盖，也可以对存在的版本进行覆盖。如果覆盖的是源中crate的已存在版本，则实际上是把这个版本替换掉了。</p>
<p>Cargo 只读取 workspace 中顶层 <code>Cargo.toml</code> 中的 <code>[patch]</code> 设置，依赖中的patch设置会被忽略。</p>
<h3 id="replace-部分"><a class="header" href="#replace-部分"><code>[replace]</code> 部分</a></h3>
<blockquote>
<p><strong>注意</strong>: <code>[replace]</code> 已经废弃，你应该使用 <a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code></a>。</p>
</blockquote>
<p>Cargo.toml的这个部分被用来以其他拷贝来覆盖某个依赖。语法与 <code>[dependencies]</code> 相似。</p>
<pre><code class="language-toml">[replace]
&quot;foo:0.1.0&quot; = { git = 'https://github.com/example/foo.git' }
&quot;bar:1.0.2&quot; = { path = 'my/local/bar' }
</code></pre>
<p><code>[replace]</code> 表中的每个key都是一个 <a href="reference/pkgid-spec.html">package ID specification</a>，其可以覆盖依赖图中的任意一个节点 (需要以三数字格式标明版本号)。每个key对应的value与 <code>[dependencies]</code> 中依赖格式相同 (除了不能使用 feature 字段以外)。用于覆盖的crate必须与被覆盖的crate版本相同，但是可以来自不同的源 (比如git或本地路径)。</p>
<p>Cargo 仅读取 workspace 中顶层 <code>Cargo.toml</code> 中的 <code>[replace]</code> 设置，依赖中的设置会被忽略。</p>
<h3 id="paths-覆盖"><a class="header" href="#paths-覆盖"><code>paths</code> 覆盖</a></h3>
<p>有时你仅仅想临时使用一个crate，而不想修改 <code>Cargo.toml</code> (比如<code>[patch]</code> 字段)，为此 Cargo 提供了一个更简单但功能有限的 <strong>路径覆盖</strong>(<strong>path overrides</strong>) 功能。</p>
<p>路径覆盖可以通过 <a href="reference/config.html"><code>.cargo/config.toml</code></a> 而不是 <code>Cargo.toml</code> 来指定。在 <code>.cargo/config.toml</code> 中，你可以指定一个名为 <code>paths</code> 的key:</p>
<pre><code class="language-toml">paths = [&quot;/path/to/uuid&quot;]
</code></pre>
<p>这个数组中应该填写一系列包含一个 <code>Cargo.toml</code> 文件的路径。在这个例子中，我们只添加了 <code>uuid</code> ，所以只有这个ctate被覆盖。这个路径可以是绝对地址，也可以是相对于<strong>包含.cargo文件夹</strong>的那个文件夹的相对路径。</p>
<p>译者注：这里说法比较绕，举个例子</p>
<p>比如你的路径格式为:</p>
<pre><code>rust
├── .cargo
│   └── config.toml
├── .rustup
└── overrides
    └── uuid
        └── Cargo.toml
</code></pre>
<p>那么相应的在 <code>config.toml</code> 中应该写:</p>
<pre><code class="language-toml">paths = [&quot;overrides/uuid&quot;]
</code></pre>
<p>而且paths字段应写在文件的最上方，不在任何一个 <code>[xxx]</code> 的下面，才能生效。</p>
<p>路径覆盖比 <code>[patch]</code> 更严格，其无法改变依赖图的结构。替换路径后，之前所有的依赖必须满足新 <code>Cargo.toml</code> 的要求。这意味着路径覆盖无法在测试时给某个crate添加依赖，这种情况只能使用 <code>[patch]</code> 。因此，路径覆盖一般只用于孤立地修改某个crate，以快速修复其中的bug，而不应用于更大规模的修改。</p>
<p>注意：用本地设置来进行路径覆盖，仅能用于那些已经发布在 <a href="https://crates.io/">crates.io</a> 上的包。你无法把这个功能用于让Cargo查找本地的未发布crate。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="配置清单格式"><a class="header" href="#配置清单格式">配置清单格式</a></h2>
<p>每个包的 <code>Cargo.toml</code> 文件被称为其<em>manifest</em> &quot;配置清单&quot;。它是以<a href="https://toml.io/">TOML</a>格式编写的。
它包含编译包所需的元数据。查看 <code>cargo locate-project</code> 部分，了解更多关于cargo如何查找配置清单文件的细节。</p>
<p>每个配置清单文件由以下部分组成:</p>
<ul>
<li><a href="reference/unstable.html"><code>cargo-features</code></a> — 不稳定, 每日构建特性。</li>
<li><a href="reference/manifest.html#the-package-section"><code>[package]</code></a> — 定义包。
<ul>
<li><a href="reference/manifest.html#the-name-field"><code>name</code></a> — 包的名字。</li>
<li><a href="reference/manifest.html#the-version-field"><code>version</code></a> — 包的版本。</li>
<li><a href="reference/manifest.html#the-authors-field"><code>authors</code></a> — 包的作者。</li>
<li><a href="reference/manifest.html#the-edition-field"><code>edition</code></a> — Rust版次。</li>
<li><a href="reference/manifest.html#the-rust-version-field"><code>rust-version</code></a> — 最小支持的Rust版本。</li>
<li><a href="reference/manifest.html#the-description-field"><code>description</code></a> — 包的描述。</li>
<li><a href="reference/manifest.html#the-documentation-field"><code>documentation</code></a> — 包文档的URL。</li>
<li><a href="reference/manifest.html#the-readme-field"><code>readme</code></a> — 包的README文件路径。</li>
<li><a href="reference/manifest.html#the-homepage-field"><code>homepage</code></a> — 包主页的URL。</li>
<li><a href="reference/manifest.html#the-repository-field"><code>repository</code></a> — 包源库的URL。</li>
<li><a href="reference/manifest.html#the-license-and-license-file-fields"><code>license</code></a> — 包协议。</li>
<li><a href="reference/manifest.html#the-license-and-license-file-fields"><code>license-file</code></a> — 许可证文本的路径。</li>
<li><a href="reference/manifest.html#the-keywords-field"><code>keywords</code></a> — 包的Keywords。</li>
<li><a href="reference/manifest.html#the-categories-field"><code>categories</code></a> — 包的分类。</li>
<li><a href="reference/manifest.html#the-workspace-field"><code>workspace</code></a> — 包的工作空间路径。</li>
<li><a href="reference/manifest.html#the-build-field"><code>build</code></a> — 包的构建脚本路径。</li>
<li><a href="reference/manifest.html#the-links-field"><code>links</code></a> — 包与之链接的本地库的名称。</li>
<li><a href="reference/manifest.html#the-exclude-and-include-fields"><code>exclude</code></a> — 发布时要排除的文件。</li>
<li><a href="reference/manifest.html#the-exclude-and-include-fields"><code>include</code></a> — 发布时要包含的文件。</li>
<li><a href="reference/manifest.html#the-publish-field"><code>publish</code></a> — 可用于防止发布包。</li>
<li><a href="reference/manifest.html#the-metadata-table"><code>metadata</code></a> — 外部工具的附加设置。</li>
<li><a href="reference/manifest.html#the-default-run-field"><code>default-run</code></a> — 由 <a href="reference/../commands/cargo-run.html"><code>cargo run</code></a> 运行的默认二进制。</li>
<li><a href="reference/cargo-targets.html#target-auto-discovery"><code>autobins</code></a> — 禁用二进制自动搜索。</li>
<li><a href="reference/cargo-targets.html#target-auto-discovery"><code>autoexamples</code></a> — 禁用例子自动搜索。</li>
<li><a href="reference/cargo-targets.html#target-auto-discovery"><code>autotests</code></a> — 禁用测试自动搜索。</li>
<li><a href="reference/cargo-targets.html#target-auto-discovery"><code>autobenches</code></a> — 禁用基准自动搜索。</li>
<li><a href="reference/resolver.html#resolver-versions"><code>resolver</code></a> — 设置要使用的依赖解析器。</li>
</ul>
</li>
<li>目标表: (设置参阅 <a href="reference/cargo-targets.html#configuring-a-target">configuration</a> )
<ul>
<li><a href="reference/cargo-targets.html#library"><code>[lib]</code></a> — 库目标设置。</li>
<li><a href="reference/cargo-targets.html#binaries"><code>[[bin]]</code></a> — 二进制目标设置。</li>
<li><a href="reference/cargo-targets.html#examples"><code>[[example]]</code></a> — 实例目标设置。</li>
<li><a href="reference/cargo-targets.html#tests"><code>[[test]]</code></a> — 测试目标设置。</li>
<li><a href="reference/cargo-targets.html#benchmarks"><code>[[bench]]</code></a> — 基准目标设置。</li>
</ul>
</li>
<li>依赖表:
<ul>
<li><a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a> — 包库依赖。</li>
<li><a href="reference/specifying-dependencies.html#development-dependencies"><code>[dev-dependencies]</code></a> — 实例、测试、基准依赖。</li>
<li><a href="reference/specifying-dependencies.html#build-dependencies"><code>[build-dependencies]</code></a> — 构建脚本依赖。</li>
<li><a href="reference/specifying-dependencies.html#platform-specific-dependencies"><code>[target]</code></a> — 特定平台依赖。</li>
</ul>
</li>
<li><a href="reference/manifest.html#the-badges-section"><code>[badges]</code></a> — 显示在注册中心的标志。</li>
<li><a href="reference/features.html"><code>[features]</code></a> — 条件编译特性。</li>
<li><a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code></a> — 覆盖依赖。</li>
<li><a href="reference/overriding-dependencies.html#the-replace-section"><code>[replace]</code></a> — 覆盖依赖 (弃用)。</li>
<li><a href="reference/profiles.html"><code>[profile]</code></a> — 编译器设置和优化。</li>
<li><a href="reference/workspaces.html"><code>[workspace]</code></a> — 工作空间定义。</li>
</ul>
<p><a id="package-metadata"></a></p>
<h3 id="package-部分"><a class="header" href="#package-部分"><code>[package]</code> 部分</a></h3>
<p>在 <code>Cargo.toml</code> 中的第一个部分就是 <code>[package]</code> 。</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot; # 包的名称
version = &quot;0.1.0&quot;    # 当前版本, 语义化版本。
authors = [&quot;Alice &lt;a@example.com&gt;&quot;, &quot;Bob &lt;b@example.com&gt;&quot;]
</code></pre>
<p>Cargo 仅需要的字段是 <a href="reference/manifest.html#the-name-field"><code>name</code></a> 和 <a href="reference/manifest.html#the-version-field"><code>version</code></a> 。
如果发布到注册中心，注册中心可能需要额外的字段。
关于发布到<a href="https://crates.io/">crates.io</a>的要求，请参见下面的注释和<a href="reference/publishing.html">发布章节</a>。</p>
<h4 id="name-字段"><a class="header" href="#name-字段"><code>name</code> 字段</a></h4>
<p>包的名称是一个用来引用包的标识符。
可被列为另一个包的依赖，并作为lib和bin目标推导的默认名称。</p>
<p>该名称只能使用 [字母数字] 字符或 <code>-</code> 或 <code>_</code> ，并且不能为空。</p>
<p>请注意，<a href="reference/../commands/cargo-new.html"><code>cargo new</code></a>和<a href="reference/../commands/cargo-init.html"><code>cargo init</code></a>对包名有一些额外的限制，比如强制要求为有效的Rust标识符，而不能是关键词。
<a href="https://crates.io/">crates.io</a>有更多的限制，比如说:</p>
<ul>
<li>仅允许ASCII字符。</li>
<li>不能使用保留名称。</li>
<li>不要使用特殊的Windows名称，如 &quot;nul&quot; 。</li>
<li>最长使用64个字符。</li>
</ul>
<h4 id="version-字段"><a class="header" href="#version-字段"><code>version</code> 字段</a></h4>
<p>Cargo 遵循 <a href="https://semver.org/">语义化版本</a> 的概念，遵循一些基本规则:</p>
<ul>
<li>在达到1.0.0之前，可以任意进行，但如果做了破坏性的改变，就要增加次要版本。在Rust中，破坏性修改包括向结构体添加字段或向枚举添加变体。</li>
<li>在1.0.0之后，只有在增加主版本的时候才可以进行破坏性的修改。不要破坏构建。</li>
<li>1.0.0之后，不要在补丁级版本中添加任何新的公共API(即没有新的 <code>pub</code> 接口)。如果添加任何新的 <code>pub</code> 结构、特征、字段、类型、函数、方法或其他东西，总是增加次要版本。</li>
<li>使用有三个数字部分的版本号，如1.0.0而不是1.0。</li>
</ul>
<p>请参阅 <a href="reference/resolver.html">Resolver</a> 章节，了解更多关于Cargo如何使用版本来解决依赖，以及设置自己版本的指南。
参见<a href="reference/semver.html">语义化兼容</a>一章，以了解更多关于什么是破坏性变化的细节。</p>
<p><a id="the-authors-field-optional"></a></p>
<h4 id="authors-字段"><a class="header" href="#authors-字段"><code>authors</code> 字段</a></h4>
<p>可选的 <code>authors</code> 字段，以数组形式列出包 &quot;作者&quot; 的人或组织。
确切的意思有多种解释--可以列出原始或主要的作者、当前的维护者或者包的所有者。
可以在每个作者条目末尾的斜方括号内包含可选的电子邮件。</p>
<pre><code class="language-toml">[package]
# ...
authors = [&quot;Graydon Hoare&quot;, &quot;Fnu Lnu &lt;no-reply@rust-lang.org&gt;&quot;]
</code></pre>
<p>这个字段仅在包元数据和 <code>build.rs</code> 中的 <code>CARGO_PKG_AUTHORS</code> 环境变量中出现。
它不显示在 <a href="https://crates.io/">crates.io</a> 用户界面中。</p>
<blockquote>
<p><strong>警告</strong>: 包配置清单一旦发布就不能改变，所以这个字段不能在包已发布版本中改变或删除。</p>
</blockquote>
<p><a id="the-edition-field-optional"></a></p>
<h4 id="edition-字段"><a class="header" href="#edition-字段"><code>edition</code> 字段</a></h4>
<p><code>edition</code>键是可选的键，它影响你的包是用哪个<a href="reference/../../edition-guide/index.html">Rust 版次</a>编译的。
在 <code>[package]</code> 中设置 <code>edition</code> 键会影响到包中的所有targets/crates，包括测试套件、基准、二进制文件、实例等。</p>
<pre><code class="language-toml">[package]
# ...
edition = '2021'
</code></pre>
<p>大多数配置清单的 <code>edition</code> 字段由 <a href="reference/../commands/cargo-new.html"><code>cargo new</code></a> 自动填充，具有最新的稳定版本。
默认 <code>cargo new</code> 创建的是2021年版次的配置清单。</p>
<p>如果 <code>Cargo.toml</code> 中没有 <code>edition</code>  字段，那么为了向后兼容，将假定为2015版。
请注意，凡是用 <a href="reference/../commands/cargo-new.html"><code>cargo new</code></a> 创建的配置清单不会使用这种历史版次，而会将 <code>edition</code> 指定为一个较新的值。</p>
<h4 id="rust-version-字段"><a class="header" href="#rust-version-字段"><code>rust-version</code> 字段</a></h4>
<p><code>rust-version</code> 字段是可选的键，它告知cargo包可以用哪个版本的Rust语言和编译器来编译。
如果当前选择的Rust编译器的版本比声明的版本早，cargo会退出，并告诉用户需要什么版本。</p>
<p>第一个支持这个字段的Cargo版本是随着Rust 1.56.0发布的。
在旧版本中，这个字段会被忽略，Cargo会显示一个警告。</p>
<pre><code class="language-toml">[package]
# ...
rust-version = &quot;1.56&quot;
</code></pre>
<p>Rust版本必须是由两或三个部分组成的基础版本号；它不能包括语义化操作符或预发布标识符。
编译器的预发布标识符，如-nightly，在检查Rust版本时将被忽略。
<code>rust-version</code> 必须等于或高于首次引入配置的 <code>edition</code> 的版本。</p>
<p>可以使用 <code>--ignore-rust-version</code> 选项忽略 <code>rust-version</code> 。</p>
<p>在 <code>[package]</code> 中设置 <code>rust-version</code> 键将影响包中的所有 target/crates ，包括测试套件、基准、二进制文件、实例等。</p>
<h4 id="description-字段"><a class="header" href="#description-字段"><code>description</code> 字段</a></h4>
<p>描述是关于该包的简介。<a href="https://crates.io/">crates.io</a>会在你的包中显示这个。这应是纯文本(不是Markdown)。</p>
<pre><code class="language-toml">[package]
# ...
description = &quot;A short description of my package&quot;
</code></pre>
<blockquote>
<p><strong>注意</strong>: <a href="https://crates.io/">crates.io</a> 需要 <code>description</code> 设置。</p>
</blockquote>
<p><a id="the-documentation-field-optional"></a></p>
<h4 id="documentation-字段"><a class="header" href="#documentation-字段"><code>documentation</code> 字段</a></h4>
<p><code>documentation</code> 字段指定托管了crate文档网站的URL。
如果配置清单文件中没有指定URL，则 <a href="https://crates.io/">crates.io</a> 会自动将你的crate链接到相应的 <a href="https://docs.rs/">docs.rs</a> 页面。</p>
<pre><code class="language-toml">[package]
# ...
documentation = &quot;https://docs.rs/bitflags&quot;
</code></pre>
<h4 id="readme-字段"><a class="header" href="#readme-字段"><code>readme</code> 字段</a></h4>
<p><code>readme</code> 字段应该是包根位置的文件的路径(相对于这个<code>Cargo.toml</code>)，其中包含关于包的常规信息。
当你发布时，这个文件将被转移到注册中心。
<a href="https://crates.io/">crates.io</a> 将把它解释为Markdown并在crate的页面上呈现。</p>
<pre><code class="language-toml">[package]
# ...
readme = &quot;README.md&quot;
</code></pre>
<p>如果没有指定这个字段的值，并且在包的根位置存在名为 <code>README.md</code> 、 <code>README.txt</code> 或 <code>README</code> 的文件，那么将使用该文件名称。
你可以通过设置这个字段为 <code>false</code> 来阻止这种行为。如果该字段被设置为 <code>true</code> ，将假定默认值为 <code>README.md</code> 。</p>
<h4 id="homepage-字段"><a class="header" href="#homepage-字段"><code>homepage</code> 字段</a></h4>
<p><code>homepage</code> 字段应该是网站的URL，它是包的主页。</p>
<pre><code class="language-toml">[package]
# ...
homepage = &quot;https://serde.rs/&quot;
</code></pre>
<h4 id="repository-字段"><a class="header" href="#repository-字段"><code>repository</code> 字段</a></h4>
<p><code>repository</code> 字段应该是包的源存储库的URL。</p>
<pre><code class="language-toml">[package]
# ...
repository = &quot;https://github.com/rust-lang/cargo/&quot;
</code></pre>
<h4 id="license-和-license-file-字段"><a class="header" href="#license-和-license-file-字段"><code>license</code> 和 <code>license-file</code> 字段</a></h4>
<p><code>license</code> 字段包含软件许可证的名称，包根据该许可证发布的。
<code>license-file</code> 字段包含许可证文本的文件路径(相对于这个<code>Cargo.toml</code>)。</p>
<p><a href="https://crates.io/">crates.io</a>将 <code>license</code> 字段解释为 <a href="https://spdx.org/spdx-specification-21-web-version#h.jxpfx0ykyb60">SPDX 2.1 license expression</a> 。
该名称必须是 <a href="https://github.com/spdx/license-list-data/tree/v3.11">SPDX license list 3.11</a> 中的一个已知许可证。
目前不支持括号。更多信息请参见 <a href="https://spdx.org/license-list">SPDX网站</a> 。</p>
<p>SPDX许可证表达式支持AND和OR运算符，以组合多个许可证。<sup class="footnote-reference"><a href="#slash">1</a></sup></p>
<pre><code class="language-toml">[package]
# ...
license = &quot;MIT OR Apache-2.0&quot;
</code></pre>
<p>使用 <code>OR</code> 表示用户可以选择任何一项许可证。使用 <code>AND</code> 表示用户必须同时遵守两个许可证。
使用 <code>WITH</code> 操作符表示有特殊例外的许可证。一些例子:</p>
<ul>
<li><code>MIT OR Apache-2.0</code></li>
<li><code>LGPL-2.1-only AND MIT AND BSD-2-Clause</code></li>
<li><code>GPL-2.0-or-later WITH Bison-exception-2.2</code></li>
</ul>
<p>如果包使用非标准的许可证，那么可以指定 <code>license-file</code> 字段来代替 <code>license</code> 字段。</p>
<pre><code class="language-toml">[package]
# ...
license-file = &quot;LICENSE.txt&quot;
</code></pre>
<blockquote>
<p><strong>注意</strong>: <a href="https://crates.io/">crates.io</a> 要求设置 <code>license</code> 或 <code>license-file</code> 。</p>
</blockquote>
<div class="footnote-definition" id="slash"><sup class="footnote-definition-label">1</sup>
<p>以前，多个许可证可以用 <code>/</code> 来分隔，但这种用法已经过时了。</p>
</div>
<h4 id="keywords-字段"><a class="header" href="#keywords-字段"><code>keywords</code> 字段</a></h4>
<p><code>keywords</code> 字段是描述这个包的字符串数组。
当在注册中心搜索该包时，提供帮助，你可以选择任意可以帮助别人找到这个crate的词。</p>
<pre><code class="language-toml">[package]
# ...
keywords = [&quot;gamedev&quot;, &quot;graphics&quot;]
</code></pre>
<blockquote>
<p><strong>注意</strong>: <a href="https://crates.io/">crates.io</a>最多可以有5个关键词。每个关键词必须是ASCII文本，以字母开头，只包含字母、数字、 <code>_</code> 或 <code>-</code> ，最多20个字符。</p>
</blockquote>
<h4 id="categories-字段"><a class="header" href="#categories-字段"><code>categories</code> 字段</a></h4>
<p><code>categories</code> 字段是一个字符串数组，表示该包所属的类别。</p>
<pre><code class="language-toml">categories = [&quot;command-line-utilities&quot;, &quot;development-tools::cargo-plugins&quot;]
</code></pre>
<blockquote>
<p><strong>注意</strong>: <a href="https://crates.io/">crates.io</a>最多可以有5个类别。每个类别应与 <a href="https://crates.io/category_slugs">https://crates.io/category_slugs</a> 中的一个字符串完全匹配。</p>
</blockquote>
<p><a id="the-workspace--field-optional"></a></p>
<h4 id="workspace-字段"><a class="header" href="#workspace-字段"><code>workspace</code> 字段</a></h4>
<p><code>workspace</code> 字段用来配置包的工作空间。
如果没有指定，这将被推断为文件系统中第一个带有 <code>[workspace]</code> 的Cargo.toml。
如果成员不在工作空间根目录下，设置这个很有用。</p>
<pre><code class="language-toml">[package]
# ...
workspace = &quot;path/to/workspace/root&quot;
</code></pre>
<p>如果配置清单中已经定义了 <code>[workspace]</code> 表，则不能指定此字段。
也就是说，crate 不能既是一个工作空间的根 crate (包含 <code>[workspace]</code>)，又是另一个工作空间的成员 crate (包含 <code>package.workspace</code> )。</p>
<p>了解更多信息，请参见<a href="reference/workspaces.html">工作空间章节</a>。</p>
<p><a id="package-build"></a>
<a id="the-build-field-optional"></a></p>
<h4 id="build-字段"><a class="header" href="#build-字段"><code>build</code> 字段</a></h4>
<p><code>build</code> 字段指定包根位置的一个文件，该文件是用于构建本地代码的[构建脚本]。
更多信息可以在 <a href="reference/build-scripts.html">构建脚本指南</a> 中找到。</p>
<pre><code class="language-toml">[package]
# ...
build = &quot;build.rs&quot;
</code></pre>
<p>默认是 <code>&quot;build.rs&quot;</code> ，从包根目录下的 <code>build.rs</code> 文件中加载脚本。
使用 <code>build = &quot;custom_build_name.rs&quot;</code> 来指定不同文件的路径，或者使用 <code>build = false</code> 来禁止自动检测构建脚本。</p>
<p><a id="the-links-field-optional"></a></p>
<h4 id="links-字段"><a class="header" href="#links-字段"><code>links</code> 字段</a></h4>
<p><code>links</code> 字段指定了被链接的本地库的名称。
更多信息可以在构建脚本指南的 [<code>links</code>][link] 部分找到。</p>
<p>例如，可以指定链接名为 &quot;git2&quot; 的本地库的crate(例如Linux上的 <code>libgit2.a</code> )。</p>
<pre><code class="language-toml">[package]
# ...
links = &quot;git2&quot;
</code></pre>
<p><a id="the-exclude-and-include-fields-optional"></a></p>
<h4 id="exclude-和-include-字段"><a class="header" href="#exclude-和-include-字段"><code>exclude</code> 和 <code>include</code> 字段</a></h4>
<p><code>exclude</code> 和 <code>include</code> 字段可以用来明确指定哪些文件在进行打包<a href="reference/publishing.html">发布</a>项目时被包含，以及某些特征的变更跟踪(如下所述)。
在 <code>exclude</code> 字段中指定的模式确定了一组不包括的文件，而 <code>include</code> 中的模式指定了明确包括的文件。
你可以运行 <a href="reference/../commands/cargo-package.html"><code>cargo package --list</code></a> 来验证哪些文件将被包含在包中。</p>
<pre><code class="language-toml">[package]
# ...
exclude = [&quot;/ci&quot;, &quot;images/&quot;, &quot;.*&quot;]
</code></pre>
<pre><code class="language-toml">[package]
# ...
include = [&quot;/src&quot;, &quot;COPYRIGHT&quot;, &quot;/examples&quot;, &quot;!/examples/big_example&quot;]
</code></pre>
<p>如果这两个字段都没有被指定，默认情况是包括包根位置的所有文件，除了下面列出的例外情况。</p>
<p>如果未指定 <code>include</code> ，则以下文件将被排除:</p>
<ul>
<li>如果包不在git仓库中，所有以点开头的&quot;隐藏&quot;文件都会被跳过。</li>
<li>如果包在git仓库中，任何被仓库和全局git配置的<a href="https://git-scm.com/docs/gitignore">gitignore</a>规则所忽略的文件都将被跳过。</li>
</ul>
<p>不管是指定 <code>exclude</code> 或 <code>include</code> ，以下文件总是被排除在外:</p>
<ul>
<li>任何子包将被跳过(任何包含<code>Cargo.toml</code>文件的子目录)。</li>
<li>在包根位置的名为 <code>target</code> 的目录将被跳过。</li>
</ul>
<p>以下文件总是被包含:</p>
<ul>
<li>包本身的 <code>Cargo.toml</code> 文件总是被包括在内，它不需要被列在 <code>include</code> 中。</li>
<li>如果包包含二进制或示例目标，则会自动包含最小化的 <code>Cargo.lock</code> ，更多信息请参见 <a href="reference/../commands/cargo-package.html"><code>cargo package</code></a> 。</li>
<li>如果指定了<a href="reference/manifest.html#the-license-and-license-file-fields"><code>license-file</code></a>，它总是被包括在内。</li>
</ul>
<p>这些选项是相互排斥的；设置 <code>include</code> 将覆盖 <code>exclude</code> 。
如果你需要对一组 <code>include</code> 文件进行排除，使用下面描述的 <code>!</code> 操作符。</p>
<p>这些模式应该是<a href="https://git-scm.com/docs/gitignore">gitignore</a>格式的模式。简而言之:</p>
<ul>
<li><code>foo</code> 匹配包中任何名字为 <code>foo</code> 的文件或目录。这等同于模式 <code>**/foo</code> 。</li>
<li><code>/foo</code> 匹配任何文件或目录，名称为<code>foo</code>，只在包的根位置。</li>
<li><code>foo/</code> 匹配包中任何名字为<code>foo</code>的 <em>目录</em> 。</li>
<li>支持常见的通配符模式，如<code>*</code>，<code>?</code>，和<code>[]</code>。
<ul>
<li><code>*</code> 匹配除 <code>/</code> 以外的零个或多个字符。例如， <code>*.html</code> 匹配包中任何带有 <code>.html</code> 扩展名的文件或目录。</li>
<li><code>?</code> 匹配除 <code>/</code> 以外的任何字符。例如，<code>foo?</code> 匹配 <code>food</code> ， 但不匹配 <code>foo</code> 。</li>
<li><code>[]</code> 允许匹配一定范围的字符。例如， <code>[ab]</code> 匹配 <code>a</code> 或 <code>b</code>。 <code>[a-z]</code> 匹配字母 a 到 z。</li>
</ul>
</li>
<li><code>**/</code> 前缀可以在任何目录下匹配。例如， <code>**/foo/bar</code> 匹配直接位于 <code>foo</code> 目录下的任何文件或目录 <code>bar</code> 。</li>
<li><code>/**</code> 后缀匹配里面的所有文件。例如，<code>foo/**</code> 匹配目录 <code>foo</code> 内的所有文件，包括 <code>foo</code> 下面子目录中的所有文件。</li>
<li><code>/**/</code>  匹配零个或多个目录。例如， <code>a/**/b</code> 匹配 <code>a/b</code> ， <code>a/x/b</code> ， <code>a/x/y/b</code> ，以此类推。</li>
<li><code>!</code> 前缀否定了一个模式。例如， <code>src/*.rs</code> 和 <code>!foo.rs</code> 的模式将匹配 <code>src</code> 目录下所有扩展名为 <code>.rs</code> 的文件，但不包括任何名为 <code>foo.rs</code> 的文件。</li>
</ul>
<p>在某些情况下，include/exclude 列表被用于变化跟踪。
对于用 <code>rustdoc</code> 构建的目标，它被用来确定追踪的文件列表，以确定目标是否应该被重新构建。
如果包有一个没有发出任何 <code>rerun-if-*</code> 指令的 <a href="reference/build-scripts.html">build script</a> ，那么include/exclude列表就被用来跟踪如果这些文件有变化，build script是否应该被重新运行。</p>
<p><a id="the-publish--field-optional"></a></p>
<h4 id="publish-字段"><a class="header" href="#publish-字段"><code>publish</code> 字段</a></h4>
<p><code>publish</code> 字段可以用来防止一个包被错误地发布到包注册中心(如<em>crates.io</em>)，比如，在公司里保持包为私密的。</p>
<pre><code class="language-toml">[package]
# ...
publish = false
</code></pre>
<p>该值也可以是一个字符串数组，这些字符串是允许发布的注册中心的名称。</p>
<pre><code class="language-toml">[package]
# ...
publish = [&quot;some-registry-name&quot;]
</code></pre>
<p>如果发布数组包含单个注册中心，当未指定 <code>--registry</code> 标志时， <code>cargo publish</code> 命令将使用它。</p>
<p><a id="the-metadata-table-optional"></a></p>
<h4 id="metadata-表"><a class="header" href="#metadata-表"><code>metadata</code> 表</a></h4>
<p>默认情况下，Cargo会对 <code>Cargo.toml</code> 中未使用的键发出警告，以帮助检测错别字之类的。
然而， <code>package.metadata</code> 表是完全被Cargo忽略，不会被警告。
这一部分可以用于那些想在 <code>Cargo.toml</code> 中存储包配置的工具。比如说:</p>
<pre><code class="language-toml">[package]
name = &quot;...&quot;
# ...

# 例如，生成Android APK时使用的元数据。
[package.metadata.android]
package-name = &quot;my-awesome-android-app&quot;
assets = &quot;path/to/static&quot;
</code></pre>
<p>在工作空间层级也有类似的表，位于<a href="reference/workspaces.html#the-metadata-table"><code>workspace.metadata</code></a>。
虽然cargo没有指定这两个表的内容格式，但建议外部工具以一致的方式使用它们，例如，
如果<code>package.metadata</code>中缺少数据，就引用<code>workspace.metadata</code> 中的数据，如果这对相关工具来说合理。</p>
<h4 id="default-run-字段"><a class="header" href="#default-run-字段"><code>default-run</code> 字段</a></h4>
<p>配置清单中 <code>[package]</code> 部分的 <code>default-run</code> 字段可用于指定由 <a href="reference/../commands/cargo-run.html"><code>cargo run</code></a> 选择的默认二进制文件。
例如，当同时存在 <code>src/bin/a.rs</code> 和 <code>src/bin/b.rs</code> 时。</p>
<pre><code class="language-toml">[package]
default-run = &quot;a&quot;
</code></pre>
<h3 id="badges-部分"><a class="header" href="#badges-部分"><code>[badges]</code> 部分</a></h3>
<p><code>[badges]</code> 部分用于指定状态标志，当包发布时可以在注册中心网站上显示。</p>
<blockquote>
<p>注意: <a href="https://crates.io/">crates.io</a> 以前在其网站上的crate旁边显示标志，但该功能已被删除。
包应在其README文件中放置标志，该文件将在<a href="https://crates.io/">crates.io</a>上显示(参阅<a href="reference/manifest.html#the-readme-field"><code>readme</code>字段</a>)。</p>
</blockquote>
<pre><code class="language-toml">[badges]
# `maintenance` 表表示crate的维护状态。
# 这可能被一个注册中心使用，但目前crates.io没有使用。
# 参阅 https://github.com/rust-lang/crates.io/issues/2437 和 https://github.com/rust-lang/crates.io/issues/2438。
#
# `status` 字段是必填字段。可用的选项有:
# - `actively-developed`: 新功能正在添加，bug正在修复。
# - `passively-maintained`: 目前还没有新功能的计划，但维护者打算对提交的问题作出回应。
# - `as-is`:  这个板块的功能是完整的，维护者不打算继续工作或提供支持，但它可以满足它所设计的目的。
# - `experimental`: 作者希望与社区分享，但并不打算满足任何人的特定使用情况。
# - `looking-for-maintainer`: 目前的维护者想把这个crate转让给其他人。
# - `deprecated`: 维护者不建议使用这个crate (crate的描述可以说明原因，可能有更好的解决方案，或者crate可能存在作者不想修复的问题)。
# - `none`: 在crates.io上未显示标志，因为维护者没有选择说明他们的意图，潜在的crate用户需要自己去查寻。
maintenance = { status = &quot;...&quot; }
</code></pre>
<h3 id="依赖部分"><a class="header" href="#依赖部分">依赖部分</a></h3>
<p>参阅 <a href="reference/specifying-dependencies.html">特定依赖页</a> 在 <code>[dependencies]</code>, <code>[dev-dependencies]</code>, <code>[build-dependencies]</code>, 和 target-specific <code>[target.*.dependencies]</code> 部分.</p>
<h3 id="profile-部分"><a class="header" href="#profile-部分"><code>[profile.*]</code> 部分</a></h3>
<p><code>[profile]</code> 表提供了一种定制编译器设置的方法，如优化和调试设置。
更多细节请参见<a href="reference/profiles.html">配置文件章节</a>。</p>
<script>
(function() {
    var fragments = {
        "#the-project-layout": "../guide/project-layout.html",
        "#examples": "cargo-targets.html#examples",
        "#tests": "cargo-targets.html#tests",
        "#integration-tests": "cargo-targets.html#integration-tests",
        "#configuring-a-target": "cargo-targets.html#configuring-a-target",
        "#target-auto-discovery": "cargo-targets.html#target-auto-discovery",
        "#the-required-features-field-optional": "cargo-targets.html#the-required-features-field",
        "#building-dynamic-or-static-libraries": "cargo-targets.html#the-crate-type-field",
        "#the-workspace-section": "workspaces.html#the-workspace-section",
        "#virtual-workspace": "workspaces.html",
        "#package-selection": "workspaces.html#package-selection",
        "#the-features-section": "features.html#the-features-section",
        "#rules": "features.html",
        "#usage-in-end-products": "features.html",
        "#usage-in-packages": "features.html",
        "#the-patch-section": "overriding-dependencies.html#the-patch-section",
        "#using-patch-with-multiple-versions": "overriding-dependencies.html#using-patch-with-multiple-versions",
        "#the-replace-section": "overriding-dependencies.html#the-replace-section",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-构建目标"><a class="header" href="#cargo-构建目标">Cargo 构建目标</a></h2>
<p>Cargo 包由 <em>构建目标</em> 组成，构建目标对应着可以编译成 crate 的源文件。
包中可以包含 <a href="reference/cargo-targets.html#library">library</a>, <a href="reference/cargo-targets.html#binaries">binary</a>,
<a href="reference/cargo-targets.html#examples">example</a>, <a href="reference/cargo-targets.html#tests">test</a> 和 <a href="reference/cargo-targets.html#benchmarks">benchmark</a> 的构建目标。
构建目标列表可以在 <code>Cargo.toml</code> 目录清单中配置，但总是由源文件的 <a href="reference/../guide/project-layout.html">目录结构</a>
<a href="reference/cargo-targets.html#target-auto-discovery">inferred automatically</a></p>
<p>关于构建目标的配置，查看下面的 <a href="reference/cargo-targets.html#configuring-a-target">Configuring a target</a>。</p>
<h3 id="类库"><a class="header" href="#类库">类库</a></h3>
<p>类库的构建目标定义了 &quot;类库&quot; 的概念，即可以被其他类库和可执行程序使用和链接的库。
默认文件名会是 <code>src/lib.rs</code> ，类库的名词默认为包的名称。
包可以只有一个类库。你可以在 <code>Cargo.toml</code> 的 <code>[lib]</code> 标签下 [自定义] 类库的设置。</p>
<pre><code class="language-toml"># 在 Cargo.toml 自定义类库设置的例子。
[lib]
crate-type = [&quot;cdylib&quot;]
bench = false
</code></pre>
<h3 id="二进制构建目标"><a class="header" href="#二进制构建目标">二进制构建目标</a></h3>
<p>二进制构建目标为编译后可以运行的可执行程序。
默认的二进制文件名为 <code>src/main.rs</code> ，它默认是包的名称。
额外的二进制文件会放在 <a href="reference/../guide/project-layout.html"><code>src/bin/</code> 目录</a>。
你可以在 <code>Cargo.toml</code> 的 <code>[[bin]]</code> 标签下为每个二进制文件的 [自定义] 设置。</p>
<p>二进制文件可以使用包的类库提供的公共 API。
它们通过 <code>Cargo.toml</code> 中定义的 <a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a> 链接起来。</p>
<p>你可以使用带 <code>--bin &lt;bin-名称&gt;</code> 参数的 <a href="reference/../commands/cargo-run.html"><code>cargo run</code></a> 命令来运行单个二进制文件。
可以使用 <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 将可以执行文件赋值到通用目录。</p>
<pre><code class="language-toml"># 在 Cargo.toml 自定义二进制文件设置的例子。
[[bin]]
name = &quot;cool-tool&quot;
test = false
bench = false

[[bin]]
name = &quot;frobnicator&quot;
required-features = [&quot;frobnicate&quot;]
</code></pre>
<h3 id="例子"><a class="header" href="#例子">例子</a></h3>
<p><a href="reference/../guide/project-layout.html"><code>examples</code> 目录</a> 下的文件便是使用类库功能的例子。
编译后，文件会生成在 <a href="reference/../guide/build-cache.html"><code>target/debug/examples</code> 目录</a>。</p>
<p>例子可以使用包中类库的公共 API 。它们通过 <code>Cargo.toml</code> 中定义的 <a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a> 和
<a href="reference/specifying-dependencies.html#development-dependencies"><code>[dev-dependencies]</code></a> 链接起来。</p>
<p>例子默认是二进制可执行文件(带有 <code>main()</code> 函数)。
你可以指定 <a href="reference/cargo-targets.html#the-crate-type-field"><code>crate-type</code> 字段</a> 另一个例子编译为类库:</p>
<pre><code class="language-toml">[[example]]
name = &quot;foo&quot;
crate-type = [&quot;staticlib&quot;]
</code></pre>
<p>你可以使用带 <code>--example &lt;例子名&gt;</code> 参数的 <a href="reference/../commands/cargo-run.html"><code>cargo run</code></a> 命令来运行单个例子。
使用带 <code>--example &lt;例子名&gt;</code> 参数的 <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 命令来将二进制可执行文件复制到通用目录。
使用 <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 命令编译例子可以防止位衰减。
如果你想运行 <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 的例子中存在 <code>#[test]</code> 函数，你需要将 <a href="reference/cargo-targets.html#the-test-field">the <code>test</code> field</a> 为 <code>true</code> 。</p>
<h3 id="测试-1"><a class="header" href="#测试-1">测试</a></h3>
<p>Cargo 项目中有两种测试的方式:</p>
<ul>
<li><em>单元测试</em> 为在类库或二进制(或任何启用了 <a href="reference/cargo-targets.html#the-test-field">the <code>test</code> field</a> 的构建目标)中
使用 <a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code> 属性</a> 标记的函数，这种测试可以访问构建目标中定义的私有 API 。</li>
<li><em>集成测试</em> 为单独的与项目类库链接的二进制可执行文件。
它也包含了 <code>#[test]</code> 函数并且仅能访问 <em>公有</em> API 。</li>
</ul>
<p>使用 <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 命令运行测试。默认情况下，Cargo 和 <code>rustc</code> 使用 <a href="reference/../../rustc/tests/index.html">libtest harness</a> ，
它负责收集和并行执行带有 <a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code> 属性</a> 标记的函数，并报告所有测试的成功或失败情况。
如果你想使用不同的使用或测试策略可以查看 <a href="reference/cargo-targets.html#the-harness-field">the <code>harness</code> field</a> 。</p>
<blockquote>
<p><strong>注意</strong>: Cargo 有另一种特殊的测试方式:
<a href="reference/../../rustdoc/documentation-tests.html">documentation tests</a>。
它们通过 <code>rustdoc</code> 处理并且使用略有不同的执行模型。
你可以在 <a href="reference/../commands/cargo-test.html#documentation-tests"><code>cargo test</code></a> 查看更多信息。</p>
</blockquote>
<h4 id="集成测试"><a class="header" href="#集成测试">集成测试</a></h4>
<p><a href="reference/../guide/project-layout.html"><code>tests</code> 目录</a> 目录下的文件便是集成测试。
当你运行 <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 时，Cargo 会将该目录下的每个文件编译为单独的 crate 并执行。</p>
<p>集成测试可以使用包中类库的公有 API 。
它们也通过 <code>Cargo.toml</code> 中定义的 <a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a> 和
<a href="reference/specifying-dependencies.html#development-dependencies"><code>[dev-dependencies]</code></a> 链接起来。</p>
<p>如果你想在多个集成测试中复用代码，你可以将代码放在一个单独的模块中，
比如 <code>tests/common/mod.rs</code> 并在测试中使用 <code>mod common;</code> 导入这个模块。</p>
<p>每个单独二进制可执行文件产生一个集成测试结果，<a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 命令会串行执行集成测试。
在某些情况下可能效率较低，比如编译耗时较长或运行时没有充分利用CPU多个核心。
如果你需要进行大量集成测试，推荐创建单个集成测试，并将测试分割成多个模块。
libtest harness 会自动寻找和并行执行所有 <code>#[test]</code> 标记的函数。
你可以将模块名传递给 <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 来将测试的范围限定在模块内。</p>
<p>二进制构建目标的集成测试是自动构建的。
这样集成测试可以检验二进制文件执行的行为。
集成测试在构建时会设置 <code>CARGO_BIN_EXE_&lt;name&gt;</code> <a href="reference/environment-variables.html#environment-variables-cargo-sets-for-crates">environment variable</a> ，这样它可以使用 <a href="reference/../../std/macro.env.html"><code>env</code> macro</a> 来确定可执行文件的位置。</p>
<h3 id="性能测试"><a class="header" href="#性能测试">性能测试</a></h3>
<p>使用 <a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a> 命令来测试代码的性能。它与 <a href="reference/cargo-targets.html#tests">tests</a> 遵循相同的结构，
需要性能测试的函数要用 <code>#[bench]</code> 标记。
以下几点与测试相似:</p>
<ul>
<li>性能测试的文件放置在 <a href="reference/../guide/project-layout.html"><code>benches</code> 目录</a> 目录下。</li>
<li>类库和二进制文件中定义的性能测试可以访问构建目标中定义的 <em>私有</em> API。
<code>benches</code> 目录下的性能测试仅能访问 <em>公有</em> API 。</li>
<li><a href="reference/cargo-targets.html#the-bench-field">The <code>bench</code> field</a> 可以用来定义默认对哪个构建目标进行性能测试。</li>
<li><a href="reference/cargo-targets.html#the-harness-field">The <code>harness</code> field</a> 可以用来禁用内置的 harness 。</li>
</ul>
<blockquote>
<p><strong>注意</strong>: <a href="reference/../../unstable-book/library-features/test.html"><code>#[bench]</code>
attribute</a> 目前还不稳定并且仅在 <a href="reference/../../book/appendix-07-nightly-rust.html">nightly channel</a> 中提供。
<a href="https://crates.io/keywords/benchmark">crates.io</a> 提供的一些包也许有助于在 stable channel 中运行性能测试，
比如 <a href="https://crates.io/crates/criterion">Criterion</a>。</p>
</blockquote>
<h3 id="配置构建目标"><a class="header" href="#配置构建目标">配置构建目标</a></h3>
<p>对于指定构建目标应该如何构建，<code>Cargo.toml</code> 中所有的 <code>[lib]</code>, <code>[[bin]]</code>,
<code>[[example]]</code>, <code>[[test]]</code> 和 <code>[[bench]]</code> 标记都支持相似的配置。
比如 <code>[[bin]]</code> 这种双层括号标记代表 <a href="https://toml.io/en/v1.0.0-rc.3#array-of-tables">array-of-table of TOML</a>，
意味着你可以在 crate 添加多个 <code>[[bin]]</code> 来生成多个可执行文件。
比如 <code>[lib]</code> 代表普通 TOML 列表，意味着你仅可以制定一个类库。</p>
<p>下面是 TOML 中构建目标设置的概览，针对每个字段都有详细介绍。</p>
<pre><code class="language-toml">[lib]
name = &quot;foo&quot;           # 构建目标的名称
path = &quot;src/lib.rs&quot;    # 构建目标的源文件相对路径
test = true            # 是否默认进行测试
doctest = true         # 文档示例是否默认进行测试
bench = true           # 是否默认进行性能测试
doc = true             # 是否默认带有文档
plugin = false         # 是否用作编译器插件(已弃用)
proc-macro = false     # proc-macro 类库要设置为 `true`
harness = true         # 是否使用 libtest harness
edition = &quot;2015&quot;       # 构建目标的版本
crate-type = [&quot;lib&quot;]   # 要生成的 crate 类型
required-features = [] # 构建此目标需要使用的特性 (类库不适用)
</code></pre>
<h3 id="name-字段-1"><a class="header" href="#name-字段-1"><code>name</code> 字段</a></h3>
<p><code>name</code> 字段指定构建目标的名称，它对应着自动生成的 artifact 的文件名。
对类库来说，这个字段是它的 crate 名称，其他依赖会使用这个名称来引用它。</p>
<p>对于 <code>[lib]</code> 和默认的二进制程序(<code>src/main.rs</code>)来说，这个字段默认就是包的名称，
其中的破折号会被替换成下划线。对于其他 <a href="reference/cargo-targets.html#target-auto-discovery">auto discovered</a> 构建目标，
它默认是目录或文件的名称。</p>
<p>这个字段对所有构建目标是必填的，除了 <code>[lib]</code> 。</p>
<h4 id="path-字段"><a class="header" href="#path-字段"><code>path</code> 字段</a></h4>
<p><code>path</code> 字段指定 crate 的源代码相对于 <code>Cargo.toml</code> 的相对路径。</p>
<p>若此字段未指定，则默认会使用 <a href="reference/cargo-targets.html#target-auto-discovery">inferred path</a> 基于构建目标的名称自动填充。</p>
<h4 id="test-字段"><a class="header" href="#test-字段"><code>test</code> 字段</a></h4>
<p><code>test</code> 字段指明构建目标是否默认使用 <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 命令进行测试。
对类库、可执行程序和测试来说，默认为 <code>true</code> 。</p>
<blockquote>
<p><strong>注意</strong>: 默认会使用 <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 构建例子来保证它们可以通过编译，
但是默认情况下，它们没有 <em>测试</em> 过运行时是否符合预期。
为例子设置 <code>test = true</code> 也会将它构建为测试并且运行例子中所有带 <a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code></a> 标记的方法。</p>
</blockquote>
<h4 id="doctest-字段"><a class="header" href="#doctest-字段"><code>doctest</code> 字段</a></h4>
<p><code>doctest</code> 字段指明 [文档例子(documentation examples)] 是否默认使用 <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 测试。
这个字段只与类库有关，它对其他部分的配置没有任何作用。
对类库来说，此字段默认为 <code>true</code> 。</p>
<h4 id="bench-字段"><a class="header" href="#bench-字段"><code>bench</code> 字段</a></h4>
<p><code>bench</code> 字段指明构建目标是否默认使用 <a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a> 进行性能测试。
对类库、二进制程序和性能测试程序来说，此字段默认为 <code>true</code> 。</p>
<h4 id="doc-字段"><a class="header" href="#doc-字段"><code>doc</code> 字段</a></h4>
<p><code>doc</code> 字段指明构建目标是否包括在 <a href="reference/../commands/cargo-doc.html"><code>cargo doc</code></a> 默认生成的文档中。
对类库和二进制程序来说，此字段默认为 <code>true</code> 。</p>
<blockquote>
<p><strong>注意</strong>: 若二进制程序的名称与类库的名称相同，二进制程序则会被跳过。</p>
</blockquote>
<h4 id="plugin-字段"><a class="header" href="#plugin-字段"><code>plugin</code> 字段</a></h4>
<p>此字段用于 <code>rustc</code> 的插件，现在已被弃用。</p>
<h4 id="proc-macro-字段"><a class="header" href="#proc-macro-字段"><code>proc-macro</code> 字段</a></h4>
<p><code>proc-macro</code> 字段指明类库是 <a href="reference/%5Breference%5D%5Bproc-macro-reference%5D">procedural macro</a> 。
此字段仅适用于 <code>[lib]</code> 构建目标。</p>
<h4 id="harness-字段"><a class="header" href="#harness-字段"><code>harness</code> 字段</a></h4>
<p><code>harness</code> 字段指明 [<code>--test</code> 参数] 会传递给 <code>rustc</code> 令其自动包含 libtest 类库。
libtest 类库用来收集并运行标有 <a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code> 属性</a> 的测试或标有 <code>#[bench]</code> 属性的性能测试。
对所有构建目标来说，此字段默认为 <code>true</code> 。</p>
<p>如果此字段设置为 <code>false</code> ，则你需要负责定义 <code>main()</code> 函数来运行测试和性能测试。</p>
<p>无论 harness 字段是否启用，测试都会启用 <a href="reference/../../reference/conditional-compilation.html#test"><code>cfg(test)</code> 条件表达式</a> 字段。</p>
<h4 id="edition-字段-1"><a class="header" href="#edition-字段-1"><code>edition</code> 字段</a></h4>
<p><code>edition</code> 字段定义了构建目标将会使用的 <a href="reference/../../edition-guide/index.html">Rust edition</a> 。
若未指定，默认会使用 <code>[package]</code> 的 <a href="reference/manifest.html#the-edition-field"><code>edition</code> 字段</a> 。
此字段通常不需设置，它只用于类似大型包增量迁移到一个新版本这样的高级场景。</p>
<h4 id="crate-type-字段"><a class="header" href="#crate-type-字段"><code>crate-type</code> 字段</a></h4>
<p><code>crate-type</code> 字段定义了构建目标将生成的 <a href="reference/../../reference/linkage.html">crate types</a> 。
它是字符串数组，用于在一个构建目标中指定多个 crate 类型 。
此字段仅用于类库和例子。对于二进制程序，测试和性能测试，此字段总是为 &quot;bin&quot; crate 类型。
默认值为:</p>
<div class="table-wrapper"><table><thead><tr><th>构建目标</th><th>Crate Type</th></tr></thead><tbody>
<tr><td>普通类库</td><td><code>&quot;lib&quot;</code></td></tr>
<tr><td>Proc-macro 类库</td><td><code>&quot;proc-macro&quot;</code></td></tr>
<tr><td>例子</td><td><code>&quot;bin&quot;</code></td></tr>
</tbody></table>
</div>
<p>此字段可用的值有 <code>bin</code>, <code>lib</code>, <code>rlib</code>, <code>dylib</code>, <code>cdylib</code>, <code>staticlib</code> 和 <code>proc-macro</code> 。
关于各种 crate 类型的更多信息在 <a href="reference/../../reference/linkage.html">Rust Reference Manual</a> 。</p>
<h4 id="required-features-字段"><a class="header" href="#required-features-字段"><code>required-features</code> 字段</a></h4>
<p><code>required-features</code> 字段指定了构建目标完成构建所需要的 <a href="reference/features.html">features</a> 。
如果要求的特性都没有启用，则此构建目标将被跳过。
此字段仅与 <code>[[bin]]</code>, <code>[[bench]]</code>, <code>[[test]]</code> 和 <code>[[example]]</code> 有关。
此字段对 <code>[lib]</code> 没有影响。</p>
<pre><code class="language-toml">[features]
# ...
postgres = []
sqlite = []
tools = []

[[bin]]
name = &quot;my-pg-tool&quot;
required-features = [&quot;postgres&quot;, &quot;tools&quot;]
</code></pre>
<h3 id="构建目标自动探测"><a class="header" href="#构建目标自动探测">构建目标自动探测</a></h3>
<p>Cargo 默认会根据文件系统上的 <a href="reference/../guide/project-layout.html">文件结构</a> 推断构建目标。
可以在构建目标的配置表中添加不同于标准目录结构的额外构建目标，比如使用
<code>[lib]</code>, <code>[[bin]]</code>, <code>[[test]]</code>, <code>[[bench]]</code> 或 <code>[[example]]</code> 标记。</p>
<p>可以禁用目标探测，这样只有手动配置的构建目标会进行构建。
要禁用对应构建目标类型的自动探测，需在 <code>[package]</code> 部分将
<code>autobins</code>, <code>autoexamples</code>, <code>autotests</code> 或 <code>autobenches</code> 设置为 <code>false</code> 。</p>
<pre><code class="language-toml">[package]
# ...
autobins = false
autoexamples = false
autotests = false
autobenches = false
</code></pre>
<p>禁用自动探测应该仅用于一些特殊场景。
比如，如果你想在类库中给一个 <em>模块</em> 命名为 <code>bin</code> ，
这样是不行的，因为 Cargo 通常会将 <code>bin</code> 目录下的文件编译为可执行文件。
这个例子的文件结构如下:</p>
<pre><code class="language-text">├── Cargo.toml
└── src
    ├── lib.rs
    └── bin
        └── mod.rs
</code></pre>
<p>在 <code>Cargo.toml</code> 中声明 <code>autobins = false</code> 禁用自动探测来防止 Cargo 将 <code>src/bin/mod.rs</code> 推断为可执行文件:</p>
<pre><code class="language-toml">[package]
# …
autobins = false
</code></pre>
<blockquote>
<p><strong>注意</strong>: 对于 2015 版本的包，如果 <code>Cargo.toml</code> 中手动设置了构建目标，
则自动推断字段默认会设置为 <code>false</code> 。
自从 2018 版本，此字段默认设置为 <code>true</code> 。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="工作空间"><a class="header" href="#工作空间">工作空间</a></h2>
<p><em>工作空间</em>是一个或多个包的集合，称为<em>工作空间成员</em>，它们被一起管理。</p>
<p>工作空间的关键点是:</p>
<ul>
<li>普通命令可以在所有工作空间成员中运行，如<code>cargo check --workspace</code>。</li>
<li>所有软件包共享一个共同的<a href="reference/../guide/cargo-toml-vs-cargo-lock.html"><code>Cargo.lock</code></a>文件，该文件驻留在 <em>工作空间根</em> 下。</li>
<li>所有软件包共享一个共同的<a href="reference/../guide/build-cache.html">output directory</a>，该目录默认为 <em>工作空间根</em> 下的<code>target</code>。</li>
<li>共享包的元数据，比如<a href="reference/workspaces.html#%60package%60%E8%A1%A8"><code>workspace.package</code></a>。</li>
<li><code>Cargo.toml</code>中的<a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code></a>, <a href="reference/overriding-dependencies.html#the-replace-section"><code>[replace]</code></a>和<a href="reference/profiles.html"><code>[profile.*]</code></a>只在 <em>根</em> 清单中被识别，而在成员crates'清单中被忽略。</li>
</ul>
<p>在<code>Cargo.toml</code>中，<code>[workspace]</code>表格支持以下部分:</p>
<ul>
<li><a href="reference/workspaces.html#%60%5Bworkspace%5D%60%E9%83%A8%E5%88%86"><code>[workspace]</code></a> — 定义了一个工作空间。
<ul>
<li><a href="reference/resolver.html#resolver-versions"><code>resolver</code></a> — 设置要使用的依赖关系解析器。</li>
<li><a href="reference/workspaces.html#%60members%60%E5%92%8C%60exclude%60%E5%AD%97%E6%AE%B5"><code>members</code></a> — 包括在工作空间的包。</li>
<li><a href="reference/workspaces.html#%60members%60%E5%92%8C%60exclude%60%E5%AD%97%E6%AE%B5"><code>exclude</code></a> — 要从工作空间排除的包。</li>
<li><a href="reference/workspaces.html#%60default-members%60%E5%AD%97%E6%AE%B5"><code>default-members</code></a> — 当没有选择特定的包时，要对包进行操作。</li>
<li><a href="reference/workspaces.html#%60package%60%E8%A1%A8"><code>package</code></a> — 在包中继承的key。</li>
<li><a href="reference/workspaces.html#%60dependencies%60%E8%A1%A8"><code>dependencies</code></a> — 在包的依赖中继承的key。</li>
<li><a href="reference/workspaces.html#%60metadata%60%E8%A1%A8"><code>metadata</code></a> — 外部工具的额外设置。</li>
</ul>
</li>
<li><a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code></a> — 依赖覆盖。</li>
<li><a href="reference/overriding-dependencies.html#the-replace-section"><code>[replace]</code></a> — 依赖覆盖(已废弃)。</li>
<li><a href="reference/profiles.html"><code>[profile]</code></a> — 编译器设置和优化。</li>
</ul>
<h3 id="workspace部分"><a class="header" href="#workspace部分"><code>[workspace]</code>部分</a></h3>
<p>要创建一个工作空间，你需要在<code>Cargo.toml</code>中添加<code>[workspace]</code>:</p>
<pre><code class="language-toml">[workspace]
# ...
</code></pre>
<p>一个工作空间至少有一个成员，要么是一个根package，要么作为虚拟清单。</p>
<h4 id="根package"><a class="header" href="#根package">根package</a></h4>
<p>如果 <a href="reference/workspaces.html#%60%5Bworkspace%5D%60%E9%83%A8%E5%88%86"><code>[workspace]</code> </a>被添加到了一个已定义<code>[package]</code>的 <code>Cargo.toml</code>中，该package就是工作空间的<em>根package</em>。 <em>工作空间根</em> 是指工作空间的 <code>Cargo.toml</code> 所在的目录。</p>
<pre><code class="language-toml">[workspace]

[package]
name = &quot;hello_world&quot; # package的名字
version = &quot;0.1.0&quot;    # 当前版本, 遵循 semver
authors = [&quot;Alice &lt;a@example.com&gt;&quot;, &quot;Bob &lt;b@example.com&gt;&quot;]
</code></pre>
<p><a id="virtual-manifest"></a></p>
<h4 id="虚拟工作空间"><a class="header" href="#虚拟工作空间">虚拟工作空间</a></h4>
<p>或者可以创建一个 <code>Cargo.toml</code>文件，其中有一个<code>[workspace]</code>但没有<a href="reference/manifest.html#the-package-section"><code>[package]</code></a>。这被称为<em>虚拟清单</em>。当没有一个 &quot;主要 &quot;软件包时，这通常很有用，或者你想把所有的软件包放在不同的目录里。</p>
<pre><code class="language-toml"># [PROJECT_DIR]/Cargo.toml
[workspace]
members = [&quot;hello_world&quot;]
</code></pre>
<pre><code class="language-toml"># [PROJECT_DIR]/hello_world/Cargo.toml
[package]
name = &quot;hello_world&quot; # package名称
version = &quot;0.1.0&quot;    # 当前版本, 遵循 semver
authors = [&quot;Alice &lt;a@example.com&gt;&quot;, &quot;Bob &lt;b@example.com&gt;&quot;]
</code></pre>
<h3 id="members和exclude字段"><a class="header" href="#members和exclude字段"><code>members</code>和<code>exclude</code>字段</a></h3>
<p><code>members</code> 和 <code>exclude</code>字段定义哪些package是工作空间的成员:</p>
<pre><code class="language-toml">[workspace]
members = [&quot;member1&quot;, &quot;path/to/member2&quot;, &quot;crates/*&quot;]
exclude = [&quot;crates/foo&quot;, &quot;path/to/other&quot;]
</code></pre>
<p>驻留在工作空间目录中的所有<a href="reference/specifying-dependencies.html#specifying-path-dependencies"><code>path</code> dependencies</a>自动成为成员。其他成员可以用 <code>members</code>key列出。
它应该是一个包含<code>Cargo.toml</code>文件的目录的字符串数组。</p>
<p><code>members</code>列表也支持<a href="https://docs.rs/glob/0.3.0/glob/struct.Pattern.html">globs</a>来匹配多个路径，使用典型的文件名glob模式，如<code>*</code>和<code>?</code>。</p>
<p><code>exclude</code>key可以用来防止路径被包含在一个工作空间。可以用于如果某些路径依赖不希望出现在工作空间中，使用glob模式和你想删除一个目录中。</p>
<p>当在工作空间的一个子目录中，Cargo将自动搜索父目录中带<code>[workspace]</code>的 <code>Cargo.toml</code>文件，以确定使用哪个工作空间。定义的文件来决定使用哪个工作空间。
<a href="reference/manifest.html#the-workspace-field"><code>package.workspace</code></a>文件可在成员crates中使用清单key来指向工作空间的根，以覆盖这种自动搜索。当成员不在工作空间根目录的子目录内，手动设置就很有用。</p>
<h4 id="package-部分-1"><a class="header" href="#package-部分-1">Package 部分</a></h4>
<p>在工作空间中，与package有关的cargo命令，如<a href="reference/../commands/cargo-build.html"><code>cargo build</code></a>可以使用
<code>-p</code>/<code>-package</code>或<code>-workspace</code>命令行标志来决定对哪些
package来操作。如果这两个标志都没有被指定，Cargo将使用当前工作目录下的package。
如果当前的目录是一个<a href="reference/workspaces.html#virtual-workspace">虚拟工作空间</a>，它将用于所有成员(就像<code>--workspace</code>是在命令行上指定的)。
也请参见<a href="reference/workspaces.html#the-default-members-field"><code>default-members</code></a>。</p>
<h3 id="default-members字段"><a class="header" href="#default-members字段"><code>default-members</code>字段</a></h3>
<p>可选的<code>default-members</code>key可以被指定，以设置在工作空间根和package选择标志未被使用时操作的成员:</p>
<pre><code class="language-toml">[workspace]
members = [&quot;path/to/member1&quot;, &quot;path/to/member2&quot;, &quot;path/to/member3/*&quot;]
default-members = [&quot;path/to/member2&quot;, &quot;path/to/member3/foo&quot;]
</code></pre>
<p>当指定时，<code>default-members</code>必须扩展到<code>members</code>的一个子集。</p>
<h3 id="package表"><a class="header" href="#package表"><code>package</code>表</a></h3>
<p><code>workspace.package</code>表是你定义可以被工作空间成员继承的key的地方。这些key可以通过在成员包中定义<code>{key}.workspace = true</code>来继承。</p>
<p>支持的key</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><code>authors</code></td><td><code>categories</code></td></tr>
<tr><td><code>description</code></td><td><code>documentation</code></td></tr>
<tr><td><code>edition</code></td><td><code>exclude</code></td></tr>
<tr><td><code>homepage</code></td><td><code>include</code></td></tr>
<tr><td><code>keywords</code></td><td><code>license</code></td></tr>
<tr><td><code>license-file</code></td><td><code>publish</code></td></tr>
<tr><td><code>readme</code></td><td><code>repository</code></td></tr>
<tr><td><code>rust-version</code></td><td><code>version</code></td></tr>
</tbody></table>
</div>
<ul>
<li><code>license-file</code>和 <code>readme</code>是相对于工作空间根的。</li>
<li><code>include</code>和<code>exclude</code>是相对于你的package根的。</li>
</ul>
<p>例子:</p>
<pre><code class="language-toml"># [PROJECT_DIR]/Cargo.toml
[workspace]
members = [&quot;bar&quot;]

[workspace.package]
version = &quot;1.2.3&quot;
authors = [&quot;Nice Folks&quot;]
description = &quot;A short description of my package&quot;
documentation = &quot;https://example.com/bar&quot;
</code></pre>
<pre><code class="language-toml"># [PROJECT_DIR]/bar/Cargo.toml
[package]
name = &quot;bar&quot;
version.workspace = true
authors.workspace = true
description.workspace = true
documentation.workspace = true
</code></pre>
<h3 id="dependencies表"><a class="header" href="#dependencies表"><code>dependencies</code>表</a></h3>
<p><code>workspace.dependencies</code>是你定义工作空间成员所继承的依赖性的地方。</p>
<p>指定工作空间依赖与<a href="reference/specifying-dependencies.html">package依赖</a>类似，除了:</p>
<ul>
<li>此表中的依赖关系不能被声明为 <code>optional</code>。</li>
<li>在此表中声明的<a href="reference/features.html"><code>features</code></a>与来自<code>[dependencies]</code>的 <code>features</code> 是相加的。</li>
</ul>
<p>然后你可以<a href="reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace">把工作区的依赖性作为包的依赖性来继承</a></p>
<p>例子:</p>
<pre><code class="language-toml"># [PROJECT_DIR]/Cargo.toml
[workspace]
members = [&quot;bar&quot;]

[workspace.dependencies]
cc = &quot;1.0.73&quot;
rand = &quot;0.8.5&quot;
regex = { version = &quot;1.6.0&quot;, default-features = false, features = [&quot;std&quot;] }
</code></pre>
<pre><code class="language-toml"># [PROJECT_DIR]/bar/Cargo.toml
[package]
name = &quot;bar&quot;
version = &quot;0.2.0&quot;

[dependencies]
regex = { workspace = true, features = [&quot;unicode&quot;] }

[build-dependencies]
cc.workspace = true

[dev-dependencies]
rand.workspace = true
</code></pre>
<h3 id="metadata表"><a class="header" href="#metadata表"><code>metadata</code>表</a></h3>
<p><code>workspace.metadata</code>表会被Cargo忽略，不会被警告。这一部分可以用于那些想在<code>Cargo.toml</code>中存储工作空间配置的工具。比如说:</p>
<pre><code class="language-toml">[workspace]
members = [&quot;member1&quot;, &quot;member2&quot;]

[workspace.metadata.webcontents]
root = &quot;path/to/webproject&quot;
tool = [&quot;npm&quot;, &quot;run&quot;, &quot;build&quot;]
# ...
</code></pre>
<p>在package一级也有一组类似的表格，地址是
<a href="reference/manifest.html#the-metadata-table"><code>package.metadata</code></a>。虽然Cargo没有为这些表的内容指定格式，但建议外部工具以一致的方式使用它们，例如，如果<code>package.metadata</code>中缺少数据，可以参考<code>workspace.metadata</code>中的数据，如果这对相关工具来说是有意义的。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="特性"><a class="header" href="#特性">特性</a></h2>
<p>Cargo的 &quot;特性&quot; 提供了一种机制来表达 <a href="reference/../../reference/conditional-compilation.html">条件编译</a> 和 <a href="reference/features.html#optional-dependencies">可选依赖</a> 。
包在 <code>Cargo.toml</code> 的 <code>[features]</code> 表中定义了一组命名的特性，每个特性可以被启用或禁用。
正在构建的包的特性可以在命令行中用 <code>--features</code> 这样的标志启用。
依赖的特性可以在 <code>Cargo.toml</code> 的依赖声明中启用。</p>
<p>参阅<a href="reference/features-examples.html">特性实例</a>章节，有关于如何使用特性的一些例子。</p>
<h3 id="features-部分"><a class="header" href="#features-部分"><code>[features]</code> 部分</a></h3>
<p>特性在 <code>Cargo.toml</code> 的 <code>[features]</code> 表中定义。
每个特性都指定了一个其他特性的数组，或者它所启用的可选依赖。
下面的例子说明了如何将特性用于二维图像处理库，其中对不同图像格式的支持可以选择性地包含在内。</p>
<pre><code class="language-toml">[features]
# 定义了一个名为 `webp` 的特性，它不会启用任何其他特性。
webp = []
</code></pre>
<p>有了这个特性的定义，[<code>cfg</code> 表达式] 可以用来在编译时，通过条件来包含代码，以支持所要求的特性。例如，在包的 <code>lib.rs</code> 里面可以这样:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 有条件地包含实现WEBP支持的模块。
#[cfg(feature = &quot;webp&quot;)]
pub mod webp;
<span class="boring">}</span></code></pre></pre>
<p>Cargo使用 <code>rustc</code> <a href="reference/../../rustc/command-line-arguments.html#option-cfg"><code>--cfg</code> flag</a> 在包中设置特性，代码可以用[<code>cfg</code> 属性]或[<code>cfg</code> 宏]测试它们的存在。</p>
<p>特性可以列出要启用的其他特性。例如，ICO图像格式可以包含BMP和PNG图像，所以当它被启用时，应该确保其他这些特性也被启用:</p>
<pre><code class="language-toml">[features]
bmp = []
png = []
ico = [&quot;bmp&quot;, &quot;png&quot;]
webp = []
</code></pre>
<p>特性名称可以包括 <a href="https://unicode.org/reports/tr31/">Unicode XID standard</a> (包括大多数字母)中的字符，另外，允许以 <code>_</code> 或数字 <code>0</code> 到 <code>9</code> 开头，在第一个字符之后还可以包含 <code>-</code> 、 <code>+</code> 或 <code>.</code> 。</p>
<blockquote>
<p><strong>注意</strong>: <a href="https://crates.io/">crates.io</a>对特性名称的语法有额外的限制，只能是<a href="reference/../../std/primitive.char.html#method.is_ascii_alphanumeric">ASCII字母数字</a>字符或 <code>_</code> ， <code>-</code> ，或 <code>+</code> 。</p>
</blockquote>
<h3 id="default-特性"><a class="header" href="#default-特性"><code>default</code> 特性</a></h3>
<p>默认情况下，所有特性都是禁用的，除非明确启用。这可以通过指定 <code>default</code> 特性来更改:</p>
<pre><code class="language-toml">[features]
default = [&quot;ico&quot;, &quot;webp&quot;]
bmp = []
png = []
ico = [&quot;bmp&quot;, &quot;png&quot;]
webp = []
</code></pre>
<p>当包被构建时， <code>default</code> 特性被启用，这反过来又启用了所列出的特性。这种行为可以通过以下方式改变:</p>
<ul>
<li><code>--no-default-features</code><a href="reference/features.html#command-line-feature-options">command-line flag</a>禁用包的默认功能。</li>
<li>可以在 <a href="reference/features.html#dependency-features">依赖声明</a> 中指定 <code>default-features = false</code> .</li>
</ul>
<blockquote>
<p><strong>注意</strong>: 选择默认特性要小心。默认特性让用户更容易使用包，而不需要强迫用户仔细选择启用哪些常用特性，但也有一些缺点。
除非指定 <code>default-features = false</code> ，否则依赖会自动启用默认特性。
这可能会使我们难以确保默认特性不被启用，特别是对于在依赖图中出现多次的依赖。
每个包都必须确保指定 <code>default-features = false</code> 以避免启用它们。
另一个问题是，从默认集合中删除特性可能是<a href="reference/features.html#semver-compatibility">语义版本不兼容的变化</a>，所以你应该有信心时才保留这些特性。</p>
</blockquote>
<h3 id="可选依赖"><a class="header" href="#可选依赖">可选依赖</a></h3>
<p>依赖可以被标记为 &quot;可选&quot;，这意味着它们将不会被默认编译。
例如，假设2D图像处理库使用一个外部包来处理GIF图像。可以这样表达:</p>
<pre><code class="language-toml">[dependencies]
gif = { version = &quot;0.11.1&quot;, optional = true }
</code></pre>
<p>默认情况下，这个可选依赖隐式地定义了一个看起来像这样的特征。</p>
<pre><code class="language-toml">[features]
gif = [&quot;dep:gif&quot;]
</code></pre>
<p>这意味着只有在启用了 <code>gif</code> 特性的情况下才会包含这个依赖。
同样的 <code>cfg(feature = &quot;gif&quot;)</code> 语法可以在代码中使用，并且该依赖可以像任何特性一样被启用，
例如 <code>--features gif</code> (见下面的<a href="reference/features.html#command-line-feature-options">命令行特性选项</a>)。</p>
<p>在某些情况下，你可能不想公开与可选依赖同名的特性。
例如，也许这个可选依赖是一个内部细节，或者你想把多个可选依赖组合在一起，或者你只是想使用一个更好的名字。
如果你在 <code>[features]</code> 表中的任何地方用 <code>dep:</code> 前缀来指定可选依赖，将禁用该隐含特征。</p>
<blockquote>
<p><strong>注意</strong>: <code>dep:</code> 语法仅从Rust 1.60开始可用。
以前的版本只能使用隐含的特征名称。</p>
</blockquote>
<p>例如，假设为了支持AVIF图像格式，库需要启用另外两个依赖项:</p>
<pre><code class="language-toml">[dependencies]
ravif = { version = &quot;0.6.3&quot;, optional = true }
rgb = { version = &quot;0.8.25&quot;, optional = true }

[features]
avif = [&quot;dep:ravif&quot;, &quot;dep:rgb&quot;]
</code></pre>
<p>在这个例子中， <code>avif</code> 特性将启用两个列出的依赖。
这也避免了创建隐式的 <code>ravif</code> 和 <code>rgb</code> 特性，因为我们不希望用户单独启用这些特性，因为它们是crate的内部细节。</p>
<blockquote>
<p><strong>注意</strong>: 另一种可选的包含依赖的方法是使用<a href="reference/specifying-dependencies.html#platform-specific-dependencies">特定平台依赖</a>。
而不是使用特性，这些是基于目标平台的条件。</p>
</blockquote>
<h3 id="依赖特性"><a class="header" href="#依赖特性">依赖特性</a></h3>
<p>依赖特性可以在依赖声明中启用。
<code>features</code> 键表示要启用哪些特性。</p>
<pre><code class="language-toml">[dependencies]
# 启用serde的 `derive` 特性。
serde = { version = &quot;1.0.118&quot;, features = [&quot;derive&quot;] }
</code></pre>
<p>可以用 <code>default-features = false</code> 来禁用 <a href="reference/features.html#the-default-feature"><code>default</code> 特性</a> 。</p>
<pre><code class="language-toml">[dependencies]
flate2 = { version = &quot;1.0.3&quot;, default-features = false, features = [&quot;zlib&quot;] }
</code></pre>
<blockquote>
<p><strong>注意</strong>: 这可能无法确保默认特性被禁用。
如果另一个依赖包含 <code>flate2</code> 而没有指定 <code>default-features = false</code> ，那么将启用默认特性。
更多细节请参见下面的<a href="reference/features.html#feature-unification">特性联合</a>。</p>
</blockquote>
<p>依赖的特性也可以在 <code>[features]</code> 表中启用。
语法是 <code>&quot;package-name/feature-name&quot;</code> 。例如:</p>
<pre><code class="language-toml">[dependencies]
jpeg-decoder = { version = &quot;0.1.20&quot;, default-features = false }

[features]
# 通过启用jpeg解码器的 &quot;rayon&quot; 特性来启用并行处理支持。
parallel = [&quot;jpeg-decoder/rayon&quot;]
</code></pre>
<p><code>&quot;package-name/feature-name&quot;</code> 语法也将启用 <code>package-name</code> ，如果它是一个可选的依赖。通常这不是你想要的。
你可以在 <code>&quot;package-name?/feature-name&quot;</code> 中添加一个 <code>?</code> ，只有在其他内容启用了可选依赖时，才会启用给定的特性。</p>
<blockquote>
<p><strong>注意</strong>: <code>?</code> 语法仅从Rust 1.60开始可用。</p>
</blockquote>
<p>例如，假设在库中添加序列化支持，它需要在一些可选的依赖中启用相应的特性。
可以像这样做:</p>
<pre><code class="language-toml">[dependencies]
serde = { version = &quot;1.0.133&quot;, optional = true }
rgb = { version = &quot;0.8.25&quot;, optional = true }

[features]
serde = [&quot;dep:serde&quot;, &quot;rgb?/serde&quot;]
</code></pre>
<p>在这个例子中，启用 <code>serde</code> 特性将启用serde依赖。
它也将启用 <code>rgb</code> 依赖的 <code>serde</code> 特性，但只有在其他内容已经启用了 <code>rgb</code> 依赖的情况下。</p>
<h3 id="命令行可选特性"><a class="header" href="#命令行可选特性">命令行可选特性</a></h3>
<p>以下命令行标志可以用来控制哪些特性被启用:</p>
<ul>
<li>
<p><code>--features</code> <em>FEATURES</em>: 启用列出的特性。多个特性可以用逗号或空格分开。
若使用空格，如果从shell中运行Cargo，请确保在所有特性周围使用引号(例如 <code>---features &quot;foo bar&quot;</code> )。
如果在[工作空间]中构建多个包，可以使用 <code>package-name/feature-name</code> 语法来指定特定工作空间成员的特性。</p>
</li>
<li>
<p><code>--all-features</code>: 激活在命令行上选择的所有包的所有特性。</p>
</li>
<li>
<p><code>--no-default-features</code>: 不激活所选包的<a href="reference/features.html#the-default-feature"><code>default</code> 特性</a>。</p>
</li>
</ul>
<h3 id="特性联合"><a class="header" href="#特性联合">特性联合</a></h3>
<p>特性对于定义它们的包来说是唯一的。在包上启用一个特性，不会在其他包上启用相同名称的特性。</p>
<p>当依赖被多个软件包使用时，Cargo会在构建时使用该依赖上启用的所有特性的联合。
这有助于确保只使用该依赖的一个副本。
更多细节请参见解析器文档中的 [特性部分] 。</p>
<p>例如，来看一下 <a href="https://crates.io/crates/winapi"><code>winapi</code></a> 包，它使用了 <a href="https://github.com/retep998/winapi-rs/blob/0.3.9/Cargo.toml#L25-L431">大量</a> 的特性。
如果你的包依赖于包 <code>foo</code> ，它启用了 <code>winapi</code> 的 &quot;fileapi&quot; 和 &quot;handleapi&quot; 特性，
而另一个依赖包 <code>bar</code> 启用了 <code>winapi</code> 的 &quot;std&quot; 和 &quot;winnt&quot; 特性，那么 <code>winapi</code> 将在启用所有这四种特性后被构建。</p>
<p><img src="reference/../images/winapi-features.svg" alt="winapi features example" /></p>
<p>这样做的效果是，特性应该是 <em>增加性</em> 的。也就是说，启用特性不应该禁用功能，
而且启用任意特性的组合通常都是安全的。一个特性不应该引入 <a href="reference/features.html#semver-compatibility">不兼容语义化改变</a>。</p>
<p>例如，如果你想选择性地支持 <a href="reference/../../reference/names/preludes.html#the-no_std-attribute"><code>no_std</code></a> 环境，<strong>不要</strong>使用 <code>no_std</code> 特性。相反，使用 &quot;std&quot; 特性，<em>启用</em> <code>std</code> 。比如说:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![no_std]

<span class="boring">fn main() {
</span>#[cfg(feature = &quot;std&quot;)]
extern crate std;

#[cfg(feature = &quot;std&quot;)]
pub fn function_that_requires_std() {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h4 id="互斥特性"><a class="header" href="#互斥特性">互斥特性</a></h4>
<p>在极少数情况下，特性之间可能相互不兼容。
如果可能的话，应该避免这种情况，因为这需要协调依赖图中包的所有使用，避免同时启用。
如果不可能，可以考虑增加一个编译错误来检测这种情况。比如说:</p>
<pre><code class="language-rust ignore">#[cfg(all(feature = &quot;foo&quot;, feature = &quot;bar&quot;))]
compile_error!(&quot;feature \&quot;foo\&quot; and feature \&quot;bar\&quot; cannot be enabled at the same time&quot;);</code></pre>
<p>与其使用相互排斥的特性，不如考虑一些其他选择:</p>
<ul>
<li>将功能分成独立的包。</li>
<li>当有冲突时，<a href="reference/features-examples.html#feature-precedence">选择其中之一</a>。<a href="https://crates.io/crates/cfg-if"><code>cfg-if</code></a> 包可以帮助编写更复杂的 <code>cfg</code> 表达式。</li>
<li>构建代码以允许同时启用这些功能，并使用运行时选项来控制使用哪个功能。例如，使用一个配置文件、命令行参数或环境变量来选择启用哪种行为。</li>
</ul>
<h4 id="检查解析特性"><a class="header" href="#检查解析特性">检查解析特性</a></h4>
<p>在复杂的依赖图中，有时很难理解不同的特性是如何在不同的包上被启用的。
<a href="reference/../commands/cargo-tree.html"><code>cargo tree</code></a> 命令提供了几个选项来帮助检查和可视化哪些特性被启用。可以尝试:</p>
<ul>
<li><code>cargo tree -e features</code>: 这将显示依赖图中的特征。
每个特性都会出现，显示哪个软件包启用了它。</li>
<li><code>cargo tree -f &quot;{p} {f}&quot;</code>: 这是更紧凑的视图，显示每个包上启用的特性的逗号分隔的列表。</li>
<li><code>cargo tree -e features -i foo</code>: 这将反转树形图，显示特征如何流入给定的包 &quot;foo&quot;。这可能很有用，因为查看整个图表可能相当大，而且令人不知所措。
当你试图弄清楚哪些特性在特定的包上被启用以及为什么要这样做时，可以使用这个方法。
请看<a href="reference/../commands/cargo-tree.html"><code>cargo tree</code></a>页面底部的例子，了解阅读。</li>
</ul>
<h3 id="特性解析版本2"><a class="header" href="#特性解析版本2">特性解析版本2</a></h3>
<p>可以用 <code>Cargo.toml</code> 中的 <code>resolver</code> 字段指定不同的特性解析器，像这样:</p>
<pre><code class="language-toml">[package]
name = &quot;my-package&quot;
version = &quot;1.0.0&quot;
resolver = &quot;2&quot;
</code></pre>
<p>关于指定解析器版本的更多细节，请参见 <a href="reference/resolver.html#resolver-versions">解析器版本</a> 部分。</p>
<p>版本 <code>&quot;2&quot;</code> 的解析器在一些不需要联合的情况下避免了联合的特性。
具体的情况在 <a href="reference/resolver.html#feature-resolver-version-2">解析器章节</a> 中有描述，简而言之，它避免在这些情况下进行联合。</p>
<ul>
<li>对于目前没有被构建的目标，在<a href="reference/specifying-dependencies.html#platform-specific-dependencies">特定平台依赖</a>上启用的特性会被忽略。</li>
<li><a href="reference/specifying-dependencies.html#build-dependencies">Build-dependencies</a> 和 proc-macros 不与常规依赖共享特性。</li>
<li><a href="reference/specifying-dependencies.html#development-dependencies">Dev-dependencies</a> 不会激活特性，除非构建需要它们的目标(如测试或实例)。</li>
</ul>
<p>在某些情况下，避免联合是必要的。
例如，如果build-dependency启用了 <code>std</code> 特性，而同一个依赖被用作 <code>no_std</code> 环境的常规依赖，启用 <code>std</code> 会破坏构建。</p>
<p>然而，一个缺点是，这可能会增加构建时间，因为依赖会被构建多次(每次都有不同的特性)。
当使用版本 <code>&quot;2&quot;</code> 解析器时，建议检查那些被多次构建的依赖，以减少整体构建时间。
如果不是 <em>必须</em> 要用单独的特性来构建这些重复的包，可以考虑在<a href="reference/features.html#dependency-features">依赖声明</a>中的 <code>特性</code> 列表中添加特性，
这样重复的包最后就会有相同的特性(因此Cargo只会构建一次)。
你可以用<a href="reference/../commands/cargo-tree.html"><code>cargo tree --duplicates</code></a>命令检测这些重复的依赖。它将显示哪些包被多次构建；
寻找任何列出相同版本的条目。参见 <a href="reference/features.html#inspecting-resolved-features">Inspecting resolved features</a> 获取更多关于获取已解决特性的信息。
对于构建依赖，如果你使用 <code>--target</code> 标志进行交叉编译，则没有必要这样做，因为在这种情况下，构建依赖总是与普通依赖分开构建。</p>
<h4 id="解析器版本2命令行标记"><a class="header" href="#解析器版本2命令行标记">解析器版本2命令行标记</a></h4>
<p><code>resolver = &quot;2&quot;</code> 的设置也改变了 <code>--features</code> 和 <code>--no-default-features</code> <a href="reference/features.html#command-line-feature-options">命令行选项</a> 的行为。</p>
<p>在版本 <code>&quot;1&quot;</code> 中，你只能为当前工作目录中的包启用特性。
例如，在一个有 <code>foo</code> 和 <code>bar</code> 包的工作空间中，如果你在 <code>foo</code> 包的目录下，运行 <code>cargo build -p bar --features bar-feat</code> 命令，就会失败，
因为 <code>--features</code> 标志只允许启用 <code>foo</code> 的特性。</p>
<p>在 <code>resolver = &quot;2&quot;</code> 的情况下，特性标志允许启用任何在命令行中用 <code>-p</code> 和 <code>--workspace</code> 标志选择的包的特性。比如说:</p>
<pre><code class="language-sh"># 这个命令在 resolver = &quot;2&quot; 的情况下是允许的，无论你在哪个目录下。
cargo build -p foo -p bar --features foo-feat,bar-feat

# 这个明确的等价形式适用于任何解析器版本:
cargo build -p foo -p bar --features foo/foo-feat,bar/bar-feat
</code></pre>
<p>此外，在 <code>resolver = &quot;1&quot;</code> 的情况下，<code>--no-default-features</code> 标志只停用当前目录下包的默认特性。
如果版本为 &quot;2&quot; ，它将禁用所有工作空间成员的默认特性。</p>
<h3 id="构建脚本"><a class="header" href="#构建脚本">构建脚本</a></h3>
<p><a href="reference/build-scripts.html">构建脚本</a>可以通过检查 <code>CARGO_FEATURE_&lt;name&gt;</code> 环境变量来检测包上启用了哪些特性，其中<code>&lt;name&gt;</code>是转换为大写的特性名称， <code>-</code> 转换为 <code>_</code> 。</p>
<h3 id="必须特性"><a class="header" href="#必须特性">必须特性</a></h3>
<p>如果某个特性没有被启用，<a href="reference/cargo-targets.html#the-required-features-field"><code>required-features</code> 字段</a>可以用来禁用特定的<a href="reference/cargo-targets.html">Cargo 目标</a>。
更多细节请参阅链接的文档。</p>
<h3 id="语义化版本兼容"><a class="header" href="#语义化版本兼容">语义化版本兼容</a></h3>
<p>启用特性不应该引入语义化不兼容的变化。
例如，该特性不应该以可能破坏现有用途的方式改变现有的API。
关于哪些变化是兼容的，可以在<a href="reference/semver.html">语义化版本兼容性章节</a>中找到更多细节。</p>
<p>在添加和删除特性定义和可选的依赖时应该小心，因为这些有时可能是向后不兼容的变化。
更多细节可以在语义化版本兼容性章节的<a href="reference/semver.html#cargo">Cargo 部分</a>中找到。简而言之，遵循这些规则:</p>
<ul>
<li>在次要版本中，以下做法通常是安全的:
<ul>
<li>添加 <a href="reference/semver.html#cargo-feature-add">新特性</a> 或 <a href="reference/semver.html#cargo-dep-add">可选依赖</a>。</li>
<li><a href="reference/semver.html#cargo-change-dep-feature">改变依赖上使用的特性</a>.</li>
</ul>
</li>
<li>以下内容通常<strong>不</strong>应该在次要版本中去做:
<ul>
<li><a href="reference/semver.html#cargo-feature-remove">移除特性</a> 或者 <a href="reference/semver.html#cargo-remove-opt-dep">可选依赖</a>.</li>
<li><a href="reference/semver.html#item-remove">将现有的公共代码移到特性之后</a>.</li>
<li><a href="reference/semver.html#cargo-feature-remove-another">从特性列表中移除特性</a>.</li>
</ul>
</li>
</ul>
<p>注意事项和实例见链接。</p>
<h3 id="特征文档和发现"><a class="header" href="#特征文档和发现">特征文档和发现</a></h3>
<p>我们鼓励你记录你的包中有哪些特性。
这可以通过在 <code>lib.rs</code> 的顶部添加 <a href="reference/../../rustdoc/how-to-write-documentation.html">doc comments</a> 来实现。
请查看 <a href="https://github.com/rust-lang/regex/blob/1.4.2/src/lib.rs#L488-L583">regex crate source</a>例子，它被渲染后可以在 <a href="https://docs.rs/regex/1.4.2/regex/#crate-features">docs.rs</a> 上查看。
如果你有其他的文档，比如用户指南，考虑将文档添加到那里(例如，参阅<a href="https://serde.rs/feature-flags.html">serde.rs</a>)。
如果你有一个二进制项目，考虑在README或项目的其他文档中记录这些特性(例如，参阅<a href="https://github.com/mozilla/sccache/blob/0.2.13/README.md#build-requirements">sccache</a>)。</p>
<p>明确记录特性可以为那些被认为是 &quot;不稳定&quot; 或不应该被使用的特性设定期望。
例如，如果有一个可选的依赖，但你不希望用户明确地把这个可选依赖列为特性，那么就把它从记录的列表中排除。</p>
<p>在<a href="https://docs.rs/">docs.rs</a>上发布的文档可以使用 <code>Cargo.toml</code> 中的元数据来控制文档构建时启用哪些特性。
更多细节请参见 <a href="https://docs.rs/about/metadata">docs.rs metadata documentation</a> 。</p>
<blockquote>
<p><strong>注意</strong>: Rustdoc实验性地支持对文档进行注释，以表明使用某些API需要哪些特性。
更多细节见 <a href="reference/../../unstable-book/language-features/doc-cfg.html"><code>doc_cfg</code></a> 文档。一个例子是<a href="https://docs.rs/syn/1.0.54/syn/#modules"><code>syn</code> documentation</a>，你可以看到彩色的方框，其中指出使用哪些特性是需要的。</p>
</blockquote>
<h4 id="发现特性"><a class="header" href="#发现特性">发现特性</a></h4>
<p>当特性被记录在库的API中时，这可以使你的用户更容易发现哪些特性是可用的以及它们的作用。
如果一个包的特性文档不容易获得，你可以看看 <code>Cargo.toml</code> 文件，但有时会很难追踪到它。
如果存在，<a href="https://crates.io/">crates.io</a>上的crate页面有一个指向源码库的链接。
像 <a href="reference/../commands/cargo-vendor.html"><code>cargo vendor</code></a> 或 <a href="https://crates.io/crates/cargo-clone-crate">cargo-clone-crate</a> 这样的工具可以用来下载源码并检查它。</p>
<h3 id="特性组合"><a class="header" href="#特性组合">特性组合</a></h3>
<p>因为特性是一种条件编译的形式，它们需要指数级的配置和测试案例才能100%覆盖。
默认情况下，测试、文档和其他工具，如<a href="https://github.com/rust-lang/rust-clippy">Clippy</a>将只在默认的特性集下运行。</p>
<p>我们鼓励你考虑你的策略和工具在不同的特性组合方面 - 每个项目将有不同的要求，结合时间、资源和覆盖特定场景的成本效益。
常见的配置可能是有/无默认功能，特定的特性组合，或所有的特性组合。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="特性实例"><a class="header" href="#特性实例">特性实例</a></h2>
<p>下面说明一些实际中的特性实例。</p>
<h3 id="最大限度地减少构建时间和文件大小"><a class="header" href="#最大限度地减少构建时间和文件大小">最大限度地减少构建时间和文件大小</a></h3>
<p>一些包使用了特性，所以如果不启用这些特性，就会减小crate的大小并减少编译时间。一些例子是:</p>
<ul>
<li><a href="https://crates.io/crates/syn"><code>syn</code></a> 是流行的用于解析Rust代码的crate。它对减少编译时间很有帮助，影响了很多项目，很流行。
它有一个<a href="https://docs.rs/syn/1.0.54/syn/#optional-features">明确记录的列表</a>的特性，可以用来减少它所包含的代码量。</li>
<li><a href="https://crates.io/crates/regex"><code>regex</code></a>有<a href="https://github.com/rust-lang/regex/blob/1.4.2/Cargo.toml#L33-L101">几个特性</a>，这些特性都有<a href="https://docs.rs/regex/1.4.2/regex/#crate-features">很好的文档</a>。
移除Unicode支持可以减少结果文件的大小，因为它可以删除一些大表。</li>
<li><a href="https://crates.io/crates/winapi"><code>winapi</code></a>有<a href="https://github.com/retep998/winapi-rs/blob/0.3.9/Cargo.toml#L25-L431">大量</a>的特性，以限制它支持哪些Windows API绑定。</li>
<li><a href="https://crates.io/crates/web-sys"><code>web-sys</code></a>是另一个类似于 <code>winapi</code> 的例子，它提供了<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/crates/web-sys/Cargo.toml#L32-L1395">巨量</a>的API绑定，使用特性限制这些绑定。</li>
</ul>
<h3 id="扩展行为"><a class="header" href="#扩展行为">扩展行为</a></h3>
<p><a href="https://crates.io/crates/serde_json"><code>serde_json</code></a>包有<a href="https://github.com/serde-rs/json/blob/v1.0.60/Cargo.toml#L53-L56"><code>preserve_order</code>功能</a>，它<a href="https://github.com/serde-rs/json/blob/v1.0.60/src/map.rs#L23-L26">改变JSON映射行为</a>，以保持键的插入顺序。
请注意，它启用了一个可选的依赖项 <a href="https://crates.io/crates/indexmap"><code>indexmap</code></a> 来实现新的行为。</p>
<p>当改变这样的行为时，要注意确保这些改变是[语义版本兼容]的。
也就是说，启用该特性不应该破坏通常在该特性关闭时构建的代码。</p>
<h3 id="no_std-支持"><a class="header" href="#no_std-支持"><code>no_std</code> 支持</a></h3>
<p>一些包希望同时支持 <a href="reference/../../reference/names/preludes.html#the-no_std-attribute"><code>no_std</code></a> 和 <code>std</code> 环境。
这对于支持嵌入式和资源受限的平台是很有用的，但对于支持完整标准库的平台，仍然允许扩展功能。</p>
<p><a href="https://crates.io/crates/wasm-bindgen"><code>wasm-bindgen</code></a>包定义了一个<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L25"><code>std</code> 特性</a>，<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L23">默认启用</a>。
在库的顶部，它<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L8">非可选的启用 <code>no_std</code> 属性</a>。
这确保了 <code>std</code> 和<a href="reference/../../std/prelude/index.html"><code>std</code> prelude</a>不会自动进入作用域。
然后，在代码的不同地方(<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L270-L273">example1</a>, <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L67-L75">example2</a>)，它使用 <code>#[cfg(feature = &quot;std&quot;)]</code> 属性，有条件地启用需要 <code>std</code> 的附加功能。</p>
<h3 id="重新导出依赖特性"><a class="header" href="#重新导出依赖特性">重新导出依赖特性</a></h3>
<p>从依赖中重新导出特性可能是很方便的。
这允许依赖于crate的用户控制这些特性，而不需要直接指定这些依赖。
例如，<a href="https://crates.io/crates/regex"><code>regex</code></a> <a href="https://github.com/rust-lang/regex/blob/1.4.2/Cargo.toml#L65-L89">重新导出特性</a> 来自 <a href="https://github.com/rust-lang/regex/blob/1.4.2/regex-syntax/Cargo.toml#L17-L32"><code>regex_syntax</code></a> 包。
<code>regex</code> 的用户不需要知道 <code>regex_syntax</code> 包，但他们仍然可以访问它所包含的功能。</p>
<h3 id="c库支持"><a class="header" href="#c库支持">C库支持</a></h3>
<p>一些包提供了与普通C库的绑定(有时被称为<a href="reference/build-scripts.html#-sys-packages">&quot;sys&quot; crates</a>)。
有时，这些包让你选择使用系统上安装的C库，或者从源代码中构建它。
例如，<a href="https://crates.io/crates/openssl"><code>openssl</code></a>包有一个<a href="https://github.com/sfackler/rust-openssl/blob/openssl-v0.10.31/openssl/Cargo.toml#L19"><code>vendored</code> 特性</a>，它可以启用<a href="https://crates.io/crates/openssl-sys"><code>openssl-sys</code></a>的相应 <code>vendored</code> 特性。
<code>openssl-sys</code> 构建脚本有一些<a href="https://github.com/sfackler/rust-openssl/blob/openssl-v0.10.31/openssl-sys/build/main.rs#L47-L54">条件逻辑</a>，使其从OpenSSL源代码的本地副本构建，而不是使用系统的版本。</p>
<p><a href="https://crates.io/crates/curl-sys"><code>curl-sys</code></a> 包是另一个例子，<a href="https://github.com/alexcrichton/curl-rust/blob/0.4.34/curl-sys/Cargo.toml#L49"><code>static-curl</code> 特性</a>导致它从源码构建libcurl。
注意它也有一个<a href="https://github.com/alexcrichton/curl-rust/blob/0.4.34/curl-sys/Cargo.toml#L52"><code>force-system-lib-on-osx</code></a>特性，强制它<a href="https://github.com/alexcrichton/curl-rust/blob/0.4.34/curl-sys/build.rs#L15-L20">使用系统libcurl</a>，推翻了static-curl的设置。</p>
<h3 id="特性优先级"><a class="header" href="#特性优先级">特性优先级</a></h3>
<p>一些包可能有相互排斥的特性。处理这个问题的选项是，在一个特性优先于另一个。
<a href="https://crates.io/crates/log"><code>log</code></a> 包是一个例子。它有<a href="https://github.com/rust-lang/log/blob/0.4.11/Cargo.toml#L29-L42">几个特性</a>，用于在编译时选择最大的日志级别，<a href="https://docs.rs/log/0.4.11/log/#compile-time-filters">这里</a>描述。
它使用<a href="https://crates.io/crates/cfg-if"><code>cfg-if</code></a>来<a href="https://github.com/rust-lang/log/blob/0.4.11/src/lib.rs#L1422-L1448">选择一个优先级</a>。如果启用了多个特性，较高的 &quot;max&quot; 级别将优先于较低的级别。</p>
<h3 id="进程宏协同包"><a class="header" href="#进程宏协同包">进程宏协同包</a></h3>
<p>有些包有一个与之紧密相连的进程宏。然而，并不是所有的用户都需要使用这个进程宏。
通过使进程宏成为可选的依赖，这允许你方便地选择是否包含它。
这很有帮助，因为有时进程宏的版本必须与父包保持同步，而你不想强迫用户必须指定两个依赖并保持它们同步。</p>
<p>一个例子是 <a href="https://crates.io/crates/serde"><code>serde</code></a> ，它有一个<a href="https://github.com/serde-rs/serde/blob/v1.0.118/serde/Cargo.toml#L34-L35"><code>derive</code></a>特性，可以启用<a href="https://crates.io/crates/serde_derive"><code>serde_derive</code></a>进程宏。
<code>serde_derive</code> crate与 <code>serde</code> 紧密相连，所以它使用<a href="https://github.com/serde-rs/serde/blob/v1.0.118/serde/Cargo.toml#L17">相同版本要求</a>来确保它们保持同步。</p>
<h3 id="每日构建特性"><a class="header" href="#每日构建特性">每日构建特性</a></h3>
<p>一些包想要试验只有在 Rust <a href="reference/../../book/appendix-07-nightly-rust.html">nightly channel</a>上才有的API或语言特性。
然而，他们可能不希望要求他们的用户也使用nightly频道。
一个例子是<a href="https://crates.io/crates/wasm-bindgen"><code>wasm-bindgen</code></a>，它有一个<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L27"><code>nightly</code> 特性</a>，
它启用了一个<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/closure.rs#L257-L269">扩展的API</a>，使用<a href="reference/../../std/marker/trait.Unsize.html"><code>Unsize</code></a>标记特性，在写这篇文章时，只有在nightly频道中才有。</p>
<p>请注意，在crate的root，它使用了<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L11"><code>cfg_attr</code> 来启用每日特性</a>。
要知道，[<code>feature</code> 属性]与Cargo特性无关，它是用来选择加入实验性语言特性的。</p>
<p><a href="https://crates.io/crates/rand"><code>rand</code></a> 包的 <a href="https://github.com/rust-random/rand/blob/0.7.3/Cargo.toml#L40"><code>simd_support</code> 特性</a>是另一个例子，它依赖于一个只在每日频道构建的依赖。</p>
<h3 id="实验特性"><a class="header" href="#实验特性">实验特性</a></h3>
<p>一些包有新的特性，他们可能想进行实验，而不必承诺这些API的稳定性。
这些功能通常被记录在案，它们是实验性的，因此在未来可能会发生变化或损坏，甚至在一个次要的版本中。
一个例子是[async-std]包，它有一个[unstable]特性<a href="https://github.com/async-rs/async-std/blob/v1.8.0/Cargo.toml#L38-L42">async-std-unstable</a>，<a href="https://github.com/async-rs/async-std/blob/v1.8.0/src/macros.rs#L46">gates new APIs</a>，人们可以选择使用，但可能还没有完全准备好被依赖。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="profiles"><a class="header" href="#profiles">Profiles</a></h2>
<p>Profiles provide a way to alter the compiler settings, influencing things like
optimizations and debugging symbols.</p>
<p>Cargo has 4 built-in profiles: <code>dev</code>, <code>release</code>, <code>test</code>, and <code>bench</code>. The
profile is automatically chosen based on which command is being run if a
profile is not specified on the command-line. In addition to the built-in
profiles, custom user-defined profiles can also be specified.</p>
<p>Profile settings can be changed in <a href="reference/manifest.html"><code>Cargo.toml</code></a> with the
<code>[profile]</code> table. Within each named profile, individual settings can be changed
with key/value pairs like this:</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1               # Use slightly better optimizations.
overflow-checks = false     # Disable integer overflow checks.
</code></pre>
<p>Cargo only looks at the profile settings in the <code>Cargo.toml</code> manifest at the
root of the workspace. Profile settings defined in dependencies will be
ignored.</p>
<p>Additionally, profiles can be overridden from a <a href="reference/config.html">config</a> definition.
Specifying a profile in a config file or environment variable will override
the settings from <code>Cargo.toml</code>.</p>
<h3 id="profile-settings"><a class="header" href="#profile-settings">Profile settings</a></h3>
<p>The following is a list of settings that can be controlled in a profile.</p>
<h4 id="opt-level"><a class="header" href="#opt-level">opt-level</a></h4>
<p>The <code>opt-level</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#opt-level"><code>-C opt-level</code> flag</a> which controls the level
of optimization. Higher optimization levels may produce faster runtime code at
the expense of longer compiler times. Higher levels may also change and
rearrange the compiled code which may make it harder to use with a debugger.</p>
<p>The valid options are:</p>
<ul>
<li><code>0</code>: no optimizations</li>
<li><code>1</code>: basic optimizations</li>
<li><code>2</code>: some optimizations</li>
<li><code>3</code>: all optimizations</li>
<li><code>&quot;s&quot;</code>: optimize for binary size</li>
<li><code>&quot;z&quot;</code>: optimize for binary size, but also turn off loop vectorization.</li>
</ul>
<p>It is recommended to experiment with different levels to find the right
balance for your project. There may be surprising results, such as level <code>3</code>
being slower than <code>2</code>, or the <code>&quot;s&quot;</code> and <code>&quot;z&quot;</code> levels not being necessarily
smaller. You may also want to reevaluate your settings over time as newer
versions of <code>rustc</code> changes optimization behavior.</p>
<p>See also <a href="reference/../../rustc/profile-guided-optimization.html">Profile Guided Optimization</a> for more advanced optimization
techniques.</p>
<h4 id="debug"><a class="header" href="#debug">debug</a></h4>
<p>The <code>debug</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#debuginfo"><code>-C debuginfo</code> flag</a> which controls the
amount of debug information included in the compiled binary.</p>
<p>The valid options are:</p>
<ul>
<li><code>0</code> or <code>false</code>: no debug info at all</li>
<li><code>1</code>: line tables only</li>
<li><code>2</code> or <code>true</code>: full debug info</li>
</ul>
<p>You may wish to also configure the <a href="reference/profiles.html#split-debuginfo"><code>split-debuginfo</code></a> option
depending on your needs as well.</p>
<h4 id="split-debuginfo"><a class="header" href="#split-debuginfo">split-debuginfo</a></h4>
<p>The <code>split-debuginfo</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#split-debuginfo"><code>-C split-debuginfo</code> flag</a> which
controls whether debug information, if generated, is either placed in the
executable itself or adjacent to it.</p>
<p>This option is a string and acceptable values are the same as those the
<a href="reference/../../rustc/codegen-options/index.html#split-debuginfo">compiler accepts</a>. The default value for this option
is <code>unpacked</code> on macOS for profiles that have debug information otherwise
enabled. Otherwise the default for this option is <a href="reference/../../rustc/codegen-options/index.html#split-debuginfo">documented with rustc</a> and is platform-specific. Some options are only
available on the <a href="reference/../../book/appendix-07-nightly-rust.html">nightly channel</a>. The Cargo default may change in the future
once more testing has been performed, and support for DWARF is stabilized.</p>
<h4 id="strip"><a class="header" href="#strip">strip</a></h4>
<p>The <code>strip</code> option controls the <a href="reference/../../rustc/codegen-options/index.html#strip"><code>-C strip</code> flag</a>, which directs rustc to
strip either symbols or debuginfo from a binary. This can be enabled like so:</p>
<pre><code class="language-toml">[package]
# ...

[profile.release]
strip = &quot;debuginfo&quot;
</code></pre>
<p>Possible string values of <code>strip</code> are <code>&quot;none&quot;</code>, <code>&quot;debuginfo&quot;</code>, and <code>&quot;symbols&quot;</code>.
The default is <code>&quot;none&quot;</code>.</p>
<p>You can also configure this option with the boolean values <code>true</code> or <code>false</code>.
<code>strip = true</code> is equivalent to <code>strip = &quot;symbols&quot;</code>. <code>strip = false</code> is
equivalent to <code>strip = &quot;none&quot;</code> and disables <code>strip</code> completely.</p>
<h4 id="debug-assertions"><a class="header" href="#debug-assertions">debug-assertions</a></h4>
<p>The <code>debug-assertions</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#debug-assertions"><code>-C debug-assertions</code> flag</a> which
turns <code>cfg(debug_assertions)</code> <a href="reference/../../reference/conditional-compilation.html#debug_assertions">conditional compilation</a> on or off. Debug
assertions are intended to include runtime validation which is only available
in debug/development builds. These may be things that are too expensive or
otherwise undesirable in a release build. Debug assertions enables the
<a href="reference/../../std/macro.debug_assert.html"><code>debug_assert!</code> macro</a> in the standard library.</p>
<p>The valid options are:</p>
<ul>
<li><code>true</code>: enabled</li>
<li><code>false</code>: disabled</li>
</ul>
<h4 id="overflow-checks"><a class="header" href="#overflow-checks">overflow-checks</a></h4>
<p>The <code>overflow-checks</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#overflow-checks"><code>-C overflow-checks</code> flag</a> which
controls the behavior of <a href="reference/../../reference/expressions/operator-expr.html#overflow">runtime integer overflow</a>. When overflow-checks are
enabled, a panic will occur on overflow.</p>
<p>The valid options are:</p>
<ul>
<li><code>true</code>: enabled</li>
<li><code>false</code>: disabled</li>
</ul>
<h4 id="lto"><a class="header" href="#lto">lto</a></h4>
<p>The <code>lto</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#lto"><code>-C lto</code> flag</a> which controls LLVM's <a href="https://llvm.org/docs/LinkTimeOptimization.html">link
time optimizations</a>. LTO can produce better optimized code, using
whole-program analysis, at the cost of longer linking time.</p>
<p>The valid options are:</p>
<ul>
<li><code>false</code>: Performs &quot;thin local LTO&quot; which performs &quot;thin&quot; LTO on the local
crate only across its <a href="reference/profiles.html#codegen-units">codegen units</a>. No LTO is performed
if codegen units is 1 or <a href="reference/profiles.html#opt-level">opt-level</a> is 0.</li>
<li><code>true</code> or <code>&quot;fat&quot;</code>: Performs &quot;fat&quot; LTO which attempts to perform
optimizations across all crates within the dependency graph.</li>
<li><code>&quot;thin&quot;</code>: Performs <a href="http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html">&quot;thin&quot; LTO</a>. This is similar to &quot;fat&quot;, but takes
substantially less time to run while still achieving performance gains
similar to &quot;fat&quot;.</li>
<li><code>&quot;off&quot;</code>: Disables LTO.</li>
</ul>
<p>See also the <a href="reference/../../rustc/codegen-options/index.html#linker-plugin-lto"><code>-C linker-plugin-lto</code></a> <code>rustc</code> flag for cross-language LTO.</p>
<h4 id="panic"><a class="header" href="#panic">panic</a></h4>
<p>The <code>panic</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#panic"><code>-C panic</code> flag</a> which controls which panic
strategy to use.</p>
<p>The valid options are:</p>
<ul>
<li><code>&quot;unwind&quot;</code>: Unwind the stack upon panic.</li>
<li><code>&quot;abort&quot;</code>: Terminate the process upon panic.</li>
</ul>
<p>When set to <code>&quot;unwind&quot;</code>, the actual value depends on the default of the target
platform. For example, the NVPTX platform does not support unwinding, so it
always uses <code>&quot;abort&quot;</code>.</p>
<p>Tests, benchmarks, build scripts, and proc macros ignore the <code>panic</code> setting.
The <code>rustc</code> test harness currently requires <code>unwind</code> behavior. See the
<a href="reference/unstable.html#panic-abort-tests"><code>panic-abort-tests</code></a> unstable flag which enables <code>abort</code> behavior.</p>
<p>Additionally, when using the <code>abort</code> strategy and building a test, all of the
dependencies will also be forced to build with the <code>unwind</code> strategy.</p>
<h4 id="incremental"><a class="header" href="#incremental">incremental</a></h4>
<p>The <code>incremental</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#incremental"><code>-C incremental</code> flag</a> which controls
whether or not incremental compilation is enabled. Incremental compilation
causes <code>rustc</code> to save additional information to disk which will be reused
when recompiling the crate, improving re-compile times. The additional
information is stored in the <code>target</code> directory.</p>
<p>The valid options are:</p>
<ul>
<li><code>true</code>: enabled</li>
<li><code>false</code>: disabled</li>
</ul>
<p>Incremental compilation is only used for workspace members and &quot;path&quot;
dependencies.</p>
<p>The incremental value can be overridden globally with the <code>CARGO_INCREMENTAL</code>
<a href="reference/environment-variables.html">environment variable</a> or the <a href="reference/config.html#buildincremental"><code>build.incremental</code></a> config variable.</p>
<h4 id="codegen-units"><a class="header" href="#codegen-units">codegen-units</a></h4>
<p>The <code>codegen-units</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#codegen-units"><code>-C codegen-units</code> flag</a> which
controls how many &quot;code generation units&quot; a crate will be split into. More
code generation units allows more of a crate to be processed in parallel
possibly reducing compile time, but may produce slower code.</p>
<p>This option takes an integer greater than 0.</p>
<p>The default is 256 for <a href="reference/profiles.html#incremental">incremental</a> builds, and 16 for
non-incremental builds.</p>
<h4 id="rpath"><a class="header" href="#rpath">rpath</a></h4>
<p>The <code>rpath</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#rpath"><code>-C rpath</code> flag</a> which controls
whether or not <a href="https://en.wikipedia.org/wiki/Rpath"><code>rpath</code></a> is enabled.</p>
<h3 id="default-profiles"><a class="header" href="#default-profiles">Default profiles</a></h3>
<h4 id="dev"><a class="header" href="#dev">dev</a></h4>
<p>The <code>dev</code> profile is used for normal development and debugging. It is the
default for build commands like <a href="reference/../commands/cargo-build.html"><code>cargo build</code></a>, and is used for <code>cargo install --debug</code>.</p>
<p>The default settings for the <code>dev</code> profile are:</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0
debug = true
split-debuginfo = '...'  # Platform-specific.
debug-assertions = true
overflow-checks = true
lto = false
panic = 'unwind'
incremental = true
codegen-units = 256
rpath = false
</code></pre>
<h4 id="release"><a class="header" href="#release">release</a></h4>
<p>The <code>release</code> profile is intended for optimized artifacts used for releases
and in production. This profile is used when the <code>--release</code> flag is used, and
is the default for <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a>.</p>
<p>The default settings for the <code>release</code> profile are:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 3
debug = false
split-debuginfo = '...'  # Platform-specific.
debug-assertions = false
overflow-checks = false
lto = false
panic = 'unwind'
incremental = false
codegen-units = 16
rpath = false
</code></pre>
<h4 id="test"><a class="header" href="#test">test</a></h4>
<p>The <code>test</code> profile is the default profile used by <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a>.
The <code>test</code> profile inherits the settings from the <a href="reference/profiles.html#dev"><code>dev</code></a> profile.</p>
<h4 id="bench"><a class="header" href="#bench">bench</a></h4>
<p>The <code>bench</code> profile is the default profile used by <a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a>.
The <code>bench</code> profile inherits the settings from the <a href="reference/profiles.html#release"><code>release</code></a> profile.</p>
<h4 id="build-dependencies"><a class="header" href="#build-dependencies">Build Dependencies</a></h4>
<p>All profiles, by default, do not optimize build dependencies (build scripts,
proc macros, and their dependencies). The default settings for build overrides
are:</p>
<pre><code class="language-toml">[profile.dev.build-override]
opt-level = 0
codegen-units = 256

[profile.release.build-override]
opt-level = 0
codegen-units = 256
</code></pre>
<p>Build dependencies otherwise inherit settings from the active profile in use, as
described in <a href="reference/profiles.html#profile-selection">Profile selection</a>.</p>
<h3 id="custom-profiles"><a class="header" href="#custom-profiles">Custom profiles</a></h3>
<p>In addition to the built-in profiles, additional custom profiles can be
defined. These may be useful for setting up multiple workflows and build
modes. When defining a custom profile, you must specify the <code>inherits</code> key to
specify which profile the custom profile inherits settings from when the
setting is not specified.</p>
<p>For example, let's say you want to compare a normal release build with a
release build with <a href="reference/profiles.html#lto">LTO</a> optimizations, you can specify something like
the following in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.release-lto]
inherits = &quot;release&quot;
lto = true
</code></pre>
<p>The <code>--profile</code> flag can then be used to choose this custom profile:</p>
<pre><code class="language-console">cargo build --profile release-lto
</code></pre>
<p>The output for each profile will be placed in a directory of the same name
as the profile in the <a href="reference/../guide/build-cache.html"><code>target</code> directory</a>. As in the example above, the
output would go into the <code>target/release-lto</code> directory.</p>
<h3 id="profile-selection"><a class="header" href="#profile-selection">Profile selection</a></h3>
<p>The profile used depends on the command, the command-line flags like
<code>--release</code> or <code>--profile</code>, and the package (in the case of
<a href="reference/profiles.html#overrides">overrides</a>). The default profile if none is specified is:</p>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Default Profile</th></tr></thead><tbody>
<tr><td><a href="reference/../commands/cargo-run.html"><code>cargo run</code></a>, <a href="reference/../commands/cargo-build.html"><code>cargo build</code></a>,<br><a href="reference/../commands/cargo-check.html"><code>cargo check</code></a>, <a href="reference/../commands/cargo-rustc.html"><code>cargo rustc</code></a></td><td><a href="reference/profiles.html#dev"><code>dev</code> profile</a></td></tr>
<tr><td><a href="reference/../commands/cargo-test.html"><code>cargo test</code></a></td><td><a href="reference/profiles.html#test"><code>test</code> profile</a></td></tr>
<tr><td><a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a></td><td><a href="reference/profiles.html#bench"><code>bench</code> profile</a></td></tr>
<tr><td><a href="reference/../commands/cargo-install.html"><code>cargo install</code></a></td><td><a href="reference/profiles.html#release"><code>release</code> profile</a></td></tr>
</tbody></table>
</div>
<p>You can switch to a different profile using the <code>--profile=NAME</code> option which will used the given profile.
The <code>--release</code> flag is equivalent to <code>--profile=release</code>.</p>
<p>The selected profile applies to all Cargo targets, 
including <a href="reference/./cargo-targets.html#library">library</a>,
<a href="reference/./cargo-targets.html#binaries">binary</a>, 
<a href="reference/./cargo-targets.html#examples">example</a>, 
<a href="reference/./cargo-targets.html#tests">test</a>, 
and <a href="reference/./cargo-targets.html#benchmarks">benchmark</a>.</p>
<p>The profile for specific packages can be specified with
<a href="reference/profiles.html#overrides">overrides</a>, described below.</p>
<h3 id="overrides"><a class="header" href="#overrides">Overrides</a></h3>
<p>Profile settings can be overridden for specific packages and build-time
crates. To override the settings for a specific package, use the <code>package</code>
table to change the settings for the named package:</p>
<pre><code class="language-toml"># The `foo` package will use the -Copt-level=3 flag.
[profile.dev.package.foo]
opt-level = 3
</code></pre>
<p>The package name is actually a <a href="reference/pkgid-spec.html">Package ID Spec</a>, so you can
target individual versions of a package with syntax such as
<code>[profile.dev.package.&quot;foo:2.1.0&quot;]</code>.</p>
<p>To override the settings for all dependencies (but not any workspace member),
use the <code>&quot;*&quot;</code> package name:</p>
<pre><code class="language-toml"># Set the default for dependencies.
[profile.dev.package.&quot;*&quot;]
opt-level = 2
</code></pre>
<p>To override the settings for build scripts, proc macros, and their
dependencies, use the <code>build-override</code> table:</p>
<pre><code class="language-toml"># Set the settings for build scripts and proc-macros.
[profile.dev.build-override]
opt-level = 3
</code></pre>
<blockquote>
<p>Note: When a dependency is both a normal dependency and a build dependency,
Cargo will try to only build it once when <code>--target</code> is not specified. When
using <code>build-override</code>, the dependency may need to be built twice, once as a
normal dependency and once with the overridden build settings. This may
increase initial build times.</p>
</blockquote>
<p>The precedence for which value is used is done in the following order (first
match wins):</p>
<ol>
<li><code>[profile.dev.package.name]</code> — A named package.</li>
<li><code>[profile.dev.package.&quot;*&quot;]</code> — For any non-workspace member.</li>
<li><code>[profile.dev.build-override]</code> — Only for build scripts, proc macros, and
their dependencies.</li>
<li><code>[profile.dev]</code> — Settings in <code>Cargo.toml</code>.</li>
<li>Default values built-in to Cargo.</li>
</ol>
<p>Overrides cannot specify the <code>panic</code>, <code>lto</code>, or <code>rpath</code> settings.</p>
<h4 id="overrides-and-generics"><a class="header" href="#overrides-and-generics">Overrides and generics</a></h4>
<p>The location where generic code is instantiated will influence the
optimization settings used for that generic code. This can cause subtle
interactions when using profile overrides to change the optimization level of
a specific crate. If you attempt to raise the optimization level of a
dependency which defines generic functions, those generic functions may not be
optimized when used in your local crate. This is because the code may be
generated in the crate where it is instantiated, and thus may use the
optimization settings of that crate.</p>
<p>For example, <a href="https://crates.io/crates/nalgebra">nalgebra</a> is a library which defines vectors and matrices making
heavy use of generic parameters. If your local code defines concrete nalgebra
types like <code>Vector4&lt;f64&gt;</code> and uses their methods, the corresponding nalgebra
code will be instantiated and built within your crate. Thus, if you attempt to
increase the optimization level of <code>nalgebra</code> using a profile override, it may
not result in faster performance.</p>
<p>Further complicating the issue, <code>rustc</code> has some optimizations where it will
attempt to share monomorphized generics between crates. If the opt-level is 2
or 3, then a crate will not use monomorphized generics from other crates, nor
will it export locally defined monomorphized items to be shared with other
crates. When experimenting with optimizing dependencies for development,
consider trying opt-level 1, which will apply some optimizations while still
allowing monomorphized items to be shared.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<p>本文档解释了Cargo的配置系统如何工作，以及可用的键或配置。关于通过包的配置清单进行的配置，参阅<a href="reference/manifest.html">配置清单格式</a>。</p>
<h3 id="层次结构"><a class="header" href="#层次结构">层次结构</a></h3>
<p>Cargo允许对某一特定包进行本地配置，也允许进行全局配置。它在当前目录和所有父目录下寻找配置文件。例如，如果在<code>/projects/foo/bar/baz</code>中调用Cargo，那么以下的配置文件会被探测到，并按照这个顺序统一起来。</p>
<ul>
<li><code>/projects/foo/bar/baz/.cargo/config.toml</code></li>
<li><code>/projects/foo/bar/.cargo/config.toml</code></li>
<li><code>/projects/foo/.cargo/config.toml</code></li>
<li><code>/projects/.cargo/config.toml</code></li>
<li><code>/.cargo/config.toml</code></li>
<li><code>$CARGO_HOME/config.toml</code> 默认为:
<ul>
<li>Windows: <code>%USERPROFILE%\.cargo\config.toml</code></li>
<li>Unix: <code>$HOME/.cargo/config.toml</code></li>
</ul>
</li>
</ul>
<p>有了这种结构，你可以指定每个包的配置，甚至可以将其检查到版本控制中。你也可以在你的主目录下用一个配置文件指定个人默认值。</p>
<p>如果一个键在多个配置文件中被指定，这些值将被合并在一起。数字、字符串和布尔值将使用更深层级配置目录中的值，其优先于祖先目录的，其主目录的优先级最低。数组将被连接在一起。</p>
<p>目前，当从工作区调用时，Cargo不会从工作区的crates中读取配置文件，即如果一个工作区有两个crates，分别名为 <code>/projects/foo/bar/baz/mylib</code> 和 <code>/projects/foo/bar/baz/mybin</code> ，并且存在 <code>/projects/foo/bar/baz/mylib/.cargo/config.toml</code> 和 <code>/projects/foo/bar/baz/mybin/.cargo/config.toml</code> ，如果从工作区根(<code>/projects/foo/bar/baz/</code>)调用，Cargo就不会读取这些配置文件。</p>
<blockquote>
<p><strong>注意:</strong> Cargo 也可以读取没有 <code>.toml</code> 扩展名的配置文件，如<code>.cargo/config</code>。
对<code>.toml</code>扩展的支持是在1.39版本中加入的，是首选的形式。
如果两个文件都存在，Cargo 将使用没有扩展名的文件。</p>
</blockquote>
<h3 id="配置格式"><a class="header" href="#配置格式">配置格式</a></h3>
<p>配置文件是以 <a href="https://toml.io/">TOML格式</a> 编写的，在表内有简洁的键值对。以下是对所有设置的快速概述，详细说明见下文。</p>
<p>paths = [&quot;/path/to/override&quot;] # 路径依赖覆盖</p>
<p>[alias]     # 命令别名
b = &quot;build&quot;
c = &quot;check&quot;
t = &quot;test&quot;
r = &quot;run&quot;
rr = &quot;run --release&quot;
recursive_example = &quot;rr --example recursions&quot;
space_example = [&quot;run&quot;, &quot;--release&quot;, &quot;--&quot;, &quot;&quot;command list&quot;&quot;]</p>
<p>[build]
jobs = 1                      # 并行任务数, 默认为 CPU 数
rustc = &quot;rustc&quot;               # rust  编译器工具
rustc-wrapper = &quot;…&quot;           # 运行这个包装器，而不是 <code>rustc</code>
rustc-workspace-wrapper = &quot;…&quot; # 运行这个包装器，而不是 <code>rustc</code> ，对于工作区成员
rustdoc = &quot;rustdoc&quot;           # 文档生成工具
target = &quot;triple&quot;             # 构建 target triple (被 <code>cargo install</code> 忽略)
target-dir = &quot;target&quot;         # 放置所有生成制品的路径
rustflags = [&quot;…&quot;, &quot;…&quot;]        # 要传递给所有编译器调用的自定义标志
rustdocflags = [&quot;…&quot;, &quot;…&quot;]     # 传递给rustdoc的自定义标志
incremental = true            # 是否启用增量编译
dep-info-basedir = &quot;…&quot;        # 开发文件中目标的基础目录路径</p>
<p>[doc]
browser = &quot;chromium&quot;          # 与 <code>cargo doc --open</code> 一起使用的浏览器，覆盖 <code>BROWSER</code> 环境变量。</p>
<p><a href="reference/environment-variables.html">env</a></p>
<h1 id="为cargo运行的任何进程设置env_var_namevalue"><a class="header" href="#为cargo运行的任何进程设置env_var_namevalue">为Cargo运行的任何进程设置ENV_VAR_NAME=value</a></h1>
<p>ENV_VAR_NAME = &quot;value&quot;</p>
<h1 id="即使环境中已经存在也将设置"><a class="header" href="#即使环境中已经存在也将设置">即使环境中已经存在，也将设置</a></h1>
<p>ENV_VAR_NAME_2 = { value = &quot;value&quot;, force = true }</p>
<h1 id="该值是相对于包含-configtoml-的cargo目录而言的设置为绝对的"><a class="header" href="#该值是相对于包含-configtoml-的cargo目录而言的设置为绝对的">该值是相对于包含 <code>config.toml</code> 的.cargo目录而言的，设置为绝对的。</a></h1>
<p>ENV_VAR_NAME_3 = { value = &quot;relative/path&quot;, relative = true }</p>
<p>[future-incompat-report]
frequency = 'always' # 何时显示关于未来不兼容报告的通知</p>
<p>[cargo-new]
vcs = &quot;none&quot;              # VCS 便用 ('git', 'hg', 'pijul', 'fossil', 'none')</p>
<p>[http]
debug = false               # HTTP 调试
proxy = &quot;host:port&quot;         # libcurl格式的HTTP代理
ssl-version = &quot;tlsv1.3&quot;     # 要使用的TLS版本
ssl-version.max = &quot;tlsv1.3&quot; # TLS 最大版本
ssl-version.min = &quot;tlsv1.1&quot; # TLS 最小版本
timeout = 30                # 每个HTTP请求的超时，单位为秒
low-speed-limit = 10        # 网络超时阈值(字节/秒)。
cainfo = &quot;cert.pem&quot;         # CA证书绑定的路径
check-revoke = true         # 检查SSL证书是否被撤销
multiplexing = true         # HTTP/2 多路复用
user-agent = &quot;…&quot;            # user-agent 头</p>
<p>[install]
root = &quot;/some/path&quot;         # <code>cargo install</code> 目标目录</p>
<p>[net]
retry = 2                   # 网络重试
git-fetch-with-cli = true   # 使用 <code>git</code> 可执行文件进行git操作
offline = true              # 不接入网络</p>
<p>[patch.<registry>]</p>
<h1 id="与cargotoml中-patch-的键相同"><a class="header" href="#与cargotoml中-patch-的键相同">与Cargo.toml中 [patch] 的键相同。</a></h1>
<p>[profile.<name>]         # 通过配置来修改配置文件设置。
opt-level = 0            # 优化级别。
debug = true             # 包括调试信息。
split-debuginfo = '...'  # 调试信息拆分行为。
debug-assertions = true  # 启用调试断言。
overflow-checks = true   # 启用运行时的整数溢出检查。
lto = false              # 设置链接时优化。
panic = 'unwind'         # 恐慌策略。
incremental = true       # 增量编译。
codegen-units = 16       # 代码生成单元的数目。
rpath = false            # 设置rpath链接选项。
[profile.<name>.build-override]  # 覆盖build-script的设置。</p>
<h1 id="profile下的键是一样的"><a class="header" href="#profile下的键是一样的">profile下的键是一样的。</a></h1>
<p>[profile.<name>.package.<name>]  # 覆盖包的配置文件。</p>
<h1 id="profile下的键是一样的-减去-panic-lto-和-rpath"><a class="header" href="#profile下的键是一样的-减去-panic-lto-和-rpath">profile下的键是一样的 (减去 <code>panic</code>, <code>lto</code>, 和 <code>rpath</code>)。</a></h1>
<p>[registries.<name>]  # crates.io外的其他注册中心
index = &quot;…&quot;          # 注册中心的URL索引
token = &quot;…&quot;          # 注册中心的认证令牌</p>
<p>[registry]
default = &quot;…&quot;        # 默认注册中心的名称
token = &quot;…&quot;          # crates.io的认证令牌</p>
<p>[source.<name>]      # 源的定义和替换
replace-with = &quot;…&quot;   # 用给定命名的源替换这个源
directory = &quot;…&quot;      # 目录源的路径
registry = &quot;…&quot;       # 注册中心源的 URL
local-registry = &quot;…&quot; # 本地注册源的路径
git = &quot;…&quot;            # git 源的 URL
branch = &quot;…&quot;         # git仓库的分支名称
tag = &quot;…&quot;            # git仓库的tag名称
rev = &quot;…&quot;            # git仓库的修订</p>
<p>[target.<triple>]
linker = &quot;…&quot;            # 要使用的链接器
runner = &quot;…&quot;            # 运行可执行文件的包装器
rustflags = [&quot;…&quot;, &quot;…&quot;]  # <code>rustc</code> 的自定义标记</p>
<p>[target.<cfg>]
runner = &quot;…&quot;            # 运行可执行文件的包装器
rustflags = [&quot;…&quot;, &quot;…&quot;]  # <code>rustc</code> 的自定义标记</p>
<p>[target.<triple>.<links>] # <code>links</code> 构建脚本覆盖
rustc-link-lib = [&quot;foo&quot;]
rustc-link-search = [&quot;/path/to/foo&quot;]
rustc-flags = [&quot;-L&quot;, &quot;/some/path&quot;]
rustc-cfg = ['key=&quot;value&quot;']
rustc-env = {key = &quot;value&quot;}
rustc-cdylib-link-arg = [&quot;…&quot;]
metadata_key1 = &quot;value&quot;
metadata_key2 = &quot;value&quot;</p>
<p>[term]
quiet = false          # cargo是否输出静默
verbose = false        # cargo是否提供详细输出
color = 'auto'         # cargo是否着色输出
progress.when = 'auto' # cargo是否显示进度条
progress.width = 80    # 进度条的宽度</p>
<pre><code>
### 环境变量

除了TOML配置文件，Cargo还可以通过环境变量进行配置。对于每个形如 `foo.bar` 的配置键，也可以用环境变量 `CARGO_FOO_BAR` 定义值。
键被转换为大写字母，点和破折号被转换为下划线。例如，`target.x86_64-unknown-linux-gnu.runner` 键也可以由 `CARGO_TARGET_X86_64_UNKNOWN_LINUX_GNU_RUNNER` 环境变量定义。

环境变量将优先于TOML配置文件。目前只有整数、布尔值、字符串和一些数组值支持由环境变量定义。
[下面描述](#configuration-keys)表明哪些键支持环境变量，否则由于[技术问题](https://github.com/rust-lang/cargo/issues/5416)而不受支持。

除了上述系统外，Cargo还能识别一些其他特定的[环境变量][env]。

### 命令行覆盖

Cargo也可以通过 `--config` 命令行选项接受任意的配置覆盖。参数应是TOML语法中的 &quot;KEY=VALUE&quot; 。

```console
cargo --config net.git-fetch-with-cli=true fetch
</code></pre>
<p><code>--config</code> 选项可以被多次指定，在这种情况下，这些值将按照从左到右的顺序合并，使用与适用多个配置文件时相同的合并逻辑。
以这种方式指定的配置值优先于环境变量，环境变量优先于配置文件。</p>
<p>一些看起像什么Bourne shell语法使用的例子:</p>
<pre><code class="language-console"># 多数 shells 请求将转义。
cargo --config http.proxy=\&quot;http://example.com\&quot; …

# 可以使用空格。
cargo --config &quot;net.git-fetch-with-cli = true&quot; …

# TOML数组例子。单引号使其更容易读写。
cargo --config 'build.rustdocflags = [&quot;--html-in-header&quot;, &quot;header.html&quot;]' …

# 一个复杂的TOML键的例子。
cargo --config &quot;target.'cfg(all(target_arch = \&quot;arm\&quot;, target_os = \&quot;none\&quot;))'.runner = 'my-runner'&quot; …

# 覆盖一个配置文件设置的例子。
cargo --config profile.dev.package.image.opt-level=3 …
</code></pre>
<p><code>--config</code> 选项也可以用来传递额外的配置文件的路径，Cargo应该在特定的调用中使用这些文件。
通过这种方式加载的配置文件中的选项与直接用 <code>--config</code> 指定的其他选项遵循同样的优先级规则。</p>
<h3 id="config相对路径"><a class="header" href="#config相对路径">Config相对路径</a></h3>
<p>配置文件中的路径可以是绝对的、相对的，或者是没有任何路径分隔符的无修饰名称。
没有路径分隔符的可执行文件的路径将使用 <code>PATH</code> 环境变量来搜索可执行文件。
非可执行文件的路径将相对于配置值定义位置。</p>
<p>具体来说，规则是:</p>
<ul>
<li>对于环境变量，路径是相对于当前工作目录的。</li>
<li>对于直接从 <a href="reference/config.html#command-line-overrides"><code>--config KEY=VALUE</code></a> 选项加载的配置值，路径是相对于当前工作目录的。</li>
<li>对于配置文件，路径是相对于定义配置文件的目录的父目录而言的，无论这些文件是来自 <a href="reference/config.html#hierarchical-structure">层级检索</a> 还是 <a href="reference/config.html#command-line-overrides"><code>--config &lt;path&gt;</code></a> 选项。</li>
</ul>
<blockquote>
<p><strong>注意:</strong> 为了与现有的 <code>.cargo/config.toml</code> 检索行为保持一致，在设计上，通过 <code>--config &lt;path&gt;</code> 传递的配置文件中的路径也是相对于配置文件本身两级。
为了避免意外的结果，经验方法是把你的额外配置文件放在项目中发现的 <code>.cargo/config.toml</code> 的同一级别。
例如，给定项目 <code>/my/project</code> ，建议把配置文件放在 <code>/my/project/.cargo</code> 下，或者在同一级别上新建一个目录，如 <code>/my/project/.config</code> 。</p>
</blockquote>
<pre><code class="language-toml"># 相对路径例子。

[target.x86_64-unknown-linux-gnu]
runner = &quot;foo&quot;  # 在 `PATH` 中搜索 `foo` .

[source.vendored-sources]
# 目录是相对于 `.cargo/config.toml` 所在的父目录而言的。
# 比如, `/my/project/.cargo/config.toml` 会在 `/my/project/vendor` 。
directory = &quot;vendor&quot;
</code></pre>
<h3 id="带参数的可执行路径"><a class="header" href="#带参数的可执行路径">带参数的可执行路径</a></h3>
<p>一些Cargo命令调用外部程序，可以将其配置为路径和一些参数。</p>
<p>该值可以是一个字符串数组，如 <code>['/path/to/program', 'somearg']</code> 或一个空格分隔的字符串，如 <code>'/path/to/program somearg'</code> 。如果可执行文件的路径包含一个空格，则必须使用列表形式。</p>
<p>如果Cargo向程序传递其他参数，比如打开或运行的路径，它们将在这种格式的选项值中最后指定的参数之后传递。如果指定的程序没有路径分隔符，Cargo会在 <code>PATH</code> 中搜索其可执行文件。</p>
<h3 id="证书"><a class="header" href="#证书">证书</a></h3>
<p>带有敏感信息的配置值存储在 <code>$CARGO_HOME/credentials.toml</code> 文件中。这个文件由 <a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> 自动创建和更新。它遵循与Cargo配置文件相同的格式。</p>
<pre><code class="language-toml">[registry]
token = &quot;…&quot;   # crates.io 访问 token

[registries.&lt;name&gt;]
token = &quot;…&quot;   # 具名注册中心访问 token
</code></pre>
<p>一些Cargo命令使用令牌，例如<a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a>，用于与远程注册中心进行认证。应该注意保护令牌，使其私密。</p>
<p>与其他大多数配置值一样，令牌可以用环境变量来指定。
<a href="https://crates.io/">crates.io</a>的令牌可以用 <code>CARGO_REGISTRY_TOKEN</code> 环境变量来指定。
其他注册中心的令牌可以用 <code>CARGO_REGISTRIES_&lt;name&gt;_TOKEN</code> 形式的环境变量来指定，其中 <code>&lt;name&gt;</code> 是大写的注册中心的名称。</p>
<h3 id="配置键"><a class="header" href="#配置键">配置键</a></h3>
<p>本节记录了所有的配置键。带有可变部分的键的描述用角括号标注，如 <code>target.&lt;triple&gt;</code> ，其中 <code>&lt;triple&gt;</code> 部分可以是任何目标三元组，如 <code>target.x86_64-pc-windows-msvc</code> 。</p>
<h4 id="paths"><a class="header" href="#paths"><code>paths</code></a></h4>
<ul>
<li>Type: 字符串数组 (paths)</li>
<li>Default: none</li>
<li>Environment: 不受支持</li>
</ul>
<p>一个本地包的路径数组，这些包将被用作依赖覆盖。
更多信息请参阅 <a href="reference/overriding-dependencies.html#paths-overrides">覆盖依赖指南</a> 。</p>
<h4 id="alias"><a class="header" href="#alias"><code>[alias]</code></a></h4>
<ul>
<li>Type: 字符串或字符串数组</li>
<li>Default: 参阅下面</li>
<li>Environment: <code>CARGO_ALIAS_&lt;name&gt;</code></li>
</ul>
<p><code>[alias]</code> 表定义了CLI命令的别名。例如，运行 <code>cargo b</code> 是运行 <code>cargo build</code> 的别名。表中的每个键是子命令，而值是实际要运行的命令。
值可以是一个字符串数组，其中第一个元素是命令，后面的元素是参数。它也可以是一个字符串，它将在空格处被分割成子命令和参数。以下是Cargo内置的别名。</p>
<pre><code class="language-toml">[alias]
b = &quot;build&quot;
c = &quot;check&quot;
d = &quot;doc&quot;
t = &quot;test&quot;
r = &quot;run&quot;
rm = &quot;remove&quot;
</code></pre>
<p>别名不允许重新定义现有的内置命令。</p>
<p>别名可递归:</p>
<pre><code class="language-toml">[alias]
rr = &quot;run --release&quot;
recursive_example = &quot;rr --example recursions&quot;
</code></pre>
<h4 id="build"><a class="header" href="#build"><code>[build]</code></a></h4>
<p><code>[build]</code> 表控制构建时的操作和编译器设置。</p>
<h5 id="buildjobs"><a class="header" href="#buildjobs"><code>build.jobs</code></a></h5>
<ul>
<li>Type: 整数</li>
<li>Default: 逻辑CPU的数量</li>
<li>Environment: <code>CARGO_BUILD_JOBS</code></li>
</ul>
<p>设定并行运行的最大编译器进程数。如果是负数，它将编译器进程的最大数量设置为逻辑CPU的数量加上所提供的值。不应该是0。</p>
<p>可以用 <code>--jobs</code> CLI选项覆盖。</p>
<h5 id="buildrustc"><a class="header" href="#buildrustc"><code>build.rustc</code></a></h5>
<ul>
<li>Type: 字符串 (程序路径)</li>
<li>Default: &quot;rustc&quot;</li>
<li>Environment: <code>CARGO_BUILD_RUSTC</code> 或 <code>RUSTC</code></li>
</ul>
<p>设置用于 <code>rustc</code> 的可执行文件。</p>
<h5 id="buildrustc-wrapper"><a class="header" href="#buildrustc-wrapper"><code>build.rustc-wrapper</code></a></h5>
<ul>
<li>Type: 字符串 (程序路径)</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_BUILD_RUSTC_WRAPPER</code> 或 <code>RUSTC_WRAPPER</code></li>
</ul>
<p>设置包装器来代替 <code>rustc</code> 执行。传递给包装器的第一个参数是要使用的实际可执行文件的路径(即 <code>build.rustc</code> ，如果它被设置了，或者 <code>&quot;rustc&quot;</code> 以其它方式)。</p>
<h5 id="buildrustc-workspace-wrapper"><a class="header" href="#buildrustc-workspace-wrapper"><code>build.rustc-workspace-wrapper</code></a></h5>
<ul>
<li>Type: 字符串 (程序路径)</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_BUILD_RUSTC_WORKSPACE_WRAPPER</code> 或 <code>RUSTC_WORKSPACE_WRAPPER</code></li>
</ul>
<p>设置包装器来代替 <code>rustc</code> 执行，仅适用于工作区成员。
传递给包装器的第一个参数是要使用的实际可执行文件的路径(即<code>build.rustc</code>，如果它被设置了，或 <code>&quot;rustc&quot;</code> 以其它方式)。
它影响文件名hash，以便包装器产生的制品被单独缓存。</p>
<h5 id="buildrustdoc"><a class="header" href="#buildrustdoc"><code>build.rustdoc</code></a></h5>
<ul>
<li>Type: 字符串 (程序路径)</li>
<li>Default: &quot;rustdoc&quot;</li>
<li>Environment: <code>CARGO_BUILD_RUSTDOC</code> 或 <code>RUSTDOC</code></li>
</ul>
<p>设置用于 <code>rustdoc</code> 的可执行文件。</p>
<h5 id="buildtarget"><a class="header" href="#buildtarget"><code>build.target</code></a></h5>
<ul>
<li>Type: 字符串或字符串数组</li>
<li>Default: 主机平台</li>
<li>Environment: <code>CARGO_BUILD_TARGET</code></li>
</ul>
<p>默认的目标平台三元组编译。</p>
<p>这允许传递字符串或字符串数组。每个字符串值是目标平台三元组。将为每个选定的架构构建目标。</p>
<p>该字符串值也可以是 <code>.json</code> 目标规格文件的相对路径。</p>
<p>可以用 <code>--target</code> CLI选项覆盖。</p>
<pre><code class="language-toml">[build]
target = [&quot;x86_64-unknown-linux-gnu&quot;, &quot;i686-unknown-linux-gnu&quot;]
</code></pre>
<h5 id="buildtarget-dir"><a class="header" href="#buildtarget-dir"><code>build.target-dir</code></a></h5>
<ul>
<li>Type: 字符路 (path)</li>
<li>Default: &quot;target&quot;</li>
<li>Environment: <code>CARGO_BUILD_TARGET_DIR</code> 或 <code>CARGO_TARGET_DIR</code></li>
</ul>
<p>放置所有编译器输出的路径。如果没有指定，默认是位于工作区根的名为 <code>target</code> 的目录。</p>
<p>可以用 <code>--target-dir</code> CLI选项覆盖。</p>
<h5 id="buildrustflags"><a class="header" href="#buildrustflags"><code>build.rustflags</code></a></h5>
<ul>
<li>Type: 字符串或字符串数组</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_BUILD_RUSTFLAGS</code> 或 <code>CARGO_ENCODED_RUSTFLAGS</code> 或 <code>RUSTFLAGS</code></li>
</ul>
<p>额外的命令行标志，传递给 <code>rustc</code> 。该值可以是字符串数组或以空格分隔的字符串。</p>
<p>有四个互相排斥的额外标志源，依次检查，首先使用第一个:</p>
<ol>
<li><code>CARGO_ENCODED_RUSTFLAGS</code> 环境变量。</li>
<li><code>RUSTFLAGS</code>  环境变量。</li>
<li>所有匹配的 <code>target.&lt;triple&gt;.rustflags</code> 和 <code>target.&lt;cfg&gt;.rustflags</code> 配置项连接在一起。</li>
<li><code>build.rustflags</code> 配置值。</li>
</ol>
<p>额外的标志也可以通过 <a href="reference/../commands/cargo-rustc.html"><code>cargo rustc</code></a> 命令传递。</p>
<p>如果使用 <code>--target</code> 标志(或<a href="reference/config.html#buildtarget"><code>build.target</code></a>)，那么这些标志将只传递给目标的编译器。为主机构建的东西，如构建脚本或proc macros，将不会收到这些args。
如果不使用 <code>--target</code> ，标志将被传递给所有编译器调用(包括构建脚本和proc macros)，因为依赖是共享的。
如果你有不想传递给构建脚本或proc macros的args，并且是为主机构建的，请将 <code>--target</code> 与主机三元组一起传递。</p>
<p>我们不建议传入Cargo本身通常管理的标志。
例如，由<a href="reference/profiles.html">profiles</a>决定的标志，最好通过设置适当的配置文件来处理。</p>
<blockquote>
<p><strong>警告</strong>: 由于直接向编译器传递标志的低阶特性，这可能会与未来版本的Cargo产生冲突，后者可能会自行发布相同或类似的标志，这可能会干扰你指定的标志。
这是Cargo可能总是不会向后兼容的领域。</p>
</blockquote>
<h5 id="buildrustdocflags"><a class="header" href="#buildrustdocflags"><code>build.rustdocflags</code></a></h5>
<ul>
<li>Type: 字符串或字符串数组</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_BUILD_RUSTDOCFLAGS</code> 或 <code>CARGO_ENCODED_RUSTDOCFLAGS</code> 或 <code>RUSTDOCFLAGS</code></li>
</ul>
<p>额外的命令行标志，传递给 <code>rustdoc</code> 。该值可以是字符串数组或以空格分隔的字符串。</p>
<p>有三个相互排斥的额外标志源。依次检查它们，首先使用第一个。</p>
<ol>
<li><code>CARGO_ENCODED_RUSTDOCFLAGS</code> 环境变量。</li>
<li><code>RUSTDOCFLAGS</code> 环境变量。</li>
<li><code>build.rustdocflags</code> 配置值。</li>
</ol>
<p>附加标志也可以通过 <a href="reference/../commands/cargo-rustdoc.html"><code>cargo rustdoc</code></a> 命令传递。</p>
<h5 id="buildincremental"><a class="header" href="#buildincremental"><code>build.incremental</code></a></h5>
<ul>
<li>Type: bool</li>
<li>Default: 来自配置文件</li>
<li>Environment: <code>CARGO_BUILD_INCREMENTAL</code> 或 <code>CARGO_INCREMENTAL</code></li>
</ul>
<p>是否执行[增量编译]。如果没有设置，默认是使用 <a href="reference/profiles.html#incremental">profile</a> 中的值。否则这将覆盖所有配置文件的设置。</p>
<p><code>CARGO_INCREMENTAL</code> 环境变量可以设置为 <code>1</code> 以强制启用所有配置文件的增量编译，或 <code>0</code> 以禁用它。这个环境变量覆盖配置设置。</p>
<h5 id="builddep-info-basedir"><a class="header" href="#builddep-info-basedir"><code>build.dep-info-basedir</code></a></h5>
<ul>
<li>Type: 字符串 (path)</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_BUILD_DEP_INFO_BASEDIR</code></li>
</ul>
<p>从<a href="reference/../guide/build-cache.html#dep-info-files">dep info</a>文件路径中分割指定的路径前缀。
这个配置的目的是为需要相对路径的工具，将绝对路径转换成相对路径。</p>
<p>这个设置自身是与配置相对的路径。举例来说，<code>&quot;.&quot;</code> 的值将分割所有以 <code>.cargo</code> 目录的父目录为起点的路径。</p>
<h5 id="buildpipelining"><a class="header" href="#buildpipelining"><code>build.pipelining</code></a></h5>
<p>这个选项已被废弃，未使用。Cargo总是启用流水线。</p>
<h4 id="doc"><a class="header" href="#doc"><code>[doc]</code></a></h4>
<p><code>[doc]</code> 表定义了 <a href="reference/../commands/cargo-doc.html"><code>cargo doc</code></a> 命令的选项。</p>
<h5 id="docbrowser"><a class="header" href="#docbrowser"><code>doc.browser</code></a></h5>
<ul>
<li>Type: 字符串或字符串数组 (<a href="reference/config.html#executable-paths-with-arguments">带参数的程序路径</a>)</li>
<li>Default: <code>BROWSER</code> 环境变量，如果缺少该变量，则以系统特定的方式打开链接</li>
</ul>
<p>这个选项设置 <a href="reference/../commands/cargo-doc.html"><code>cargo doc</code></a> 使用的浏览器，在用 <code>--open</code> 选项打开文档时，覆盖 <code>BROWSER</code> 环境变量。</p>
<h4 id="cargo-new"><a class="header" href="#cargo-new"><code>[cargo-new]</code></a></h4>
<p><code>[cargo-new]</code> 表定义了 <a href="reference/../commands/cargo-new.html"><code>cargo new</code></a> 命令的默认值。</p>
<h5 id="cargo-newname"><a class="header" href="#cargo-newname"><code>cargo-new.name</code></a></h5>
<p>该选项已被废弃，未被使用。</p>
<h5 id="cargo-newemail"><a class="header" href="#cargo-newemail"><code>cargo-new.email</code></a></h5>
<p>该选项已被废弃，未被使用。</p>
<h5 id="cargo-newvcs"><a class="header" href="#cargo-newvcs"><code>cargo-new.vcs</code></a></h5>
<ul>
<li>Type: 字符串</li>
<li>Default: &quot;git&quot; 或 &quot;none&quot;</li>
<li>Environment: <code>CARGO_CARGO_NEW_VCS</code></li>
</ul>
<p>指定初始化新版本库时使用的源码控制系统。
有效值是 <code>git</code> 、 <code>hg</code> (用于Mercurial) 、 <code>pijul</code>  、 <code>fossil</code> ，或 <code>none</code> 以禁用此行为。默认为 <code>git</code> ，如果已经在一个VCS仓库内，则默认为 <code>none</code> 。可以用 <code>--vcs</code> CLI选项来覆盖。</p>
<h3 id="env"><a class="header" href="#env"><code>[env]</code></a></h3>
<p><code>[env]</code> 部分允许你为构建脚本、rustc调用、 <code>cargo run</code> 和 <code>cargo build</code> 设置附加的环境变量。</p>
<pre><code class="language-toml">[env]
OPENSSL_DIR = &quot;/opt/openssl&quot;
</code></pre>
<p>默认情况下，指定的变量将不会覆盖环境中已经存在的值。可以通过设置 <code>force</code> 标志来改变这种行为。</p>
<p>设置 <code>relative</code> 标志会将该值评估为相对配置路径，它是相对于包含<code>config.toml</code> 文件的 <code>.cargo</code> 目录的父目录而言的。环境变量的值将是完整的绝对路径。</p>
<pre><code class="language-toml">[env]
TMPDIR = { value = &quot;/home/tmp&quot;, force = true }
OPENSSL_DIR = { value = &quot;vendor/openssl&quot;, relative = true }
</code></pre>
<h3 id="future-incompat-report"><a class="header" href="#future-incompat-report"><code>[future-incompat-report]</code></a></h3>
<p><code>[future-incompat-report]</code> 表控制 <a href="reference/future-incompat-report.html">未来不匹配的报告</a> 的设置。</p>
<h4 id="future-incompat-reportfrequency"><a class="header" href="#future-incompat-reportfrequency"><code>future-incompat-report.frequency</code></a></h4>
<ul>
<li>Type: 字符串</li>
<li>Default: &quot;always&quot;</li>
<li>Environment: <code>CARGO_FUTURE_INCOMPAT_REPORT_FREQUENCY</code></li>
</ul>
<p>控制当未来不兼容报告可用时，多长时间向终端显示一次通知。可能的值为:</p>
<ul>
<li><code>always</code> (默认): 当命令(例如 <code>cargo build</code>)产生未来不兼容报告时，总是显示通知。</li>
<li><code>never</code>: 永不显示通知</li>
</ul>
<h4 id="http"><a class="header" href="#http"><code>[http]</code></a></h4>
<p><code>[http]</code> 表定义了HTTP行为设置。包括获取crate的依赖和访问远程git仓库。</p>
<h5 id="httpdebug"><a class="header" href="#httpdebug"><code>http.debug</code></a></h5>
<ul>
<li>Type: boolean</li>
<li>Default: false</li>
<li>Environment: <code>CARGO_HTTP_DEBUG</code></li>
</ul>
<p>如果 <code>true</code> ，启用对HTTP请求的调试。调试信息可以通过设置 <code>CARGO_LOG=cargo::ops::registry=debug</code> 环境变量查看(或者使用 <code>trace</code> 获取更多信息) 。</p>
<p>当把这个输出的日志发布到公开位置时，要小心谨慎。该输出可能包括带有认证令牌的头信息，你不希望泄漏这些信息。在发布日志之前，一定要审查日志。</p>
<h5 id="httpproxy"><a class="header" href="#httpproxy"><code>http.proxy</code></a></h5>
<ul>
<li>Type: 字符串</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_HTTP_PROXY</code> 或 <code>HTTPS_PROXY</code> 或 <code>https_proxy</code> 或 <code>http_proxy</code></li>
</ul>
<p>设置一个要使用的HTTP和HTTPS代理。其格式为 [libcurl格式] ，如 <code>[protocol://]host[:port]</code> 。
如果没有设置，Cargo也会检查你全局git配置中的 <code>http.proxy</code> 设置。
如果这些都没有设置， <code>HTTPS_PROXY</code> 或 <code>https_proxy</code> 环境变量为HTTPS请求设置代理， <code>http_proxy</code> 为HTTP请求设置。</p>
<h5 id="httptimeout"><a class="header" href="#httptimeout"><code>http.timeout</code></a></h5>
<ul>
<li>Type: 整数</li>
<li>Default: 30</li>
<li>Environment: <code>CARGO_HTTP_TIMEOUT</code> 或 <code>HTTP_TIMEOUT</code></li>
</ul>
<p>设置每个HTTP请求的超时，单位为秒。</p>
<h5 id="httpcainfo"><a class="header" href="#httpcainfo"><code>http.cainfo</code></a></h5>
<ul>
<li>Type: 字符串 (path)</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_HTTP_CAINFO</code></li>
</ul>
<p>CA证书绑定文件的路径，用于验证TLS证书。如果没有指定，Cargo会尝试使用系统证书。</p>
<h5 id="httpcheck-revoke"><a class="header" href="#httpcheck-revoke"><code>http.check-revoke</code></a></h5>
<ul>
<li>Type: boolean</li>
<li>Default: true (Windows) false (all others)</li>
<li>Environment: <code>CARGO_HTTP_CHECK_REVOKE</code></li>
</ul>
<p>这决定了是否应该进行TLS证书撤销检查。仅适用于Windows。</p>
<h5 id="httpssl-version"><a class="header" href="#httpssl-version"><code>http.ssl-version</code></a></h5>
<ul>
<li>Type: string 或 min/max table</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_HTTP_SSL_VERSION</code></li>
</ul>
<p>此设置要使用的最小TLS版本。它需要一个字符串，可能的值是 &quot;default&quot;、&quot;tlsv1&quot;、&quot;tlsv1.0&quot;、&quot;tlsv1.1&quot;、&quot;tlsv1.2&quot;、&quot;tlsv1.3&quot; 之一。</p>
<p>这可能是有两个键的表，<code>min</code> 和 <code>max</code> ，每个键都有相同的字符串值，指定要使用的TLS版本的最小和最大范围。</p>
<p>默认情况下，最小版本为 &quot;tlsv1.0&quot; ，最大版本为你的平台上支持的最新版本，通常为 &quot;tlsv1.3&quot; 。</p>
<h5 id="httplow-speed-limit"><a class="header" href="#httplow-speed-limit"><code>http.low-speed-limit</code></a></h5>
<ul>
<li>Type: 整数</li>
<li>Default: 10</li>
<li>Environment: <code>CARGO_HTTP_LOW_SPEED_LIMIT</code></li>
</ul>
<p>此设置控制过慢连接超时行为。
如果以字节/秒为单位的平均传输速度低于<a href="reference/config.html#httptimeout"><code>http.timeout</code></a>秒的给定值(默认为30秒)，那么该连接被认为太慢，Cargo将中止并重试。</p>
<h5 id="httpmultiplexing"><a class="header" href="#httpmultiplexing"><code>http.multiplexing</code></a></h5>
<ul>
<li>Type: boolean</li>
<li>Default: true</li>
<li>Environment: <code>CARGO_HTTP_MULTIPLEXING</code></li>
</ul>
<p>当 <code>true</code> 时，Cargo将尝试使用多路复用的HTTP2协议。
这允许多个请求使用同一个连接，通常可以提高获取多文件的性能。
如果 <code>false</code> ，Cargo将使用HTTP1.1，没有管道。</p>
<h5 id="httpuser-agent"><a class="header" href="#httpuser-agent"><code>http.user-agent</code></a></h5>
<ul>
<li>Type: 字符串</li>
<li>Default: Cargo的版本</li>
<li>Environment: <code>CARGO_HTTP_USER_AGENT</code></li>
</ul>
<p>指定要使用的自定义user-agent header。如果没有指定，默认是一个包括Cargo版本的字符串。</p>
<h4 id="install"><a class="header" href="#install"><code>[install]</code></a></h4>
<p><code>[install]</code> 表定义了 <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 命令的默认值。</p>
<h5 id="installroot"><a class="header" href="#installroot"><code>install.root</code></a></h5>
<ul>
<li>Type: 字符串 (path)</li>
<li>Default: Cargo的主目录</li>
<li>Environment: <code>CARGO_INSTALL_ROOT</code></li>
</ul>
<p>为 <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 设置安装可执行文件的根目录的路径。可执行文件会进入根目录下的 <code>bin</code> 目录。</p>
<p>为了跟踪已安装的可执行文件的信息，一些附加文件，如 <code>.crates.toml</code> 和 <code>.crates2.json</code> 也会在这个根下创建。</p>
<p>如果没有指定，默认是Cargo的主目录 (默认为你的主目录中 <code>.cargo</code> ) 。</p>
<p>可以用 <code>--root</code> 命令行选项来覆盖。</p>
<h4 id="net"><a class="header" href="#net"><code>[net]</code></a></h4>
<p><code>[net]</code> 表控制网络配置。</p>
<h5 id="netretry"><a class="header" href="#netretry"><code>net.retry</code></a></h5>
<ul>
<li>Type: 整数</li>
<li>Default: 2</li>
<li>Environment: <code>CARGO_NET_RETRY</code></li>
</ul>
<p>可能是虚假网络的错误重试次数。</p>
<h5 id="netgit-fetch-with-cli"><a class="header" href="#netgit-fetch-with-cli"><code>net.git-fetch-with-cli</code></a></h5>
<ul>
<li>Type: boolean</li>
<li>Default: false</li>
<li>Environment: <code>CARGO_NET_GIT_FETCH_WITH_CLI</code></li>
</ul>
<p>如果这是 <code>true</code> ，那么Cargo将使用 <code>git</code> 可执行程序来获取注册中心索引和git依赖。如果是 <code>false</code> ，那么它将使用内置的 <code>git</code> 库。</p>
<p>如果你有特殊的认证要求，而Cargo不支持的话，将此设置为 <code>true</code> 会有帮助。
参阅 <a href="reference/../appendix/git-authentication.html">Git Authentication</a>以了解更多关于设置git认证的信息。</p>
<h5 id="netoffline"><a class="header" href="#netoffline"><code>net.offline</code></a></h5>
<ul>
<li>Type: boolean</li>
<li>Default: false</li>
<li>Environment: <code>CARGO_NET_OFFLINE</code></li>
</ul>
<p>如果是 <code>true</code> ，那么Cargo将避免访问网络，并尝试使用本地缓存的数据。
如果是 <code>false</code> ，Cargo将根据需要访问网络，如果遇到网络错误，将产生一个错误。</p>
<p>可以用 <code>--offline</code> 命令行选项来覆盖。</p>
<h4 id="patch"><a class="header" href="#patch"><code>[patch]</code></a></h4>
<p>就像你可以用<a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code> in <code>Cargo.toml</code></a>覆盖依赖一样，
你可以在cargo配置文件中覆盖它们，将这些补丁应用于任何受影响的构建。其格式与 <code>Cargo.toml</code> 中的格式相同。</p>
<p>由于 <code>.cargo/config.toml</code> 文件通常不会被检查到源代码控制中，你应该尽可能选择使用 <code>Cargo.toml</code> 来打补丁，以确保其他开发者可以在自己的环境中编译你的crate。
一般来说，只有当补丁部分由外部构建工具自动生成时，通过cargo配置文件进行修补才是合适的。</p>
<p>如果特定的依赖在cargo配置文件和 <code>Cargo.toml</code> 文件中都有补丁，则使用配置文件中的补丁。
如果多个配置文件对同一个依赖打了补丁，则使用标准的cargo配置合并，它更倾向于使用离当前目录最近的定义值。
<code>$HOME/.cargo/config.toml</code> 的优先级最低。</p>
<p>在这样的 <code>[patch]</code> 部分中的相对 <code>path</code> 依赖是相对于它们出现配置文件的。</p>
<h4 id="profile"><a class="header" href="#profile"><code>[profile]</code></a></h4>
<p><code>[profile]</code> 表可以用来全局改变配置文件的设置，并覆盖 <code>Cargo.toml</code> 中指定的设置。
它的语法和选项与 <code>Cargo.toml</code> 中指定的配置文件相同。
关于选项的详细信息，请参阅 [配置文件章节] 。</p>
<h5 id="profilenamebuild-override"><a class="header" href="#profilenamebuild-override"><code>[profile.&lt;name&gt;.build-override]</code></a></h5>
<ul>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_BUILD_OVERRIDE_&lt;key&gt;</code></li>
</ul>
<p>构建覆盖表覆盖构建脚本、进程宏和其依赖的设置。
它的键值与普通配置文件相同。
参见 <a href="reference/profiles.html#overrides">覆盖部分</a> 以了解更多细节。</p>
<h5 id="profilenamepackagename"><a class="header" href="#profilenamepackagename"><code>[profile.&lt;name&gt;.package.&lt;name&gt;]</code></a></h5>
<ul>
<li>Environment: 不支持</li>
</ul>
<p>包表覆盖特定包的设置。
它和普通的配置文件有相同的键，除 <code>panic</code> 、 <code>lto</code> 和 <code>rpath</code> 设置。
参阅 <a href="reference/profiles.html#overrides">overrides section</a> 以了解更多细节。</p>
<h5 id="profilenamecodegen-units"><a class="header" href="#profilenamecodegen-units"><code>profile.&lt;name&gt;.codegen-units</code></a></h5>
<ul>
<li>Type: 整数</li>
<li>Default: 参阅配置文件文档。</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_CODEGEN_UNITS</code></li>
</ul>
<p>参阅 <a href="reference/profiles.html#codegen-units">codegen-units</a> 。</p>
<h5 id="profilenamedebug"><a class="header" href="#profilenamedebug"><code>profile.&lt;name&gt;.debug</code></a></h5>
<ul>
<li>Type: 整数或布尔</li>
<li>Default: 参阅配置文件文档。</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_DEBUG</code></li>
</ul>
<p>参阅 <a href="reference/profiles.html#debug">debug</a>。</p>
<h5 id="profilenamesplit-debuginfo"><a class="header" href="#profilenamesplit-debuginfo"><code>profile.&lt;name&gt;.split-debuginfo</code></a></h5>
<ul>
<li>Type: 字符串</li>
<li>Default: 参阅配置文件文档。</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_SPLIT_DEBUGINFO</code></li>
</ul>
<p>参阅 <a href="reference/profiles.html#split-debuginfo">split-debuginfo</a>。</p>
<h5 id="profilenamedebug-assertions"><a class="header" href="#profilenamedebug-assertions"><code>profile.&lt;name&gt;.debug-assertions</code></a></h5>
<ul>
<li>Type: 布尔</li>
<li>Default: 参阅配置文件文档。</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_DEBUG_ASSERTIONS</code></li>
</ul>
<p>参阅 <a href="reference/profiles.html#debug-assertions">debug-assertions</a>。</p>
<h5 id="profilenameincremental"><a class="header" href="#profilenameincremental"><code>profile.&lt;name&gt;.incremental</code></a></h5>
<ul>
<li>Type: 布尔</li>
<li>Default: 参阅配置文件文档。</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_INCREMENTAL</code></li>
</ul>
<p>参阅 <a href="reference/profiles.html#incremental">incremental</a>.</p>
<h5 id="profilenamelto"><a class="header" href="#profilenamelto"><code>profile.&lt;name&gt;.lto</code></a></h5>
<ul>
<li>Type: 字符串或布尔</li>
<li>Default: 参阅配置文件文档。</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_LTO</code></li>
</ul>
<p>参阅 <a href="reference/profiles.html#lto">lto</a> 。</p>
<h5 id="profilenameoverflow-checks"><a class="header" href="#profilenameoverflow-checks"><code>profile.&lt;name&gt;.overflow-checks</code></a></h5>
<ul>
<li>Type: 布尔</li>
<li>Default: 参阅配置文件文档。</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_OVERFLOW_CHECKS</code></li>
</ul>
<p>参阅 <a href="reference/profiles.html#overflow-checks">overflow-checks</a> 。</p>
<h5 id="profilenameopt-level"><a class="header" href="#profilenameopt-level"><code>profile.&lt;name&gt;.opt-level</code></a></h5>
<ul>
<li>Type: 字符串或布尔</li>
<li>Default: 参阅配置文件文档。</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_OPT_LEVEL</code></li>
</ul>
<p>参阅 <a href="reference/profiles.html#opt-level">opt-level</a> 。</p>
<h5 id="profilenamepanic"><a class="header" href="#profilenamepanic"><code>profile.&lt;name&gt;.panic</code></a></h5>
<ul>
<li>Type: 字符串</li>
<li>default: 参阅配置文件文档。</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_PANIC</code></li>
</ul>
<p>参阅 <a href="reference/profiles.html#panic">panic</a> 。</p>
<h5 id="profilenamerpath"><a class="header" href="#profilenamerpath"><code>profile.&lt;name&gt;.rpath</code></a></h5>
<ul>
<li>Type: 布尔</li>
<li>default: 参阅配置文件文档。</li>
<li>Environment: <code>CARGO_PROFILE_&lt;name&gt;_RPATH</code></li>
</ul>
<p>参阅 <a href="reference/profiles.html#rpath">rpath</a> 。</p>
<h4 id="registries"><a class="header" href="#registries"><code>[registries]</code></a></h4>
<p><code>[注册表]</code> 表用于指定附加的[注册中心]。
它由各个命名的注册中心的子表组成。</p>
<h5 id="registriesnameindex"><a class="header" href="#registriesnameindex"><code>registries.&lt;name&gt;.index</code></a></h5>
<ul>
<li>Type: 字符串 (url)</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_REGISTRIES_&lt;name&gt;_INDEX</code></li>
</ul>
<p>指定注册中心git索引的URL。</p>
<h5 id="registriesnametoken"><a class="header" href="#registriesnametoken"><code>registries.&lt;name&gt;.token</code></a></h5>
<ul>
<li>Type: 字符串</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_REGISTRIES_&lt;name&gt;_TOKEN</code></li>
</ul>
<p>指定给定注册中心的认证令牌。
这个值应该只出现在 <a href="reference/config.html#credentials">credentials</a> 文件中。
这用于需要认证的注册中心命令，如 <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> 。</p>
<p>可以用 <code>--token</code> 命令行选项来覆盖。</p>
<h4 id="registry"><a class="header" href="#registry"><code>[registry]</code></a></h4>
<p><code>[注册中心]</code> 表控制在没有指定的情况下使用的默认注册中心。</p>
<h5 id="registryindex"><a class="header" href="#registryindex"><code>registry.index</code></a></h5>
<p>不再接受此值，不应使用。</p>
<h5 id="registrydefault"><a class="header" href="#registrydefault"><code>registry.default</code></a></h5>
<ul>
<li>Type: 字符串</li>
<li>Default: <code>&quot;crates-io&quot;</code></li>
<li>Environment: <code>CARGO_REGISTRY_DEFAULT</code></li>
</ul>
<p>注册中心的名称(来自<a href="reference/config.html#registries"> <code>registries</code> 表</a>)，默认用于 <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> 等注册中心命令。</p>
<p>可以用 <code>--registry</code> 命令行选项来覆盖。</p>
<h5 id="registrytoken"><a class="header" href="#registrytoken"><code>registry.token</code></a></h5>
<ul>
<li>Type: 字符串</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_REGISTRY_TOKEN</code></li>
</ul>
<p>指定 <a href="https://crates.io/">crates.io</a> 的认证令牌。
这个值应该只出现在 <a href="reference/config.html#credentials">credentials</a> 文件中。
这用于像 <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> 这样的需要认证的注册中心命令。</p>
<p>可以用 <code>--token</code> 命令行选项来覆盖。</p>
<h4 id="source"><a class="header" href="#source"><code>[source]</code></a></h4>
<p><code>[source]</code> 表定义了可用的注册中心源。
更多信息见<a href="reference/source-replacement.html">源替换</a>。
它由每个命名的源的一个子表组成。
源应该只定义为一种(目录、注册中心、本地注册或git)。</p>
<h5 id="sourcenamereplace-with"><a class="header" href="#sourcenamereplace-with"><code>source.&lt;name&gt;.replace-with</code></a></h5>
<ul>
<li>Type: 字符串</li>
<li>Default: none</li>
<li>Environment: 不支持</li>
</ul>
<p>如果设置，用给定的命名源或命名注册中心替换这个源。</p>
<h5 id="sourcenamedirectory"><a class="header" href="#sourcenamedirectory"><code>source.&lt;name&gt;.directory</code></a></h5>
<ul>
<li>Type: 字符串 (path)</li>
<li>Default: none</li>
<li>Environment: 不支持</li>
</ul>
<p>设置目录路径，作为目录源使用。</p>
<h5 id="sourcenameregistry"><a class="header" href="#sourcenameregistry"><code>source.&lt;name&gt;.registry</code></a></h5>
<ul>
<li>Type: 字符串 (url)</li>
<li>Default: none</li>
<li>Environment: 不支持</li>
</ul>
<p>设置用于注册中心源的URL。</p>
<h5 id="sourcenamelocal-registry"><a class="header" href="#sourcenamelocal-registry"><code>source.&lt;name&gt;.local-registry</code></a></h5>
<ul>
<li>Type: 字符串 (path)</li>
<li>Default: none</li>
<li>Environment: 不支持</li>
</ul>
<p>设置目录路径，用作本地注册源。</p>
<h5 id="sourcenamegit"><a class="header" href="#sourcenamegit"><code>source.&lt;name&gt;.git</code></a></h5>
<ul>
<li>Type: 字符串 (url)</li>
<li>Default: none</li>
<li>Environment: 不支持</li>
</ul>
<p>设置用于git仓库源的URL。</p>
<h5 id="sourcenamebranch"><a class="header" href="#sourcenamebranch"><code>source.&lt;name&gt;.branch</code></a></h5>
<ul>
<li>Type: 字符串</li>
<li>Default: none</li>
<li>Environment: 不支持</li>
</ul>
<p>设置用于git仓库的分支名称。</p>
<p>如果没有设置 <code>branch</code> 、 <code>tag</code> 或 <code>rev</code> ，则默认为 <code>master</code> 分支。</p>
<h5 id="sourcenametag"><a class="header" href="#sourcenametag"><code>source.&lt;name&gt;.tag</code></a></h5>
<ul>
<li>Type: 字符串</li>
<li>Default: none</li>
<li>Environment: 不支持</li>
</ul>
<p>设置用于git仓库的tag名称。</p>
<p>如果没有设置 <code>branch</code> 、 <code>tag</code> 或 <code>rev</code> ，则默认为 <code>master</code> 分支。</p>
<h5 id="sourcenamerev"><a class="header" href="#sourcenamerev"><code>source.&lt;name&gt;.rev</code></a></h5>
<ul>
<li>Type: 字符串</li>
<li>Default: none</li>
<li>Environment: 不支持</li>
</ul>
<p>设置用于git仓库的<a href="https://git-scm.com/docs/gitrevisions">修订</a>。</p>
<p>如果没有设置 <code>branch</code> 、 <code>tag</code> 或 <code>rev</code> ，则默认为 <code>master</code> 分支。</p>
<h4 id="target"><a class="header" href="#target"><code>[target]</code></a></h4>
<p><code>[target]</code> 表用于指定特定平台目标的设置。
它由子表组成，这个子表是平台三元组或 <a href="reference/../../reference/conditional-compilation.html"><code>cfg()</code> 表达式</a> 。
如果目标平台与 <code>&lt;triple&gt;</code> 值或 <code>&lt;cfg&gt;</code> 表达式匹配，将使用给定的值。</p>
<pre><code class="language-toml">[target.thumbv7m-none-eabi]
linker = &quot;arm-none-eabi-gcc&quot;
runner = &quot;my-emulator&quot;
rustflags = [&quot;…&quot;, &quot;…&quot;]

[target.'cfg(all(target_arch = &quot;arm&quot;, target_os = &quot;none&quot;))']
runner = &quot;my-arm-wrapper&quot;
rustflags = [&quot;…&quot;, &quot;…&quot;]
</code></pre>
<p><code>cfg</code> 值来自编译器内置的值 (运行 <code>rustc --print=cfg</code> 查看)，由[构建脚本]设置的值，以及传递给 <code>rustc</code> 的附加 <code>--cfg</code> 标志(例如在 <code>RUSTFLAGS</code> 中定义的标志)。
不要在 <code>debug_assertions</code> 或 Cargo 特性(如 <code>feature=&quot;foo&quot;</code> )上尝试match。</p>
<p>如果使用目标规格的JSON文件，<code>&lt;triple&gt;</code> 值是文件名。
例如， <code>--target foo/bar.json</code> 将匹配 <code>[target.bar]</code> 。</p>
<h5 id="targettriplear"><a class="header" href="#targettriplear"><code>target.&lt;triple&gt;.ar</code></a></h5>
<p>该选项已被废弃，未被使用。</p>
<h5 id="targettriplelinker"><a class="header" href="#targettriplelinker"><code>target.&lt;triple&gt;.linker</code></a></h5>
<ul>
<li>Type: 字符串 (程序路径)</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_TARGET_&lt;triple&gt;_LINKER</code></li>
</ul>
<p>指定在编译 <code>&lt;triple&gt;</code> 时传递给 <code>rustc</code> (通过<a href="reference/../../rustc/codegen-options/index.html#linker"><code>-C linker</code></a>) 的链接器。
默认情况下，链接器不可覆盖。</p>
<h5 id="targettriplerunner"><a class="header" href="#targettriplerunner"><code>target.&lt;triple&gt;.runner</code></a></h5>
<ul>
<li>Type: 字符串或者字符串数组 (<a href="reference/config.html#executable-paths-with-arguments">带参数的程序路径</a>)</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_TARGET_&lt;triple&gt;_RUNNER</code></li>
</ul>
<p>如果提供了运行器，目标 <code>&lt;triple&gt;</code> 的可执行文件将通过调用指定的运行器和作为参数传递的实际可执行文件来执行。
这适用于 <a href="reference/../commands/cargo-run.html"><code>cargo run</code></a>, <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 和 <a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a> 命令。
默认情况下，编译后的可执行文件被直接执行。</p>
<h5 id="targetcfgrunner"><a class="header" href="#targetcfgrunner"><code>target.&lt;cfg&gt;.runner</code></a></h5>
<p>这类似于 <a href="reference/config.html#targettriplerunner">target runner</a> ，但使用 <a href="reference/../../reference/conditional-compilation.html"><code>cfg()</code> 表达式</a> 。
如果同时有 <code>&lt;triple&gt;</code> 和 <code>&lt;cfg&gt;</code> 运行器匹配， <code>&lt;triple&gt;</code> 将优先使用。
如果有一个以上的 <code>&lt;cfg&gt;</code> 运行器与当前目标匹配，则错误。</p>
<h5 id="targettriplerustflags"><a class="header" href="#targettriplerustflags"><code>target.&lt;triple&gt;.rustflags</code></a></h5>
<ul>
<li>Type: 字符串或字符串数组</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_TARGET_&lt;triple&gt;_RUSTFLAGS</code></li>
</ul>
<p>为这个 <code>&lt;triple&gt;</code> 向编译器传递一组自定义标志。
该值可以是字符串数组或以空格分隔的字符串。</p>
<p>参阅 <a href="reference/config.html#buildrustflags"><code>build.rustflags</code></a> ，以了解更多关于特定附加标志的不同方式的细节。</p>
<h5 id="targetcfgrustflags"><a class="header" href="#targetcfgrustflags"><code>target.&lt;cfg&gt;.rustflags</code></a></h5>
<p>这类似于 <a href="reference/config.html#targettriplerustflags">target rustflags</a> ，但使用 <a href="reference/../../reference/conditional-compilation.html"><code>cfg()</code> 表达式</a> 。
如果有几个 <code>&lt;cfg&gt;</code> 和 <code>&lt;triple&gt;</code> 条目与当前的目标相匹配，这些标志就会被连在一起。</p>
<h5 id="targettriplelinks"><a class="header" href="#targettriplelinks"><code>target.&lt;triple&gt;.&lt;links&gt;</code></a></h5>
<p>链接子表提供了一种[覆盖构建脚本]的方法。
当指定时，给定的 <code>links</code> 库的构建脚本将不会运行，而会使用给定的值。</p>
<pre><code class="language-toml">[target.x86_64-unknown-linux-gnu.foo]
rustc-link-lib = [&quot;foo&quot;]
rustc-link-search = [&quot;/path/to/foo&quot;]
rustc-flags = &quot;-L /some/path&quot;
rustc-cfg = ['key=&quot;value&quot;']
rustc-env = {key = &quot;value&quot;}
rustc-cdylib-link-arg = [&quot;…&quot;]
metadata_key1 = &quot;value&quot;
metadata_key2 = &quot;value&quot;
</code></pre>
<h4 id="term"><a class="header" href="#term"><code>[term]</code></a></h4>
<p><code>[term]</code> 表控制终端输出和交互。</p>
<h5 id="termquiet"><a class="header" href="#termquiet"><code>term.quiet</code></a></h5>
<ul>
<li>Type: 布尔</li>
<li>Default: false</li>
<li>Environment: <code>CARGO_TERM_QUIET</code></li>
</ul>
<p>控制Cargo是否显示日志信息。</p>
<p>指定 <code>--quiet</code> 标志将覆盖和强制静默输出。
指定 <code>--verbose</code> 标志将覆盖和禁用静默输出。</p>
<h5 id="termverbose"><a class="header" href="#termverbose"><code>term.verbose</code></a></h5>
<ul>
<li>Type: 布尔</li>
<li>Default: false</li>
<li>Environment: <code>CARGO_TERM_VERBOSE</code></li>
</ul>
<p>控制Cargo是否显示附加的详细信息。</p>
<p>指定 <code>--quiet</code> 标志将覆盖并禁用粗略输出。
指定 <code>--verbose</code> 标志将覆盖并强制进行粗略输出。</p>
<h5 id="termcolor"><a class="header" href="#termcolor"><code>term.color</code></a></h5>
<ul>
<li>Type: 字符串</li>
<li>Default: &quot;auto&quot;</li>
<li>Environment: <code>CARGO_TERM_COLOR</code></li>
</ul>
<p>控制是否在终端中使用彩色输出。可能的值:</p>
<ul>
<li><code>auto</code> (默认): 自动检测终端是否有颜色支持。</li>
<li><code>always</code>: 允许显示颜色。</li>
<li><code>never</code>: 不允许显示颜色。</li>
</ul>
<p>可以用 <code>--color</code> 命令行选项来覆盖。</p>
<h5 id="termprogresswhen"><a class="header" href="#termprogresswhen"><code>term.progress.when</code></a></h5>
<ul>
<li>Type: 字符串</li>
<li>Default: &quot;auto&quot;</li>
<li>Environment: <code>CARGO_TERM_PROGRESS_WHEN</code></li>
</ul>
<p>控制是否在终端中显示进度条。可能的值:</p>
<ul>
<li><code>auto</code> (默认): 智能地猜测是否显示进度条。</li>
<li><code>always</code>: 允许显示进度条。</li>
<li><code>never</code>: 不允许显示进度条。</li>
</ul>
<h5 id="termprogresswidth"><a class="header" href="#termprogresswidth"><code>term.progress.width</code></a></h5>
<ul>
<li>Type: 整数</li>
<li>Default: none</li>
<li>Environment: <code>CARGO_TERM_PROGRESS_WIDTH</code></li>
</ul>
<p>设置进度条的宽度。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h2>
<p>Cargo设置和读取一些环境变量，你的代码可以检测或覆盖这些变量。
下面是Cargo设置的变量列表，按照它与这些变量交互的时间排列:</p>
<h3 id="cargo读取环境变量"><a class="header" href="#cargo读取环境变量">Cargo读取环境变量</a></h3>
<p>你可以覆盖这些环境变量来改变Cargo在系统中的行为:</p>
<ul>
<li><code>CARGO_LOG</code> - Cargo 使用 <a href="https://docs.rs/env_logger"><code>env_logger</code></a> crate 来显示调试日志信息。
<code>CARGO_LOG</code> 环境变量可以被设置为启用调试日志，其值为 <code>trace</code> 、 <code>debug</code> 或 <code>warn</code> 。
通常情况下，它只在调试时使用。更多细节请参考<a href="https://doc.crates.io/contrib/architecture/console.html#debug-logging">Debug logging</a>。</li>
<li><code>CARGO_HOME</code> — Cargo 维护着注册中心索引和git签出crate的本地缓存。
默认情况下，这些数据存储在 <code>$HOME/.cargo</code> 下(Windows下为 <code>%USERPROFILE%\.cargo</code>)，但这个变量可以覆盖这个目录位置。
一旦crate被缓存，就不会被clean命令删除。
更多细节请参考<a href="reference/.../guide/cargo-home.html">指南</a>。</li>
<li><code>CARGO_TARGET_DIR</code> — 放置所有生成制品的位置，相对于当前工作目录。见<a href="reference/config.html#buildtarget-dir"><code>build.target-dir</code></a>，通过配置来设置。</li>
<li><code>CARGO</code> - 如果设置了这个变量，Cargo在构建crate以及执行构建脚本和外部子命令时，将转发这个值，而不是设置为自己的自动检测路径。
这个值不会被Cargo直接执行，它应该总是指向一个行为与 <code>cargo</code> 完全相同的命令，因为这也是该变量的用户所期望的。</li>
<li><code>RUSTC</code> — Cargo将执行这个指定的编译器，而不是运行 <code>rustc</code> 。见<a href="reference/config.html#buildrustc"><code>build.rustc</code></a>通过配置来设置。</li>
<li><code>RUSTC_WRAPPER</code> — Cargo将执行这个指定的包装器，而不是简单地运行 <code>rustc</code> ，将rustc的调用作为其命令行参数，第一个参数是实际rustc的路径。
这对设置构建缓存工具(如 <code>sccache</code>)很有用。见<a href="reference/config.html#buildrustc-wrapper"><code>build.rustc-wrapper</code></a>通过配置来设置。
将其设置为空字符串会覆盖配置，并将crate重置为不使用包装器。</li>
<li><code>RUSTC_WORKSPACE_WRAPPER</code> — 对于工作空间成员，Cargo将执行这个指定的包装器，而不是简单地运行 <code>rustc</code>，将rustc的调用作为其命令行参数，第一个参数是实际rustc的路径。
它影响文件名hash，以便包装器产生的制品被单独缓存。参见<a href="reference/config.html#buildrustc-workspace-wrapper"><code>build.rustc-workspace-wrapper</code></a>，通过配置来设置。
将其设置为空字符串会覆盖配置，并将crate重置为不对工作空间成员使用包装器。</li>
<li><code>RUSTDOC</code> — Cargo将执行这个指定的 <code>rustdoc</code> 实例，而不是运行 <code>rustdoc </code>。见 <a href="reference/config.html#buildrustdoc"><code>build.rustdoc</code></a> 通过配置来设置。</li>
<li><code>RUSTDOCFLAGS</code> — 以空格分隔的自定义标志列表，用于传递给Cargo执行的所有 <code>rustdoc</code> 调用。
与 <a href="reference/../commands/cargo-rustdoc.html"><code>cargo rustdoc</code></a> 不同的是，这对于向<em>所有</em> <code>rustdoc</code> 实例传递标志很有用。
参见<a href="reference/config.html#buildrustdocflags"><code>build.rustdocflags</code></a>以了解更多设置标志的方法。这个字符串被空格分割；如果要对多个参数进行更健壮的编码，请参见 <code>CARGO_ENCODED_RUSTDOCFLAGS</code> 。</li>
<li><code>CARGO_ENCODED_RUSTDOCFLAGS</code> - 用 <code>0x1f</code> (ASCII单位分隔符)分隔的自定义标志列表，用于传递给Cargo执行的所有 <code>rustdoc</code> 调用。</li>
<li><code>RUSTFLAGS</code> — 以空格分隔的自定义标志列表，用于传递给Cargo执行的所有编译器调用。
与<a href="reference/../commands/cargo-rustc.html"><code>cargo rustc</code></a>不同的是，这对于向<em>所有</em>编译器实例传递标志很有用。
参见<a href="reference/config.html#buildrustflags"><code>build.rustflags</code></a>以了解更多设置标志的方法。这个字符串是由空格分割的；如果要对多个参数进行更健壮的编码，见<code>CARGO_ENCODED_RUSTFLAGS</code> 。</li>
<li><code>CARGO_ENCODED_RUSTFLAGS</code> - 用 <code>0x1f</code> (ASCII单元分隔符) 分隔的自定义标志列表，用于传递给Cargo执行的所有编译器调用。</li>
<li><code>CARGO_INCREMENTAL</code> — 如果设置为1，那么Cargo将强制在当前编译中启用<a href="reference/profiles.html#incremental">incremental compilation</a> ，设置为0时，
将强制禁用增量编译。如果这个环境变量不存在，那么将使用cargo的默认值。另请参见 <a href="reference/config.html#buildincremental"><code>build.incremental</code></a> 配置值。</li>
<li><code>CARGO_CACHE_RUSTC_INFO</code> — 如果这个设置为0，那么Cargo将不会尝试缓存编译器版本信息。</li>
<li><code>HTTPS_PROXY</code> or <code>https_proxy</code> or <code>http_proxy</code> — 要使用的HTTP代理，更多细节见 <a href="reference/config.html#httpproxy"><code>http.proxy</code></a> 。</li>
<li><code>HTTP_TIMEOUT</code> — HTTP超时，以秒为单位，详见 <a href="reference/config.html#httptimeout"><code>http.timeout</code></a> 。</li>
<li><code>TERM</code> — 如果这个设置为 <code>dumb</code> ，将禁用进度条。</li>
<li><code>BROWSER</code> — 用 <a href="reference/../commands/cargo-doc.html"><code>cargo doc</code></a>的 <code>--open</code> 标志打开文档时要执行的网络浏览器，更多细节见 <a href="reference/config.html#docbrowser"><code>doc.browser</code></a> 。</li>
<li><code>RUSTFMT</code> — 不运行 <code>rustfmt</code> ，<a href="https://github.com/rust-lang/rustfmt"><code>cargo fmt</code></a> 将执行这个指定的 <code>rustfmt</code> 实例来代替。</li>
</ul>
<h4 id="配置环境变量"><a class="header" href="#配置环境变量">配置环境变量</a></h4>
<p>Cargo会读取一些配置值的环境变量。详情见<a href="reference/config.html#environment-variables">配置章节</a>。概括起来，支持的环境变量有:</p>
<ul>
<li><code>CARGO_ALIAS_&lt;name&gt;</code> — 命令别名, 见 <a href="reference/config.html#alias"><code>alias</code></a> 。</li>
<li><code>CARGO_BUILD_JOBS</code> — 并行执行数量, 见 <a href="reference/config.html#buildjobs"><code>build.jobs</code></a> 。</li>
<li><code>CARGO_BUILD_RUSTC</code> — <code>rustc</code> 可执行文件, 见 <a href="reference/config.html#buildrustc"><code>build.rustc</code></a> 。</li>
<li><code>CARGO_BUILD_RUSTC_WRAPPER</code> — <code>rustc</code> 包装器, 见 <a href="reference/config.html#buildrustc-wrapper"><code>build.rustc-wrapper</code></a> 。</li>
<li><code>CARGO_BUILD_RUSTC_WORKSPACE_WRAPPER</code> — 工作空间成员 <code>rustc</code> 包装器, 见 <a href="reference/config.html#buildrustc-workspace-wrapper"><code>build.rustc-workspace-wrapper</code></a> 。</li>
<li><code>CARGO_BUILD_RUSTDOC</code> — <code>rustdoc</code> 可执行文件, 见 <a href="reference/config.html#buildrustdoc"><code>build.rustdoc</code></a> 。</li>
<li><code>CARGO_BUILD_TARGET</code> — 默认目标平台, 见 <a href="reference/config.html#buildtarget"><code>build.target</code></a> 。</li>
<li><code>CARGO_BUILD_TARGET_DIR</code> — 默认输出目录, 见 <a href="reference/config.html#buildtarget-dir"><code>build.target-dir</code></a> 。</li>
<li><code>CARGO_BUILD_RUSTFLAGS</code> — 附加 <code>rustc</code> 标志, 见 <a href="reference/config.html#buildrustflags"><code>build.rustflags</code></a> 。</li>
<li><code>CARGO_BUILD_RUSTDOCFLAGS</code> — 附加 <code>rustdoc</code> 标志, 见 <a href="reference/config.html#buildrustdocflags"><code>build.rustdocflags</code></a> 。</li>
<li><code>CARGO_BUILD_INCREMENTAL</code> — 增量编译, 见 <a href="reference/config.html#buildincremental"><code>build.incremental</code></a> 。</li>
<li><code>CARGO_BUILD_DEP_INFO_BASEDIR</code> — 仓库信息的相对目录, 见 <a href="reference/config.html#builddep-info-basedir"><code>build.dep-info-basedir</code></a>.</li>
<li><code>CARGO_CARGO_NEW_VCS</code> —  <a href="reference/../commands/cargo-new.html"><code>cargo new</code></a> 默认的源码控制系统, 见 <a href="reference/config.html#cargo-newvcs"><code>cargo-new.vcs</code></a>.</li>
<li><code>CARGO_FUTURE_INCOMPAT_REPORT_FREQUENCY</code> - 应该多长时间生成一次未来的不兼容报告通知, 见 <a href="reference/config.html#future-incompat-reportfrequency"><code>future-incompat-report.frequency</code></a>.</li>
<li><code>CARGO_HTTP_DEBUG</code> — 启用 HTTP 调试, 见 <a href="reference/config.html#httpdebug"><code>http.debug</code></a>.</li>
<li><code>CARGO_HTTP_PROXY</code> — 启用HTTP代理, 见 <a href="reference/config.html#httpproxy"><code>http.proxy</code></a>.</li>
<li><code>CARGO_HTTP_TIMEOUT</code> — HTTP超时, 见 <a href="reference/config.html#httptimeout"><code>http.timeout</code></a>.</li>
<li><code>CARGO_HTTP_CAINFO</code> — TLS证书机构文件, 见 <a href="reference/config.html#httpcainfo"><code>http.cainfo</code></a>.</li>
<li><code>CARGO_HTTP_CHECK_REVOKE</code> — 禁用TLS证书废止检查, 见 <a href="reference/config.html#httpcheck-revoke"><code>http.check-revoke</code></a>.</li>
<li><code>CARGO_HTTP_SSL_VERSION</code> — 要使用的TLS版本, 见 <a href="reference/config.html#httpssl-version"><code>http.ssl-version</code></a>.</li>
<li><code>CARGO_HTTP_LOW_SPEED_LIMIT</code> — HTTP的低速限制, 见 <a href="reference/config.html#httplow-speed-limit"><code>http.low-speed-limit</code></a>.</li>
<li><code>CARGO_HTTP_MULTIPLEXING</code> — 是否使用HTTP/2多路复用, 见 <a href="reference/config.html#httpmultiplexing"><code>http.multiplexing</code></a>.</li>
<li><code>CARGO_HTTP_USER_AGENT</code> — HTTP user-agent 头, 见 <a href="reference/config.html#httpuser-agent"><code>http.user-agent</code></a>.</li>
<li><code>CARGO_INSTALL_ROOT</code> — <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 的默认目录, 见 <a href="reference/config.html#installroot"><code>install.root</code></a>.</li>
<li><code>CARGO_NET_RETRY</code> — 网络错误重试的次数, 见 <a href="reference/config.html#netretry"><code>net.retry</code></a>.</li>
<li><code>CARGO_NET_GIT_FETCH_WITH_CLI</code> — 启用 <code>git</code> 可执行程序来获取, 见 <a href="reference/config.html#netgit-fetch-with-cli"><code>net.git-fetch-with-cli</code></a>.</li>
<li><code>CARGO_NET_OFFLINE</code> — 脱机模式, 见 <a href="reference/config.html#netoffline"><code>net.offline</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_BUILD_OVERRIDE_&lt;key&gt;</code> — 覆盖构建脚本配置文件, 见 <a href="reference/config.html#profilenamebuild-override"><code>profile.&lt;name&gt;.build-override</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_CODEGEN_UNITS</code> — 设定代码生成单元, 见 <a href="reference/config.html#profilenamecodegen-units"><code>profile.&lt;name&gt;.codegen-units</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_DEBUG</code> — 要包括什么样的调试信息, 见 <a href="reference/config.html#profilenamedebug"><code>profile.&lt;name&gt;.debug</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_DEBUG_ASSERTIONS</code> — 启用/禁用调试断言, 见 <a href="reference/config.html#profilenamedebug-assertions"><code>profile.&lt;name&gt;.debug-assertions</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_INCREMENTAL</code> — 启用/禁用增量编译, 见 <a href="reference/config.html#profilenameincremental"><code>profile.&lt;name&gt;.incremental</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_LTO</code> — 链接时间优化, 见 <a href="reference/config.html#profilenamelto"><code>profile.&lt;name&gt;.lto</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_OVERFLOW_CHECKS</code> — 启用/禁用溢出检查, 见 <a href="reference/config.html#profilenameoverflow-checks"><code>profile.&lt;name&gt;.overflow-checks</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_OPT_LEVEL</code> — 设置优化级别, 见 <a href="reference/config.html#profilenameopt-level"><code>profile.&lt;name&gt;.opt-level</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_PANIC</code> — 要使用的恐慌策略, 见 <a href="reference/config.html#profilenamepanic"><code>profile.&lt;name&gt;.panic</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_RPATH</code> — rpath链接选项, 见 <a href="reference/config.html#profilenamerpath"><code>profile.&lt;name&gt;.rpath</code></a>.</li>
<li><code>CARGO_PROFILE_&lt;name&gt;_SPLIT_DEBUGINFO</code> — 控制调试文件的输出行为, 见 <a href="reference/config.html#profilenamesplit-debuginfo"><code>profile.&lt;name&gt;.split-debuginfo</code></a>.</li>
<li><code>CARGO_REGISTRIES_&lt;name&gt;_INDEX</code> — 注册中心索引的URL, 见 <a href="reference/config.html#registriesnameindex"><code>registries.&lt;name&gt;.index</code></a>.</li>
<li><code>CARGO_REGISTRIES_&lt;name&gt;_TOKEN</code> — 注册中心认证token, 见 <a href="reference/config.html#registriesnametoken"><code>registries.&lt;name&gt;.token</code></a>.</li>
<li><code>CARGO_REGISTRY_DEFAULT</code> — <code>--registry</code> 的默认注册中心。见 <a href="reference/config.html#registrydefault"><code>registry.default</code></a> 。</li>
<li><code>CARGO_REGISTRY_TOKEN</code> — <a href="https://crates.io/">crates.io</a>的认证token。 见 <a href="reference/config.html#registrytoken"><code>registry.token</code></a> 。</li>
<li><code>CARGO_TARGET_&lt;triple&gt;_LINKER</code> — 使用的链接器, 见 <a href="reference/config.html#targettriplelinker"><code>target.&lt;triple&gt;.linker</code></a> 。 三元组必须是 <a href="reference/config.html#environment-variables">转换为大写字母和下划线</a> 。</li>
<li><code>CARGO_TARGET_&lt;triple&gt;_RUNNER</code> — 可执行的运行器, 见 <a href="reference/config.html#targettriplerunner"><code>target.&lt;triple&gt;.runner</code></a> 。</li>
<li><code>CARGO_TARGET_&lt;triple&gt;_RUSTFLAGS</code> — 目标的额外 <code>rustc</code> 标志, 见 <a href="reference/config.html#targettriplerustflags"><code>target.&lt;triple&gt;.rustflags</code></a> 。</li>
<li><code>CARGO_TERM_QUIET</code> — 静默模式, 见 <a href="reference/config.html#termquiet"><code>term.quiet</code></a> 。</li>
<li><code>CARGO_TERM_VERBOSE</code> — 默认的终端口令, 见 <a href="reference/config.html#termverbose"><code>term.verbose</code></a> 。</li>
<li><code>CARGO_TERM_COLOR</code> — 默认颜色模式, 见 <a href="reference/config.html#termcolor"><code>term.color</code></a> 。</li>
<li><code>CARGO_TERM_PROGRESS_WHEN</code> — 默认的进度条显示模式, 见 <a href="reference/config.html#termprogresswhen"><code>term.progress.when</code></a> 。</li>
<li><code>CARGO_TERM_PROGRESS_WIDTH</code> — 默认的进度条宽度, 见 <a href="reference/config.html#termprogresswidth"><code>term.progress.width</code></a> 。</li>
</ul>
<h3 id="环境变量cargo的crate集"><a class="header" href="#环境变量cargo的crate集">环境变量Cargo的crate集</a></h3>
<p>Cargo在编译时将这些环境变量暴露给你的crate。
注意，这也适用于用 <code>cargo run</code> 和 <code>cargo test</code> 运行二进制文件。
要在Rust程序中获得这些变量的值，请这样做:</p>
<pre><code class="language-rust ignore">let version = env!(&quot;CARGO_PKG_VERSION&quot;);</code></pre>
<p><code>version</code> 现在将包含 <code>CARGO_PKG_VERSION</code> 的值。</p>
<p>请注意，如果配置清单中没有提供这些值之一，则相应的环境变量将被设置为空字符串 <code>&quot;&quot;</code> 。</p>
<ul>
<li><code>CARGO</code> — 执行构建的 <code>cargo</code> 二进制文件的路径。</li>
<li><code>CARGO_MANIFEST_DIR</code> — 包含你的包配置清单的目录。</li>
<li><code>CARGO_PKG_VERSION</code> — 你的包的完整版本。</li>
<li><code>CARGO_PKG_VERSION_MAJOR</code> — 你的包的主要版本。</li>
<li><code>CARGO_PKG_VERSION_MINOR</code> — 你的包的次要版本。</li>
<li><code>CARGO_PKG_VERSION_PATCH</code> — 你的包的补丁版本。</li>
<li><code>CARGO_PKG_VERSION_PRE</code> — 你的包的预发布版本。</li>
<li><code>CARGO_PKG_AUTHORS</code> — 冒号分隔的作者名单，来自你的包的配置清单。</li>
<li><code>CARGO_PKG_NAME</code> — 你的包的名称。</li>
<li><code>CARGO_PKG_DESCRIPTION</code> — 你的包配置清单的描述。</li>
<li><code>CARGO_PKG_HOMEPAGE</code> — 你的包的配置清单中的主页。</li>
<li><code>CARGO_PKG_REPOSITORY</code> — 你的包配置清单中的存储库。</li>
<li><code>CARGO_PKG_LICENSE</code> — 你的包的配置清单中的许可证。</li>
<li><code>CARGO_PKG_LICENSE_FILE</code> — 你的包的配置清单中的许可证文件。</li>
<li><code>CARGO_PKG_RUST_VERSION</code> — 你的包的配置清单中的Rust版本。 注意，这是包支持的最小Rust版本，而不是当前的Rust版本。</li>
<li><code>CARGO_CRATE_NAME</code> — 当前正在编译的crate的名称。</li>
<li><code>CARGO_BIN_NAME</code> — 当前正在编译的二进制文件的名称(如果它是一个二进制文件)。这个名字不包括任何文件扩展名，如 <code>.exe</code> 。</li>
<li><code>OUT_DIR</code> — 如果该包有构建脚本，这将被设置为构建脚本应该放置其输出的文件夹。更多信息见下文。(只在编译过程中设置)。</li>
<li><code>CARGO_BIN_EXE_&lt;name&gt;</code> — 二进制目标的可执行文件的绝对路径。这只在构建[集成测试]或基准时设置。这可以与<a href="reference/../../std/macro.env.html"><code>env</code> macro</a>一起使用，以找到为测试目的运行的可执行文件。 <code>&lt;name&gt;</code> 是二进制目标的名称，完全按原样。例如， <code>CARGO_BIN_EXE_my-program</code> 代表一个名为 <code>my-program</code> 的二进制文件。当测试建立时，二进制文件会自动建立，除非二进制文件有未启用的必要特性。</li>
<li><code>CARGO_PRIMARY_PACKAGE</code> — 如果正在构建的包是主要的，这个环境变量将被设置。主要包是用户在命令行中选择的，可以是 <code>-p</code> 标志，也可以是基于当前目录和默认工作空间成员的默认值。这个环境变量在构建依赖时不会被设置。只有在编译包时才会设置（而不是在运行二进制文件或测试时）。</li>
<li><code>CARGO_TARGET_TMPDIR</code> — 只在构建[集成测试]或基准代码时设置。这是一个指向目标目录内的路径，集成测试或基准测试可以在这里自由放置测试/基准所需的任何数据。Cargo初始创建这个目录，但不以任何方式管理其内容，这是测试代码的责任。</li>
</ul>
<h4 id="动态库路径"><a class="header" href="#动态库路径">动态库路径</a></h4>
<p>在使用 <code>cargo run</code> 和 <code>cargo test</code> 等命令编译和运行二进制文件时，Cargo也会设置动态库路径。这有助于定位作为构建过程一部分的共享库。变量名称取决于平台:</p>
<ul>
<li>Windows: <code>PATH</code></li>
<li>macOS: <code>DYLD_FALLBACK_LIBRARY_PATH</code></li>
<li>Unix: <code>LD_LIBRARY_PATH</code></li>
</ul>
<p>macOS有特殊的考虑，如果 <code>DYLD_FALLBACK_LIBRARY_PATH</code> 还没有设置，它就会增加默认的 <code>$HOME/lib:/usr/local/lib:/usr/lib</code> 。</p>
<p>Cargo包括以下路径:</p>
<ul>
<li>搜索任何带有<a href="reference/build-scripts.html#rustc-link-search"><code>rustc-link-search</code> instruction</a>的构建脚本中包含的路径。 <code>target</code> 目录之外的路径会被删除。如果在搜索路径中需要额外的系统库，运行Cargo的用户有责任正确设置环境。</li>
<li>基本输出目录，如 <code>target/debug</code> ，和 &quot;deps&quot; 目录。这主要是为了对 <code>rustc</code> 编译器插件的遗留支持。</li>
<li>rustc sysroot库的路径。这对大多数用户来说通常并不重要。</li>
</ul>
<h3 id="环境变量-cargo为构建脚本设置的环境变量"><a class="header" href="#环境变量-cargo为构建脚本设置的环境变量">环境变量 Cargo为构建脚本设置的环境变量</a></h3>
<p>Cargo在运行构建脚本时设置了几个环境变量。因为这些变量在编译构建脚本时还没有设置，所以上面的例子中使用 <code>env!</code> 是行不通的，而是需要在运行构建脚本时检索这些值。</p>
<pre><code class="language-rust ignore">use std::env;
let out_dir = env::var(&quot;OUT_DIR&quot;).unwrap();</code></pre>
<p><code>out_dir</code> 现在将包含 <code>OUT_DIR</code> 的值。</p>
<ul>
<li><code>CARGO</code> — 执行构建的 <code>cargo</code> 二进制文件的路径。</li>
<li><code>CARGO_MANIFEST_DIR</code> — 包含正在构建的包的配置清单的目录(包含构建脚本的软件包)。还要注意，这是构建脚本启动时的当前工作目录的值。</li>
<li><code>CARGO_MANIFEST_LINKS</code> — 配置清单 <code>links</code> 值。</li>
<li><code>CARGO_MAKEFLAGS</code> — 包含Cargo的<a href="https://www.gnu.org/software/make/manual/html_node/Job-Slots.html">jobserver</a>实现所需的参数，以使子进程并行化。Rustc或build.rs中的cargo调用已经可以读取 <code>CARGO_MAKEFLAGS</code> ，但GNU Make要求这些标志直接作为参数指定，或通过 <code>MAKEFLAGS</code> 环境变量指定。目前Cargo并没有设置 <code>MAKEFLAGS</code>变量，但GNU Make的编译脚本可以将其设置为 <code>CARGO_MAKEFLAGS</code> 的内容。</li>
<li><code>CARGO_FEATURE_&lt;name&gt;</code> — 对于正在构建的包的每个激活的特性，这个环境变量将出现，其中 <code>&lt;name&gt;</code> 是特性的名称，为大写字母， <code>-</code> 转换成 <code>_</code> 。</li>
<li><code>CARGO_CFG_&lt;cfg&gt;</code> — 对于正在构建的包的每一个<a href="reference/../../reference/conditional-compilation.html">配置选项</a>，这个环境变量将包含配置的值，其中 <code>&lt;cfg&gt;</code> 是配置的名称，为大写，并将 <code>-</code> 转换为 <code>_</code> 。
布尔型配置如果被设置就会出现，否则就不会出现。具有多个值的配置连接到一个变量，其值以 <code>,</code> 分割。
这包括编译器内置的值(可以用<code>rustc --print=cfg</code> 查看)，以及由编译脚本和传递给 <code>rustc</code> 的额外标志(比如在 <code>RUSTFLAGS</code> 中定义的)设置的值。这些变量的一些例子:
<ul>
<li><code>CARGO_CFG_UNIX</code> — 在 <a href="reference/../../reference/conditional-compilation.html#unix-and-windows">unix-like platforms</a> 设置。</li>
<li><code>CARGO_CFG_WINDOWS</code> — 在 <a href="reference/../../reference/conditional-compilation.html#unix-and-windows">windows-like platforms</a> 设置。</li>
<li><code>CARGO_CFG_TARGET_FAMILY=unix</code> —  <a href="reference/../../reference/conditional-compilation.html#target_family">target family</a> 。</li>
<li><code>CARGO_CFG_TARGET_OS=macos</code> —  <a href="reference/../../reference/conditional-compilation.html#target_os">target operating system</a> 。</li>
<li><code>CARGO_CFG_TARGET_ARCH=x86_64</code> —  CPU <a href="reference/../../reference/conditional-compilation.html#target_arch">target architecture</a> 。</li>
<li><code>CARGO_CFG_TARGET_VENDOR=apple</code> —  <a href="reference/../../reference/conditional-compilation.html#target_vendor">target vendor</a> 。</li>
<li><code>CARGO_CFG_TARGET_ENV=gnu</code> —  <a href="reference/../../reference/conditional-compilation.html#target_env">target environment</a> ABI 。</li>
<li><code>CARGO_CFG_TARGET_POINTER_WIDTH=64</code> —  CPU <a href="reference/../../reference/conditional-compilation.html#target_pointer_width">pointer width</a> 。</li>
<li><code>CARGO_CFG_TARGET_ENDIAN=little</code> —  CPU <a href="reference/../../reference/conditional-compilation.html#target_endian">target endianness</a> 。</li>
<li><code>CARGO_CFG_TARGET_FEATURE=mmx,sse</code> — 启用的CPU<a href="reference/../../reference/conditional-compilation.html#target_feature">target features</a> 列表。</li>
</ul>
</li>
<li><code>OUT_DIR</code> — 所有输出和中间制品应该放在哪个文件夹里。这个文件夹位于正在构建的包的构建目录内，而且对相关的包来说是唯一的。</li>
<li><code>TARGET</code> — 正在被编译的目标三元组。本地代码应该为这个三元组进行编译。更多信息请参见 <a href="reference/../appendix/glossary.html#target">Target Triple</a> 的描述。</li>
<li><code>HOST</code> — 是Rust编译器的主机三元组。</li>
<li><code>NUM_JOBS</code> — 被指定为顶层并行性的并行性。这对于向 <code>make</code> 这样的系统传递 <code>-j</code> 参数很有用。注意，在解释这个环境变量的时候要注意。
出于历史原因，仍然提供了这个变量，但最近的Cargo版本，例如，不需要运行 <code>make -j</code> ，而是可以将 <code>MAKEFLAGS</code> 环境变量设置为 <code>CARGO_MAKEFLAGS</code> 的内容，以激活使用Cargo的GNU Make兼容 <a href="https://www.gnu.org/software/make/manual/html_node/Job-Slots.html">jobserver</a> 进行子make调用。</li>
<li><code>OPT_LEVEL</code>, <code>DEBUG</code> — 目前正在建立的配置文件的相应变量的值。</li>
<li><code>PROFILE</code> — <code>release</code> 用于发布版本， <code>debug</code> 用于其他版本。这是根据 <a href="reference/profiles.html">profile</a> 是否继承自 <a href="reference/profiles.html#dev"><code>dev</code></a> 或 <a href="reference/profiles.html#release"><code>release</code></a> 配置文件来决定的。不建议使用这个环境变量。使用其他环境变量，如 <code>OPT_LEVEL</code> ，可以更准确地了解正在使用的实际设置。</li>
<li><code>DEP_&lt;name&gt;_&lt;key&gt;</code> — 关于这组环境变量的更多信息，请参见关于 <a href="reference/build-scripts.html#the-links-manifest-key"><code>links</code></a> 的构建脚本文档。</li>
<li><code>RUSTC</code>, <code>RUSTDOC</code> — 是Cargo决定使用的编译器和文档生成器，传递给构建脚本，以便它也能使用。</li>
<li><code>RUSTC_WRAPPER</code> — Cargo使用的 <code>rustc</code> 包装器，如果有的话。 见 <a href="reference/config.html#buildrustc-wrapper"><code>build.rustc-wrapper</code></a>.</li>
<li><code>RUSTC_WORKSPACE_WRAPPER</code> — <code>rustc</code> 包装器，如果有的话，Cargo对工作空间成员使用。 见 <a href="reference/config.html#buildrustc-workspace-wrapper"><code>build.rustc-workspace-wrapper</code></a>.</li>
<li><code>RUSTC_LINKER</code> — 如果指定了链接器，则是Cargo已经决定为当前目标使用的链接器二进制文件的路径。链接器可以通过编辑 <code>.cargo/config.toml</code> 来改变；更多信息请参见 <a href="reference/config.html">cargo configuration</a> 文档。</li>
<li><code>CARGO_ENCODED_RUSTFLAGS</code> — 附加的标志，Cargo调用 <code>rustc</code> 时，用 <code>0x1f</code> 字符(ASCII单位分隔符)分隔。见 <a href="reference/config.html#buildrustflags"><code>build.rustflags</code></a> 。注意，从Rust 1.55开始， <code>RUSTFLAGS</code> 已经从环境中移除；脚本应该使用 <code>CARGO_ENCODED_RUSTFLAGS</code> 代替。</li>
<li><code>CARGO_PKG_&lt;var&gt;</code> - 包的信息变量，其名称和数值与<a href="reference/environment-variables.html#environment-variables-cargo-sets-for-crates">在crate构建过程中提供的</a>相同。</li>
</ul>
<h3 id="环境变量-cargo为第三方子命令设置的环境变量"><a class="header" href="#环境变量-cargo为第三方子命令设置的环境变量">环境变量 Cargo为第三方子命令设置的环境变量</a></h3>
<p>Cargo将这个环境变量暴露给第三方子命令(即放在 <code>$PATH</code> 中的名为 <code>cargo-foobar</code> 的程序):</p>
<ul>
<li><code>CARGO</code> — 执行构建的 <code>cargo</code> 二进制文件的路径。</li>
</ul>
<p>对于你的环境的扩展信息，可以运行 <code>cargo metadata</code> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="构建脚本-1"><a class="header" href="#构建脚本-1">构建脚本</a></h2>
<p>有些包需要编译第三方的非Rust代码，例如C库。
有些包需要链接到C库，这些库可能位于系统中，也可能需要从源代码中构建。
还有包需要一些功能性工具，比如在构建前生成代码(想想语法分析生成器)。</p>
<p>Cargo的目的并不是要取代其他为这些任务而优化的工具，但它可以通过定制构建脚本与这些工具进行整合。
在软件包的根目录下放置一个名为 <code>build.rs</code> 的文件，就会使Cargo在构建软件包之前编译该脚本并执行。</p>
<pre><code class="language-rust ignore">// 自定义构建脚本实例
fn main() {
    // 告诉Cargo，如果给定的文件发生更改，则重新运行此构建脚本。
    println!(&quot;cargo:rerun-if-changed=src/hello.c&quot;);
    // 使用 `cc` crate 构建一个C文件并静态链接它。
    cc::Build::new()
        .file(&quot;src/hello.c&quot;)
        .compile(&quot;hello&quot;);
}</code></pre>
<p>构建脚本的一些用例如下:</p>
<ul>
<li>构建C库绑定。</li>
<li>在主机系统上查找C库。</li>
<li>根据规范生成Rust模块。</li>
<li>执行crate所需的任意平台特定配置。</li>
</ul>
<p>下面的章节描述了构建脚本的工作方式，<a href="reference/build-script-examples.html">示例章节</a> 展示了关于如何编写脚本的各种示例。</p>
<blockquote>
<p>注意: 可以使用 <a href="reference/manifest.html#package-build"><code>package.build</code> 配置清单key</a> 来改变构建脚本的名称，或完全禁用它。</p>
</blockquote>
<h3 id="构建脚本的生命周期"><a class="header" href="#构建脚本的生命周期">构建脚本的生命周期</a></h3>
<p>在构建包之前，Cargo会将构建脚本编译成可执行文件(如果还没有构建的话)。
然后它将运行脚本，该脚本可以执行任意数量的任务。
脚本可以通过将带有 <code>cargo:</code> 前缀的特殊格式化命令打印到标准输出来与Cargo通信。</p>
<p>如果构建脚本的任意源文件或依赖项发生更改，将重新构建脚本。</p>
<p>默认情况下，如果软件包中的任何文件发生变化，Cargo 会重新运行构建脚本。
通常情况下，最好使用下面 <a href="reference/build-scripts.html#change-detection">change detection</a> 一节中描述的 <code>rerun-if</code> 命令，以缩小触发构建脚本重新运行的关注点。</p>
<p>一旦构建脚本成功执行完毕，包的其他部分就会被编译。
脚本应该以非零的退出代码退出，以便在出现错误时停止编译，在这种情况下，编译脚本的输出将显示在终端。</p>
<h3 id="构建脚本的输入"><a class="header" href="#构建脚本的输入">构建脚本的输入</a></h3>
<p>当构建脚本运行时，若有一些输入到构建脚本，则都是以 <a href="reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">环境变量</a> 的形式传递。</p>
<p>除了环境变量外，构建脚本的当前目录是构建脚本的包的源目录。</p>
<h3 id="构建脚本的输出"><a class="header" href="#构建脚本的输出">构建脚本的输出</a></h3>
<p>构建脚本可以将任何输出文件或中间构件保存在 <a href="reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts"><code>OUT_DIR</code> 环境变量</a> 指定的目录中。
脚本不应该修改该目录之外的任何文件。</p>
<p>构建脚本通过打印到 stdout 来与Cargo交流。
Cargo会把每一行以 <code>cargo:</code> 开头的字解释为影响包编译的指令。所有其他的行都会被忽略。</p>
<blockquote>
<p>注意：构建脚本打印的 <code>cargo:</code> 指令的顺序 <em>可能</em> 会影响 <code>cargo</code> 传递给 <code>rustc</code> 的参数的顺序。
反过来，传递给 <code>rustc</code> 的参数顺序也可能影响传递给链接器的参数顺序。
因此，你要注意构建脚本的指令顺序。
例如，如果对象 <code>foo</code> 需要与库 <code>bar</code> 链接，你可能需要确保库 <code>bar</code> 的 <a href="reference/build-scripts.html#rustc-link-lib"><code>cargo:rustc-link-lib</code></a> 指令出现在链接对象 <code>foo</code> 的指令 <em>之后</em> 。</p>
</blockquote>
<p>在正常的编译过程中，脚本的输出被隐藏在终端中。
如果你想在终端上直接看到输出，可以用 <code>-vv</code> 标志来调用Cargo的 &quot;very verbose&quot; 。
这只发生在编译脚本运行的时候。
如果Cargo认为没有任何变化，它就不会重新运行脚本，更多信息请参见下面的 <a href="reference/build-scripts.html#change-detection">变化检测</a> 。</p>
<p>构建脚本打印到stdout的所有行都被写入一个文件，如 <code>target/debug/build/&lt;pkg&gt;/output</code>(确切位置可能取决于你的配置)。stderr输出也被保存在同一目录中。</p>
<p>以下是 Cargo 所认识的指令摘要，每条指令都在下面详细说明。</p>
<ul>
<li><a href="reference/build-scripts.html#rerun-if-changed"><code>cargo:rerun-if-changed=PATH</code></a> — 告诉Cargo何时重新运行脚本。</li>
<li><a href="reference/build-scripts.html#rerun-if-env-changed"><code>cargo:rerun-if-env-changed=VAR</code></a> — 告诉Cargo何时重新运行脚本。</li>
<li><a href="reference/build-scripts.html#rustc-link-arg"><code>cargo:rustc-link-arg=FLAG</code></a> — 为基准、二进制文件、<code>cdylib</code> crates、例子和测试的链接器传递自定义标志。</li>
<li><a href="reference/build-scripts.html#rustc-link-arg-bin"><code>cargo:rustc-link-arg-bin=BIN=FLAG</code></a> — 为二进制 <code>BIN</code> 的链接器传递自定义标志。</li>
<li><a href="reference/build-scripts.html#rustc-link-arg-bins"><code>cargo:rustc-link-arg-bins=FLAG</code></a> — 向二进制文件的链接器传递自定义标志。</li>
<li><a href="reference/build-scripts.html#rustc-link-arg-tests"><code>cargo:rustc-link-arg-tests=FLAG</code></a> —  将自定义标志传递给链接器进行测试。</li>
<li><a href="reference/build-scripts.html#rustc-link-arg-examples"><code>cargo:rustc-link-arg-examples=FLAG</code></a> — 将自定义标志传递给链接器的例子。</li>
<li><a href="reference/build-scripts.html#rustc-link-arg-benches"><code>cargo:rustc-link-arg-benches=FLAG</code></a> — 将自定义的标志传递给链接器，用于基准测试。</li>
<li><a href="reference/build-scripts.html#rustc-link-lib"><code>cargo:rustc-link-lib=LIB</code></a> — 添加一个库到链接。</li>
<li><a href="reference/build-scripts.html#rustc-link-search"><code>cargo:rustc-link-search=[KIND=]PATH</code></a> — 添加到库的搜索路径。</li>
<li><a href="reference/build-scripts.html#rustc-flags"><code>cargo:rustc-flags=FLAGS</code></a> — 将特定标志传递给编译器。</li>
<li><a href="reference/build-scripts.html#rustc-cfg"><code>cargo:rustc-cfg=KEY[=&quot;VALUE&quot;]</code></a> — 启用编译时的 <code>cfg</code> 设置。</li>
<li><a href="reference/build-scripts.html#rustc-env"><code>cargo:rustc-env=VAR=VALUE</code></a> — 设置一个环境变量。</li>
<li><a href="reference/build-scripts.html#rustc-cdylib-link-arg"><code>cargo:rustc-cdylib-link-arg=FLAG</code></a> — 为cdylib crates的链接器传递自定义标志。</li>
<li><a href="reference/build-scripts.html#cargo-warning"><code>cargo:warning=MESSAGE</code></a> — 在终端上显示一个警告。</li>
<li><a href="reference/build-scripts.html#the-links-manifest-key"><code>cargo:KEY=VALUE</code></a> — 元数据，由 <code>links</code> 脚本使用。</li>
</ul>
<p><a id="rustc-link-arg"></a></p>
<h4 id="cargorustc-link-argflag"><a class="header" href="#cargorustc-link-argflag"><code>cargo:rustc-link-arg=FLAG</code></a></h4>
<p><code>rustc-link-arg</code> 指令告诉Cargo将 <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> 传递给编译器，但只在构建支持的目标(基准、二进制文件、<code>cdylib</code>板条、例子和测试)时使用。
它的使用是高度平台化的。对设置共享库版本或链接器脚本很有用。</p>
<p><a id="rustc-link-arg-bin"></a></p>
<h4 id="cargorustc-link-arg-binbinflag"><a class="header" href="#cargorustc-link-arg-binbinflag"><code>cargo:rustc-link-arg-bin=BIN=FLAG</code></a></h4>
<p><code>rustc-link-arg-bin</code> 指令告诉Cargo将 <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> 传递给编译器，但只在构建名称为 <code>BIN</code> 的二进制目标时使用。
它的用法与平台高度相关。对设置链接器脚本或其他链接器选项很有用。</p>
<p><a id="rustc-link-arg-bins"></a></p>
<h4 id="cargorustc-link-arg-binsflag"><a class="header" href="#cargorustc-link-arg-binsflag"><code>cargo:rustc-link-arg-bins=FLAG</code></a></h4>
<p><code>rustc-link-arg-bins</code> 指令告诉Cargo将 <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> 传递给编译器，但只在构建二进制目标时使用。
它的用法与平台高度相关。对于设置链接器脚本或其他链接器选项很有用。</p>
<p><a id="rustc-link-lib"></a></p>
<h4 id="cargorustc-link-liblib"><a class="header" href="#cargorustc-link-liblib"><code>cargo:rustc-link-lib=LIB</code></a></h4>
<p><code>rustc-link-lib</code> 指令告诉 Cargo 使用编译器的 <a href="reference/../../rustc/command-line-arguments.html#option-l-link-lib"><code>-l</code> flag</a> 来链接指定的库。
这通常用于使用 <a href="reference/../../nomicon/ffi.html">FFI</a> 来链接本地库。</p>
<p><code>LIB</code> 字符串是直接传递给rustc的，所以它支持 <code>-l</code> 的任何语法。
目前， <code>LIB</code> 支持的全部语法是 <code>[KIND[:MODIFIERS]=]NAME[:RENAME]</code> 。</p>
<p><code>-l</code> 标志只传递给包的库目标，除非没有库目标，在这种情况下它会传递给所有目标。
这样做是因为所有其他目标都隐含着对库目标的依赖，而要链接的库只应该包含一次。
这意味着，如果一个包有一个库和一个二进制目标，那么 <em>库</em> 可以访问给定lib的标识符，而二进制应该通过库目标的公共API来访问它们。</p>
<p>可选的 <code>KIND</code> 可以是 <code>dylib</code> 、 <code>static</code> 或<code> framework</code> 之一。
更多细节见 <a href="reference/../../rustc/command-line-arguments.html#option-l-link-lib">rustc book</a> 。</p>
<p><a id="rustc-link-arg-tests"></a></p>
<h4 id="cargorustc-link-arg-testsflag"><a class="header" href="#cargorustc-link-arg-testsflag"><code>cargo:rustc-link-arg-tests=FLAG</code></a></h4>
<p><code>rustc-link-arg-tests</code> 指令告诉Cargo将 <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> 传递给编译器，但只在构建测试目标时使用。</p>
<p><a id="rustc-link-arg-examples"></a></p>
<h4 id="cargorustc-link-arg-examplesflag"><a class="header" href="#cargorustc-link-arg-examplesflag"><code>cargo:rustc-link-arg-examples=FLAG</code></a></h4>
<p><code>rustc-link-arg-examples</code> 指令告诉Cargo将 <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> 传递给编译器，但只在构建实例目标时传递。</p>
<p><a id="rustc-link-arg-benches"></a></p>
<h4 id="cargorustc-link-arg-benchesflag"><a class="header" href="#cargorustc-link-arg-benchesflag"><code>cargo:rustc-link-arg-benches=FLAG</code></a></h4>
<p><code>rustc-link-arg-benches</code> 指令告诉Cargo将 <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> 传递给编译器，但只在构建基准目标时使用。</p>
<p><a id="rustc-link-search"></a></p>
<h4 id="cargorustc-link-searchkindpath"><a class="header" href="#cargorustc-link-searchkindpath"><code>cargo:rustc-link-search=[KIND=]PATH</code></a></h4>
<p><code>rustc-link-search</code> 指令告诉Cargo将 <a href="reference/../../rustc/command-line-arguments.html#option-l-search-path"><code>-L</code> flag</a> 传递给编译器，在库搜索路径中添加一个目录。</p>
<p>可选的 <code>KIND</code> 可以是 <code>dependency</code> 、 <code>crate</code> 、 <code>native</code> 、 <code>framework</code> 、 <code>all</code> 之一。更多细节见 <a href="reference/../../rustc/command-line-arguments.html#option-l-search-path">rustc book</a> 。</p>
<p>如果这些路径在 <code>OUT_DIR</code> 内，它们也会被添加到 <a href="reference/environment-variables.html#dynamic-library-paths">动态库搜索路径环境变量</a> 。
不鼓励依赖这种行为，因为这使得使用产生的二进制文件很困难。一般来说，最好避免在构建脚本中创建动态库(使用现有的系统库就可以了)。</p>
<p><a id="rustc-flags"></a></p>
<h4 id="cargorustc-flagsflags"><a class="header" href="#cargorustc-flagsflags"><code>cargo:rustc-flags=FLAGS</code></a></h4>
<p><code>rustc-flags</code> 指令告诉Cargo将给定的以空格分隔的标志传递给编译器。
这只允许使用 <code>-l </code>和 <code>-L</code> 标志，相当于使用 <a href="reference/build-scripts.html#rustc-link-lib"><code>rustc-link-lib</code></a> 和 <a href="reference/build-scripts.html#rustc-link-search"><code>rustc-link-search</code></a> 。</p>
<p><a id="rustc-cfg"></a></p>
<h4 id="cargorustc-cfgkeyvalue"><a class="header" href="#cargorustc-cfgkeyvalue"><code>cargo:rustc-cfg=KEY[=&quot;VALUE&quot;]</code></a></h4>
<p><code>rustc-cfg</code> 指令告诉Cargo将给定的<a href="reference/../../rustc/command-line-arguments.html#option-cfg"><code>--cfg</code> flag</a> 的值传递给编译器。
这可用于编译时检测功能，以启用 <a href="reference/../../reference/conditional-compilation.html">条件编译</a> 。</p>
<p>请注意，这并 <em>不</em> 影响Cargo的依赖解析。
这不能用来启用一个可选的依赖，或启用其他Cargo功能。</p>
<p>请注意，<a href="reference/features.html">Cargo features</a>使用的是 <code>feature=&quot;foo&quot;</code> 的形式。
用这个标志传递的 <code>cfg</code> 值不限于这种形式，可以只提供一个标识符，或任意的键/值对。例如，发送 <code>cargo:rustc-cfg=abc</code> 将允许代码使用 <code>#[cfg(abc)]</code> (注意缺少 <code>feature=</code> )。
或者可以使用一个任意的键/值对与一个 <code>=</code> 号，如<code>cargo:rustc-cfg=my_component=&quot;foo&quot;</code>。
键应该是一个Rust标识符，值应该是一个字符串。</p>
<p><a id="rustc-env"></a></p>
<h4 id="cargorustc-envvarvalue"><a class="header" href="#cargorustc-envvarvalue"><code>cargo:rustc-env=VAR=VALUE</code></a></h4>
<p><code>rustc-env</code> 指令告诉Cargo在编译包的时候设置指定的环境变量。
然后可以通过编译后的crate中的<a href="reference/../../std/macro.env.html"><code>env!</code> macro</a>来检索该值。
这对于在crate的代码中嵌入额外的元数据很有用，例如git HEAD的哈希值或持续集成服务器的唯一标识符。</p>
<p>参阅 <a href="reference/environment-variables.html#environment-variables-cargo-sets-for-crates">Cargo自动包含环境变量</a>。</p>
<blockquote>
<p><strong>注意</strong>: 当用 <code>cargo run</code> 或 <code>cargo test</code> 运行可执行文件时，也会设置这些环境变量。
然而，不鼓励这种用法，因为它将可执行文件与Cargo的执行环境关联在一起。
通常情况下，这些环境变量应该只在编译时用 <code>env!</code> 宏来检查。</p>
</blockquote>
<p><a id="rustc-cdylib-link-arg"></a></p>
<h4 id="cargorustc-cdylib-link-argflag"><a class="header" href="#cargorustc-cdylib-link-argflag"><code>cargo:rustc-cdylib-link-arg=FLAG</code></a></h4>
<p><code>rustc-dylib-link-arg</code> 指令告诉Cargo将 <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> 传递给编译器，但只在构建 <code>cdylib</code> 库目标时使用。
它的使用是高度平台特定的。对于设置共享库的版本或运行时路径很有用。</p>
<p><a id="cargo-warning"></a></p>
<h4 id="cargowarningmessage"><a class="header" href="#cargowarningmessage"><code>cargo:warning=MESSAGE</code></a></h4>
<p><code>warning</code> 指令告诉Cargo在构建脚本运行完毕后显示一个警告。
警告只针对 <code>path</code> 依赖(也就是你在本地工作的那些依赖)，所以例如在<a href="https://crates.io/">crates.io</a>crates中打印出来的警告，默认是不会发送的。
<code>-vv</code> &quot;very verbose&quot; 标志可以用来让Cargo显示所有crate的警告。</p>
<h3 id="构建依赖-1"><a class="header" href="#构建依赖-1">构建依赖</a></h3>
<p>构建脚本也可以依赖其他基于Cargo的crates。
依赖是通过配置清单中的 <code>build-dependencies</code> 部分来声明的。</p>
<pre><code class="language-toml">[build-dependencies]
cc = &quot;1.0.46&quot;
</code></pre>
<p>构建脚本<em>不</em>访问列在 <code>dependencies</code> 或 <code>dev-dependencies</code> 部分的依赖项(它们还没有被构建！)。
另外，除非在 <code>[dependencies]</code> 表中明确添加，否则构建的依赖项对包本身是不可用的。</p>
<p>建议仔细考虑你添加的每个依赖，权衡对编译时间、许可、维护等的影响。
如果一个依赖是在构建依赖和正常依赖之间共享的，Cargo会尝试重用它。然而，这并不总是能用，例如在交叉编译时，所以要考虑到对编译时间的影响。</p>
<h3 id="变化检测"><a class="header" href="#变化检测">变化检测</a></h3>
<p>当重建包时，Cargo不一定知道是否需要再次运行构建脚本。
默认情况下，它采取一种保守的方法，即如果包中的任何文件被改变(或由 <a href="reference/manifest.html#the-exclude-and-include-fields"><code>exclude</code> 和 <code>include</code> 字段</a> 控制的文件列表被改变)，则总是重新运行构建脚本。
在大多数情况下，这不是一个好的选择，所以建议每个构建脚本至少发出一个 <code>rerun-if</code> 指令(如下所述)。
如果发出了这些指令，那么Cargo只会在给定值发生变化时重新运行脚本。
如果Cargo重新运行你自己的crate或依赖的构建脚本，而你又不知道为什么，请参见FAQ中的<a href="reference/.../faq.html#why-is-cargo-rebuilding-my-code">&quot;为什么Cargo要重新构建我的代码？&quot;</a>。</p>
<p><a id="rerun-if-changed"></a></p>
<h4 id="cargorerun-if-changedpath"><a class="header" href="#cargorerun-if-changedpath"><code>cargo:rerun-if-changed=PATH</code></a></h4>
<p><code>rerun-if-changed</code> 指令告诉Cargo在指定路径的文件发生变化时重新运行构建脚本。
目前，Cargo只使用文件系统最后修改的 &quot;mtime&quot; 时间戳来确定文件是否有变化。
它与内部缓存的构建脚本最后运行的时间戳进行比较。</p>
<p>如果路径指向一个目录，它将扫描整个目录的任何修改。</p>
<p>如果构建脚本在任何情况下都不需要重新运行，那么发出 <code>cargo:rerun-if-changed=build.rs</code> 是防止其重新运行的简单方法(否则，如果没有发出 <code>rerun-if</code> 指令，则默认为扫描整个包目录的变化)。
Cargo会自动处理脚本本身是否需要重新编译，当然，脚本在重新编译后会被重新运行。
否则，指定 <code>build.rs</code> 是多余的，没有必要。</p>
<p><a id="rerun-if-env-changed"></a></p>
<h4 id="cargorerun-if-env-changedname"><a class="header" href="#cargorerun-if-env-changedname"><code>cargo:rerun-if-env-changed=NAME</code></a></h4>
<p><code>rerun-if-env-changed</code> 指令告诉Cargo，如果给定名称的环境变量值发生变化，则重新运行构建脚本。</p>
<p>注意，这里的环境变量是针对全局环境变量如 <code>CC</code> 之类的，对于Cargo设置的 <code>TARGET</code> 之类的环境变量没有必要使用这个。</p>
<h3 id="links-配置清单key"><a class="header" href="#links-配置清单key"><code>links</code> 配置清单Key</a></h3>
<p><code>package.links</code> 键可以在 <code>Cargo.toml</code> 清单中设置，以声明该包与给定的本地库相链接。
这个清单键的目的是让Cargo了解一个包的本地依赖，以及提供在包构建脚本之间传递元数据的有条理的系统。</p>
<pre><code class="language-toml">[package]
# ...
links = &quot;foo&quot;
</code></pre>
<p>该清单表明，该包链接到 <code>libfoo</code> 本地库。
当使用 <code>links</code> 键时，包必须有一个构建脚本，而构建脚本应该使用 <a href="reference/build-scripts.html#rustc-link-lib"><code>rustc-link-lib</code>指令</a> 来链接该库。</p>
<p>主要的是，Cargo要求每个 <code>links</code> 值最多只能有一个包。
换句话说，禁止让两个包链接到同一个本地库。
这有助于防止crates之间的重复符号。注意，有一些<a href="reference/build-scripts.html#-sys-packages">已有的惯例</a>可以缓解这个问题。</p>
<p>如上文在输出格式中提到的，每个构建脚本可以以键值对的形式生成一组任意的元数据。
这些元数据被传递给 <strong>依赖的</strong> 包的构建脚本。
例如，如果包 <code>bar</code> 依赖于 <code>foo</code> ，那么如果 <code>foo</code> 生成 <code>key=value</code> 作为其构建脚本元数据的一部分，那么 <code>bar</code> 的构建脚本将有 <code>DEP_FOO_KEY=value</code> 的环境变量。
参见 <a href="reference/build-script-examples.html#using-another-sys-crate">&quot;使用另一个 <code>sys</code> crate&quot;</a>，以了解如何使用这个例子。</p>
<p>请注意，元数据只传递给直接依赖，而不传递给过渡依赖。</p>
<h3 id="-sys-包"><a class="header" href="#-sys-包"><code>*-sys</code> 包</a></h3>
<p>一些链接到系统库的Cargo包有后缀为 <code>-sys</code> 的命名惯例。
任何名为 <code>foo-sys</code> 的包都应该提供两个主要功能。</p>
<ul>
<li>库crate应该链接到本地库 <code>libfoo</code> 。这通常会在从源代码构建之前探测当前系统中的 <code>libfoo</code> 。</li>
<li>这个库应该为 <code>libfoo</code> 中的类型和函数提供 <strong>声明</strong>，而<strong>不是</strong>更高级别的抽象。</li>
</ul>
<p><code>*-sys</code> 包的集合为连接本地库提供了通用的依赖。
有了这个本地库相关包的惯例，带来许多好处。</p>
<ul>
<li>对 <code>foo-sys</code> 的共同依赖简便了对于每个 <code>links</code> 值一个包的规则。</li>
<li>其他 <code>sys</code> 包可以利用 <code>DEP_NAME_KEY=value</code> 环境变量的优势，更好地与其他包集成。参见 <a href="reference/build-script-examples.html#using-another-sys-crate">&quot;使用另一个 <code>sys</code> crate&quot;</a> 例子。</li>
<li>一个共同的依赖允许将逻辑集中在发现 <code>libfoo</code> 本身(或从源代码构建它)。</li>
<li>这些依赖很容易被 <a href="reference/build-scripts.html#overriding-build-scripts">覆盖</a> 。</li>
</ul>
<p>通常会有一个没有 <code>-sys</code> 后缀的配套包，在sys包的基础上提供安全的高级抽象。
例如，<a href="https://crates.io/crates/git2"><code>git2</code> crate</a> 为 <a href="https://crates.io/crates/libgit2-sys"><code>libgit2-sys</code> crate</a> 提供了一个高级接口。</p>
<h3 id="覆盖构建脚本"><a class="header" href="#覆盖构建脚本">覆盖构建脚本</a></h3>
<p>如果配置清单中包含 <code>links</code> 键，那么Cargo支持用自定义库覆盖指定的构建脚本。
这一功能的目的是为了防止完全运行相关的构建脚本，而是提前提供元数据。</p>
<p>要覆盖一个构建脚本，在任意允许的 <a href="reference/config.html"><code>config.toml</code></a> 文件中放置以下配置。</p>
<pre><code class="language-toml">[target.x86_64-unknown-linux-gnu.foo]
rustc-link-lib = [&quot;foo&quot;]
rustc-link-search = [&quot;/path/to/foo&quot;]
rustc-flags = &quot;-L /some/path&quot;
rustc-cfg = ['key=&quot;value&quot;']
rustc-env = {key = &quot;value&quot;}
rustc-cdylib-link-arg = [&quot;…&quot;]
metadata_key1 = &quot;value&quot;
metadata_key2 = &quot;value&quot;
</code></pre>
<p>在这种配置下，如果包声明它链接到 <code>foo</code> ，那么构建脚本将 <strong>不</strong> 被编译或运行，而将使用指定的元数据。</p>
<p>不应使用 <code>warning</code> 、 <code>rerun-if-changed</code> 和 <code>rerun-if-env-changed</code> 键，它们将被忽略。</p>
<h3 id="jobserver"><a class="header" href="#jobserver">Jobserver</a></h3>
<p>Cargo和 <code>rustc</code> 使用为GNU 制作开发的<a href="http://make.mad-scientist.net/papers/jobserver-implementation/">jobserver 协议</a>来协调进程间的并发。
它本质上是信号，控制同时运行的作业数量。
并发性可以用 <code>--jobs</code> 标志来设置，默认为逻辑CPU的数量。</p>
<p>每个构建脚本都从Cargo那里继承一个作业槽，并试图运行时只使用一个CPU。
如果脚本想并行使用更多的CPU，应该使用<a href="https://crates.io/crates/jobserver"><code>jobserver</code> crate</a>来与Cargo协调。</p>
<p>As an example, the <a href="https://crates.io/crates/cc"><code>cc</code> crate</a> may enable the optional <code>parallel</code> feature
which will use the jobserver protocol to attempt to build multiple C files
at the same time.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="构建脚本示例"><a class="header" href="#构建脚本示例">构建脚本示例</a></h2>
<p>下面小节是一些编写的构建脚本的示例演示。</p>
<p>在<a href="https://crates.io/">crates.io</a>的crates构建脚本中可以找到一些常见的功能。
查看 <a href="https://crates.io/keywords/build-dependencies"><code>build-dependencies</code> keyword</a>，看看有那些可用。
下面是一些流行的 crates<sup class="footnote-reference"><a href="#†">1</a></sup> 示例。</p>
<ul>
<li><a href="https://crates.io/crates/bindgen"><code>bindgen</code></a> — 自动生成Rust FFI与C库的绑定。</li>
<li><a href="https://crates.io/crates/cc"><code>cc</code></a> — 编译 C/C++/assembly 。</li>
<li><a href="https://crates.io/crates/pkg-config"><code>pkg-config</code></a> — 使用 <code>pkg-config</code> 工具检测系统库。</li>
<li><a href="https://crates.io/crates/cmake"><code>cmake</code></a> — 运行 <code>cmake</code> 构建工具来构建一个本地库。</li>
<li><a href="https://crates.io/crates/autocfg"><code>autocfg</code></a>,
<a href="https://crates.io/crates/rustc_version"><code>rustc_version</code></a>,
<a href="https://crates.io/crates/version_check"><code>version_check</code></a> — 这些crates提供了基于当前 <code>rustc</code> (如编译器的版本) 实现条件编译的方法。</li>
</ul>
<div class="footnote-definition" id="†"><sup class="footnote-definition-label">1</sup>
<p>这个列表并不仅是一种签注。它评估你的依赖，看哪一个是更适合你的项目。</p>
</div>
<h3 id="code-生成"><a class="header" href="#code-生成">Code 生成</a></h3>
<p>由于各种原因，有些Cargo包在编译前需要生成代码。
在这里，通过一个简单的例子，生成一个库调用将作为构建脚本的一部分。</p>
<p>首先，来看一下这个包的目录结构:</p>
<pre><code class="language-text">.
├── Cargo.toml
├── build.rs
└── src
    └── main.rs

1 directory, 3 files
</code></pre>
<p>可以看到，有一个 <code>build.rs</code> 构建脚本和 <code>main.rs</code> 二进制文件。这个包有一个基本的配置清单:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = &quot;hello-from-generated-code&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
</code></pre>
<p>来看看构建脚本里面有什么内容:</p>
<pre><pre class="playground"><code class="language-rust no_run">// build.rs

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let out_dir = env::var_os(&quot;OUT_DIR&quot;).unwrap();
    let dest_path = Path::new(&amp;out_dir).join(&quot;hello.rs&quot;);
    fs::write(
        &amp;dest_path,
        &quot;pub fn message() -&gt; &amp;'static str {
            \&quot;Hello, World!\&quot;
        }
        &quot;
    ).unwrap();
    println!(&quot;cargo:rerun-if-changed=build.rs&quot;);
}</code></pre></pre>
<p>这里有几个值得注意的地方:</p>
<ul>
<li>脚本使用 <code>OUT_DIR</code> 环境变量来发现输出文件的位置。
它可以使用进程的当前工作目录来寻找输入文件的位置，但在当前情况下我们没有任何输入文件。</li>
<li>一般来说，构建脚本不应该修改 <code>OUT_DIR</code> 以外的任何文件。
乍一看，这似乎没什么问题，但当你使用这样的crate作为依赖时，却会产生问题，因为 <em>implicit</em> &quot;隐式&quot;不变性，即 <code>.cargo/registry</code> 中的源码应该是不可改变的。 <code>cargo</code> 在打包时不允许这样的脚本。</li>
<li>这个脚本相对简单，因为它只是写生成了一个小的文件。
可以想象，还可以进行其他更多有趣的操作，例如从C头文件或其他语言定义中生成一个Rust模块。</li>
<li><a href="reference/build-scripts.html#rerun-if-changed"><code>rerun-if-changed</code> instruction</a> 告知Cargo，只有当构建脚本本身发生变化时才需要重新运行构建脚本。
如果没有这一行，Cargo会在包中的任何文件发生变化时自动运行构建脚本。
如果你的代码生成使用了一些输入文件，这里就应是你要打印每个文件列表的地方。</li>
</ul>
<p>接下来，来看一下库本身:</p>
<pre><code class="language-rust ignore">// src/main.rs

include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/hello.rs&quot;));

fn main() {
    println!(&quot;{}&quot;, message());
}</code></pre>
<p>这就是真正奇妙的地方。该库使用rustc定义的 <a href="reference/../../std/macro.include.html"><code>include!</code> macro</a> 与 <a href="reference/../../std/macro.concat.html"><code>concat!</code></a> 和 <a href="reference/../../std/macro.env.html"><code>env!</code></a> 宏相结合，将生成的文件(<code>hello.rs</code>)纳入crate的编译。</p>
<p>使用这里显示的结构，crates可以include来自构建脚本本身任意数量的生成文件。</p>
<h3 id="构建本地库"><a class="header" href="#构建本地库">构建本地库</a></h3>
<p>有时有必要将一些本地C或C++代码作为包的一部分来构建。
这是利用构建脚本在Rust crate本身之前构建本地库的另一个很好的用例。
作为例子，我们将创建一个Rust库，调用C语言来打印 “Hello, World!” 。</p>
<p>像上面一样，来先看一下包的层次。</p>
<pre><code class="language-text">.
├── Cargo.toml
├── build.rs
└── src
    ├── hello.c
    └── main.rs

1 directory, 4 files
</code></pre>
<p>与上面的相似，以下是配置清单:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = &quot;hello-world-from-c&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
</code></pre>
<p>现在我们不打算使用任何构建依赖，先来看一下构建脚本:</p>
<pre><pre class="playground"><code class="language-rust no_run">// build.rs

use std::process::Command;
use std::env;
use std::path::Path;

fn main() {
    let out_dir = env::var(&quot;OUT_DIR&quot;).unwrap();

    // Note that there are a number of downsides to this approach, the comments
    // below detail how to improve the portability of these commands.
    Command::new(&quot;gcc&quot;).args(&amp;[&quot;src/hello.c&quot;, &quot;-c&quot;, &quot;-fPIC&quot;, &quot;-o&quot;])
                       .arg(&amp;format!(&quot;{}/hello.o&quot;, out_dir))
                       .status().unwrap();
    Command::new(&quot;ar&quot;).args(&amp;[&quot;crus&quot;, &quot;libhello.a&quot;, &quot;hello.o&quot;])
                      .current_dir(&amp;Path::new(&amp;out_dir))
                      .status().unwrap();

    println!(&quot;cargo:rustc-link-search=native={}&quot;, out_dir);
    println!(&quot;cargo:rustc-link-lib=static=hello&quot;);
    println!(&quot;cargo:rerun-if-changed=src/hello.c&quot;);
}</code></pre></pre>
<p>这个编译脚本首先将C文件编译成object文件(通过调用<code>gcc</code>)，然后将这个object文件转换为静态库 (通过调用<code>ar</code>)。
最后一步是反馈给Cargo本身，告知输出在 <code>out_dir</code> ，编译器应该通过 <code>-l static=hello</code> 标志将crate静态链接到 <code>libhello.a</code> 。</p>
<p>注意，这种硬编码的方法有很多缺点:</p>
<ul>
<li><code>gcc</code> 命令本身不能跨平台移植。例如，Windows平台不太可能有 <code>gcc</code> ，甚至不是所有Unix平台都可能有 <code>gcc</code> 。 <code>ar</code> 命令也是类似的情况。</li>
<li>这些命令没有考虑到交叉编译的问题。如果为Android这样的平台进行交叉编译，那么 <code>gcc</code> 不太可能产生ARM的可执行文件。</li>
</ul>
<p>不过不用担心，这时 <code>build-dependencies</code> 条目会有帮助。Cargo生态系统有许多包，可以使这种任务变得更容易、便携、标准。
试试<a href="https://crates.io/">crates.io</a>的<a href="https://crates.io/crates/cc"><code>cc</code> crate</a>。首先，把它添加到 <code>Cargo.toml</code> 的 <code>build-dependencies</code> 中。</p>
<pre><code class="language-toml">[build-dependencies]
cc = &quot;1.0&quot;
</code></pre>
<p>并重写构建脚本以使用这个crate。</p>
<pre><code class="language-rust ignore">// build.rs

fn main() {
    cc::Build::new()
        .file(&quot;src/hello.c&quot;)
        .compile(&quot;hello&quot;);
    println!(&quot;cargo:rerun-if-changed=src/hello.c&quot;);
}</code></pre>
<p><a href="https://crates.io/crates/cc"><code>cc</code> crate</a> 抽象了一系列对C代码构建的脚本需求:</p>
<ul>
<li>它调用适当的编译器 (MSVC用于Windows， <code>gcc</code> 用于MinGW， <code>cc</code> 用于Unix平台，等等)。</li>
<li>它通过向正在使用的编译器传递适当的标志，将 <code>TARGET</code> 变量考虑在内。</li>
<li>其他环境变量，如 <code>OPT_LEVEL</code> 、 <code>DEBUG</code> 等，都是自动处理的。</li>
<li>stdout输出和 <code>OUT_DIR</code> 位置也由 <code>cc</code> 库处理。</li>
</ul>
<p>在这里，可以看到将尽可能多的功能移植到共同的构建依赖中，而不是在所有的构建脚本中重复逻辑的一些主要好处。</p>
<p>回到示例研究，来快速看一下 <code>src</code> 目录的内容:</p>
<pre><code class="language-c">// src/hello.c

#include &lt;stdio.h&gt;

void hello() {
    printf(&quot;Hello, World!\n&quot;);
}
</code></pre>
<pre><code class="language-rust ignore">// src/main.rs

// 注意没有 `#[link]` 属性。把链接内容的责任交给了构建脚本，而不是在源文件中硬编码。
extern { fn hello(); }

fn main() {
    unsafe { hello(); }
}</code></pre>
<p>那么开始! 这样就完成了从Cargo包中使用构建脚本本身构建一些C代码的例子。
这也说明为什么在很多情况下，使用构建依赖是非常关键的，甚至更加简洁!</p>
<p>我们也看到了这个简短的示例，说明构建脚本如何单纯将crate作为依赖，而不是在运行时将crate本身作为依赖。</p>
<h3 id="链接到系统库"><a class="header" href="#链接到系统库">链接到系统库</a></h3>
<p>这个例子演示了如何链接系统库，以及如何支持使用构建脚本。</p>
<p>很多时候，Rust crate想要链接到系统上提供的本地库，绑定其功能，或者只是将其作为实现细节的一部分。
当涉及到以一种平台无关的方式执行时，这是相当细微的问题。
最好的办法是，如果可能的话，尽可能多地把这部分工作交给别人去做，让使用者更轻松。</p>
<p>对于这个例子，将创建一个与系统zlib库的绑定。
这是在大多数类Unix系统中常见的库，提供数据压缩。
这已经包含在<a href="https://crates.io/crates/libz-sys"><code>libz-sys</code> crate</a>中了，但对于这个例子，我们将做一个极其简化的版本。请查看<a href="https://github.com/rust-lang/libz-sys">libz源码</a>以了解完整的用例。</p>
<p>为了方便找到库的位置，我们将使用<a href="https://crates.io/crates/pkg-config"><code>pkg-config</code> crate</a>。这个crate使用系统的 <code>pkg-config</code> 工具来发现库的信息。
它将自动告诉Cargo需要什么来链接这个库。这可能只能在安装了 <code>pkg-config</code> 的类Unix系统上工作。先从设置配置清单开始:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = &quot;libz-sys&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
links = &quot;z&quot;

[build-dependencies]
pkg-config = &quot;0.3.16&quot;
</code></pre>
<p>请注意，我们在 <code>package</code> 表中加入了 <code>links</code> 键。
这告知Cargo，正在链接到 <code>libz</code> 库。
请看<a href="reference/build-script-examples.html#using-another-sys-crate">&quot;使用另一个系统crate&quot;</a>中的例子，可以利用这点。</p>
<p>构建脚本相当简单:</p>
<pre><code class="language-rust ignore">// build.rs

fn main() {
    pkg_config::Config::new().probe(&quot;zlib&quot;).unwrap();
    println!(&quot;cargo:rerun-if-changed=build.rs&quot;);
}</code></pre>
<p>那么用基本的FFI绑定来完善这个例子:</p>
<pre><code class="language-rust ignore">// src/lib.rs

use std::os::raw::{c_uint, c_ulong};

extern &quot;C&quot; {
    pub fn crc32(crc: c_ulong, buf: *const u8, len: c_uint) -&gt; c_ulong;
}

#[test]
fn test_crc32() {
    let s = &quot;hello&quot;;
    unsafe {
        assert_eq!(crc32(0, s.as_ptr(), s.len() as c_uint), 0x3610a686);
    }
}</code></pre>
<p>运行 <code>cargo build -vv</code> 来查看构建脚本的输出。在已经安装了 <code>libz</code> 的系统上，可能看起来像这样:</p>
<pre><code class="language-text">[libz-sys 0.1.0] cargo:rustc-link-search=native=/usr/lib
[libz-sys 0.1.0] cargo:rustc-link-lib=z
[libz-sys 0.1.0] cargo:rerun-if-changed=build.rs
</code></pre>
<p>很好! <code>pkg-config</code> 做了所有寻找库的工作，并告知Cargo它的位置。</p>
<p>包包括库的源代码，如果在系统中找不到它，或者设置了某个特性或环境变量，就静态地构建它，这种情况并不罕见。
例如，实际的 <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code> crate</a> 检查环境变量 <code>LIBZ_SYS_STATIC</code> 或 <code>static</code> 特性，从源码构建而不是使用系统库。
请查看 <a href="https://github.com/rust-lang/libz-sys">the source</a> 以了解更完整的例子。</p>
<h3 id="使用另一个-sys-crate"><a class="header" href="#使用另一个-sys-crate">使用另一个 <code>sys</code> crate</a></h3>
<p>当使用 <code>links</code> 键时，crates可以设置元数据，这些元数据可以被其他依赖它的crates读取。这提供了一种在crates之间通信的机制。在这个例子中，我们将创建一个C语言库，利用实际的 <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code> crate</a> 中的zlib。</p>
<p>如果你有一个依赖于zlib的C库，你可以利用 <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code> crate</a> 来自动查找或构建它。这对于跨平台支持非常有用，比如通常不安装zlib的Windows。
<code>libz-sys</code><a href="https://github.com/rust-lang/libz-sys/blob/3c594e677c79584500da673f918c4d2101ac97a1/build.rs#L156">设置 <code>include</code> 元数据</a> ，告诉其他软件包在哪里可以找到zlib的头文件。
我们的构建脚本可以通过 <code>DEP_Z_INCLUDE</code> 环境变量读取该元数据。
下面是一个例子:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = &quot;zuser&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
libz-sys = &quot;1.0.25&quot;

[build-dependencies]
cc = &quot;1.0.46&quot;
</code></pre>
<p>这里我们包含了 <code>libz-sys</code> ，这将确保在最终库中只有一个 <code>libz</code> ，并允许我们从构建脚本中访问它:</p>
<pre><code class="language-rust ignore">// build.rs

fn main() {
    let mut cfg = cc::Build::new();
    cfg.file(&quot;src/zuser.c&quot;);
    if let Some(include) = std::env::var_os(&quot;DEP_Z_INCLUDE&quot;) {
        cfg.include(include);
    }
    cfg.compile(&quot;zuser&quot;);
    println!(&quot;cargo:rerun-if-changed=src/zuser.c&quot;);
}</code></pre>
<p>有了 <code>libz-sys</code> 做所有繁重的工作，C源码现在可以include zlib头文件，它应能找到这个头文件，即使在还没有安装它的系统上。</p>
<pre><code class="language-c">// src/zuser.c

#include &quot;zlib.h&quot;

// … 使用zlib的其余代码。
</code></pre>
<h3 id="条件编译"><a class="header" href="#条件编译">条件编译</a></h3>
<p>构建脚本可以发出 <a href="reference/build-scripts.html#rustc-cfg"><code>rustc-cfg</code> 指令</a> ，这些指令可以启用在编译时可以检查的条件。
在这个例子中，我们将看看 <a href="https://crates.io/crates/openssl"><code>openssl</code> crate</a> 如何使用它来支持多个版本的OpenSSL库。</p>
<p><a href="https://crates.io/crates/openssl-sys"><code>openssl-sys</code> crate</a> 实现了OpenSSL库的构建和链接。
它支持多种不同的实现方式 (如LibreSSL) 和多个版本。
它使用了 <code>links</code> 键，这样就可以向其他构建脚本传递信息。
它传递的信息之一是 <code>version_number</code> 键，这是检测到的OpenSSL的版本。
构建脚本中的代码看起来<a href="https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl-sys/build/main.rs#L216">像这样</a>:</p>
<pre><code class="language-rust ignore">println!(&quot;cargo:version_number={:x}&quot;, openssl_version);</code></pre>
<p>这条指令使 <code>DEP_OPENSSL_VERSION_NUMBER</code> 环境变量在任何直接依赖 <code>openssl-sys</code> 的crates中被设置。</p>
<p><code>openssl</code> crate 提供了更高层次的接口，指定 <code>openssl-sys</code> 为依赖项。
<code>openssl</code> 构建脚本可以通过 <code>DEP_OPENSSL_VERSION_NUMBER</code> 环境变量读取由 <code>openssl-sys</code> 构建脚本生成的版本信息。
它用这个来生成一些 <a href="https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl/build.rs#L18-L36"><code>cfg</code> values</a>。</p>
<pre><code class="language-rust ignore">// (portion of build.rs)

if let Ok(version) = env::var(&quot;DEP_OPENSSL_VERSION_NUMBER&quot;) {
    let version = u64::from_str_radix(&amp;version, 16).unwrap();

    if version &gt;= 0x1_00_01_00_0 {
        println!(&quot;cargo:rustc-cfg=ossl101&quot;);
    }
    if version &gt;= 0x1_00_02_00_0 {
        println!(&quot;cargo:rustc-cfg=ossl102&quot;);
    }
    if version &gt;= 0x1_01_00_00_0 {
        println!(&quot;cargo:rustc-cfg=ossl110&quot;);
    }
    if version &gt;= 0x1_01_00_07_0 {
        println!(&quot;cargo:rustc-cfg=ossl110g&quot;);
    }
    if version &gt;= 0x1_01_01_00_0 {
        println!(&quot;cargo:rustc-cfg=ossl111&quot;);
    }
}</code></pre>
<p>这些 <code>cfg</code> 值可以与 <a href="reference/../../reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code> attribute</a>  或 <a href="reference/../../std/macro.cfg.html"><code>cfg</code> macro</a>一起使用，从而有条件地include代码。
例如，SHA3支持是在OpenSSL 1.1.1中添加的，所以对于旧版本它被<a href="https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl/src/hash.rs#L67-L85">条件排除</a>。</p>
<pre><code class="language-rust ignore">// (portion of openssl crate)

#[cfg(ossl111)]
pub fn sha3_224() -&gt; MessageDigest {
    unsafe { MessageDigest(ffi::EVP_sha3_224()) }
}</code></pre>
<p>当然，使用这种方法时应该小心，因为它使生成的二进制文件更加依赖于构建环境。
在这个例子中，如果二进制文件被分发到另一个系统，它可能没有完全相同的共享库，这可能导致问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="发布到cratesio"><a class="header" href="#发布到cratesio">发布到crates.io</a></h2>
<p>你有一个想与世界分享的库，就该在<a href="https://crates.io/">crates.io</a>上发布它，发布crate是指将特定版本上传到<a href="https://crates.io/">crates.io</a>上托管。</p>
<p>在发布crate时要小心，因为发布是<strong>永久的</strong>。该版本永远不能被覆盖，代码也不能被删除。然而，可以发布的版本数量是没有限制的。</p>
<h3 id="在你第一次发布之前"><a class="header" href="#在你第一次发布之前">在你第一次发布之前</a></h3>
<p>首先，你需要一个<a href="https://crates.io/">crates.io</a>的账户来获取API token。要做到这一点，<a href="https://crates.io/">访问主页</a>并通过GitHub账户登录(目前需要)。
之后，访问你的<a href="https://crates.io/me">账户设置</a>页面并运行<a href="reference/../commands/cargo-login.html"><code>cargo login</code></a>命令。</p>
<pre><code class="language-console">$ cargo login
</code></pre>
<p>然后在提示中输入指定的Token。</p>
<pre><code class="language-console">please paste the API Token found on https://crates.io/me below
abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>这个命令会将你的API token告知Cargo，并将其保存在你本地的 <code>~/.cargo/credentials.toml</code> 中。
请注意，这个token是<strong>私秘的</strong>，不应该与其他人分享。如果它因某些原因被泄露，你应该立即撤销它。</p>
<h3 id="在发布新crate之前"><a class="header" href="#在发布新crate之前">在发布新crate之前</a></h3>
<p>[cates.io]上的crate名称是以先到先得的方式分配的。一旦一个crate的名字被占用，它就不能用于其他crate。</p>
<p>查看 <code>Cargo.toml</code> 中的<a href="reference/manifest.html">你能指定的元数据</a>，让使用者更容易发现你crate! 在发布之前，请确保你已经填写了以下字段:</p>
<ul>
<li><a href="reference/manifest.html#the-license-and-license-file-fields"><code>license</code> or <code>license-file</code></a></li>
<li><a href="reference/manifest.html#the-description-field"><code>description</code></a></li>
<li><a href="reference/manifest.html#the-homepage-field"><code>homepage</code></a></li>
<li><a href="reference/manifest.html#the-documentation-field"><code>documentation</code></a></li>
<li><a href="reference/manifest.html#the-repository-field"><code>repository</code></a></li>
<li><a href="reference/manifest.html#the-readme-field"><code>readme</code></a></li>
</ul>
<p>包含一些<a href="reference/manifest.html#the-keywords-field"><code>keywords</code></a> 和 <a href="reference/manifest.html#the-categories-field"><code>categories</code></a> 也会很好，尽管不是必须的。</p>
<p>如果你要发布库，可能还需要参考一下<a href="https://rust-lang.github.io/api-guidelines/">Rust API Guidelines</a>。</p>
<h4 id="打包crate"><a class="header" href="#打包crate">打包crate</a></h4>
<p>下一步是将你的crate打包并上传到<a href="https://crates.io/">crates.io</a>。为此使用 <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> 子命令。
这个命令会执行以下步骤:</p>
<ol>
<li>对包进行一些验证检查。</li>
<li>将源代码压缩成 <code>.crate</code> 文件。</li>
<li>将<code>.crate</code>文件解压缩到临时目录中，并验证它是否可以编译。</li>
<li>将<code>.crate</code>文件上传到<a href="https://crates.io/">crates.io</a>。</li>
<li>注册中心将在添加之前对上传的包进行一些额外的检查。</li>
</ol>
<p>建议你首先运行 <code>cargo publish --dry-run</code> (或<a href="reference/../commands/cargo-package.html"><code>cargo package</code></a>) ，
以确保在发布前没有任何警告或错误。这将执行上面列出的前三个步骤。</p>
<pre><code class="language-console">$ cargo publish --dry-run
</code></pre>
<p>你可以在 <code>target/package</code> 目录下检查生成的 <code>.crate</code> 文件。
<a href="https://crates.io/">crates.io</a>目前对 <code>.crate</code> 文件有10MB的大小限制。你需要检查 <code>.crate</code> 文件的大小，
以确保没有意外地打包了构建包所不需要的大型资产，如测试数据、网站文档或代码生成。
你可以用下面的命令来检查哪些文件被包含:</p>
<pre><code class="language-console">$ cargo package --list
</code></pre>
<p>Cargo在打包时将自动忽略您的版本控制系统所忽略的文件，但如果想额外指定一组要忽略的文件，
您可以在配置清单中使用<a href="reference/manifest.html#the-exclude-and-include-fields"><code>exclude</code> 键</a>。</p>
<pre><code class="language-toml">[package]
# ...
exclude = [
    &quot;public/assets/*&quot;,
    &quot;videos/*&quot;,
]
</code></pre>
<p>如果你想明确地列出要包括的文件，Cargo也支持 <code>include</code> 键，如果设置了这个键，就可以覆盖 <code>exclude</code> 键。</p>
<pre><code class="language-toml">[package]
# ...
include = [
    &quot;**/*.rs&quot;,
    &quot;Cargo.toml&quot;,
]
</code></pre>
<h3 id="上传crate"><a class="header" href="#上传crate">上传crate</a></h3>
<p>当你准备好发布时，使用 <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> 命令上传至 <a href="https://crates.io/">crates.io</a> :</p>
<pre><code class="language-console">$ cargo publish
</code></pre>
<p>这样，你现在已经发布了第一个 crate !</p>
<h3 id="发布现有crate的新版本"><a class="header" href="#发布现有crate的新版本">发布现有crate的新版本</a></h3>
<p>为了发布新版本，请更改 &quot;Cargo.toml&quot; 清单中指定的 <a href="reference/manifest.html#the-version-field"><code>version</code> 值</a>。
请记住 <a href="reference/semver.html">语义化版本规范</a>，该规范提供了关于什么是兼容性改变的指南。
然后如上所述运行<a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> 来上传新版本。</p>
<h3 id="管理基于crateio的crate"><a class="header" href="#管理基于crateio的crate">管理基于crate.io的crate</a></h3>
<p>crate的管理主要是通过命令行 <code>cargo</code> 工具而不是 <a href="https://crates.io/">crates.io</a> 网络界面来完成。
因此，有几个子命令来管理crate。</p>
<h4 id="cargo-yank"><a class="header" href="#cargo-yank"><code>cargo yank</code></a></h4>
<p>偶尔会出现这样的情况：你发布的版本由于某种原因(语法错误、忘记包含某个文件等)，实际上已经坏了。
对于这样的情况，Cargo支持 &quot;删除&quot; crate 的一个版本。</p>
<pre><code class="language-console">$ cargo yank --version 1.0.1
$ cargo yank --version 1.0.1 --undo
</code></pre>
<p>yank <strong>不会</strong>删除任何代码。这个功能不能删除意外上传的秘密。如果发生这种情况，请立即重置这些秘密。</p>
<p>被删除的版本的语义是，不能针对该版本创建新的依赖，但已有的依赖继续使用。
<a href="https://crates.io/">crates.io</a>的主要目标之一是作为一个不随时间变化的永久档案，允许删除一个版本将违背这一目标。
从本质上讲，yank 意味着所有带有 &quot;Cargo.lock&quot; 的包都不会损坏，而未来生成的任何 &quot;Cargo.lock&quot; 文件都不会列出被yank的版本。</p>
<h4 id="cargo-owner"><a class="header" href="#cargo-owner"><code>cargo owner</code></a></h4>
<p>crate通常是由多人开发的，或者主要的维护者可能会随着时间的推移而改变!
crate的所有者是唯一被允许发布crate新版本的人，但所有者可以指定其他所有者。</p>
<pre><code class="language-console">$ cargo owner --add github-handle
$ cargo owner --remove github-handle
$ cargo owner --add github:rust-lang:owners
$ cargo owner --remove github:rust-lang:owners
</code></pre>
<p>给予这些命令的所有者ID必须是GitHub用户名或GitHub团队。</p>
<p>如果一个用户名被赋予<code>--add</code>，该用户就会被邀请为 &quot;命名&quot; 的所有者，拥有对该crate的全部权利。
除了能够发布或取消crate的版本外，他们还能够添加或删除所有者，<em>包括</em> 使他们成为所有者的所有者。
不用说，你不应该把你不完全信任的人变成指定的所有者。为了成为指定的所有者，用户必须在之前登录过[cates.io]。</p>
<p>如果一个团队的名字被赋予 <code>--add</code> ，该团队被邀请为 &quot;团队&quot; 所有者，对crate的权利受到限制。
虽然他们有权限发布或删除crate的版本，但他们<em>没有</em>能力添加或删除所有者。
除了在管理所有者群体方面更方便外，团队在防止所有者成为恶意的方面也更安全。</p>
<p>目前团队的语法是 <code>github:org:team</code> (见上面的例子)。
为了邀请一个团队成为所有者，其必须是该团队的成员。
在删除一个团队的所有者时没有这种限制。</p>
<h3 id="github-许可"><a class="header" href="#github-许可">GitHub 许可</a></h3>
<p>团队成员资格不是GitHub提供的简单的公共访问，你在与他们合作时很可能会遇到以下信息:</p>
<blockquote>
<p>看起来你没有权限从GitHub查询一个必要的属性来完成这个请求。你可能需要在 <a href="https://crates.io/">crates.io</a> 上重新认证，以授予读取 GitHub org 会员资格的权限。</p>
</blockquote>
<p>大体会说：&quot;你试图查询一个团队，但五级成员访问控制拒绝了这一点&quot; 。
这并不夸张。GitHub对团队访问控制的支持是企业级的。</p>
<p>最有可能的原因是，你最后一次登录是在这个功能添加之前。我们最初在认证用户时<em>没有</em>要求GitHub提供权限，
因为我们除了登录用户外，实际上没有使用过用户的令牌。然而，为了代表你查询团队成员，我们现在需要 <a href="https://developer.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/"><code>read:org</code> 域</a>。</p>
<p>你可以自由地拒绝这个域，在引入团队之前的一切工作都将继续运作。
然而，你将无法作为所有者添加一个团队，或作为团队所有者发布crate。如果你试图这样做,会得到上面的错误。
如果你试图发布一个根本不属于你的crate，但恰好有一个团队，也可能看到这个错误。</p>
<p>如果你改变了主意，或者只是不确定<a href="https://crates.io/">crates.io</a>是否有足够的权限，
你可以随时去<a href="https://crates.io/">https://crates.io/</a>重新认证，如果<a href="https://crates.io/">crates.io</a>没有所有它想拥有的域，它会提示你的权限。</p>
<p>查询GitHub的另一个障碍是，该组织可能主动拒绝第三方访问。要检查这一点，你可以去:</p>
<pre><code class="language-text">https://github.com/organizations/:org/settings/oauth_application_policy
</code></pre>
<p>其中 <code>:org</code> 是组织的名称(例如，<code>rust-lang</code>)。你可能会看到类似的情形:</p>
<p><img src="reference/../images/org-level-acl.png" alt="组织访问控制" /></p>
<p>在这里，你可以选择从组织黑名单中明确删除 <a href="https://crates.io/">crates.io</a> ，
或者直接按下 &quot;移除限制&quot; 按钮，允许所有第三方应用程序访问这些数据。</p>
<p>另外，当<a href="https://crates.io/">crates.io</a>请求 &quot;read:org&quot; 域时，你可以通过按下其名称旁边的 &quot;Grant Access&quot; 按钮，明确地将<a href="https://crates.io/">crates.io</a>查询有关的组织列为白名单。</p>
<p><img src="reference/../images/auth-level-acl.png" alt="认证访问控制" /></p>
<h4 id="解决github团队访问错误"><a class="header" href="#解决github团队访问错误">解决GitHub团队访问错误</a></h4>
<p>当试图添加GitHub团队作为crate 所有者时，你可能会看到类似的错误:</p>
<pre><code class="language-text">error: failed to invite owners to crate &lt;crate_name&gt;: api errors (status 200 OK): could not find the github team org/repo
</code></pre>
<p>在这种情况下，你应该去<a href="https://github.com/settings/applications">the GitHub Application settings page</a>，检查crates.io是否被列在 &quot;授权的OAuth应用程序&quot; 标签中。
如果没有，你应该去<a href="https://crates.io/">https://crates.io/</a>并授权它。
然后回到GitHub上的应用设置页面，点击列表中的crates.io应用，确保你或你的组织被列在 &quot;组织访问&quot; 列表中，并打上绿色的勾。
如果有标注 &quot;Grant&quot; 或 &quot;Request&quot; 的按钮，你应该授予权限或要求组织所有者这样做。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="包id规范"><a class="header" href="#包id规范">包ID规范</a></h2>
<h3 id="包id规范-1"><a class="header" href="#包id规范-1">包ID规范</a></h3>
<p>Cargo的子命令经常需要引用依赖图中的某个特定包来进行各种操作，如更新、清理、构建等。
为了解决这个问题，Cargo支持 <em>包ID规范</em> 。规范是一个字符串，用来唯一地指代包图中的一个包。</p>
<p>该规范可以是完整标准的，例如 <code>https://github.com/rust-lang/crates.io-index#regex@1.4.3</code> ，也可以是缩写的，例如 <code>regex</code> 。
缩写的形式可以使用，只要它在依赖图中唯一地标识了一个包。如果有歧义，可以添加额外的限定词来使其唯一。
例如，如果图中有两个版本的 <code>regex</code> 包，那么可以用一个版本来限定，使其唯一，如 <code>regex@1.4.3</code> 。</p>
<h4 id="规范语法"><a class="header" href="#规范语法">规范语法</a></h4>
<p>包Id规范形式的语法是:</p>
<pre><code class="language-notrust">spec := pkgname
       | proto &quot;://&quot; hostname-and-path [ &quot;#&quot; ( pkgname | semver ) ]
pkgname := name [ (&quot;@&quot; | &quot;:&quot; ) semver ]

proto := &quot;http&quot; | &quot;git&quot; | ...
</code></pre>
<p>这里，方括号表示内容是可选的。</p>
<p>URL形式可用于git依赖，或区分来自不同来源的包，如不同的注册中心。</p>
<h4 id="示例规范"><a class="header" href="#示例规范">示例规范</a></h4>
<p>以下是对 <code>crates.io</code> 上的 <code>regex</code> 包的引用:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Spec</th><th style="text-align: center">Name</th><th style="text-align: center">Version</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>regex</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>*</code></td></tr>
<tr><td style="text-align: left"><code>regex@1.4.3</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>1.4.3</code></td></tr>
<tr><td style="text-align: left"><code>https://github.com/rust-lang/crates.io-index#regex</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>*</code></td></tr>
<tr><td style="text-align: left"><code>https://github.com/rust-lang/crates.io-index#regex@1.4.3</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>1.4.3</code></td></tr>
</tbody></table>
</div>
<p>下面是几个不同的git依赖的规范例子:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Spec</th><th style="text-align: center">Name</th><th style="text-align: center">Version</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>https://github.com/rust-lang/cargo#0.52.0</code></td><td style="text-align: center"><code>cargo</code></td><td style="text-align: center"><code>0.52.0</code></td></tr>
<tr><td style="text-align: left"><code>https://github.com/rust-lang/cargo#cargo-platform@0.1.2</code></td><td style="text-align: center"><nobr><code>cargo-platform</code></nobr></td><td style="text-align: center"><code>0.1.2</code></td></tr>
<tr><td style="text-align: left"><code>ssh://git@github.com/rust-lang/regex.git#regex@1.4.3</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>1.4.3</code></td></tr>
</tbody></table>
</div>
<p>文件系统上的本地包可以使用 <code>file://</code> URL来引用它们:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Spec</th><th style="text-align: center">Name</th><th style="text-align: center">Version</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>file:///path/to/my/project/foo</code></td><td style="text-align: center"><code>foo</code></td><td style="text-align: center"><code>*</code></td></tr>
<tr><td style="text-align: left"><code>file:///path/to/my/project/foo#1.1.8</code></td><td style="text-align: center"><code>foo</code></td><td style="text-align: center"><code>1.1.8</code></td></tr>
</tbody></table>
</div>
<h4 id="规范简略"><a class="header" href="#规范简略">规范简略</a></h4>
<p>这样做的目的是为了使在依赖图中引用包的语法既简明又详尽。模糊的引用可能指的是一个或多个包。
如果有一个以上的包可以用相同的规范被引用，大多数命令会产生一个错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="源替换"><a class="header" href="#源替换">源替换</a></h2>
<p>这篇文档是关于替换 crate 索引的。你可以在本文档的 <a href="reference/overriding-dependencies.html">overriding dependencies</a> 部分阅读关于覆盖依赖的内容。</p>
<p><em>源</em> 是包含可以作为包的依赖项的crate的提供者。
Cargo支持 <strong>用一个源替换另一个源的能力</strong> ，从而有以下的策略:</p>
<ul>
<li>
<p>拓展 - 可以自定义源，代表本地文件系统上的crate。这些源是它们所替换源的子集，如果有必要，可以被检查引到包中。</p>
</li>
<li>
<p>镜像 - 源被替换成一个相等的版本，作为crates.io的缓存。</p>
</li>
</ul>
<p>Cargo有一个关于源替换的核心假设，即两个源的源代码是完全一样的。
请注意，这也意味着替换源不允许有原始源中没有的crate。</p>
<p>因此，源替换并不适合于修补依赖或私有注册中心的情况。
Cargo支持通过使用<a href="reference/overriding-dependencies.html"> <code>[patch]</code> 键</a>来修补依赖，对私有注册中心的支持在<a href="reference/registries.html">注册中心章节</a>中描述。</p>
<p>当使用源替换时，运行像 <code>cargo publish</code>  这样需要联系注册中心的命令需要通过 <code>--registry</code> 选项。这有助于避免在联系哪个注册中心方面出现歧义，并将使用指定注册中心的认证令牌。</p>
<h3 id="配置-1"><a class="header" href="#配置-1">配置</a></h3>
<p>替换源的配置是通过 <a href="reference/config.html"><code>.cargo/config.toml</code></a> 完成的，全部可用的键有：</p>
<pre><code class="language-toml"># `source` 表是存储所有与源替换有关的键的位置。
[source]

# 在 `source` 表下有一些其他的表，它们的键是相关来源的名称。
# 例如，这一节定义了一个新的源文件，叫做 `my-vendor-source` ，它来自一个位于 `vendor` 的目录，相对于包含这个 `.cargo/config.toml` 文件的目录而言。
[source.my-vendor-source]
directory = &quot;vendor&quot;

# crates.io的默认源代码以 &quot;crates-io&quot; 的名称提供，这里我们使用 `replace-with` 键来表示它被我们上面的源替换。
#
# `replace-with` 键也可以引用在 `[registries]` 表中定义的其他注册中心名称。
[source.crates-io]
replace-with = &quot;my-vendor-source&quot;

# 每个源都有自己的表，其中键是源的名称。
[source.the-source-name]

# 表示 `the-source-name` 替换为 `another-source` ，定义在其他地方
replace-with = &quot;another-source&quot;

# 可以指定几种源(下文有更详细的描述):
registry = &quot;https://example.com/path/to/index&quot;
local-registry = &quot;path/to/registry&quot;
directory = &quot;path/to/vendor&quot;

# Git源也可以选择指定一个branch/tag/rev
git = &quot;https://example.com/path/to/repo&quot;
# branch = &quot;master&quot;
# tag = &quot;v1.0.1&quot;
# rev = &quot;313f44e8&quot;
</code></pre>
<h3 id="注册中心源"><a class="header" href="#注册中心源">注册中心源</a></h3>
<p>&quot;注册中心源&quot; 是与crates.io 相同的。
也就是说，它有一个在git仓库中提供的索引，与 <a href="https://github.com/rust-lang/crates.io-index">crates.io index</a> 的格式一致。
然后，该仓库表明从哪里下载crates的配置。</p>
<p>目前还没有一个已经可用的项目来建立crates.io的镜像。但请继续关注!</p>
<h3 id="本地注册中心源"><a class="header" href="#本地注册中心源">本地注册中心源</a></h3>
<p>&quot;本地注册中心源&quot; 旨在成为另一个注册中心源的子集，但在本地文件系统上可用(又称拓展)。
本地注册中心是提前下载的，通常与 <code>Cargo.lock</code> 同步，并由一组 <code>*.crate</code> 文件和一个索引组成，就像普通注册中心一样。</p>
<p>管理和创建本地注册中心源的主要方式是通过 <a href="https://crates.io/crates/cargo-local-registry"><code>cargo-local-registry</code></a> 子命令，
<a href="https://crates.io/crates/cargo-local-registry">crates.io上有</a>，可以用 <code>cargo install cargo-local-registry</code> 来安装。</p>
<p>本地注册中心包含在一个目录中，并包含一些从crates.io下载的 <code>*.crate</code> 文件，以及 <code>index</code> 目录，其格式与 crates.io-index 项目相同 (只填充存在的crates的条目)。</p>
<h3 id="目录源"><a class="header" href="#目录源">目录源</a></h3>
<p>&quot;目录源&quot; 类似于本地注册中心源，它包含了一些在本地文件系统上可用的crate，适合于拓展依赖。目录源主要由 <code>cargo vendor</code> 子命令管理。</p>
<p>但目录源与本地注册中心不同，它们包含 <code>*.crate</code> 文件的解压版本，在某些情况下更适合将所有东西都检查引入源控制中。
目录源只是一个包含其他一些目录的目录，这些目录包含了crate的源代码(<code>*.crate</code> 文件的解压版本)。目前对每个目录的名称没有限制。</p>
<p>目录源中的每个crate也有一个相关的元数据文件，表明crate中每个文件的校验和，以防止意外的修改。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="插件"><a class="header" href="#插件">插件</a></h2>
<p>Cargo的目标之一是与第三方工具的简单集成，如IDE和其他构建系统。为了使集成更容易，Cargo有几个工具:</p>
<ul>
<li>
<p><a href="reference/../commands/cargo-metadata.html"><code>cargo metadata</code></a>命令，以JSON格式输出包结构和依赖信息。</p>
</li>
<li>
<p><code>--message-format</code> 标志，用于输出关于特定构建的信息，以及</p>
</li>
<li>
<p>支持自定义子命令。</p>
</li>
</ul>
<h3 id="关于包结构信息"><a class="header" href="#关于包结构信息">关于包结构信息</a></h3>
<p>你可以使用 <a href="reference/../commands/cargo-metadata.html"><code>cargo metadata</code></a> 命令来获取包结构和依赖的信息。有关输出格式的详细信息，请参见<a href="reference/../commands/cargo-metadata.html"><code>cargo metadata</code></a>文档。</p>
<p>该格式是稳定的，有相应版本。当调用 &quot;cargo metadata&quot; 时，你应该明确传递 &quot;--format-version&quot; 标志以避免向前不兼容的风险。</p>
<p>如果你使用的是Rust，可以使用<a href="https://crates.io/crates/cargo_metadata">cargo_metadata</a> crate来解析输出。</p>
<h3 id="json-消息"><a class="header" href="#json-消息">JSON 消息</a></h3>
<p>当传递 <code>---message-format=json</code> 时，Cargo会在构建时输出以下信息:</p>
<ul>
<li>
<p>编译器错误和警告。</p>
</li>
<li>
<p>产生的制品。</p>
</li>
<li>
<p>构建脚本的结果(例如，本地依赖)。</p>
</li>
</ul>
<p>在stdout以每行的JSON对象格式输出。<code>reason</code> 字段区分不同种类的信息。</p>
<p><code>--message-format</code> 选项也可以采用额外的格式化值，改变JSON信息的计算和显示方式。
更多细节见<a href="reference/../commands/cargo-build.html">build command documentation</a>中对 <code>--message-format</code> 选项的描述。</p>
<p>如果你使用的是Rust，可以使用 <a href="https://crates.io/crates/cargo_metadata">cargo_metadata</a> crate来解析这些信息。</p>
<h4 id="编译消息"><a class="header" href="#编译消息">编译消息</a></h4>
<p>&quot;compiler-message&quot; 消息包括来自编译器的输出，如警告和错误。关于 <code>rustc</code> 的消息格式，请参见 <a href="reference/.../.../rustc/json.html">rustc JSON 章节</a>，它被嵌入到以下结构中。</p>
<pre><code class="language-javascript">{
    /* &quot;reason&quot; 表示信息的种类。*/
    &quot;reason&quot;: &quot;compiler-message&quot;,
    /* 包的ID，是指包的唯一标识。 */
    &quot;package_id&quot;: &quot;my-package 0.1.0 (path+file:///path/to/my-package)&quot;,
    /*  包配置清单的绝对路径。 */
    &quot;manifest_path&quot;: &quot;/path/to/my-package/Cargo.toml&quot;,
    /* 产生该消息的Cargo目标(lib、bin、example等等)。 */
    &quot;target&quot;: {
        /* 目标种类数组。
           - lib目标列出配置清单中的 `cate-type` 值，如 &quot;lib&quot;、&quot;rlib&quot;、&quot;dylib&quot;、&quot;proc-macro&quot; 等(默认[&quot;lib&quot;])。
           - 二进制是 [&quot;bin&quot;]
           - 实例是 [&quot;example&quot;]
           - 综合测试是 [&quot;test&quot;]
           - 基准是 [&quot;bench&quot;]
           - 构建脚本是 [&quot;custom-build&quot;]
        */
        &quot;kind&quot;: [
            &quot;lib&quot;
        ],
        /* crate类型数组。
           - lib和示例库列出配置清单中的 `crate-type` 值，如 &quot;lib&quot;、&quot;rlib&quot;、&quot;dylib&quot;、&quot;proc-macro&quot; 等(默认为[&quot;lib&quot;])。
           - 所有其他目标类型是 [&quot;bin&quot;]
        */
        &quot;crate_types&quot;: [
            &quot;lib&quot;
        ],
        /* 目标名称。 */
        &quot;name&quot;: &quot;my-package&quot;,
        /* 目标的根源文件的绝对路径。 */
        &quot;src_path&quot;: &quot;/path/to/my-package/src/lib.rs&quot;,
        /* 目标的Rust版本。默认为包版本。 */
        &quot;edition&quot;: &quot;2018&quot;,
        /* 所需特性的数组。如果没有设置必要的特性，则不包含此属性。 */
        &quot;required-features&quot;: [&quot;feat1&quot;],
        /* 该目标是否启用了文档测试，以及该目标是否与文档测试兼容。 */
        &quot;doctest&quot;: true
    },
    /* 由编译器发出的信息。 参阅 https://doc.rust-lang.org/rustc/json.html 。 */
    &quot;message&quot;: {
        /* ... */
    }
}
</code></pre>
<h4 id="制品消息"><a class="header" href="#制品消息">制品消息</a></h4>
<p>对于每一个编译步骤，都会发出 &quot;compiler-artifact&quot; 消息，其结构如下:</p>
<pre><code class="language-javascript">{
    /* &quot;reason&quot; 表示信息的种类。 */
    &quot;reason&quot;: &quot;compiler-artifact&quot;,
    /* 包的ID，是指包的唯一标识。 */
    &quot;package_id&quot;: &quot;my-package 0.1.0 (path+file:///path/to/my-package)&quot;,
    /* 包配置清单的绝对路径。 */
    &quot;manifest_path&quot;: &quot;/path/to/my-package/Cargo.toml&quot;,
    /* 产生制品的Cargo目标(lib、bin、example等等)。详见上面 `compiler-message` 的定义。 */
    &quot;target&quot;: {
        &quot;kind&quot;: [
            &quot;lib&quot;
        ],
        &quot;crate_types&quot;: [
            &quot;lib&quot;
        ],
        &quot;name&quot;: &quot;my-package&quot;,
        &quot;src_path&quot;: &quot;/path/to/my-package/src/lib.rs&quot;,
        &quot;edition&quot;: &quot;2018&quot;,
        &quot;doctest&quot;: true,
        &quot;test&quot;: true
    },
    /* 该简介表明使用了哪些编译器设置。 */
    &quot;profile&quot;: {
        /* 优化级别。 */
        &quot;opt_level&quot;: &quot;0&quot;,
        /* 调试级别，是0、1或2的整数。如果 &quot;null&quot;，它意味着rustc的默认值为0。 */
        &quot;debuginfo&quot;: 2,
        /* 是否启用了调试断言。 */
        &quot;debug_assertions&quot;: true,
        /* 是否启用了溢出检查。 */
        &quot;overflow_checks&quot;: true,
        /* 是否使用`--test` 标志。*/
        &quot;test&quot;: false
    },
    /* 启用特性数组。 */
    &quot;features&quot;: [&quot;feat1&quot;, &quot;feat2&quot;],
    /* 该步骤产生的文件的数组。*/
    &quot;filenames&quot;: [
        &quot;/path/to/my-package/target/debug/libmy_package.rlib&quot;,
        &quot;/path/to/my-package/target/debug/deps/libmy_package-be9f3faac0a26ef0.rmeta&quot;
    ],
    /* 创建的可执行文件的路径的字符串，如果该步骤没有生成可执行文件，则为空。 */
    &quot;executable&quot;: null,
    /* 这个步骤是否被实际执行。当 `true` 时，这意味着预先存在的制品是最新的，并且 `rustc` 没有被执行。当 `false` 时，这意味着 `rustc` 被运行以生成制品。 */
    &quot;fresh&quot;: true
}

</code></pre>
<h4 id="构建脚本输出"><a class="header" href="#构建脚本输出">构建脚本输出</a></h4>
<p>&quot;build-script-executed&quot; 消息包括构建脚本的解析输出。注意，即使构建脚本没有运行，也会发出这个消息；
它将显示之前缓存的值。关于构建脚本输出的更多细节可以在<a href="reference/build-scripts.html">构建脚本章节</a>中找到。</p>
<pre><code class="language-javascript">{
    /* &quot;reason&quot; 表示信息的种类。 */
    &quot;reason&quot;: &quot;build-script-executed&quot;,
    /* 包的ID，是指包的唯一标识。 */
    &quot;package_id&quot;: &quot;my-package 0.1.0 (path+file:///path/to/my-package)&quot;,
    /* 要链接的库的数组，如 `cargo:rustc-link-lib` 指令所指示。注意，这可能包括字符串中的 &quot;KIND=&quot; 前缀，其中KIND是库的种类。 */
    &quot;linked_libs&quot;: [&quot;foo&quot;, &quot;static=bar&quot;],
    /* 包含在库搜索路径中的路径数组，如 `cargo:rustc-link-search` 指令所指示。注意，这可能包括字符串中的 &quot;KIND=&quot; 前缀，其中KIND是库的种类。 */
    &quot;linked_paths&quot;: [&quot;/some/path&quot;, &quot;native=/another/path&quot;],
    /* 要启用的cfg值数组，如 `cargo:rustc-cfg` 指令所示。 */
    &quot;cfgs&quot;: [&quot;cfg1&quot;, &quot;cfg2=\&quot;string\&quot;&quot;],
    /* 要设置的环境变量的 [KEY, VALUE] 数组，如 `cargo:rustc-env` 指令所示。 */
    &quot;env&quot;: [
        [&quot;SOME_KEY&quot;, &quot;some value&quot;],
        [&quot;ANOTHER_KEY&quot;, &quot;another value&quot;]
    ],
    /* 一个绝对路径，在编译当前包时作为 `OUT_DIR` 环境变量的值。 */
    &quot;out_dir&quot;: &quot;/some/path/in/target/dir&quot;
}
</code></pre>
<h4 id="构建完成"><a class="header" href="#构建完成">构建完成</a></h4>
<p>构建结束后会发出 &quot;build-finished&quot; 消息。</p>
<pre><code class="language-javascript">{
    /* &quot;reason&quot; 表示信息的种类。 */
    &quot;reason&quot;: &quot;build-finished&quot;,
    /* 构建是否成功完成。 */
    &quot;success&quot;: true,
}
</code></pre>
<p>这条信息对工具来说很有帮助，可以知道何时停止读取JSON信息。
诸如 <code>cargo test</code> 或 <code>cargo run</code> 之类的命令在构建完成后可能会产生额外的输出。
这条消息让工具知道Cargo不会产生额外的JSON消息，但之后可能会有额外的输出(比如 <code>cargo run</code> 执行的程序产生的输出)。</p>
<blockquote>
<p>注意: 对测试的JSON输出有实验性的每日支持，所以如果启用了该功能，额外的测试专用JSON消息可能会在 &quot;build-finished&quot; 消息之后。</p>
</blockquote>
<h3 id="自定义子命令"><a class="header" href="#自定义子命令">自定义子命令</a></h3>
<p>Cargo被设计成可以扩展新的子命令，而不需要修改Cargo本身。
这是通过将 cargo <code>(?&lt;command&gt;[^ ]+)</code> 形式的调用翻译成插件 <code>cargo-${command}</code> 的调用来实现的。
该插件必须存在于用户的 <code>$PATH</code> 目录中。</p>
<p>当Cargo调用一个自定义子命令时，子命令的第一个参数将是自定义子命令的文件名，像往常一样。
第二个参数将是子命令名称本身。例如，调用 &quot;cargo-${command}&quot; 时，第二个参数将是 &quot;${command}&quot; 。
命令行上的任何其他参数将被转发，不做任何改变。</p>
<p>Cargo也可以用 <code>cargo help ${command}</code> 显示自定义子命令的帮助输出。
如果子命令的第三个参数是 <code>--help</code>，Cargo会假定该子命令会打印帮助信息。
因此，<code>cargo help ${command}</code> 会调用 <code>cargo-${command} ${command} --help</code> 。</p>
<p>自定义子命令可以使用 <code>CARGO</code> 环境变量来回调Cargo。
另外，它也可以作为一个库链接到 <code>cargo</code> crate ，但这种方法有缺点。</p>
<ul>
<li>作为一个库，Cargo是不稳定的：API可能会改变而未淘汰。</li>
<li>链接的Cargo库的版本可能与Cargo二进制文件不同。</li>
</ul>
<p>相反，我们鼓励使用CLI接口来驱动Cargo。<a href="reference/../commands/cargo-metadata.html"><code>cargo metadata</code></a> 命令可以用来获取当前项目的信息(<a href="https://crates.io/crates/cargo_metadata"><code>cargo_metadata</code></a> crate为该命令提供了Rust接口)。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="注册中心"><a class="header" href="#注册中心">注册中心</a></h2>
<p>Cargo安装crates并从 &quot;注册中心&quot; 中获取依赖。
默认的注册中心是[crates.io]。注册中心包含一个 &quot;索引&quot; ，其中包含可搜索的可用crates的列表。
注册中心也可以提供一个网络API，支持直接从Cargo发布新的crates。</p>
<blockquote>
<p>注意: 如果你对镜像或拓展现有的注册中心感兴趣，请看一下<a href="reference/source-replacement.html">源替换</a>。</p>
</blockquote>
<p>如果你在实现注册中心服务器，请参阅<a href="reference/running-a-registry.html">注册中心运行</a>了解更多关于Cargo和注册中心之间协议的细节。</p>
<h3 id="使用备用注册中心"><a class="header" href="#使用备用注册中心">使用备用注册中心</a></h3>
<p>要使用[crates.io]以外的注册中心，必须将注册中心的名称和索引URL添加到 <a href="reference/config.html"><code>.cargo/config.toml</code> file</a>。<code>registries</code>表对每个注册中心都有一个键，例如:</p>
<pre><code class="language-toml">[registries]
my-registry = { index = &quot;https://my-intranet:8080/git/index&quot; }
</code></pre>
<p><code>index</code> 键应该是一个指向带有注册中心索引的git仓库的URL。
通过指定 <code>registry</code> 键和 <code>Cargo.toml</code> 中的依赖项中的注册中心名称，crate可以依赖另一个注册中心的crate。</p>
<pre><code class="language-toml"># Sample Cargo.toml
[package]
name = &quot;my-project&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
other-crate = { version = &quot;1.0&quot;, registry = &quot;my-registry&quot; }
</code></pre>
<p>就像大多数配置值一样，索引可以用环境变量而不是配置文件来指定。
例如，设置以下环境变量将完成与定义配置文件相同的事情:</p>
<pre><code class="language-ignore">CARGO_REGISTRIES_MY_REGISTRY_INDEX=https://my-intranet:8080/git/index
</code></pre>
<blockquote>
<p>注意: [crates.io]不接受依赖其他注册中心的crates的包。</p>
</blockquote>
<h3 id="发布到备用注册中心"><a class="header" href="#发布到备用注册中心">发布到备用注册中心</a></h3>
<p>如果注册中心支持Web API访问，那么包可以直接从Cargo发布到注册中心。
Cargo的一些命令，如<a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a>，需要一个 <code>--registry</code> 命令行标志来指示使用哪个注册中心。
例如，要发布当前目录下的包:</p>
<ol>
<li>
<p><code>cargo login --registry=my-registry</code></p>
<p>这只需要做一次。你必须输入从注册中心网站检索的私密API令牌。 
另外，令牌可以通过 <code>--token</code> 命令行标志直接传递给 <code>publish</code> 命令，或者用注册中心的名称作为环境变量，如<code>CARGO_REGISTRIES_MY_REGISTRY_TOKEN</code>。</p>
</li>
<li>
<p><code>cargo publish --registry=my-registry</code></p>
</li>
</ol>
<p>可以在<a href="reference/config.html">.cargo/config.toml</a>中用 <code>registry.default</code> 键设置默认注册中心，而不必总是传递 &quot;--registry&quot; 命令行选项。比如说:</p>
<pre><code class="language-toml">[registry]
default = &quot;my-registry&quot;
</code></pre>
<p>在 <code>Cargo.toml</code> 配置清单中设置 <code>package.publish</code> 键，可以限制包发布到哪些注册中心。这对于防止不小心将闭源包发布到[crates.io]很有用。该值可以是一个注册中心名称的列表，例如。</p>
<pre><code class="language-toml">[package]
# ...
publish = [&quot;my-registry&quot;]
</code></pre>
<p><code>publish</code> 值可以是 <code>false</code> ，以限制所有的发布，这与空列表相同。</p>
<p>由 <a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> 存储的认证信息被保存在Cargo主目录 (默认 <code>$HOME/.cargo</code>)下的 <code>credentials.toml</code> 文件中。
它对每个注册中心都有一个单独的表，例如。</p>
<pre><code class="language-toml">[registries.my-registry]
token = &quot;854DvwSlUwEHtIo3kWy6x7UCPKHfzCmy&quot;
</code></pre>
<script>
(function() {
    var fragments = {
        "#running-a-registry": "running-a-registry.html",
        "#index-format": "registry-index.html",
        "#web-api": "registry-web-api.html",
        "#publish": "registry-web-api.html#publish",
        "#yank": "registry-web-api.html#yank",
        "#unyank": "registry-web-api.html#unyank",
        "#owners": "registry-web-api.html#owners",
        "#owners-list": "registry-web-api.html#owners-list",
        "#owners-add": "registry-web-api.html#owners-add",
        "#owners-remove": "registry-web-api.html#owners-remove",
        "#search": "registry-web-api.html#search",
        "#login": "registry-web-api.html#login",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<div style="break-before: page; page-break-before: always;"></div><h2 id="动行注册中心"><a class="header" href="#动行注册中心">动行注册中心</a></h2>
<p>最小的注册中心可以通过拥有包含索引的git仓库和包含由 <a href="reference/../commands/cargo-package.html"><code>cargo package</code></a> 创建的压缩的<code>.crate</code>文件的服务器来实现。
用户不能使用 Cargo 来发布信息，但这对于封闭环境来说可能已经足够了。索引格式在<a href="reference/registry-index.html">Registry Index</a>中描述。</p>
<p>支持发布的全功能注册中心还需要有符合Cargo使用的API的Web API服务。该网络API在<a href="reference/registry-web-api.html">Registry Web API</a>中描述。</p>
<p>商业和社区项目可用于建立和运行注册中心。参见<a href="https://github.com/rust-lang/cargo/wiki/Third-party-registries">https://github.com/rust-lang/cargo/wiki/Third-party-registries</a>，了解可用的项目清单。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="索引格式"><a class="header" href="#索引格式">索引格式</a></h2>
<p>下面定义了索引的格式。有时会增加一些新的功能，这些新功能将从新版本 Cargo 开始识别。
旧版本的Cargo可能无法使用利用了新特性的包。而旧版本的包的格式不应改变，旧版本的Cargo应能使用它们。</p>
<p>索引存储在git仓库中，这样Cargo就可以有效地获取索引的增量更新。
仓库的根位置有一个名为 &quot;config.json&quot; 的文件，包含Cargo访问注册中心时使用的JSON信息。
这是一个[crates.io]配置文件的例子，看起来像:</p>
<pre><code class="language-javascript">{
    &quot;dl&quot;: &quot;https://crates.io/api/v1/crates&quot;,
    &quot;api&quot;: &quot;https://crates.io&quot;
}
</code></pre>
<p>键是:</p>
<ul>
<li>
<p><code>dl</code>: 这是在索引中列出的下载crates的URL。该值可能有以下标记，这些标记将被替换成其相应的值:</p>
<ul>
<li><code>{crate}</code>: crate 的名称。</li>
<li><code>{version}</code>: crate 的版本。</li>
<li><code>{prefix}</code>: 从 crate 名称计算出来的目录前缀。例如，名为 <code>cargo</code> 的 crate 的前缀是 <code>ca/rg</code> 。详见下文。</li>
<li><code>{lowerprefix}</code>: <code>{prefix}</code> 的小写变体。</li>
<li><code>{sha256-checksum}</code>: crate 的sha256校验和。</li>
</ul>
<p>如果没有任何标记，那么结尾将附加值 <code>/{crate}/{version}/download</code> 。</p>
</li>
<li>
<p><code>api</code>: 这是网络API的基本URL。这个键是可选的，但如果没有指定，<a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> 等命令将无法工作。下面将介绍网络API。</p>
</li>
</ul>
<p>下载端点应发送所请求包的 <code>.crate</code> 文件。
Cargo支持https、http和文件URL、HTTP重定向、HTTP1和HTTP2。
TLS支持的具体细节取决于Cargo所运行的平台、Cargo的版本以及它的编译方式。</p>
<p>索引库的其余部分包含每个包的一个文件，其中文件名是小写包的名称。
包的每个版本在文件中都有一个单独的行。这些文件被组织在一个层级的目录中。</p>
<ul>
<li>具有1个字符名称的包被放置在一个名为 <code>1</code> 的目录中。</li>
<li>具有2个字符名称的包被放置在一个名为 <code>2</code> 的目录中。</li>
<li>名称为3个字符的包被放置在 <code>3/{first-character}</code> 目录下，其中 <code>{first-character}</code>  是包名称的第一个字符。</li>
<li>所有其他包都存储在名为 <code>{first-two}/{second-two}</code> 的目录中，其中顶部目录是包名称的前两个字符，下一个子目录是包名称的第三和第四个字符。例如，<code>cargo</code> 将被存储在一个名为 <code>ca/rg/cargo</code>的文件中。</li>
</ul>
<blockquote>
<p>注意: 尽管索引文件名是小写的，但 <code>Cargo.toml</code> 中包含包名的字段和索引JSON数据是区分大小写的，可能包含大写和小写字符。</p>
</blockquote>
<p>上面的目录名是根据转换为小写的包名计算的；它由标记 <code>{lowerprefix}</code> 表示。当使用原始包名而不进行大小写转换时，产生的目录名由标记 <code>{prefix}</code> 表示。
例如，<code>MyCrate</code> 包的 <code>{prefix}</code> 为 <code>My/Cr</code> ， <code>{lowerprefix}</code> 为 <code>my/cr</code> 。一般来说，推荐使用 <code>{prefix}</code> 而不是 <code>{lowerprefix}</code> ，但每种选择都有优点和缺点。在不区分大小写的文件系统中使用 <code>{prefix}</code> 会导致(无害但不优雅的)目录别名。
例如， <code>crate</code> 和 <code>CrateTwo</code> 的 <code>{prefix}</code> 值分别为 <code>cr/at</code> 和 <code>Cr/at</code> ；这些在Unix机器上是不同的，但在Windows上却别名为同一个目录。 使用正常大小写的目录可以避免别名，但在对大小写敏感的文件系统中，很难支持缺乏 <code>{prefix}</code>/<code>{lowerprefix}</code> 的旧版本的Cargo。
例如，nginx的重写规则可以很容易地构建 <code>{prefix}</code> ，但不能进行大小写转换以构建<code>{lowerprefix}</code>。</p>
<p>注册中心应该考虑对添加到他们索引中的包名称实施限制。
Cargo本身允许名字中含有任何 [字母数字] 、 <code>-</code> 或 <code>_</code> 字符。[crates.io]施加了自己的限制，包括以下内容:</p>
<ul>
<li>只允许ASCII字符。</li>
<li>只有字母数字、 <code>-</code> 和 <code>_</code> 字符。</li>
<li>第一个字符必须是英文字母。</li>
<li>对大小写不敏感冲突检测。</li>
<li>防止 <code>-</code> 与 <code>_</code> 的差异。</li>
<li>在特定长度下(最大64)。</li>
<li>抛弃保留名称，如Windows的特殊文件名，如 &quot;nul&quot; 。</li>
</ul>
<p>注册中心应考虑纳入类似的限制，并考虑安全问题，如<a href="https://en.wikipedia.org/wiki/IDN_homograph_attack">IDN同源词攻击</a>以及<a href="https://www.unicode.org/reports/tr36/">UTR36</a>和<a href="https://www.unicode.org/reports/tr39/">UTS39</a>中的其他考虑。 </p>
<p>包文件中的每一行都包含一个JSON对象，描述包的发布版本。下面是一个优雅的例子，其中有注释解释了条目的格式。</p>
<pre><code class="language-javascript">{
    // 包的名称。
    // 这必须只包含字母数字、 `-` 或 `_` 字符。
    &quot;name&quot;: &quot;foo&quot;,
    // 这一行描述包的版本。
    // 根据语义化版本 2.0.0 标准，这必须是一个有效的版本号，参考网址 https://semver.org/。
    &quot;vers&quot;: &quot;0.1.0&quot;,
    // 包的直接依赖的数组。
    &quot;deps&quot;: [
        {
            // 依赖的名称。
            // 如果依赖从源包名称中重命名，这就是新的名称。源包的名称被保存在 `package` 字段中。
            &quot;name&quot;: &quot;rand&quot;,
            // 依赖的语义化版本要求。
            // 这必须是一个有效的版本要求，定义在https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html。
            &quot;req&quot;: &quot;^0.6&quot;,
            // 该依赖启用的特性数组(字符串)。
            &quot;features&quot;: [&quot;i128_support&quot;],
            // 布尔值，表示这是否是一个可选的依赖。
            &quot;optional&quot;: false,
            // 是否启用默认特性的布尔值。
            &quot;default_features&quot;: true,
            // 依赖的目标平台。
            // 如果不是目标依赖，则为空。
            // 否则，就是一个字符串，如 &quot;cfg(windows)&quot; 。
            &quot;target&quot;: null,
            // 依赖性的种类。
            // &quot;dev&quot;, &quot;build&quot;, or &quot;normal&quot;.
            // 注意: 这是必需的字段，但由于执行错误，crates.io索引中存在少量的条目，其中的 `kind` 字段缺失或为空。
            &quot;kind&quot;: &quot;normal&quot;,
            // 该依赖所在的注册中心索引的URL，是字符串。如果没有指定或为空，则假定该依赖在当前注册中心中。
            &quot;registry&quot;: null,
            // 如果依赖被重新命名，这是一个包实际的名称字符串。如果没有指定或为空，则该依赖未重命名。
            &quot;package&quot;: null,
        }
    ],
    // `.crate`文件的SHA256校验和。
    &quot;cksum&quot;: &quot;d867001db0e2b6e0496f9fac96930e2d42233ecd3ca0413e0753d4c7695d289c&quot;,
    // 为包定义的一组特性。
    // 每个特性都映射到它所启用的特性或依赖性数组。
    &quot;features&quot;: {
        &quot;extras&quot;: [&quot;rand/simd_support&quot;]
    },
    // 该版本是否已被撤消的布尔值。
    &quot;yanked&quot;: false,
    // 包的配置清单中的 `links` 字符串值，如果没有指定则为空。这个字段是可选的，默认为空。
    &quot;links&quot;: null,
    // 一个无符号的32位整数，表示该条目的模式版本。
    //
    // 如果没有指定，它应该被解释为默认的1。
    //
    // Cargo(从1.51版开始)会忽略它不认识的版本。
    // 这提供了一种方法，可以安全地对索引条目进行修改，并允许老版本的cargo忽略它不理解的新条目。1.51以上的版本会忽略这个字段，因此可能会误解索引条目的含义。
    //
    // 目前的数值是：
    //
    // * 1: 这里记录的模式，不包括较新的补充内容。
    //      这在Rust 1.51版和更新的版本中得到认可。
    // * 2: 增加了 `features2` 字段。
    //      这在Rust 1.60和更新的版本中得到认可。
    &quot;v&quot;: 2,
    // 此可选字段包含具有新的扩展语法的特性。
    // 具体来说，命名空间特性(`dep:`)和弱依赖(`pkg?/feat`)。
    //
    // 这是从 `features` 中分离出来的，因为1.19以前的版本会因为无法解析新的语法而无法加载，即使有 `Cargo.lock` 文件。
    //
    // cargo 将把这里列出的任何数值与 &quot;features&quot; 字段合并。
    //
    // 如果包括这个字段，&quot;v&quot; 字段应至少设置为 2 。
    //
    // 注册中心不需要为扩展的特性语法使用这个字段，他们可以在 &quot;features&quot; 字段中包括这些特性。
    // 只有当注册中心要支持1.19之前的cargo版本时，才有必要使用这个功能，实际上，这只是 crates.io ，因为这些旧版本不支持其他注册中心。
    &quot;features2&quot;: {
        &quot;serde&quot;: [&quot;dep:serde&quot;, &quot;chrono?/serde&quot;]
    }
}
</code></pre>
<p>除了 <code>yanked</code> 字段的值可能在任何时候改变外，JSON对象在添加后不应该被修改。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="web-api"><a class="header" href="#web-api">Web API</a></h2>
<p>注册机构可以在 <code>config.json</code> 中定义的位置托管一个网络API，以支持下面列出的任何动作。</p>
<p>对于需要认证的请求，Cargo包含 <code>Authorization</code> 头。该头的值是API token。如果 token 无效，服务器应以403代码进行响应。用户应该访问注册中心的网站来获得token ，Cargo可以使用 <a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> 命令来存储token，或者在命令行中传递token。</p>
<p>响应使用200代码表示成功。
错误应使用适当的响应代码，如404。
失败响应应该有一个JSON对象，其结构如下:</p>
<pre><code class="language-javascript">{
    // 要显示给用户的错误数组。
    &quot;errors&quot;: [
        {
            // 作为字符串的错误消息。
            &quot;detail&quot;: &quot;error message text&quot;
        }
    ]
}
</code></pre>
<p>如果响应有这种结构，Cargo会向用户显示详细的信息，即使响应代码是200。
如果响应代码表明有错误，而且内容没有这种结构，Cargo会向用户显示一条旨在帮助调试服务器错误的信息。
服务器返回一个 <code>errors</code> 对象，允许注册中心提供更详细的或以用户为中心的错误信息。</p>
<p>为了向后兼容，服务器应该忽略任何意外的查询参数或JSON字段。
如果缺少的JSON字段，应该假定它为空。端点以路径中的 <code>v1</code> 部分为版本，如果将来有任何需要，Cargo负责处理向后兼容的回调。</p>
<p>Cargo为所有请求设置了以下头信息:</p>
<ul>
<li><code>Content-Type</code>: <code>application/json</code></li>
<li><code>Accept</code>: <code>application/json</code></li>
<li><code>User-Agent</code>: The Cargo version such as <code>cargo 1.32.0 (8610973aa 2019-01-02)</code>. This may be modified by the user in a configuration value.
Added in 1.29.</li>
</ul>
<h3 id="发布"><a class="header" href="#发布">发布</a></h3>
<ul>
<li>Endpoint: <code>/api/v1/crates/new</code></li>
<li>Method: PUT</li>
<li>Authorization: Included</li>
</ul>
<p>发布端点用于发布新版本的crate。服务器应该验证该crate，使其可供下载，并将其添加到索引中。</p>
<p>Cargo发送的数据体:</p>
<ul>
<li>JSON数据长度的32位无符号小端整数。</li>
<li>作为JSON对象的包的元数据。</li>
<li><code>.crate</code> 文件长度的32位无符号小端整数。</li>
<li><code>.crate</code> 文件。</li>
</ul>
<p>下面是JSON对象注释的例子。包括一些由<a href="https://crates.io/">crates.io</a>所限制的说明，
只是为了说明一些关于可能进行的验证类型的建议，而不是<a href="https://crates.io/">crates.io</a>所限制的详尽清单。</p>
<pre><code class="language-javascript">{
    // 包的名称。
    &quot;name&quot;: &quot;foo&quot;,
    // 发布的包的版本。
    &quot;vers&quot;: &quot;0.1.0&quot;,
    // 包的直接依赖的数组。
    &quot;deps&quot;: [
        {
            // 依赖的名称。
            // 如果依赖是由源包名重新命名的，这就是原来的名字。新的包名被保存在 `explicit_name_in_toml` 字段中。
            &quot;name&quot;: &quot;rand&quot;,
            // 这个依赖的语义化版本要求。
            &quot;version_req&quot;: &quot;^0.6&quot;,
            // 为该依赖启用的特性数组(以字符串形式)。
            &quot;features&quot;: [&quot;i128_support&quot;],
            // 布尔值，表示这是否是可选的依赖。
            &quot;optional&quot;: false,
            // 是否启用默认特性的布尔值。
            &quot;default_features&quot;: true,
            // 依赖的目标平台。
            // 如果不是目标依赖，则为空。
            // 否则，就是字符串，如 &quot;cfg(windows)&quot; 。
            &quot;target&quot;: null,
            // 依赖的类别。
            // &quot;dev&quot;, &quot;build&quot;, or &quot;normal&quot;.
            &quot;kind&quot;: &quot;normal&quot;,
            // 该依赖所在的注册中心索引的URL，是字符串。如果没有指定或为空，则假定该依赖在当前注册中心中。
            &quot;registry&quot;: null,
            // 如果依赖被重新命名，这是新包名称的字符串。如果没有指定或为空，则该依赖未重命名。
            &quot;explicit_name_in_toml&quot;: null,
        }
    ],
    // 为该包定义的一组特性。
    // 每个特性都映射到它所启用的特性或依赖数组。
    // Cargo对特性名称不做限制，但crates.io需要字母数字的ASCII、 `_` 或 `-` 字符。
    &quot;features&quot;: {
        &quot;extras&quot;: [&quot;rand/simd_support&quot;]
    },
    // 作者的字符串列表.
    // 可能为空。
    &quot;authors&quot;: [&quot;Alice &lt;a@example.com&gt;&quot;],
    // 来自配置清单的描述字段。
    // 可能为空。crates.io 至少需要一些内容。
    &quot;description&quot;: null,
    // 这个包的文档的网站的URL字符串。
    // 可为空。
    &quot;documentation&quot;: null,
    // 这个包的主页的网站的URL字符串。
    // 可为空。
    &quot;homepage&quot;: null,
    // README文件内容的字符串。
    // 可为空。
    &quot;readme&quot;: null,
    // crate中的README文件的相对路径字符串。
    // 可为空。
    &quot;readme_file&quot;: null,
    // 包的关键词的字符串数组。
    &quot;keywords&quot;: [],
    // 包的类别字符串的数组。
    &quot;categories&quot;: [],
    // 包的许可证的字符串。
    // 可为空。 crates.io 要求设置 `license` 或 `license_file` 。
    &quot;license&quot;: null,
    // 许可证文件的相对路径字符串。
    // 可为空。
    &quot;license_file&quot;: null,
    // 包的源码库网站的URL字符串。
    // 可为空。
    &quot;repository&quot;: null,
    // 可选的 &quot;状态&quot; 标志的对象。每个值是字符串到字符串映射的对象。
    // crates.io对标志的格式有特殊解释。
    &quot;badges&quot;: {
        &quot;travis-ci&quot;: {
            &quot;branch&quot;: &quot;master&quot;,
            &quot;repository&quot;: &quot;rust-lang/cargo&quot;
        }
    },
    // 包清单中的 `links` 字符串值，如果没有指定则为空。这个字段是可选的，默认为空。
    &quot;links&quot;: null
}
</code></pre>
<p>响应成功包括JSON对象:</p>
<pre><code class="language-javascript">{
    // 可选的警告对象，以显示给用户。
    &quot;warnings&quot;: {
        // 无效和被忽略的类别的字符串数组。
        &quot;invalid_categories&quot;: [],
        // 标志名称的字符串数组，这些标志名称是无效的并被忽略。
        &quot;invalid_badges&quot;: [],
        // 向用户显示的任意警告字符串的数组。
        &quot;other&quot;: []
    }
}
</code></pre>
<h3 id="yank"><a class="header" href="#yank">Yank</a></h3>
<ul>
<li>Endpoint: <code>/api/v1/crates/{crate_name}/{version}/yank</code></li>
<li>Method: DELETE</li>
<li>Authorization: Included</li>
</ul>
<p>yank端点将在索引中将给定版本的crate的 <code>yank</code> 字段设置为 <code>true</code> 。</p>
<p>响应成功包括JSON对象:</p>
<pre><code class="language-javascript">{
    // 表示删除成功，始终为true。
    &quot;ok&quot;: true,
}
</code></pre>
<h3 id="unyank"><a class="header" href="#unyank">Unyank</a></h3>
<ul>
<li>Endpoint: <code>/api/v1/crates/{crate_name}/{version}/unyank</code></li>
<li>Method: PUT</li>
<li>Authorization: Included</li>
</ul>
<p>unyank端点将在索引中将给定版本的crate的 <code>yank</code> 字段设置为 <code>false</code> 。</p>
<p>响应成功包括JSON对象:</p>
<pre><code class="language-javascript">{
    // 表示删除成功，始终为true。
    &quot;ok&quot;: true,
}
</code></pre>
<h3 id="所有者"><a class="header" href="#所有者">所有者</a></h3>
<p>Cargo没有固有的用户和所有者的概念，但它提供 <code>owner</code> 命令来帮助管理谁有控制crate的授权。
具体如何处理用户和所有者，由注册中心决定。
关于<a href="https://crates.io/">crates.io</a>如何通过GitHub用户和团队处理所有者的描述，请参见[发布文档]。</p>
<h4 id="owners-list"><a class="header" href="#owners-list">Owners: List</a></h4>
<ul>
<li>Endpoint: <code>/api/v1/crates/{crate_name}/owners</code></li>
<li>Method: GET</li>
<li>Authorization: Included</li>
</ul>
<p>owners端点返回crate的所有者列表。</p>
<p>响应成功包括JSON对象:</p>
<pre><code class="language-javascript">{
    // crate的所有者数组。
    &quot;users&quot;: [
        {
            // 所有者的唯一无符号32位整数。
            &quot;id&quot;: 70,
            // 所有者唯一的用户名。
            &quot;login&quot;: &quot;github:rust-lang:core&quot;,
            // 所有者的名字。
            // 这是可选的，可以为空。
            &quot;name&quot;: &quot;Core&quot;,
        }
    ]
}
</code></pre>
<h4 id="owners-add"><a class="header" href="#owners-add">Owners: Add</a></h4>
<ul>
<li>Endpoint: <code>/api/v1/crates/{crate_name}/owners</code></li>
<li>Method: PUT</li>
<li>Authorization: Included</li>
</ul>
<p>PUT请求将向注册中心发送请求，以将新的所有者添加到crate里。
如何处理这个请求是由注册中心决定。
例如，<a href="https://crates.io/">crates.io</a>会向用户发送一个邀请，他们必须在被添加之前接受。</p>
<p>该请求应包括以下JSON对象:</p>
<pre><code class="language-javascript">{
    // 要添加的所有者的 `login` 字符串数组。
    &quot;users&quot;: [&quot;login_name&quot;]
}
</code></pre>
<p>响应成功包括JSON对象:</p>
<pre><code class="language-javascript">{
    // 表示添加成功，始终为真。
    &quot;ok&quot;: true,
    // 一个要显示给用户的字符串。
    &quot;msg&quot;: &quot;user ehuss has been invited to be an owner of crate cargo&quot;
}
</code></pre>
<h4 id="owners-remove"><a class="header" href="#owners-remove">Owners: Remove</a></h4>
<ul>
<li>Endpoint: <code>/api/v1/crates/{crate_name}/owners</code></li>
<li>Method: DELETE</li>
<li>Authorization: Included</li>
</ul>
<p>DELETE请求将从crate中删除一个所有者。该请求应包括以下JSON对象:</p>
<pre><code class="language-javascript">{
    // 要删除的所有者的 `login` 字符串数组。
    &quot;users&quot;: [&quot;login_name&quot;]
}
</code></pre>
<p>响应成功包括JSON对象:</p>
<pre><code class="language-javascript">{
    // 表示删除成功，始终为真。
    &quot;ok&quot;: true
}
</code></pre>
<h3 id="search"><a class="header" href="#search">Search</a></h3>
<ul>
<li>Endpoint: <code>/api/v1/crates</code></li>
<li>Method: GET</li>
<li>Query Parameters:
<ul>
<li><code>q</code>: The search query string.</li>
<li><code>per_page</code>: Number of results, default 10, max 100.</li>
</ul>
</li>
</ul>
<p>搜索请求将使用服务器上定义的标准对caate进行搜索。</p>
<p>响应成功包括JSON对象:</p>
<pre><code class="language-javascript">{
    // 结果数组
    &quot;crates&quot;: [
        {
            // crate的名字。
            &quot;name&quot;: &quot;rand&quot;,
            // 可用的最高版本
            &quot;max_version&quot;: &quot;0.6.1&quot;,
            // crate的文字描述。
            &quot;description&quot;: &quot;Random number generators and other randomness functionality.\n&quot;,
        }
    ],
    &quot;meta&quot;: {
        // 服务器上可用的结果总数。
        &quot;total&quot;: 119
    }
}
</code></pre>
<h3 id="login"><a class="header" href="#login">Login</a></h3>
<ul>
<li>Endpoint: <code>/me</code></li>
</ul>
<p>&quot;login&quot; 端点不是实际的API请求。
它的存在仅仅是为了 <a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> 命令显示URL，指示用户在网络浏览器中访问以登录并获取API令牌。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="依赖解析"><a class="header" href="#依赖解析">依赖解析</a></h1>
<p>Cargo 的主要功能之一就是依据每个包指定的依赖版本需求，来决定具体使用依赖的哪个版本。这个过程称为“依赖解析”，由“解析器” (resolver) 完成。解析的结果保存在 <code>Cargo.lock</code> 文件中，将每个依赖“锁定”到特定的版本，使其不会被改变。</p>
<p>解析器会尽力统一处理相同依赖，同时也会考虑可能的冲突。下面一节中详细介绍了这些约束是如何处理的，以及使用解析器。</p>
<p>查看 <a href="reference/specifying-dependencies.html">Specifying Dependencies</a> 一章了解关于如何指定依赖的更多细节。</p>
<p>可以用 <code>[cargo tree]</code> 命令来可视化解析的结果。</p>
<h2 id="semver-兼容性"><a class="header" href="#semver-兼容性">SemVer 兼容性</a></h2>
<p>Cargo 使用 <a href="https://semver.org/">SemVer</a> 来表述版本，以此判断某个包两个不同版本什么情况下是“兼容”的，关于“兼容性”修改的更多信息查看 <a href="reference/semver.html">SemVer Compatibility</a> 。“兼容性”的概念很重要，因为Cargo假设在版本兼容范围内，更新一个依赖不会导致构建出现问题。</p>
<p><em>最左侧非零数字</em>相同的版本之间被认为是兼容的。比如 <code>1.0.3</code> 和 <code>1.1.0</code> 被认为是兼容的，因此可以安全地从低版本升级到高版本。然而， <code>1.1.0</code> 到 <code>2.0.0</code> 的自动升级是不允许的。这种约定也适用于以0开头的版本，比如 <code>0.1.0</code> 与 <code>0.1.2</code> 兼容，与 <code>0.2.0</code> 不兼容。同样的， <code>0.0.1</code> 与 <code>0.0.2</code> 是不兼容的。</p>
<p>继续加深一下，Cargo 依赖使用的 <a href="reference/specifying-dependencies.html"><em>版本请求</em> 语法</a> 为:</p>
<div class="table-wrapper"><table><thead><tr><th>版本请求</th><th>示例</th><th>等同于</th><th>描述</th></tr></thead><tbody>
<tr><td><code>^</code></td><td><code>1.2.3</code> or <code>^1.2.3</code></td><td><code>&gt;=1.2.3, &lt;2.0.0</code></td><td>SemVer 兼容的版本, 高于或等于所给版本</td></tr>
<tr><td><code>~</code></td><td><code>~1.2</code></td><td><code>&gt;=1.2.0, &lt;1.3.0</code></td><td>更受限的兼容范围</td></tr>
<tr><td>通配符</td><td><code>1.*</code></td><td><code>&gt;=1.0.0, &lt;2.0.0</code></td><td><code>*</code> 位置可以运行任何值</td></tr>
<tr><td>等于号</td><td><code>=1.2.3</code></td><td><code>=1.2.3</code></td><td>完全等于指定的版本</td></tr>
<tr><td>比较符号</td><td><code>&gt;1.1</code></td><td><code>&gt;=1.2.0</code></td><td>进行简单的数字比较</td></tr>
<tr><td>组合</td><td><code>&gt;=1.2, &lt;1.5</code></td><td><code>&gt;1.2.0, &lt;1.5.0</code></td><td>同时满足多个条件</td></tr>
</tbody></table>
</div>
<p>当多个包共同指定某个公共包为依赖时，解析器会尝试让它们使用该公共包的同一个版本，前提是符合 SemVer 的兼容范围。解析器同时也会尽可能地使用兼容范围内包的最新版本。例如，假设现在解析图中有下面两个依赖请求:</p>
<pre><code class="language-toml"># Package A
[dependencies]
bitflags = &quot;1.0&quot;

# Package B
[dependencies]
bitflags = &quot;1.1&quot;
</code></pre>
<p>如果生成 <code>Cargo.lock</code> 时 <code>bigflags</code> 的最高版本是 <code>1.2.1</code>，那么两个包都会使用 <code>1.2.1</code>，因为这个是兼容范围内的最高版本。如果 <code>2.0.0</code> 已经发布，结果还是使用 <code>1.2.1</code>，因为 <code>2.0.0</code> 被认为是不兼容的。</p>
<p>如果多个包依赖的公共包版本不兼容，Cargo 会允许这种情况，同时对这个公共包构建多份拷贝。比如:</p>
<pre><code class="language-toml"># Package A
[dependencies]
rand = &quot;0.7&quot;

# Package B
[dependencies]
rand = &quot;0.6&quot;
</code></pre>
<p>上面的配置会使得包A使用最高的 <code>0.7</code> 版本(本文写作时为 <code>0.7.3</code> )，包B使用最高的 <code>0.6</code> 版本(比如 <code>0.6.5</code> )。这可能会有潜在的问题，参考 <a href="reference/resolver.html#version-incompatibility-hazards">Version-incompatibility hazards</a> 。</p>
<p>使用兼容范围内的多个版本是不允许的，这会导致解析器错误。例如，解析图中的两个包有下面的依赖请求:</p>
<pre><code class="language-toml"># Package A
[dependencies]
log = &quot;=0.4.11&quot;

# Package B
[dependencies]
log = &quot;=0.4.8&quot;
</code></pre>
<p>上面的解析会失败，因为不允许有两份 <code>0.4</code> 版的 <code>log</code>。</p>
<h3 id="版本不兼容的风险"><a class="header" href="#版本不兼容的风险">版本不兼容的风险</a></h3>
<p>当解析图中出现同一crate的多个版本时，这些版本中的类型(types)可能会被使用它们的crate再暴露出来，这会导致问题。这是因为Rust编译器以不同方式解读类型(types)和语法元素(items)，即使它们有相同的名字。一个库在发布一个 SemVer 不兼容版本时一定要小心(比如 <code>1.0.0</code> 在被使用的情况下发布 <code>2.0.0</code>)，尤其是那些被广泛使用的库。</p>
<p>&quot;<a href="https://github.com/dtolnay/semver-trick">semver trick</a>&quot; 是解决这个问题的一个变通方法，可以在发布破坏性更新的同时保持与旧版本的兼容性。上面链接中的文章详细介绍了该问题的来源以及解决方法。简而言之，当一个库想要发布一个 SemVer 破坏性更新时，先发布破坏性新版本，再同时发布一个旧版本的修复版本，在这个版本中引用新版本并将其中的类型 (types) 导出。</p>
<p>这种不兼容通常表现为编译错误，但有时也会显现为运行时的错误行为。例如，比如说有一个库 <code>foo</code> 以 <code>1.0.0</code> 和 <code>2.0.0</code> 在解析图中出现了两次，当在使用<code>foo 1.0.0</code> 的库生成的一个对象上进行  <a href="https://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_ref"><code>downcast_ref</code></a> ，而调用 <a href="https://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_ref"><code>downcast_ref</code></a> 的代码引用的类型却来自 <code>foo 2.0.0</code>，downcast 就会在运行时失败。</p>
<p>一定要确认你是否用到了某个库的多个版本，尤其是检查混用不同版本的类型(types)的可能性。 <a href="reference/../commands/cargo-tree.html"><code>cargo tree -d</code></a> 命令可以用来检查重复依赖的存在和来源。同样的，当你发布一个很流行的库的SemVer不兼容版本时，仔细考虑其对生态的影响。</p>
<h3 id="预发布"><a class="header" href="#预发布">预发布</a></h3>
<p>SemVer 有“预发布”的概念，在版本号中带有 <code>-</code> ，比如 <code>1.0.0-alpha</code> 、 <code>1.0.0-beta</code>。Cargo 会避免自动使用预发布版本，除非显式要求。例如，如果包 <code>foo</code> 发布了 <code>1.0.0-alpha</code> 版而版本请求是 <code>foo = &quot;1.0&quot;</code> ，则版本是不匹配的，Cargo 会返回错误。预发布版本必须显式指定，比如 <code>foo = &quot;1.0.0-alpha&quot;</code>。同样的， <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 也会在未显式声明情况下避免使用预发布版本。</p>
<p>Cargo 运行预发布版本间的自动更新。例如，如果 <code>1.0.0-beta</code> 发布，那么请求 <code>foo = &quot;1.0.0-alpha&quot;</code> 会允许更新到 <code>beta</code> 版本。注意，预发布版本是不稳定的，使用时要小心。一些项目可能会选择在预发布版本间进行破坏性更新，建议不要使用预发布的依赖，除非你的库也是预发布版本。更新 <code>Cargo.lock</code> 时要小心，在预发布版本造成问题之前做好充分准备。</p>
<p>预发布标记可能会用句点来分割为不同的部分。数字部分会进行数字的比较。比如 <code>1.0.0-alpha.4</code> 中的 <code>4</code> 会作为数字来比较， <code>1.0.0-alpha.11</code> 的版本就比它高。非数字部分通过字典序来比较。</p>
<h3 id="版本元数据"><a class="header" href="#版本元数据">版本元数据</a></h3>
<p>SemVer 有“版本元数据” 的概念，会在版本后随着一个加号出现，比如 <code>1.0.0+21AF26D3</code> 。通常这个元数据是被忽略的，而且不应该在版本请求中使用。永远不要在 <a href="https://crates.io/">crates.io</a> 上发布两个仅有元数据不同的版本( 然而目前 <a href="https://crates.io/">crates.io</a> 却允许这一点，这是一个 <a href="https://github.com/rust-lang/crates.io/issues/1059">known issue</a>)。</p>
<h2 id="其他约束"><a class="header" href="#其他约束">其他约束</a></h2>
<p>版本请求并不是决定解析过程的唯一因素。下面章节中介绍了影响解析过程的其他几种约束:</p>
<h3 id="features"><a class="header" href="#features">Features</a></h3>
<p>为了生成 <code>cargo.lock</code>，解析器在构建依赖图时会假设所有 <a href="reference/workspaces.html">workspace</a> 的所有 [feature] 都被启用。这保证所有可选的依赖都可用且被解析，当在命令行中通过 <a href="reference/features.html#command-line-feature-options"><code>--features</code> command-line flag</a> 添加或删除 feature 时，功能可以正常实现。当<em>编译</em>一个crate时，解析器第二次执行，根据命令来决定实际启用的feature。</p>
<p>当一个依赖被解析时，会将其被启用的所有feature一起解析(取并集)。</p>
<p>（译者注：这里介绍一下背景，<code>im</code> 这个包有多个feature，其中两个是 <code>serde</code> 和 <code>rayon</code>，启用后会包含进来同名的包。）</p>
<p>例如，一个包依赖 <a href="https://crates.io/crates/im"><code>im</code></a> 包，开启了 <a href="https://github.com/bodil/im-rs/blob/v15.0.0/Cargo.toml#L46"><code>serde</code> dependency</a>；另一个包也依赖 <a href="https://crates.io/crates/im"><code>im</code></a>，开启了 <a href="https://github.com/bodil/im-rs/blob/v15.0.0/Cargo.toml#L47"><code>rayon</code> dependency</a>。这时 <code>im</code> 会按照两个feature都启用的状态进行构建， <code>serde</code> 和 <code>rayon</code> 都会被加入解析图。如果依赖 <code>im</code> 的包都没有包含这些 feature，那么这些可选依赖会被忽略，不会影响解析过程。</p>
<p>当在工作空间(workspace)中构建多个包(比如通过 <code>--workspace</code> 或者 多个 <code>-p</code> 标记)，这些包的所有依赖的所有feature会被组合在一起进行构建。如果你有需要避免合并的需求，可以通过各自单独执行 <code>cargo</code> 进行构建。</p>
<p>解析器会跳过那些缺失所请求feature的包版本。例如，如果一个包依赖 <a href="https://crates.io/crates/regex"><code>regex</code></a> 的 <code>^1</code> 版本，且开启了 <a href="https://github.com/rust-lang/regex/blob/1.3.0/Cargo.toml#L56"><code>perf</code> feature</a>，那么其可以选择的最早版本是 <code>1.3.0</code>，因为那之前的版本没有 <code>perf</code> 这个feature。同样的，如果一个feature在新版本中被移除，那么需要这个feature的包的版本就会卡在之前包含这个feature的版本。不建议在 SemVer 兼容的更新中移除feature。注意，可选依赖是隐式的feature，因此移除某个可选依赖或者将其改变为非可选可能会导致问题，详见 <a href="reference/semver.html#cargo-remove-opt-dep">removing an optional dependency</a>。</p>
<h4 id="feature-解析器-v2"><a class="header" href="#feature-解析器-v2">Feature 解析器 v2</a></h4>
<p>在 <code>Cargo.toml</code> 中指定 <code>resolver = &quot;2&quot;</code> 时，使用不同算法的另一个feature解析器会被启用。第一代解析器会将一个包启用的所有feature合并起来，无论这些feature是在哪里指定的。而第二代解析器会在以下场景中避免合并feature:</p>
<ul>
<li>
<p>当没有实际被构建时，平台特定依赖的feature不会被启用。例如:</p>
<pre><code class="language-toml">[dependencies.common]
version = &quot;1.0&quot;
features = [&quot;f1&quot;]

[target.'cfg(windows)'.dependencies.common]
version = &quot;1.0&quot;
features = [&quot;f2&quot;]
</code></pre>
</li>
<li>
<p>当在一个非windows平台构建这个例子时， <code>f2</code> feature <em>不会</em>被启用。</p>
</li>
<li>
<p>如果一些依赖同时出现在正常的 dependency，和 <a href="reference/specifying-dependencies.html#build-dependencies">build-dependencies</a> 或 proc-macros中，那么后者中的feature不会被合并到前者中。例如:</p>
<pre><code class="language-toml">[dependencies]
log = &quot;0.4&quot;

[build-dependencies]
log = {version = &quot;0.4&quot;, features=['std']}
</code></pre>
<p>当编译构建脚本时， <code>log</code> crate 带着 <code>std</code> feature 一起编译。而当编译你的库时，则不会启用该feature。</p>
</li>
<li>
<p>构建普通目标时，不会把 <a href="reference/specifying-dependencies.html#development-dependencies">dev-dependencies</a> 中相同依赖的 feature 合并进来。只有构建开发时目标(test、example等)，<a href="reference/specifying-dependencies.html#development-dependencies">dev-dependencies</a> 被构建时，才会进行合并。</p>
<pre><code class="language-toml">[dependencies]
serde = {version = &quot;1.0&quot;, default-features = false}

[dev-dependencies]
serde = {version = &quot;1.0&quot;, features = [&quot;std&quot;]}
</code></pre>
<p>在这个例子中，该库构建 <code>serde</code> 不会带 <code>std</code> feature。然而，当构建一个 test或example时，就会带 <code>std</code> feature。比如执行 <code>cargo test</code> 或 <code>cargo build --all-targets</code> 会合并 feature 。注意 dev-dependencies 总是会被忽略，以上内容仅针对顶层 package 或 workspace 成员。</p>
</li>
</ul>
<h3 id="links"><a class="header" href="#links"><code>links</code></a></h3>
<p><a href="reference/manifest.html#the-links-field"><code>links</code> field</a> 字段用于确保二进制目标对每个本地库只链接一次。解析器会尝试创建一个依赖图，使得每个 <code>links</code> 名只对应一个实例。如果无法找到这样的一个依赖图，就会返回错误。</p>
<p>例如，如果一个包依赖 <a href="https://crates.io/crates/libgit2-sys"><code>libgit2-sys</code></a> 的 <code>0.11</code> 版，而另一个包依赖 <code>0.12</code>，则会报错，因为 Cargo 无法将两个依赖合并，即使这个两个版本链接的都是 <code>git2</code> 本地库。因此，在发布带 <code>links</code>字段的库的 SemVer 不兼容版本时，一定要多加注意。</p>
<h3 id="yanked-versions"><a class="header" href="#yanked-versions">Yanked versions</a></h3>
<p><a href="reference/publishing.html#cargo-yank">Yanked releases</a> 是那些标记为不应该使用的版本。当解析器在构建依赖图时，会忽略哪些标记为yanked的版本，除非其已经写入了 <code>Cargo.lock</code>。</p>
<h2 id="更新依赖"><a class="header" href="#更新依赖">更新依赖</a></h2>
<p>需要知晓依赖图的那些 Cargo 命令会自动执行依赖解析。例如，<a href="reference/../commands/cargo-build.html"><code>cargo build</code></a> 会运行解析器来知晓所有需要构建的依赖。在第一次执行之后，结果被保存到 <code>Cargo.lock</code> 中。接下来的命令也会执行解析器，保持依赖被锁定在 <code>Cargo.lock</code> 中声明的版本(<em>如果可以做到的话</em>)。</p>
<p>如果 <code>Cargo.toml</code> 中的依赖列表被修改，比如把依赖从 <code>1.0</code> 改到 <code>2.0</code>，解析器会选择该依赖的新版本以满足依赖请求。如果新的依赖也引用的新的依赖，那么后者也会触发额外的更新。<code>Cargo.lock</code> 会更新为新的结果。 <code>--locked</code> 或 <code>--frozen</code> flag 可以改变这种行为，或者会返回一个错误，以防止依赖请求变更时的自动依赖更新。</p>
<p><a href="reference/../commands/cargo-update.html"><code>cargo update</code></a> 可以更新 <code>Cargo.lock</code> 中有新版本的依赖项。如果不带任何选项，其会更新 lock file 中的所有 package。 <code>-p</code> flag 可以指定更新的包名，其他 flag 如 <code>--aggressive</code> 或 <code>--precise</code> 可以用于控制如何进行版本选择。</p>
<h2 id="覆盖"><a class="header" href="#覆盖">覆盖</a></h2>
<p>Cargo有多种机制来覆盖依赖图中的依赖项， <a href="reference/overriding-dependencies.html">Overriding Dependencies</a> 一章中进行了详细介绍。覆盖项是对注册机构(registry)进行覆盖，将被覆盖的依赖替换为其他条目，除此之外解析过程没有任何区别。</p>
<h2 id="依赖的种类"><a class="header" href="#依赖的种类">依赖的种类</a></h2>
<p>一个包 (package) 中有三种依赖：normal，<a href="reference/specifying-dependencies.html#build-dependencies">build</a>，和 <a href="reference/specifying-dependencies.html#development-dependencies">dev</a>。大多数情况下，这三种依赖在解析器的方式是一样，一个区别是非工作空间成员的 dev-dependencies 总是被忽略，不会影响到解析过程。</p>
<p>带有 <code>[target]</code> 的 <a href="reference/specifying-dependencies.html#platform-specific-dependencies">Platform-specific dependencies</a> (平台指定依赖) 都会被解析 (像是所有平台都被启用一样)。换句话说，解析器不会理会哪个平台或者 <code>cfg</code> 标记。</p>
<h3 id="dev-dependency-cycles"><a class="header" href="#dev-dependency-cycles">dev-dependency cycles</a></h3>
<p>通常解析器不允许循环依赖，但是在 <a href="reference/specifying-dependencies.html#development-dependencies">dev-dependencies</a> 却是允许的。例如，项目 <code>foo</code> 有一个 <a href="reference/specifying-dependencies.html#development-dependencies">dev-dependencies</a> <code>bar</code>，而 <code>bar</code> 有一个 denpendency <code>foo</code> (通常是以 &quot;path&quot; 依赖的形式)。这是允许的，因为在构建产物的视角看来，这并不是一个循环依赖。在这个例子中， <code>foo</code> 库先被构建(这个过程中不需要 <code>bar</code>，因为 <code>bar</code> 只用于 tests)，然后依赖 <code>foo</code> 的 <code>bar</code> 被构建，最后 <code>foo</code> 的 tests 也可以链接 <code>bar</code> 而被构建。</p>
<p>小心这里会产生令人困惑的错误。在构建 <code>foo</code> 的单元测试(unit tests)时，实际上有两份 <code>foo</code> 的拷贝被链接进最后的测试二进制文件：一份是 <code>bar</code> 依赖的 <code>foo</code>，另一份是包含着单元测试的 <code>foo</code>。如同在 <a href="reference/resolver.html#version-incompatibility-hazards">Version-incompatibility hazards</a> 一节中提到问题，这两个 <code>foo</code> 的类型是不兼容的。在把 <code>bar</code> 中的 <code>foo</code> 的类型进行再导出时，要小心 <code>foo</code> 的单元测试不会把这些类型与本地类型视作等同。</p>
<p>尽可能拆分你的包并进行重构，以保证依赖图中没有循环。</p>
<h2 id="解析器版本"><a class="header" href="#解析器版本">解析器版本</a></h2>
<p>可以在 <code>Cargo.toml</code> 中指定解析器版本来使用另一种 feature 解析算法:</p>
<pre><code class="language-toml">[package]
name = &quot;my-package&quot;
version = &quot;1.0.0&quot;
resolver = &quot;2&quot;
</code></pre>
<p>一代解析器在 Cargo <code>1.50</code> 之前为默认解析器。
如果在 root package 中指定 <a href="reference/manifest.html#the-edition-field"><code>edition = &quot;2021&quot;</code></a> 或者更高版本，则会使用二代解析器。其他情况下默认都是一代解析器。</p>
<p>二代解析器主要是改变了 <a href="reference/resolver.html#features">feature 合并</a> 的过程。详情见 <a href="reference/features.html#feature-resolver-version-2">features 一章</a>。</p>
<p>解析器版本设置是全局性的，会影响到整个工作空间(workspace)。依赖中定义的 <code>resolver</code> 版本会被忽略，只有顶层 package 中定义的才有效。如果使用了 <a href="reference/workspaces.html#virtual-workspace">virtual workspace</a> ，解析器版本应该在 <code>[workspace]</code> 表中指定:</p>
<pre><code class="language-toml">[workspace]
members = [&quot;member1&quot;, &quot;member2&quot;]
resolver = &quot;2&quot;
</code></pre>
<h2 id="一些建议"><a class="header" href="#一些建议">一些建议</a></h2>
<p>下面是一些关于设置你的包以及依赖项的版本的建议。这些建议在一般情况下的通用的，不过当然会有一些情况需要你指定不同寻常的依赖请求。</p>
<ul>
<li>
<p>在更新你的版本数时，遵从 <a href="reference/semver.html">SemVer guidelines</a>，无论是 SemVer 兼容或不兼容的更新。</p>
</li>
<li>
<p>尽可能使用 crate 依赖请求，比如 <code>1.2.3</code>。这让解析器可以在保证构建兼容性同时尽可能灵活地选择依赖版本。</p>
<ul>
<li>三个数字都应该设置，这可以指定可用的最小版本，保证库的使用者不会使用比这个版本更旧的版本，因而缺失一些构建所需的东西。</li>
<li>避免使用 <code>*</code> 版本，因为 <a href="https://crates.io/">crates.io</a> 不允许这种请求，而且可能会导致 <code>[cargo update]</code> 时产生破坏 SemVer 兼容的更改。</li>
<li>避免过度放宽依赖需求。例如 <code>&gt;=&quot;2.0.0&quot;</code> 可以允许任何 SemVer 不兼容的版本，比如 <code>5.0.0</code>，这会在未来破坏依赖过程。</li>
<li>尽可能避免过度缩窄依赖需求。例如如果你指定 <code>bar=~&quot;1.3&quot;</code>，而另一个包指定 <code>bar=&quot;1.4&quot;</code>，这会导致解析失败，即使一般情况下<em>次版本更新</em> (minor release)是兼容的。</li>
</ul>
</li>
<li>
<p>保持声明依赖版本与你的库实际所需的最小依赖版本一致。比如说，你有个库声明需要 <code>bar=&quot;1.0.12&quot;</code> ，后来你的库实际开始使用 <code>bar</code> <code>1.1.0</code> 版中的某些功能，这时应该更新声明为 <code>bar=&quot;1.1.0&quot;</code>。</p>
<p>如果你没有这样做，可能问题不会立即显现出来，因为当你执行 <code>cargo update</code> 时，Cargo会对把所有依赖更新到最新的版本。然而，当另一个用户使用你的库时，可能会执行 <code>cargo update -p your-library</code>，这<em>不会</em>更新 <code>bar</code> 的版本，因为 <code>bar</code> 版本可能被他的 <code>Cargo.lock</code> 锁定了。只有当声明的依赖项版本被改变时，<code>bar</code> 才会被更新。进行 <code>cargo update -p</code> 时的失败可能会让这个用户非常困惑。</p>
</li>
<li>
<p>如果两个包的耦合很强，使用 <code>=</code> 来指定依赖可以保证之间的同步。例如，一个库有一个对应的 proc-macro，通常情况下假设必须保持版本统一(两者也不会独立使用)。这时parent library 可以用 <code>=</code> 来指定这个 proc-macro，然后把这些宏重导出出来方便使用。</p>
</li>
<li>
<p><code>0.0.x</code> 版本可以被用于那些暂时还不稳定的包。</p>
</li>
</ul>
<p>一般来说，你的依赖指定的越严格，解析越可能失败；反过来说，你的依赖指定的太宽松，新版本就可能破坏构建。</p>
<h2 id="问题检查"><a class="header" href="#问题检查">问题检查</a></h2>
<p>下面部分阐述了一些你可能会遇到的问题，以及相应的解决办法:</p>
<h3 id="semver不兼容的修订版更新导致构建被破坏"><a class="header" href="#semver不兼容的修订版更新导致构建被破坏">SemVer不兼容的修订版更新导致构建被破坏</a></h3>
<p>有时一个项目可能无意间发布了一个修订版更新(point release)，但是却带有SemVer不兼容的改变。当用户通过 <code>cargo update</code> 更新到最新版本后，构建被破坏了。这时建议该项目 <a href="reference/publishing.html#cargo-yank">yank</a> 掉这个版本，要么移除这个不兼容改变，要么以主版本更新来发布。</p>
<p>如果这个改变来自一个第三方项目，可以(礼貌地)与项目合作来解决问题。</p>
<p>当等待该版本被 yank 时，可以采用一些变通措施:</p>
<ul>
<li>如果你的项目是一个末端产品(比如一个二进制可执行程序)，可以通过 <code>Cargo.lock</code> 避免更新这个有问题的包。这可以通过在 <a href="reference/../commands/cargo-update.html"><code>cargo update</code></a> 使用 <code>--precise</code> 标志来实现。</li>
<li>如果你发布一个二进制程序到 <a href="https://crates.io/">crates.io</a>，那么可以暂时添加一个 <code>=</code> 来强制依赖使用某个特定的“好”版本。
<ul>
<li>或者建议用户在 <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 时使用 <code>--locked</code> 标志来使用自带的 <code>Cargo.lock</code>，其中包含着保证可以编译成功的依赖版本。</li>
</ul>
</li>
<li>库项目可以考虑发布一个暂时的新版本，其中包含更严格的依赖版本限制，以避免导致问题的依赖。你可以考虑使用一个范围限制(而不是 <code>=</code> )来避免过于严格的要求导致与其他包的依赖冲突。当问题解决后，你可以发布另一个修订版本来放松这个依赖限制。</li>
<li>如果这个(出问题的)第三方项目看起来无法或者不情愿yank这个更新，那么一个办法是更新你的代码来兼容这个更新，同时更新依赖请求，将这个版本设置为最小要求版本。同时你还需要考虑这对于你的库来说是否是一个SemVer破坏性更新，例如你这个库导出了依赖中的某些类型。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语义化兼容性"><a class="header" href="#语义化兼容性">语义化兼容性</a></h1>
<p>本章详细介绍了对于新发布的包，什么是传统意义上的兼容或破坏性的语义化版本变化。
关于什么是语义化版本，以及Cargo如何使用它来确保库的兼容性，请参阅<a href="reference/resolver.html#semver-compatibility">SemVer compatibility</a>部分。</p>
<p>这些只是<em>准则</em>，而不一定是所有项目都会遵守的硬性规定。
<a href="reference/semver.html#change-categories">Change categories</a>部分详细说明了本指南如何对变更的级别和严重程度进行分类。
本指南的大部分内容都集中在那些会导致 <code>cargo</code> 和 <code>rustc</code> 不能构建以前正常工作的内容的变化。
几乎所有的改变都有可能对运行时的行为产生负面影响，对于这些情况，通常由项目维护者判断是否属于语义化不兼容的改变。</p>
<p>也可以参见<a href="https://github.com/rust-lang/rust-semverver">rust-semverver</a>，它是一个实验性的工具，试图以编程方式检查兼容性规则。</p>
<h2 id="更改类别"><a class="header" href="#更改类别">更改类别</a></h2>
<p>下面列出的所有策略都是按变化的级别来分类的:</p>
<ul>
<li><strong>Major change</strong>: 这种变化需要语义化版本的重要改变。</li>
<li><strong>Minor change</strong>: 这种变化只需要在语义化版本上做小改动。</li>
<li><strong>Possibly-breaking change</strong>: 一些项目可能认为是大的变化，另一些则认为是小的变化。</li>
</ul>
<p>&quot;可能破坏&quot; 类别涵盖了在更新期间有<em>潜在</em>破坏的变化，但不一定会导致破坏。
这些变化的影响应该被仔细考虑。确切的性质将取决于该变化和项目维护者的原则。</p>
<p>有些项目可能会选择只在一个小的变化上增加补丁号。我们鼓励遵循语义化规范，只在补丁版本中应用错误修复。
然而，一个错误的修复可能需要一个被标记为 &quot;次要改动&quot; 的API变化，并且不应该影响兼容性。
本指南不对每个 &quot;次要改动&quot; 应如何处理采取立场，因为次要改动和补丁改动之间的区别是取决于改动的性质的惯例。</p>
<p>有些改动被标记为 &quot;次要&quot;，即使它们有破坏构建的潜在风险。
这适用于潜在风险极低的情况，而且可能破坏的代码不太可能用习惯性的Rust编写，或者去特别强调不使用。</p>
<p>本指南使用 &quot;主要&quot; 和 &quot;次要&quot; 这两个术语是假设这与 &quot;1.0.0&quot; 或更高版本有关。从 &quot;0.y.z&quot; 开始的初始开发版本可以把 &quot;y&quot; 中的变化作为主要版本，而把 &quot;z&quot; 作为次要版本。
&quot;0.0.z&quot; 版本总是主要变化。这是因为Cargo使用的惯例是，只有最左边的非零部分中的变化才被认为是不兼容的。</p>
<ul>
<li>API 兼容性
<ul>
<li>条目
<ul>
<li><a href="reference/semver.html#item-remove">Major: 重命名/移动/移除任何公共条目</a></li>
<li><a href="reference/semver.html#item-new">Minor: 添加新的公开条目</a></li>
</ul>
</li>
<li>Structs
<ul>
<li><a href="reference/semver.html#struct-add-private-field-when-public">Major: 当所有当前字段都为公共时，添加私有结构体字段</a></li>
<li><a href="reference/semver.html#struct-add-public-field-when-no-private">Major: 在没有私有字段时添加公共字段</a></li>
<li><a href="reference/semver.html#struct-private-fields-with-private">Minor: 当至少有一个私有字段存在时添加或删除私有字段</a></li>
<li><a href="reference/semver.html#struct-tuple-normal-with-private">Minor: 从一个包含所有私有字段(至少包含一个字段)的元组结构体到一个普通结构体，反之亦然</a></li>
</ul>
</li>
<li>Enums
<ul>
<li><a href="reference/semver.html#enum-variant-new">Major: 添加新的枚举变量(没有 <code>non_exhaustive</code>)</a></li>
<li><a href="reference/semver.html#enum-fields-new">Major: 向枚举变量添加新字段</a></li>
</ul>
</li>
<li>Traits
<ul>
<li><a href="reference/semver.html#trait-new-item-no-default">Major: 添加非默认的trait条目</a></li>
<li><a href="reference/semver.html#trait-item-signature">Major: trait条目签名任何变化</a></li>
<li><a href="reference/semver.html#trait-new-default-item">Possibly-breaking: 添加默认trait条目</a></li>
<li><a href="reference/semver.html#trait-object-safety">Major: 添加trait条目使trait非对象安全</a></li>
<li><a href="reference/semver.html#trait-new-parameter-no-default">Major: 添加没有默认的类型参数</a></li>
<li><a href="reference/semver.html#trait-new-parameter-default">Minor: 增加默认的trait类型参数</a></li>
</ul>
</li>
<li>Implementations
<ul>
<li><a href="reference/semver.html#impl-item-new">Possibly-breaking change: 添加任何内部条目</a></li>
</ul>
</li>
<li>Generics
<ul>
<li><a href="reference/semver.html#generic-bounds-tighten">Major: 收紧泛型边界</a></li>
<li><a href="reference/semver.html#generic-bounds-loosen">Minor: 放宽泛型边界</a></li>
<li><a href="reference/semver.html#generic-new-default">Minor: 添加默认类型参数</a></li>
<li><a href="reference/semver.html#generic-generalize-identical">Minor: 泛化类型以使用泛型(具有等同类型)</a></li>
<li><a href="reference/semver.html#generic-generalize-different">Major: 泛化类型以使用泛型(可能有不同的类型)</a></li>
<li><a href="reference/semver.html#generic-more-generic">Minor: 将泛化类型改为更泛化的类型</a></li>
</ul>
</li>
<li>Functions
<ul>
<li><a href="reference/semver.html#fn-change-arity">Major: 添加/删除函数参数</a></li>
<li><a href="reference/semver.html#fn-generic-new">Possibly-breaking: 引入新的函数类型参数</a></li>
<li><a href="reference/semver.html#fn-generalize-compatible">Minor: 泛化函数以使用泛型(支持原始类型)</a></li>
<li><a href="reference/semver.html#fn-generalize-mismatch">Major: 泛化函数以使用类型不匹配的泛型</a></li>
</ul>
</li>
<li>Attributes
<ul>
<li><a href="reference/semver.html#attr-no-std-to-std">Major: 从 <code>no_std</code> 切换到要求 <code>std</code> </a></li>
</ul>
</li>
</ul>
</li>
<li>工具和环境的兼容性
<ul>
<li><a href="reference/semver.html#env-new-rust">Possibly-breaking: 改变所需的最小Rust版本</a></li>
<li><a href="reference/semver.html#env-change-requirements">Possibly-breaking: 改变平台和环境要求</a></li>
<li>Cargo
<ul>
<li><a href="reference/semver.html#cargo-feature-add">Minor: 增加新的Cargo特性</a></li>
<li><a href="reference/semver.html#cargo-feature-remove">Major: 删除Cargo特性</a></li>
<li><a href="reference/semver.html#cargo-feature-remove-another">Major: 如果改变了特性或公共条目，从特性列表中删除一个特性</a></li>
<li><a href="reference/semver.html#cargo-remove-opt-dep">Possibly-breaking: 删除可选的依赖</a></li>
<li><a href="reference/semver.html#cargo-change-dep-feature">Minor: 改变依赖特性</a></li>
<li><a href="reference/semver.html#cargo-dep-add">Minor: 添加依赖</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="reference/semver.html#application-compatibility">应用程序兼容性</a></li>
</ul>
<h2 id="api兼容性"><a class="header" href="#api兼容性">API兼容性</a></h2>
<p>下面所有的例子都包含三个部分：原始代码，修改后的代码，以及可能出现在另一个项目中的代码使用范例。
在次要改动中，示例用法应该成功地与前后两个版本一起构建。</p>
<p><a id="item-remove"></a></p>
<h3 id="major-重新命名移动删除任意公共条目"><a class="header" href="#major-重新命名移动删除任意公共条目">Major: 重新命名/移动/删除任意公共条目</a></h3>
<p>缺失公开暴露<a href="reference/../../reference/items.html">条目</a>将导致对该条目的任何使用无法编译。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub fn foo() {}

///////////////////////////////////////////////////////////
// 之后
// ... 条目被移除

///////////////////////////////////////////////////////////
// 示例：将打破用法。
fn main() {
    updated_crate::foo(); // Error: 不能找到函数 `foo`
}</code></pre>
<p>这包括添加任何种类的[<code>cfg</code> 属性]，它可以根据<a href="reference/../../reference/conditional-compilation.html">conditional compilation</a> &quot;条件编译&quot;改变哪些条目或行为是可用的。</p>
<p>缓和策略:</p>
<ul>
<li>将要删除的条目标记为<a href="reference/../../reference/attributes/diagnostics.html#the-deprecated-attribute">deprecated</a>，然后在以后的语义化版本打破性发布中删除它们。</li>
<li>将重命名的条目标记为<a href="reference/../../reference/attributes/diagnostics.html#the-deprecated-attribute">deprecated</a>，并使用 <a href="reference/../../reference/items/use-declarations.html"><code>pub use</code></a> 条目来重新输出旧名称。</li>
</ul>
<p><a id="item-new"></a></p>
<h3 id="minor-添加新公共条目"><a class="header" href="#minor-添加新公共条目">Minor: 添加新公共条目</a></h3>
<p>增加新的、公开的<a href="reference/../../reference/items.html">items</a>是次要变化。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// 之前
// ... 缺少条目

///////////////////////////////////////////////////////////
// 之后
pub fn foo() {}

///////////////////////////////////////////////////////////
// 示例：库的使用将安全工作。
// `foo` 没有被使用，因为它之前并不存在。</code></pre>
<p>请注意，在某些少见的情况下，由于通配符导入的原因，这可能是<em>破坏性</em>改变。例如，如果你添加了一个新的特性，
而一个条目使用了一个将该特性带入范围的通配符导入，并且这个新的特性引入了一个与它所实现的任意类型相冲突的关联项，这可能会因为这种混淆而导致编译时错误。例子:</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// 之前
// ... 缺少trait

///////////////////////////////////////////////////////////
// 之后
pub trait NewTrait {
    fn foo(&amp;self) {}
}

impl NewTrait for i32 {}

///////////////////////////////////////////////////////////
// 示例：使用是破坏性的。
use updated_crate::*;

pub trait LocalTrait {
    fn foo(&amp;self) {}
}

impl LocalTrait for i32 {}

fn main() {
    123i32.foo(); // Error:  在作用域有多个适用的条目
}</code></pre>
<p>这并不被认为是重要改变，因为通常通配符导入是一个已知的向前兼容的风险。应该避免从外部crate中导入条目的通配符。</p>
<p><a id="struct-add-private-field-when-public"></a></p>
<h3 id="major-当当前所有字段都是公共的时候添加私有结构体字段"><a class="header" href="#major-当当前所有字段都是公共的时候添加私有结构体字段">Major: 当当前所有字段都是公共的时候，添加私有结构体字段</a></h3>
<p>当私有字段被添加到之前拥有所有公共字段的结构体中时。
这将破坏任何试图用<a href="reference/../../reference/expressions/struct-expr.html">struct literal</a>&quot;结构体字面量&quot;来构建该结构体的代码。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub struct Foo {
    pub f1: i32,
}

///////////////////////////////////////////////////////////
// 之后
pub struct Foo {
    pub f1: i32,
    f2: i32,
}

///////////////////////////////////////////////////////////
// 示例：使用是破坏性的。
fn main() {
    let x = updated_crate::Foo { f1: 123 }; // Error: 不能构建 `Foo`
}</code></pre>
<p>缓和策略:</p>
<ul>
<li>不要向所有公共字段的结构体添加新字段。</li>
<li>在首次引入结构体时，将结构标记为<a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>，
以阻止用户使用结构字面量语法，而是提供构造方法或 <a href="reference/../../std/default/trait.Default.html">Default</a> 实现。</li>
</ul>
<p><a id="struct-add-public-field-when-no-private"></a></p>
<h3 id="major-在不存在私有字段的情况下添加公共字段"><a class="header" href="#major-在不存在私有字段的情况下添加公共字段">Major: 在不存在私有字段的情况下添加公共字段</a></h3>
<p>当公共字段被添加到拥有所有公共字段的结构体中时，这将破坏任何试图用<a href="reference/../../reference/expressions/struct-expr.html">struct literal</a>&quot;结构体字面量&quot;来构建它的代码。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub struct Foo {
    pub f1: i32,
}

///////////////////////////////////////////////////////////
// 之后
pub struct Foo {
    pub f1: i32,
    pub f2: i32,
}

///////////////////////////////////////////////////////////
// 示例：使用是破坏性的。
fn main() {
    let x = updated_crate::Foo { f1: 123 }; // Error: 缺失 `f2` 字段
}</code></pre>
<p>缓和策略:</p>
<ul>
<li>不要向所有公共字段结构体添加新字段。</li>
<li>在首次引入结构体时，将结构体标记为<a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>，
以阻止用户使用结构体字面量语法，而是提供构造方法或<a href="reference/../../std/default/trait.Default.html">Default</a>实现。</li>
</ul>
<p><a id="struct-private-fields-with-private"></a></p>
<h3 id="minor-当至少有一个私有字段存在时添加或删除私有字段"><a class="header" href="#minor-当至少有一个私有字段存在时添加或删除私有字段">Minor: 当至少有一个私有字段存在时添加或删除私有字段</a></h3>
<p>当结构已经至少有一个私有字段时，从结构中添加或删除私有字段是安全的。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// 之前
#[derive(Default)]
pub struct Foo {
    f1: i32,
}

///////////////////////////////////////////////////////////
// 之后
#[derive(Default)]
pub struct Foo {
    f2: f64,
}

///////////////////////////////////////////////////////////
// 示例： 使用库将是安全的。
fn main() {
    // 不能访问私有字段。
    let x = updated_crate::Foo::default();
}</code></pre>
<p>这是安全的，因为现有的代码不能使用<a href="reference/../../reference/expressions/struct-expr.html">struct literal</a>来构造它，无需彻底匹配其内容。</p>
<p>请注意，对于元组结构体来说，如果元组包含公共字段，增加或删除私有字段会改变任何公共字段的索引，将是 <strong>major变化</strong> 。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// 之前
#[derive(Default)]
pub struct Foo(pub i32, i32);

///////////////////////////////////////////////////////////
// 之后
#[derive(Default)]
pub struct Foo(f64, pub i32, i32);

///////////////////////////////////////////////////////////
// 示例：使用是破坏性的。
fn main() {
    let x = updated_crate::Foo::default();
    let y = x.0; // Error: 是私有的。
}</code></pre>
<p><a id="struct-tuple-normal-with-private"></a></p>
<h3 id="minor-从具有所有私有字段的元组结构体至少有一个字段到正常的结构体"><a class="header" href="#minor-从具有所有私有字段的元组结构体至少有一个字段到正常的结构体">Minor: 从具有所有私有字段的元组结构体(至少有一个字段)到正常的结构体。</a></h3>
<p>如果所有字段都是私有的，那么将元组结构体改变为普通结构体是安全的，反之亦然。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// 之前
#[derive(Default)]
pub struct Foo(i32);

///////////////////////////////////////////////////////////
// 之后
#[derive(Default)]
pub struct Foo {
    f1: i32,
}

///////////////////////////////////////////////////////////
// 示例：库的使用将是安全的。
fn main() {
    // 不能访问私有字段。
    let x = updated_crate::Foo::default();
}</code></pre>
<p>这是安全的，因为当前的代码不能使用<a href="reference/../../reference/expressions/struct-expr.html">struct literal</a>来构造它，不能匹配它的内容。</p>
<p><a id="enum-variant-new"></a></p>
<h3 id="major-添加新的枚举条目-没有-non_exhaustive--"><a class="header" href="#major-添加新的枚举条目-没有-non_exhaustive--">Major: 添加新的枚举条目 (没有 <code>non_exhaustive</code> ) 。</a></h3>
<p>如果枚举未使用<a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>属性，增加新的枚举条目是破坏性的改变。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub enum E {
    Variant1,
}

///////////////////////////////////////////////////////////
// 之后
pub enum E {
    Variant1,
    Variant2,
}

///////////////////////////////////////////////////////////
// 示例：使用是破坏性的。
fn main() {
    use updated_crate::E;
    let x = E::Variant1;
    match x { // Error: `E::Variant2` 未涵盖
        E::Variant1 =&gt; {}
    }
}</code></pre>
<p>缓和策略:</p>
<ul>
<li>在引入枚举时，将其标记为<a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>，以迫使用户使用[通配符模式]来捕获新的变体。</li>
</ul>
<p><a id="enum-fields-new"></a></p>
<h3 id="major-向枚举变量添加新字段"><a class="header" href="#major-向枚举变量添加新字段">Major: 向枚举变量添加新字段</a></h3>
<p>在枚举变体中添加新的字段是一种破坏性的改变，因为所有的字段都是公开的，构造函数和匹配将无法编译。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub enum E {
    Variant1 { f1: i32 },
}

///////////////////////////////////////////////////////////
// 之后
pub enum E {
    Variant1 { f1: i32, f2: i32 },
}

///////////////////////////////////////////////////////////
// 示例：使用是破坏性的。
fn main() {
    use updated_crate::E;
    let x = E::Variant1 { f1: 1 }; // Error: 缺失 f2
    match x {
        E::Variant1 { f1 } =&gt; {} // Error: 缺失 f2
    }
}</code></pre>
<p>缓和策略:</p>
<ul>
<li>在引入枚举时，将变体标记为<a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>non_exhaustive</code></a>，使其没有通配符的情况下不能构建或匹配它。
<pre><code class="language-rust ignore skip">pub enum E {
    #[non_exhaustive]
    Variant1{f1: i32}
}</code></pre>
</li>
<li>在引入枚举时，使用显式结构体作为值，在这里你可以对字段可见性进行控制。
<pre><code class="language-rust ignore skip">pub struct Foo {
   f1: i32,
   f2: i32,
}
pub enum E {
    Variant1(Foo)
}</code></pre>
</li>
</ul>
<p><a id="trait-new-item-no-default"></a></p>
<h3 id="major-添加非默认的trait条目"><a class="header" href="#major-添加非默认的trait条目">Major: 添加非默认的trait条目</a></h3>
<p>在特性中添加非默认的条目是一种破坏性的改变。这将破坏该特性的任何实现者。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub trait Trait {}

///////////////////////////////////////////////////////////
// 之后
pub trait Trait {
    fn foo(&amp;self);
}

///////////////////////////////////////////////////////////
// 示例：使用是破坏性的。
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}  // Error: 未实现所有trait条目</code></pre>
<p>缓和策略:</p>
<ul>
<li>始终为新的相关trait条目提供默认的实现或值。</li>
<li>在引入trait时，使用<a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed">sealed trait</a>技术来防止crate外的用户实现该trait。</li>
</ul>
<p><a id="trait-item-signature"></a></p>
<h3 id="major-trait条目签名的任何变化"><a class="header" href="#major-trait条目签名的任何变化">Major: trait条目签名的任何变化</a></h3>
<p>对trait条目的签名做任何改变都是破坏性的。可能会破坏该trait的外部实现者。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub trait Trait {
    fn f(&amp;self, x: i32) {}
}

///////////////////////////////////////////////////////////
// 之后
pub trait Trait {
    // 对于密封的trait或普通函数，这将是次要变化，因为用泛型来泛化严格地扩展了可能的用法。
    // 但在这种情况下，trait的实现必须使用相同的签名。
    fn f&lt;V&gt;(&amp;self, x: V) {}
}

///////////////////////////////////////////////////////////
// 示例：使用是破坏性的。
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {
    fn f(&amp;self, x: i32) {}  // Error: trait 声明有1个类型参数
}</code></pre>
<p>缓和策略:</p>
<ul>
<li>引入带有默认实现的新条目，以涵盖新功能，而不是修改现有条目。</li>
<li>当引入该trait时，使用<a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed">sealed trait</a>来防止crate外的用户实现该trait。</li>
</ul>
<p><a id="trait-new-default-item"></a></p>
<h3 id="possibly-breaking-添加默认的trait条目"><a class="header" href="#possibly-breaking-添加默认的trait条目">Possibly-breaking: 添加默认的trait条目</a></h3>
<p>添加默认的trait条目通常是安全的。然而，这有时会导致编译错误。
例如，如果在另一个trait中存在同名的方法，则会引入混淆。</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// 之前
pub trait Trait {}

///////////////////////////////////////////////////////////
// 之后
pub trait Trait {
    fn foo(&amp;self) {}
}

///////////////////////////////////////////////////////////
// 示例：使用是破坏性的。
use updated_crate::Trait;
struct Foo;

trait LocalTrait {
    fn foo(&amp;self) {}
}

impl Trait for Foo {}
impl LocalTrait for Foo {}

fn main() {
    let x = Foo;
    x.foo(); // Error: 作用域内有多个符合条目
}</code></pre>
<p>注意，这种二义性并不存在于<a href="reference/../../reference/items/implementations.html#inherent-implementations">inherent implementations</a>的名称冲突，因为它们优先于trait条目。</p>
<p>参见<a href="reference/semver.html#trait-object-safety">trait-object-safety</a>，了解添加trait条目时需要考虑的特殊情况。</p>
<p>缓和策略:</p>
<ul>
<li>一些项目可能认为这是可以接受的破坏，特别是如果新的条目名称不太可能与任何现有的代码发生冲突。请谨慎选择名称，以有助避免这些冲突。此外，要求下游用户在更新依赖时添加<a href="reference/../../reference/expressions/call-expr.html#disambiguating-function-calls">disambiguation syntax</a> &quot;歧义消除语法&quot; 以选择恰当的函数，这是可以接受的。</li>
</ul>
<p><a id="trait-object-safety"></a></p>
<h3 id="major-添加trait条目使trait非对象安全"><a class="header" href="#major-添加trait条目使trait非对象安全">Major: 添加trait条目，使trait非对象安全</a></h3>
<p>增加改变trait的条目，使trait不再是<a href="reference/../../reference/items/traits.html#object-safety">object safe</a>，这是破坏性的变化。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub trait Trait {}

///////////////////////////////////////////////////////////
// 之后
pub trait Trait {
    // 一个相关的常量使得该trait不是对象安全的。
    const CONST: i32 = 123;
}

///////////////////////////////////////////////////////////
// 示例：使用是破坏性的。
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}

fn main() {
    let obj: Box&lt;dyn Trait&gt; = Box::new(Foo); // Error: 不能成为一个对象
}</code></pre>
<p>反之也是安全的(将非对象安全的trait变成安全的trait)。</p>
<p><a id="trait-new-parameter-no-default"></a></p>
<h3 id="major-添加没有默认值的类型参数"><a class="header" href="#major-添加没有默认值的类型参数">Major: 添加没有默认值的类型参数</a></h3>
<p>在trait中添加没有默认值的类型参数是一种破坏性的改变。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub trait Trait {}

///////////////////////////////////////////////////////////
// 之后
pub trait Trait&lt;T&gt; {}

///////////////////////////////////////////////////////////
// 示例：使用是破坏性的
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}  // Error: 缺失泛型</code></pre>
<p>缓和策略:</p>
<ul>
<li>见 <a href="reference/semver.html#trait-new-parameter-default">添加默认trait类型参数</a>.</li>
</ul>
<p><a id="trait-new-parameter-default"></a></p>
<h3 id="minor-添加默认trait类型参数"><a class="header" href="#minor-添加默认trait类型参数">Minor: 添加默认trait类型参数</a></h3>
<p>在trait中添加类型参数是安全的，只要它有默认值。
外部实现者将使用默认值而不需要指定参数。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub trait Trait {}

///////////////////////////////////////////////////////////
// 之后
pub trait Trait&lt;T = i32&gt; {}

///////////////////////////////////////////////////////////
// 示例：库的使用是安全的。
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}</code></pre>
<p><a id="impl-item-new"></a></p>
<h3 id="possibly-breaking-change-添加任意内部条目"><a class="header" href="#possibly-breaking-change-添加任意内部条目">Possibly-breaking change: 添加任意内部条目</a></h3>
<p>通常情况下，向一个实现添加内部条目应该是安全的，因为内部条目比trait条目有优先权。
然而，在某些情况下，如果名称与具有不同签名的已实现的trait条目相同，则冲突会导致问题。</p>
<pre><code class="language-rust ignore">// 破坏性改变示例

///////////////////////////////////////////////////////////
// 之前
pub struct Foo;

///////////////////////////////////////////////////////////
// 之后
pub struct Foo;

impl Foo {
    pub fn foo(&amp;self) {}
}

///////////////////////////////////////////////////////////
// 示例：使用是破坏性的
use updated_crate::Foo;

trait Trait {
    fn foo(&amp;self, x: i32) {}
}

impl Trait for Foo {}

fn main() {
    let x = Foo;
    x.foo(1); // Error: 这个函数有0个参数
}</code></pre>
<p>注意，如果签名匹配，就不会出现编译时错误，但可能会出现运行时行为的静默变化(因为现在执行的是一个不同的函数)。</p>
<p>缓和策略:</p>
<ul>
<li>一些项目可能认为这是可以接受的破坏，特别是如果新的条目名称不太可能与任何现有的代码发生冲突。请谨慎选择名称，以有助避免这些冲突。此外，要求下游用户在更新依赖时添加<a href="reference/../../reference/expressions/call-expr.html#disambiguating-function-calls">disambiguation syntax</a> &quot;歧义消除语法&quot; 以选择恰当的函数，这是可以接受的。</li>
</ul>
<p><a id="generic-bounds-tighten"></a></p>
<h3 id="major-收紧泛型边界"><a class="header" href="#major-收紧泛型边界">Major: 收紧泛型边界</a></h3>
<p>在类型上收紧泛型边界是破坏性的改变，因为这可能会打破用户对较宽松边界的预期。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub struct Foo&lt;A&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// 之后
pub struct Foo&lt;A: Eq&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// 示例：使用是破坏性的。
use updated_crate::Foo;

fn main() {
    let s = Foo { f1: 1.23 }; // Error: trait 边界 `{float}: Eq` 不满足
}</code></pre>
<p><a id="generic-bounds-loosen"></a></p>
<h3 id="minor-放宽泛型边界"><a class="header" href="#minor-放宽泛型边界">Minor: 放宽泛型边界</a></h3>
<p>放宽类型泛型界限是安全的，因为它仅扩展了允许的范围。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub struct Foo&lt;A: Clone&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// 之后
pub struct Foo&lt;A&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// 示例：库的使用是安全的。
use updated_crate::Foo;

fn main() {
    let s = Foo { f1: 123 };
}</code></pre>
<p><a id="generic-new-default"></a></p>
<h3 id="minor-添加默认的类型参数"><a class="header" href="#minor-添加默认的类型参数">Minor: 添加默认的类型参数</a></h3>
<p>只要类型有默认值，给它添加类型参数是安全的。所有现有的引用将使用默认值，而不需要指定参数。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// 之前
#[derive(Default)]
pub struct Foo {}

///////////////////////////////////////////////////////////
// 之后
#[derive(Default)]
pub struct Foo&lt;A = i32&gt; {
    f1: A,
}

///////////////////////////////////////////////////////////
// 示例：库的使用是安全的。
use updated_crate::Foo;

fn main() {
    let s: Foo = Default::default();
}</code></pre>
<p><a id="generic-generalize-identical"></a></p>
<h3 id="minor-泛化类型以使用泛型具有相同的类型"><a class="header" href="#minor-泛化类型以使用泛型具有相同的类型">Minor: 泛化类型以使用泛型(具有相同的类型)</a></h3>
<p>结构体或枚举字段可以从具体类型改变为泛型类型参数，前提是这种变化带来的所有现有用例的类型相同。
例如，下面的改变是允许的。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub struct Foo(pub u8);

///////////////////////////////////////////////////////////
// 之后
pub struct Foo&lt;T = u8&gt;(pub T);

///////////////////////////////////////////////////////////
// 示例：库的使用是安全的。
use updated_crate::Foo;

fn main() {
    let s: Foo = Foo(123);
}</code></pre>
<p>因为当前 <code>Foo</code> 是 <code>Foo&lt;u8&gt;</code> 的缩写，产生相同的字段类型。</p>
<p><a id="generic-generalize-different"></a></p>
<h3 id="major-泛化类型以使用泛型可能有不同的类型"><a class="header" href="#major-泛化类型以使用泛型可能有不同的类型">Major: 泛化类型以使用泛型(可能有不同的类型)</a></h3>
<p>如果类型可以改变，将结构体或枚举字段从具体类型改为泛型类型参数就是破坏性的。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub struct Foo&lt;T = u8&gt;(pub T, pub u8);

///////////////////////////////////////////////////////////
// 之后
pub struct Foo&lt;T = u8&gt;(pub T, pub T);

///////////////////////////////////////////////////////////
// 示例：使用是破坏性的
use updated_crate::Foo;

fn main() {
    let s: Foo&lt;f32&gt; = Foo(3.14, 123); // Error: 缺失类型。
}</code></pre>
<p><a id="generic-more-generic"></a></p>
<h3 id="minor-将泛型类型改为一个更泛型的类型"><a class="header" href="#minor-将泛型类型改为一个更泛型的类型">Minor: 将泛型类型改为一个更泛型的类型</a></h3>
<p>将一个泛型类型改为更泛型的类型是安全的。例如，下面添加了一个默认为原始类型的泛型参数，
这是安全的，因为所有现有的用户都会为两个字段使用相同的类型，默认的参数不需要被指定。</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub struct Foo&lt;T&gt;(pub T, pub T);

///////////////////////////////////////////////////////////
// 之后
pub struct Foo&lt;T, U = T&gt;(pub T, pub U);

///////////////////////////////////////////////////////////
// 示例：库的使用是安全的
use updated_crate::Foo;

fn main() {
    let s: Foo&lt;f32&gt; = Foo(1.0, 2.0);
}</code></pre>
<p><a id="fn-change-arity"></a></p>
<h3 id="major-添加删除函数参数"><a class="header" href="#major-添加删除函数参数">Major: 添加/删除函数参数</a></h3>
<p>改变函数参数是一种破坏性的改变。</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub fn foo() {}

///////////////////////////////////////////////////////////
// 之后
pub fn foo(x: i32) {}

///////////////////////////////////////////////////////////
// 示例：使用是破坏性的。
fn main() {
    updated_crate::foo(); // Error: 这个函数需要一个参数
}</code></pre>
<p>缓和策略:</p>
<ul>
<li>用新的签名引入一个新的函数，并可能<a href="reference/../../reference/attributes/diagnostics.html#the-deprecated-attribute">弃用</a>旧的函数。</li>
<li>引入接受结构体参数的函数，其中结构体是用构建模式构建的。这允许将来在结构体中添加新的字段。</li>
</ul>
<p><a id="fn-generic-new"></a></p>
<h3 id="possibly-breaking-引入新的函数类型参数"><a class="header" href="#possibly-breaking-引入新的函数类型参数">Possibly-breaking: 引入新的函数类型参数</a></h3>
<p>通常情况下，增加非默认类型参数是安全的，但在某些情况下，可能是破坏性的改变。</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// 之前
pub fn foo&lt;T&gt;() {}

///////////////////////////////////////////////////////////
// 之后
pub fn foo&lt;T, U&gt;() {}

///////////////////////////////////////////////////////////
// 示例：使用是破坏性的
use updated_crate::foo;

fn main() {
    foo::&lt;u8&gt;(); // Error: 这个函数需要2个泛型参数，但只提供了一个泛型参数
}</code></pre>
<p>然而，这样的显式调用是非常少见的(通常可以用其他方式编写)，所以这种破坏通常是可以接受的。
我们应该考虑有问题的函数被显式类型参数调用的可能性。</p>
<p><a id="fn-generalize-compatible"></a></p>
<h3 id="minor-泛化函数以使用泛型支持原始类型"><a class="header" href="#minor-泛化函数以使用泛型支持原始类型">Minor: 泛化函数以使用泛型(支持原始类型)</a></h3>
<p>函数的参数或其返回值的类型可以被<em>泛化</em>以使用泛型，包括引入一个新类型的参数，
只要它可以被实例化为原始类型。例如，允许以下变化:</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub fn foo(x: u8) -&gt; u8 {
    x
}
pub fn bar&lt;T: Iterator&lt;Item = u8&gt;&gt;(t: T) {}

///////////////////////////////////////////////////////////
// 之后
use std::ops::Add;
pub fn foo&lt;T: Add&gt;(x: T) -&gt; T {
    x
}
pub fn bar&lt;T: IntoIterator&lt;Item = u8&gt;&gt;(t: T) {}

///////////////////////////////////////////////////////////
// 示例：库的使用是安全的
use updated_crate::{bar, foo};

fn main() {
    foo(1);
    bar(vec![1, 2, 3].into_iter());
}</code></pre>
<p>因为所有现有的使用都是新签名的实例化。 </p>
<p>也许有些令人惊讶的是，泛化也适用于trait对象，因为每个trait都实现了自己:</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub trait Trait {}
pub fn foo(t: &amp;dyn Trait) {}

///////////////////////////////////////////////////////////
// 之后
pub trait Trait {}
pub fn foo&lt;T: Trait + ?Sized&gt;(t: &amp;T) {}

///////////////////////////////////////////////////////////
// 示例：库的使用是安全的。
use updated_crate::{foo, Trait};

struct Foo;
impl Trait for Foo {}

fn main() {
    let obj = Foo;
    foo(&amp;obj);
}</code></pre>
<p>(使用 <code>?Sized</code> 是必要的，否则你就无法恢复原始签名。)</p>
<p>以这种方式引入泛型，有可能造成类型推断的失败。这些通常是少见的，
对于一些项目来说，可能是可以接受的故障，因为这可以通过额外的类型注解来修复。</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// 之前
pub fn foo() -&gt; i32 {
    0
}

///////////////////////////////////////////////////////////
// 之后
pub fn foo&lt;T: Default&gt;() -&gt; T {
    Default::default()
}

///////////////////////////////////////////////////////////
// 示例：使用是破坏性的
use updated_crate::foo;

fn main() {
    let x = foo(); // Error: 需要类型注释
}</code></pre>
<p><a id="fn-generalize-mismatch"></a></p>
<h3 id="major-泛化函数以使用类型不匹配的泛型"><a class="header" href="#major-泛化函数以使用类型不匹配的泛型">Major: 泛化函数以使用类型不匹配的泛型</a></h3>
<p>如果泛型约束或改变了以前允许的类型，那么改变函数参数或返回类型就是一种破坏性的改变。
例如，下面增加了一个可能不被现有代码所满足的泛型约束:</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// 之前
pub fn foo(x: Vec&lt;u8&gt;) {}

///////////////////////////////////////////////////////////
// 之后
pub fn foo&lt;T: Copy + IntoIterator&lt;Item = u8&gt;&gt;(x: T) {}

///////////////////////////////////////////////////////////
// 示例：使用是破坏性的
use updated_crate::foo;

fn main() {
    foo(vec![1, 2, 3]); // Error: `Vec&lt;u8&gt;` 没有实现 `Copy` 
}</code></pre>
<p><a id="attr-no-std-to-std"></a></p>
<h3 id="major-从-no_std-转为要求-std"><a class="header" href="#major-从-no_std-转为要求-std">Major: 从 <code>no_std</code> 转为要求 <code>std</code></a></h3>
<p>如果你的库特别支持 <a href="reference/../../reference/names/preludes.html#the-no_std-attribute"><code>no_std</code></a> 环境，做一个需要 <code>std</code> 的新版本是破坏性的改变。</p>
<pre><code class="language-rust ignore skip">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// 之前
#![no_std]
pub fn foo() {}

///////////////////////////////////////////////////////////
// 之后
pub fn foo() {
    std::time::SystemTime::now();
}

///////////////////////////////////////////////////////////
// 示例:使用是破坏性的
// 这将导致no_std目标的链接失败，因为它们没有 `std` crate。
#![no_std]
use updated_crate::foo;

fn example() {
    foo();
}</code></pre>
<p>缓和策略:</p>
<ul>
<li>为了避免这种情况，一种常见的方式是包含 <code>std</code> <a href="reference/features.html">Cargo feature</a> ，可以选择启用 <code>std</code> 支持，当该特性关闭时，库可以在<code>no_std</code> 环境下使用。</li>
</ul>
<h2 id="工具和环境的兼容性"><a class="header" href="#工具和环境的兼容性">工具和环境的兼容性</a></h2>
<p><a id="env-new-rust"></a></p>
<h3 id="possibly-breaking-改变所需的最小rust版本"><a class="header" href="#possibly-breaking-改变所需的最小rust版本">Possibly-breaking: 改变所需的最小Rust版本</a></h3>
<p>在新版本的Rust中引入使用新的特性，会破坏使用旧版本Rust的项目。
这也包括在新版本的Cargo中使用新特性，以及要求在之前在稳定版本上工作的crate中使用只在每日构建使用的特性。</p>
<p>一些项目出于各种原因选择在次要版本中允许这样做。通常情况下，更新到一个较新的Rust版本是比较容易的。Rust也有一个6周的快速发布周期，一些项目会在一个发布窗口期内提供兼容性(比如当前的稳定版加上之前的N个版本)。只要记住，一些大型项目可能无法迅速更新其Rust工具链。</p>
<p>缓和策略:</p>
<ul>
<li>使用<a href="reference/features.html">Cargo features</a>使新特性可选加入。</li>
<li>为旧版本提供更大的支持窗口期。</li>
<li>如果可能的话，复制新的标准库项目的源代码，这样你就可以继续使用旧的版本，但利用新的特性。</li>
<li>为较早的次要版本提供一个单独的分支，可以接收重要bug修复的向后移植。</li>
<li>请注意<a href="https://github.com/rust-lang/rust/issues/64796"><code>[cfg(version(..))]</code></a>和<a href="https://github.com/rust-lang/rust/issues/64797"><code>#[cfg(accessible(..))]</code></a>特性，它们为新特性提供了选择机制。这些特性目前是不稳定的，只在每日构建中可用。</li>
</ul>
<p><a id="env-change-requirements"></a></p>
<h3 id="possibly-breaking-改变平台和环境要求"><a class="header" href="#possibly-breaking-改变平台和环境要求">Possibly-breaking: 改变平台和环境要求</a></h3>
<p>一个库对它所运行的环境有非常宽泛的假设，例如主机平台、操作系统版本、可用的服务、文件系统支持等等。如果你发布的新版本限制了以前支持的内容，例如需要新版本的操作系统，这可能是破坏性的变化。这些变化可能很难跟踪，因为你可能并不总是知道在一个没有自动测试的环境中，变化是否会形成破坏。</p>
<p>一些项目可能认为这是可以接受的破坏，特别是如果这种破坏对大多数用户来说是不可能的，或者项目没有资源来支持所有环境。
另一种值得注意的情况是，当供应商停止对某些硬件或操作系统的支持时，项目可能认为停止支持也是合理的。</p>
<p>缓和策略:</p>
<ul>
<li>记录你具体支持的平台和环境。</li>
<li>在CI中，在宽泛的环境中测试你的代码。</li>
</ul>
<h3 id="cargo"><a class="header" href="#cargo">Cargo</a></h3>
<p><a id="cargo-feature-add"></a></p>
<h4 id="minor-增加新的cargo特性"><a class="header" href="#minor-增加新的cargo特性">Minor: 增加新的Cargo特性</a></h4>
<p>增加新的<a href="reference/features.html">Cargo features</a>通常是安全的。如果该特性引入了新的变化，带来破坏性，这可能会给那些有更严格的向后兼容性需求的项目带来困难。在这种情况下，应避免将该特性添加到 &quot;默认&quot; 列表中，并记录可能启用该特性的后果。</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# 之前
[features]
# ..empty

###########################################################
# 之后
[features]
std = []
</code></pre>
<p><a id="cargo-feature-remove"></a></p>
<h4 id="major-移除-cargo-特性"><a class="header" href="#major-移除-cargo-特性">Major: 移除 Cargo 特性</a></h4>
<p>移除<a href="reference/features.html">Cargo features</a>通常是一种破坏性的改变。这将导致任何启用该特性的项目出现错误。</p>
<pre><code class="language-toml"># MAJOR CHANGE

###########################################################
# 之前
[features]
logging = []

###########################################################
# 之后
[dependencies]
# ..logging removed
</code></pre>
<p>缓和策略:</p>
<ul>
<li>清楚地记录你的特性。如果有一个内部或实验性的特性，就把它标记为这样的特性，以便用户知道这个特性的状态。</li>
<li>在 <code>Cargo.toml</code> 中保留旧的特性，但删除其功能。记录该特性已被废弃，并在未来的语义化主要版本中删除。</li>
</ul>
<p><a id="cargo-feature-remove-another"></a></p>
<h4 id="major-如果改变了功能或公共条目从特性列表中删除一个特性"><a class="header" href="#major-如果改变了功能或公共条目从特性列表中删除一个特性">Major: 如果改变了功能或公共条目，从特性列表中删除一个特性</a></h4>
<p>如果从另一个特性中删除特性，这可能会破坏现有的用户，如果他们期望通过该特性来获得该功能。</p>
<pre><code class="language-toml"># Breaking change example

###########################################################
# 之前
[features]
default = [&quot;std&quot;]
std = []

###########################################################
# 之后
[features]
default = []  # 如果包期望启用std，这可能会导致它们失败。
std = []
</code></pre>
<p><a id="cargo-remove-opt-dep"></a></p>
<h4 id="possibly-breaking-删除可选依赖"><a class="header" href="#possibly-breaking-删除可选依赖">Possibly-breaking: 删除可选依赖</a></h4>
<p>删除可选依赖可能会破坏使用你的库的项目，因为另一个项目可能通过<a href="reference/features.html">Cargo features</a>启用该依赖。</p>
<pre><code class="language-toml"># Breaking change example

###########################################################
# 之前
[dependencies]
curl = { version = &quot;0.4.31&quot;, optional = true }

###########################################################
# 之后
[dependencies]
# ..curl removed
</code></pre>
<p>缓和策略:</p>
<ul>
<li>清楚地记录你的特性。如果可选依赖不包括在记录的特性列表中，那么你可以决定认为改变无记录的条目是安全的。</li>
<li>留下可选择依赖，只是在你的库中不使用它。</li>
<li>用一个什么都不做的<a href="reference/features.html">Cargo feature</a>来替换这个可选依赖，并记录下它的废弃情况。</li>
<li>使用能够实现可选的依赖的高级特性，并将这些特性记录为实现扩展功能的首选方式。例如，如果你的库对 &quot;联网&quot; 这样的内容有可选的支持，创建一个名为 &quot;联网&quot; 的泛型特性，它能够实现 &quot;联网&quot; 所需的可选依赖。然后记录 &quot;联网&quot; 特性。</li>
</ul>
<p><a id="cargo-change-dep-feature"></a></p>
<h4 id="minor-改变依赖特性"><a class="header" href="#minor-改变依赖特性">Minor: 改变依赖特性</a></h4>
<p>通常情况下，改变依赖上的特性是安全的，只要该特性不引入破坏性的变化。</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# 之前
[dependencies]
rand = { version = &quot;0.7.3&quot;, features = [&quot;small_rng&quot;] }


###########################################################
# 之后
[dependencies]
rand = &quot;0.7.3&quot;
</code></pre>
<p><a id="cargo-dep-add"></a></p>
<h4 id="minor-添加依赖"><a class="header" href="#minor-添加依赖">Minor: 添加依赖</a></h4>
<p>增加新的依赖通常是安全的，只要新的依赖没有引入新的需求而导致破坏性的变化。
例如，在一个以前在稳定版本上工作的项目中添加一个需要每日构建的新依赖，是一个重大的变化。</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# 之前
[dependencies]
# ..empty

###########################################################
# 之后
[dependencies]
log = &quot;0.4.11&quot;
</code></pre>
<h2 id="应用程序兼容性"><a class="header" href="#应用程序兼容性">应用程序兼容性</a></h2>
<p>Cargo项目也可能包括可执行的二进制文件，它们有自己的接口(如CLI接口、OS级交互等)。
由于这些是Cargo包的一部分，它们经常使用和共享与包相同的版本。
你需要决定是否以及如何在你对应用程序的修改中采用语义化版本约定与你的用户进行沟通。
对应用程序的潜在破坏性和兼容性的改变不胜枚举，
所以我们鼓励你使用<a href="https://semver.org/">SemVer</a>规范的精神来指导你决定如何将版本控制应用于你的应用程序，或者至少记录你的承诺。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="未来的不兼容报告"><a class="header" href="#未来的不兼容报告">未来的不兼容报告</a></h3>
<p>Cargo检查所有依赖中的未来不兼容的警告。
这些警告是关于未来可能成为硬性错误的修改，导致依赖在未来的rustc版本中停止构建。
如果发现任何警告，就会显示一个小通知，说明发现了这些警告，并提供如何显示完整报告的说明。</p>
<p>例如，你可能会在构建结束时看到这样的内容:</p>
<pre><code class="language-text">warning: the following packages contain code that will be rejected by a future
         version of Rust: rental v0.5.5
note: to see what the problems were, use the option `--future-incompat-report`,
      or run `cargo report future-incompatibilities --id 1`
</code></pre>
<p>完整的报告可以通过 &quot;cargo report future-incompatibilities --id ID&quot; 命令来显示，或者通过使用 &quot;--future-incompat-report&quot; 标志再次运行构建。
然后，开发者应该将他们的依赖更新到问题得到修复的版本，或者与依赖的开发者合作，帮助解决这个问题。</p>
<h2 id="配置-2"><a class="header" href="#配置-2">配置</a></h2>
<p>这个特性可以通过 <code>.cargo/config.toml</code> 中的<a href="reference/config.html#future-incompat-report"><code>[future-incompat-report]</code></a>部分来进行配置。目前，支持的选项有:</p>
<pre><code class="language-toml">[future-incompat-report]
frequency = &quot;always&quot;
</code></pre>
<p>支持的频次值是 <code>&quot;always&quot;</code> 和 <code>&quot;never&quot;</code> ，它们控制在 <code>cargo build</code> / <code>cargo check</code> 结束时是否打印出信息。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="报告构建时间"><a class="header" href="#报告构建时间">报告构建时间</a></h1>
<p><code>--timings</code> 选项提供了一些关于每次编译所需时间的信息，并跟踪时间段的并发信息。</p>
<pre><code class="language-sh">cargo build --timings
</code></pre>
<p>这将在 <code>target/cargo-timings/cargo-timing.html</code> 中写入一个HTML报告。如果你想查看更早的运行情况，也会将报告的副本写到同一目录下，文件名有时间戳。</p>
<h4 id="阅读图表"><a class="header" href="#阅读图表">阅读图表</a></h4>
<p>在输出中，有两个图表。&quot;unit&quot; 图显示每个单元随时间变化的持续时间。一个 &quot;unit&quot; 是单一的编译器调用。
有几行显示了当一个单元结束时，哪些额外的单元被 &quot;unlocked&quot; 。也就是说，它显示了现在允许运行的新单元，因为它们的依赖已经全部完成。
将鼠标悬停在一个单元上，可以突出这些线条。这可以帮助直观地看到依赖的关键路径。由于单元可能以不同的顺序完成，这在运行中可能会发生变化。</p>
<p>&quot;codegen&quot; 的时间以淡紫色突出显示。在某些情况下，构建管道允许单元在其依赖执行代码生成时开始。
这一信息并不总是显示(例如，二进制单元不显示代码生成开始时间)。</p>
<p>&quot;custom build&quot; 单元是 &quot;build.rs&quot; 脚本，运行时以橙色显示。</p>
<p>第二张图显示了Cargo在一段时间内的并发量。背景表示CPU使用率。这三条线是:</p>
<ul>
<li>&quot;等待&quot; (红色) — 这是等待CPU槽开放的单元的数量。</li>
<li>&quot;不活跃&quot; (蓝色) — 这是正在等待其依赖完成的单元的数量。</li>
<li>&quot;活跃&quot; (绿色) — 这是目前正在运行的单元的数量。</li>
</ul>
<p>注意：这并不显示编译器本身的并发量。 <code>rustc</code> 通过 &quot;作业服务器&quot; 与Cargo协调，以保持在并发量限制之内。目前这主要适用于代码生成阶段。</p>
<p>编译时间的提示:</p>
<ul>
<li>寻找缓慢的依赖。
<ul>
<li>检查它们是否有你可能希望考虑禁用的特性。</li>
<li>考虑尝试完全删除依赖。</li>
</ul>
</li>
<li>寻找crate在不同版本中被多次构建。尝试从依赖图中删除旧版本。</li>
<li>将大crate拆成小块。</li>
<li>如果有大量的crate在一个crate上出现瓶颈，那么就把注意力集中在改善这一crate上，以提高并行性。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="不稳定的特性"><a class="header" href="#不稳定的特性">不稳定的特性</a></h2>
<p>实验性的Cargo 特性只在<a href="reference/../../book/appendix-07-nightly-rust.html">nightly channel</a>&quot;每日构建&quot;中提供。我们鼓励你尝试使用这些特性，看看它们是否符合你的需求，以及是否有问题或难题。请查看下面列出的链接的问题跟踪，了解更多关于该特性的信息，如果你想获得未来的更新，请点击GitHub订阅按钮。</p>
<p>经过一段时间后，如果该特性没有任何重大问题，它可以被<a href="https://doc.crates.io/contrib/process/unstable.html#stabilization">stabilized</a>，这将使它在当前每日构建发布的版本到达稳定通道后，就可以在稳定版上使用(6到12周不等)。</p>
<p>根据特性的工作方式，有三种不同的方式可以启用不稳定的特性。</p>
<ul>
<li>
<p>按照 <code>Cargo.toml</code> 新语法，在顶部任意表之前设置 <code>cargo-features</code> 键。例如:</p>
<pre><code class="language-toml"># 这里指定启用哪些新的 Cargo.toml 特性。
cargo-features = [&quot;test-dummy-unstable&quot;]

[package]
name = &quot;my-package&quot;
version = &quot;0.1.0&quot;
im-a-teapot = true  # 这是由 test-dummy-unstable 启用的新选项。
</code></pre>
</li>
<li>
<p>新的命令行标志、选项和子命令需要同时包含 <code>-Z unstable-options</code> CLI选项。
例如，新的 <code>--out-dir</code> 选项只在每日构建中可用。</p>
<p><code>cargo +nightly build --out-dir=out -Z unstable-options</code></p>
</li>
<li>
<p><code>-Z</code>命令行标志用于启用可能没有接口的新功能，或者接口还没有设计好，或者用于影响Cargo多个部分的更复杂功能。例如，<a href="reference/unstable.html#mime-on-use">mime-on-use</a>功能可以用以下方式启用:</p>
<p><code>cargo +nightly build -Z mtime-on-use</code></p>
<p>运行 <code>cargo -Z help</code> 可以查看可用的标志列表。</p>
<p>可以用 <code>-Z</code> 标志配置的内容也可以在cargo <a href="reference/config.html">config file</a> (<code>.cargo/config.toml</code>)的 <code>unstable</code> 表中设置。比如说:</p>
<pre><code class="language-toml">[unstable]
mtime-on-use = true
build-std = [&quot;core&quot;, &quot;alloc&quot;]
</code></pre>
</li>
</ul>
<p>下面描述的每个新特性都将解释如何使用它。</p>
<h3 id="不稳定特性列表"><a class="header" href="#不稳定特性列表">不稳定特性列表</a></h3>
<ul>
<li>不稳定特定特性
<ul>
<li><a href="reference/unstable.html#allow-features">-Z allow-features</a> — 提供了一种限制使用哪些不稳定特性的方法。</li>
</ul>
</li>
<li>构建脚本和链接
<ul>
<li><a href="reference/unstable.html#metabuild">Metabuild</a> — 提供声明式的构建脚本。</li>
</ul>
</li>
<li>解析器和特性
<ul>
<li><a href="reference/unstable.html#no-index-update">no-index-update</a> — 防止cargo更新索引缓存。</li>
<li><a href="reference/unstable.html#avoid-dev-deps">avoid-dev-deps</a> — 防止解析器在解析过程中包含 dev-依赖。</li>
<li><a href="reference/unstable.html#minimal-versions">minimal-versions</a> — 强制解析器使用最低的兼容版本，而不是最高的版本。</li>
<li><a href="reference/unstable.html#public-dependency">public-dependency</a> — 允许将依赖分类为公共或私有。</li>
</ul>
</li>
<li>输出行为
<ul>
<li><a href="reference/unstable.html#out-dir">out-dir</a> — 添加一个目录，将制品复制到该目录。</li>
<li><a href="reference/unstable.html#different-binary-name">Different binary name</a> — 为构建的二进制文件指定一个与crate名称分开的名称。</li>
</ul>
</li>
<li>编译行为
<ul>
<li><a href="reference/unstable.html#mtime-on-use">mtime-on-use</a> — 在每次使用依赖时，更新其最后修改的时间戳，以提供一种机制来删除未使用的制品。</li>
<li><a href="reference/unstable.html#doctest-xcompile">doctest-xcompile</a> — 支持运行带有 <code>--target</code> 标志的文档测试。</li>
<li><a href="reference/unstable.html#build-std">build-std</a> — 构建标准库而不是使用预先构建的二进制文件。</li>
<li><a href="reference/unstable.html#build-std-features">build-std-features</a> — 设置与标准库一起使用的特性。</li>
<li><a href="reference/unstable.html#binary-dep-depinfo">binary-dep-depinfo</a> — 致使dep-info文件跟踪二进制文件的依赖。</li>
<li><a href="reference/unstable.html#panic-abort-tests">panic-abort-tests</a> — 允许用 &quot;中止&quot; 恐慌策略运行测试。</li>
<li><a href="reference/unstable.html#crate-type">crate-type</a> — 支持向编译器传递crate类型。</li>
<li><a href="reference/unstable.html#keep-going">keep-going</a> — 尽可能多地构建，而不是在第一个错误时就中止。</li>
</ul>
</li>
<li>rustdoc
<ul>
<li><a href="reference/unstable.html#doctest-in-workspace"><code>doctest-in-workspace</code></a> — 修复文档测试时与工作空间相对路径。</li>
<li><a href="reference/unstable.html#rustdoc-map">rustdoc-map</a> —提供文档的映射，以链接到外部网站，如 <a href="https://docs.rs/">docs.rs</a> 。</li>
</ul>
</li>
<li><code>Cargo.toml</code> 扩展
<ul>
<li><a href="reference/unstable.html#profile-rustflags-option">Profile <code>rustflags</code> option</a> — 直接传递给rustc。</li>
<li><a href="reference/unstable.html#per-package-target">per-package-target</a> — 设置每个独立包的 <code>--target</code> 。</li>
<li><a href="reference/unstable.html#artifact-dependencies">artifact dependencies</a> - 允许将构建制品包含到其他构建制品中，并为不同的目标构建。</li>
</ul>
</li>
<li>信息和元数据
<ul>
<li><a href="reference/unstable.html#build-plan">Build-plan</a> — 发送关于哪些命令将被运行的JSON信息。</li>
<li><a href="reference/unstable.html#unit-graph">unit-graph</a> — 为Cargo的内部图结构发送JSON。</li>
<li><a href="reference/unstable.html#rustc---print"><code>cargo rustc --print</code></a> — 用 <code>--print</code> 调用rustc，以显示来自 rustc 的信息。</li>
</ul>
</li>
<li>配置
<ul>
<li><a href="reference/unstable.html#config-include">config-include</a> — 增加配置文件包含其他文件的能力。</li>
<li><a href="reference/unstable.html#cargo-config"><code>cargo config</code></a> — 增加新的子命令用于查看配置文件。</li>
</ul>
</li>
<li>注册中心
<ul>
<li><a href="reference/unstable.html#credential-process">credential-process</a> — 增加对从外部认证程序获取注册中心令牌的支持。</li>
<li><a href="reference/unstable.html#cargo-logout"><code>cargo logout</code></a> — 添加 <code>logout</code> 命令，以删除当前保存的注册中心令牌。</li>
<li><a href="reference/unstable.html#sparse-registry">sparse-registry</a> — 增加从静态文件HTTP注册中心获取的支持(<code>sparse+</code>)。</li>
<li><a href="reference/unstable.html#publish-timeout">publish-timeout</a> — 控制上传crate和在索引中可用之间的超时。</li>
<li><a href="reference/unstable.html#registry-auth">registry-auth</a> — 增加对认证注册的支持，并使用非对称加密生成注册中心认证令牌。</li>
</ul>
</li>
</ul>
<h3 id="接受特性"><a class="header" href="#接受特性">接受特性</a></h3>
<p>这个永久不稳定的标志使得可以使用只有列出的一组不稳定的特性。具体来说，如果你传递了 <code>-Zallow-features=foo,bar</code> ，你将继续能够向 <code>cargo</code> 传递 <code>-Zfoo</code> 和 <code>-Zbar</code> ，但将无法传递 <code>-Zbaz</code> 。你可以传递一个空字符串(<code>-Zallow-features=</code>)来禁止所有不稳定的特性。</p>
<p><code>-Zallow-features</code>也限制了哪些不稳定的特性可以被传递给 <code>Cargo.toml</code> 中的 <code>cargo-features</code> 条目。例如，如果你想接受</p>
<pre><code class="language-toml">cargo-features = [&quot;test-dummy-unstable&quot;]
</code></pre>
<p>如果 <code>test-dummy-unstable</code> 是不稳定的，那么 <code>-Zallow-features=</code> 也不接受该特性，而 <code>-Zallow-features=test-dummy-unstable</code> 则接受。</p>
<p>传递给cargo的 <code>-Zallow-features</code> 的特性列表也会传递给cargo最终调用的任何Rust工具(如 <code>rustc</code> 或 <code>rustdoc</code> )。因此，如果你运行 <code>cargo -Zallow-features=</code> ，就不能使用不稳定的Cargo_或Rust特性。</p>
<h3 id="no-index-update"><a class="header" href="#no-index-update">no-index-update</a></h3>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/3479">#3479</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/7404">#7404</a></li>
</ul>
<p><code>-Z no-index-update</code> 标志确保Cargo不会尝试更新注册中心索引。这是为Crater等工具准备的，这些工具会发布很多Cargo命令，你想避免每次更新索引的网络潜在行为。</p>
<h3 id="mtime-on-use"><a class="header" href="#mtime-on-use">mtime-on-use</a></h3>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/pull/6477">#6477</a></li>
<li>Cache usage meta tracking issue: <a href="https://github.com/rust-lang/cargo/issues/7150">#7150</a></li>
</ul>
<p><code>-Z mtime-on-use</code> 标志是一个实验性的，让Cargo更新使用过的文件的时间戳，以便像cargo-sweep这样的工具更容易发现哪些文件是过时的。对于许多工作流程来说，这需要在 <em>所有</em> cargo的调用中进行设置。为了更实用，在 <code>.cargo/config.toml</code> 中设置 <code>unstable.mtime_on_use</code> 标志或相应的环境变量，将对所有每日构建cargo的调用应用 <code>-Z mtime-on-use</code> 。(config标志在稳定版本中被忽略) </p>
<h3 id="avoid-dev-deps"><a class="header" href="#avoid-dev-deps">avoid-dev-deps</a></h3>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/4988">#4988</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/5133">#5133</a></li>
</ul>
<p>当运行 <code>cargo install</code> 或 <code>cargo build</code> 等命令时，Cargo目前需要下载 dev-依赖，即使它们不被使用。
<code>-Z avoid-dev-deps</code>标志允许Cargo在不需要dev-依赖时避免下载它们。如果跳过了dev-依赖，将不会生成 <code>Cargo.lock</code> 文件。</p>
<h3 id="minimal-versions"><a class="header" href="#minimal-versions">minimal-versions</a></h3>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/4100">#4100</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/5657">#5657</a></li>
</ul>
<blockquote>
<p>注意: 不建议使用这个功能。因为它为所有的横向依赖强制执行最小版本，它的作用是有限的，因为不是所有的外部依赖都声明适当的版本下限。
我们打算在未来对其进行修改，只对直接依赖执行最小版本。</p>
</blockquote>
<p>当生成 <code>Cargo.lock</code> 文件时， <code>-Z minimal-versions</code> 标志将把依赖解析为能满足要求的最小语义化版本(而不是最高版本)。</p>
<p>这个标志的用途是在持续集成过程中检查 Cargo.toml 中指定的版本是否正确反映了你实际使用的最小版本。
也就是说，如果 Cargo.toml 说明 <code>foo = &quot;1.0.0&quot;</code>，就不会意外地依赖 <code>foo 1.5.0</code> 中增加的特性。</p>
<h3 id="out-dir"><a class="header" href="#out-dir">out-dir</a></h3>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/4875">#4875</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/6790">#6790</a></li>
</ul>
<p>这个特性允许你指定制品在构建后将被复制到的目录。通常，制品只被写入 <code>target/release</code> 或 <code>target/debug</code> 目录。然而，确定确切的文件名可能很棘手，因为你需要解析JSON输出。<code>--out-dir</code> 标志使其更容易预计访问制品。注意，制品是复制的，所以原件仍然在 <code>target</code> 目录中。例子:</p>
<pre><code class="language-sh">cargo +nightly build --out-dir=out -Z unstable-options
</code></pre>
<p>这也可以在 <code>.cargo/config.toml</code> 文件中指定。</p>
<pre><code class="language-toml">[build]
out-dir = &quot;out&quot;
</code></pre>
<h3 id="doctest-xcompile"><a class="header" href="#doctest-xcompile">doctest-xcompile</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/7040">#7040</a></li>
<li>Tracking Rustc Issue: <a href="https://github.com/rust-lang/rust/issues/64245">#64245</a></li>
</ul>
<p>这个标志改变了 <code>cargo test</code> 在传递目标时处理文档测试的行为。目前，如果传递的目标与主机不同，cargo将直接跳过文档测试。如果有这个标志，cargo将继续正常工作，将测试传给文档测试，同时也将 <code>--target</code> 选项传给它，以及启用 <code>-Zunstable-features --enable-per-target-ignores</code>，并将 <code>.cargo/config.toml</code> 的信息传给它。更多信息请参见 rustc issue。</p>
<pre><code class="language-sh">cargo test --target foo -Zdoctest-xcompile
</code></pre>
<h4 id="新的-dir-name-属性"><a class="header" href="#新的-dir-name-属性">新的 <code>dir-name</code> 属性</a></h4>
<p>在 <code>target/</code> 下生成的一些路径是约定俗成的 &quot;构建协议&quot; ， 被 <code>cargo</code> 作为更大的项目构建的一部分来调用。
因此，为了保留现有的行为，还有一个新的属性 <code>dir-name</code> ，当没有指定时，默认为配置文件的名称。比如说:</p>
<pre><code class="language-toml">[profile.release-lto]
inherits = &quot;release&quot;
dir-name = &quot;lto&quot;  # 发送到target/lto，而不是target/release-lto
lto = true
</code></pre>
<h3 id="build-plan"><a class="header" href="#build-plan">Build-plan</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/5579">#5579</a></li>
</ul>
<p><code>build</code> 命令的 <code>--build-plan</code> 参数将输出JSON信息，说明哪些命令将被运行，而不需要实际执行。这在与其他构建工具集成时很有用。
例子:</p>
<pre><code class="language-sh">cargo +nightly build --build-plan -Z unstable-options
</code></pre>
<h3 id="metabuild"><a class="header" href="#metabuild">Metabuild</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/49803">rust-lang/rust#49803</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/blob/master/text/2196-metabuild.md">#2196</a></li>
</ul>
<p>Metabuild是声明式构建脚本的特性。你不用写 <code>build.rs</code> 脚本，而是在 <code>Cargo.toml</code> 中的 <code>metabuild</code> 键中指定一个构建依赖项列表。
构建脚本会自动生成，按顺序运行每个构建依赖项。Metabuild包可以从 <code>Cargo.toml</code> 中读取元数据以指定其行为。</p>
<p>在 <code>Cargo.toml</code> 的顶部包含 <code>cargo-features</code> ，在 <code>package</code> 中包含 <code>metabuild</code> 键，
在 <code>build-dependencies</code> 中列出依赖项，并在 <code>package.metadata</code> 中添加metabuild包需要的元数据。
例子:</p>
<pre><code class="language-toml">cargo-features = [&quot;metabuild&quot;]

[package]
name = &quot;mypackage&quot;
version = &quot;0.0.1&quot;
metabuild = [&quot;foo&quot;, &quot;bar&quot;]

[build-dependencies]
foo = &quot;1.0&quot;
bar = &quot;1.0&quot;

[package.metadata.foo]
extra-info = &quot;qwerty&quot;
</code></pre>
<p>Metabuild包应该有一个名为 <code>metabuild</code> 的公共函数，执行与普通 <code>build.rs</code> 脚本相同的动作。</p>
<h3 id="public-dependency"><a class="header" href="#public-dependency">public-dependency</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/44663">#44663</a></li>
</ul>
<p>'public-dependency' 特性允许将依赖标记为 'public' 或 'private' 。当这个特性被启用时，附加的信息会传递给 rustc，以使 'exported_private_dependencies' 链接项能够正常工作。</p>
<p>这需要在 <code>cargo-features</code> 中设置适当的键。</p>
<pre><code class="language-toml">cargo-features = [&quot;public-dependency&quot;]

[dependencies]
my_dep = { version = &quot;1.2.3&quot;, public = true }
private_dep = &quot;2.0.0&quot; # 默认情况下，将是 'private' 。
</code></pre>
<h3 id="build-std"><a class="header" href="#build-std">build-std</a></h3>
<ul>
<li>Tracking Repository: <a href="https://github.com/rust-lang/wg-cargo-std-aware">https://github.com/rust-lang/wg-cargo-std-aware</a></li>
</ul>
<p><code>build-std</code> 特性使Cargo能够自己编译标准库，作为crate图编译的一部分。这个功能曾称为 &quot;std-aware Cargo&quot;。
这个功能仍处于开发的早期阶段，也是Cargo可能增加的重要特性。这是大的特性文档，即使现在以最小形式存在，
如果想保持最新，请关注<a href="https://github.com/rust-lang/wg-cargo-std-aware">跟踪仓库</a>和issues。</p>
<p>目前实现的功能是在名为 <code>-Z build-std</code> 的标志后。这个标志表明，Cargo应该使用与主构建本身相同的配置文件从源代码中编译标准库。
请注意，要实现这个功能，你需要有标准库的源代码，目前唯一支持的方法是添加 <code>rust-src</code> rust rustup组件。</p>
<pre><code class="language-console">$ rustup component add rust-src --toolchain nightly
</code></pre>
<p>现在还要求 <code>-Z build-std</code> 标志与 <code>--target</code> 标志组合。请注意，并不是强制进行交叉编译，只是要求以某种形式传递 <code>--target</code> 。</p>
<p>使用方法如下:</p>
<pre><code class="language-console">$ cargo new foo
$ cd foo
$ cargo +nightly run -Z build-std --target x86_64-unknown-linux-gnu
   Compiling core v0.0.0 (...)
   ...
   Compiling foo v0.1.0 (...)
    Finished dev [unoptimized + debuginfo] target(s) in 21.00s
     Running `target/x86_64-unknown-linux-gnu/debug/foo`
Hello, world!
</code></pre>
<p>这里，在调试模式下重新编译了标准库，并带有调试断言(就像 <code>src/main.rs</code> 被编译一样) ，最后所有内容都被连接在一起。</p>
<p>使用 <code>-Z build-std</code> 将隐式地编译稳定版本 crate <code>core</code> 、 <code>std</code> 、 <code>alloc</code> 和 <code>proc_macro</code> 。
如果你使用 <code>cargo test</code> ，它也将编译 <code>test</code> crate。如果你的工作环境不支持其中的一些crate，那么可以向 <code>-Zbuild-std</code> 传递参数。</p>
<pre><code class="language-console">$ cargo +nightly build -Z build-std=core,alloc
</code></pre>
<p>这里的值是以逗号分隔的要构建的标准库crate的列表。</p>
<h4 id="要求"><a class="header" href="#要求">要求</a></h4>
<p>总结起来，使用 <code>-Z build-std</code> 的需求清单是:</p>
<ul>
<li>你必须通过 <code>rustup component add rust-src</code> 安装libstd的源代码。</li>
<li>你必须传递 <code>--target</code> 。</li>
<li>你必须同时使用每日构建 Cargo 和 Rustc</li>
<li><code>-Z build-std</code> 标志必须传递给所有 <code>cargo</code> 调用。</li>
</ul>
<h4 id="报告错误并提供帮助"><a class="header" href="#报告错误并提供帮助">报告错误并提供帮助</a></h4>
<p><code>-Z build-std</code> 特性正处于开发的早期阶段! Cargo的这项功能有非常长的历史，范围也非常大，而这只是一个开始。如果你想报告bug，请把它们报告给:</p>
<ul>
<li>Cargo - <a href="https://github.com/rust-lang/cargo/issues/new">https://github.com/rust-lang/cargo/issues/new</a> - for implementation bugs</li>
<li>The tracking repository -
<a href="https://github.com/rust-lang/wg-cargo-std-aware/issues/new">https://github.com/rust-lang/wg-cargo-std-aware/issues/new</a> - for larger design
questions.</li>
</ul>
<p>此外，如果你想查看尚未实现的特性，或者如果某些内容没有完全按照你希望的方式工作，
请随时查看库的<a href="https://github.com/rust-lang/wg-cargo-std-aware/issues">问题跟踪</a>，如果那里没有，请提交新问题！</p>
<h3 id="build-std-features"><a class="header" href="#build-std-features">build-std-features</a></h3>
<ul>
<li>Tracking Repository: <a href="https://github.com/rust-lang/wg-cargo-std-aware">https://github.com/rust-lang/wg-cargo-std-aware</a></li>
</ul>
<p>这个标志是 <code>-Zbuild-std</code> 特性标志的成员。这将配置在构建标准库时为标准库本身启用的特性。
目前默认启用的特性是 <code>backtrace</code> 和 <code>panic_unwind</code> 。这个标志期望逗号分隔的列表，如果提供的话，将覆盖默认启用的特性列表。</p>
<h3 id="binary-dep-depinfo"><a class="header" href="#binary-dep-depinfo">binary-dep-depinfo</a></h3>
<ul>
<li>Tracking rustc issue: <a href="https://github.com/rust-lang/rust/issues/63012">#63012</a></li>
</ul>
<p><code>-Z binary-dep-depinfo</code> 标志使 Cargo 将同样的标志转发给 <code>rustc</code> ，这将使 <code>rustc</code> 在 &quot;dep info&quot; 文件(扩展名为 <code>.d</code> )中包含所有二进制依赖的路径。
Cargo会使用这些信息进行变化检测(如果有任何二进制的依赖发生变化，那么crate就会被重新构建)。
主要的用例是编译器本身，它对标准库有隐含的依赖，否则就不会追踪到变化检测。</p>
<h3 id="panic-abort-tests"><a class="header" href="#panic-abort-tests">panic-abort-tests</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/67650">#67650</a></li>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/7460">#7460</a></li>
</ul>
<p><code>-Z panic-abort-tests</code> 标志将启用每日构建支持，以 <code>-Cpanic=abort</code> 编译测试连接crate。如果没有这个标志，Cargo会用 <code>-Cpanic=unwind</code> 来编译测试，
以及所有依赖，因为这是 <code>test</code>-the-rate 知道如何操作的唯一方式。然而，从<a href="https://github.com/rust-lang/rust/pull/64158">rust-lang/rust#64158</a>开始，<code>test</code>-crate 支持 <code>-C panic=abort</code> ，并支持每个进程的测试，可以帮助避免多次编译crate图。</p>
<p>目前还不清楚如何在Cargo中稳定这一特性，但我们希望能以某种方式稳定下来。</p>
<h3 id="keep-going"><a class="header" href="#keep-going">keep-going</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/10496">#10496</a></li>
</ul>
<p><code>cargo build --keep-going</code> (以及类似的 <code>check</code> 、 <code>test</code> 等)将尽可能多地构建依赖图中的crate，而不是在第一个失败的crate中止构建。</p>
<p>例如，如果当前包依赖于 <code>fails</code> 和 <code>works</code> 两个依赖项，其中一个构建失败，<code>cargo check -j1</code> 可能也可能不会构建成功(取决于Cargo选择先运行哪一个构建)，而 <code>cargo check -j1 --keep-going</code> 肯定会同时运行两个构建，即使先运行的那个构建失败。</p>
<p>必须使用 <code>-Z unstable-options</code> 命令行选项，以便在尚未稳定时使用 <code>--keep-going</code> 。</p>
<pre><code class="language-console">cargo check --keep-going -Z unstable-options
</code></pre>
<h3 id="config-include"><a class="header" href="#config-include">config-include</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/7723">#7723</a></li>
</ul>
<p>配置文件中的 <code>include</code> 键可以用来加载另一个配置文件。它需要相对于配置文件的另一个文件路径的字符串，或者字符串列表。需要 <code>-Zconfig-include</code> 命令行选项。</p>
<pre><code class="language-toml"># .cargo/config
include = '../../some-common-config.toml'
</code></pre>
<p>配置文件的值首先从包含路径中加载，然后在其上合并配置文件本身的值。</p>
<p>这可以与<a href="reference/unstable.html#config-cli">config-cli</a>搭配使用，以指定从命令行加载的文件。传递一个配置文件的路径作为 <code>--config</code> 的参数:</p>
<pre><code class="language-console">cargo +nightly -Zunstable-options -Zconfig-include --config somefile.toml build
</code></pre>
<p>CLI路径是相对于当前工作目录的。</p>
<h3 id="target-applies-to-host"><a class="header" href="#target-applies-to-host">target-applies-to-host</a></h3>
<ul>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/9322">#9322</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9453">#9453</a></li>
</ul>
<p>曾经，Cargo对环境变量中的 <code>linker</code> 和 <code>rustflags</code> 配置选项以及 <code>[target]</code> 是否遵从构建脚本、插件和其他始终为主机平台构建的制品的行为有些不一致。当 <code>--target</code> 没有通过时，Cargo会遵从构建脚本的 <code>linker</code> 和 <code>rustflags</code> ，与所有其他编译制品相同。然而，当 <code>--target</code> 通过时，Cargo遵从 <code>[target.&lt;host triple&gt;]</code> 的 <code>linker</code> ，而不接受任何 <code>rustflags</code> 配置。这种双重行为让人困惑，也让人难以正确地配置构建，在这种情况下，主机三元组和目标三元组恰好是相同的，但打算在构建主机上运行的制品仍应以不同方式配置。</p>
<p><code>-Ztarget-applies-to-host</code> 在Cargo配置文件中启用顶层的 <code>target-applies-to-host</code> 设置，允许用户为这些属性选择不同(和更一致)的行为。当 <code>target-applies-to-host</code>  在配置文件中未设置或设置为 <code>true</code> 时，现有的Cargo行为将被保留(不过请查看 <code>-Zhost-config</code> ，它改变了这个默认值)。当它被设置为 <code>false</code> 时，无论 <code>--target</code> 是否被传递给Cargo， <code>[target.&lt;host triple&gt;]</code> 、 <code>RUSTFLAGS</code> 或 <code>[build]</code> 的选项都不会被主机制品所尊从。要定制打算在主机上运行的制品，请使用 <code>[host]</code> (<a href="reference/unstable.html#host-config"><code>host-config</code></a>)。</p>
<p>将来， <code>target- appliesto -host</code> 可能最终会默认为 <code>false</code> ，以提供更健全和一致的默认行为。</p>
<pre><code class="language-toml"># config.toml
target-applies-to-host = false
</code></pre>
<pre><code class="language-console">cargo +nightly -Ztarget-applies-to-host build --target x86_64-unknown-linux-gnu
</code></pre>
<h3 id="host-config"><a class="header" href="#host-config">host-config</a></h3>
<ul>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/9322">#9322</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9452">#9452</a></li>
</ul>
<p>配置文件中的 <code>host</code> 键可以用来向主机构建目标传递标志，比如交叉编译时必须在主机系统而不是目标系统上运行的构建脚本。
它同时支持通用的和特定于主机架构的表。匹配的host arch表优先于通用的host表。</p>
<p>它需要设置 <code>-Zhost-config</code> 和 <code>-Ztarget-applies-to-host</code> 命令行选项，并且在Cargo配置文件中设置 <code>target-applies-to-host = false</code> 。</p>
<pre><code class="language-toml"># config.toml
[host]
linker = &quot;/path/to/host/linker&quot;
[host.x86_64-unknown-linux-gnu]
linker = &quot;/path/to/host/arch/linker&quot;
rustflags = [&quot;-Clink-arg=--verbose&quot;]
[target.x86_64-unknown-linux-gnu]
linker = &quot;/path/to/target/linker&quot;
</code></pre>
<p>在 <code>x86_64-unknown-linux-gnu</code> 主机上构建时，上面的通用 <code>host</code> 表将被完全忽略，因为 <code>host.x86_64-unknown-linux-gnu</code> 表具有优先权。</p>
<p>设置 <code>-Zhost-config</code> 将 <code>target-applies-to-host</code> 的默认值从 <code>true</code> 改为 <code>false</code> 。</p>
<pre><code class="language-console">cargo +nightly -Ztarget-applies-to-host -Zhost-config build --target x86_64-unknown-linux-gnu
</code></pre>
<h3 id="unit-graph"><a class="header" href="#unit-graph">unit-graph</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/8002">#8002</a></li>
</ul>
<p><code>--unit-graph</code> 标志可以传递给任何构建命令(<code>build</code>、<code>check</code>、<code>run</code>、<code>test</code>、<code>bench</code>、<code>doc</code>等)，
以向标准输出发送JSON对象，表示Cargo的内部单元图。实际上没有任何内容被构建，
命令在打印后立即返回。每个 &quot;单元&quot; 对应于编译器的一次执行。这些对象还包含每个单元所依赖的单元。</p>
<pre><code>cargo +nightly build --unit-graph -Z unstable-options
</code></pre>
<p>这种结构提供了Cargo所看到的更完整的依赖的视图。特别是，&quot;features&quot; 字段支持新的特性解析器，
依赖可以用不同的特性构建多次。 <code>cargo metadata</code> 从根本上不能表示不同依赖种类之间的特性关系，
当前特性取决于运行哪个命令，选择哪个包和目标。此外，它还可以提供包内依赖的细节，如构建脚本或测试。</p>
<p>下面是对JSON结构的描述:</p>
<pre><code class="language-javascript">{
  /* 是JSON输出结构的版本。如果有向后不兼容的变化，这个值将增加。 */
  &quot;version&quot;: 1,
  /* 所有构建单位的数组。 */
  &quot;units&quot;: [
    {
      /* 一个不透明的字符串，表示该包。关于包的信息可以从 `cargo metadata` 中获得。 */
      &quot;pkg_id&quot;: &quot;my-package 0.1.0 (path+file:///path/to/my-package)&quot;,
      /* Cargo目标。关于这些字段的更多信息，请参见 `cargo metadata` 文档。 https://doc.rust-lang.org/cargo/commands/cargo-metadata.html */
      &quot;target&quot;: {
        &quot;kind&quot;: [&quot;lib&quot;],
        &quot;crate_types&quot;: [&quot;lib&quot;],
        &quot;name&quot;: &quot;my-package&quot;,
        &quot;src_path&quot;: &quot;/path/to/my-package/src/lib.rs&quot;,
        &quot;edition&quot;: &quot;2018&quot;,
        &quot;test&quot;: true,
        &quot;doctest&quot;: true
      },
      /* 本单元的配置文件设置。这些值可能与配置清单中定义的配置文件不一致。
         单位可以使用修改的配置文件设置。例如，&quot;panic&quot; 设置可以被覆盖，用于测试，以迫使它 &quot;unwind&quot; 。 */
      &quot;profile&quot;: {
        /* 这些设置是由配置文件名称衍生而来。 */
        &quot;name&quot;: &quot;dev&quot;,
        /* 字符串表示的优化级别。 */
        &quot;opt_level&quot;: &quot;0&quot;,
        /* 字符串表示的LTO设置。 */
        &quot;lto&quot;: &quot;false&quot;,
        /* 编码单位是一个整数。 `null` 表示它应该使用编译器的默认值。 */
        &quot;codegen_units&quot;: null,
        /* 整数表示的调试信息等级。 `null` 表示它应该使用编译器的默认值 (0) 。 */
        &quot;debuginfo&quot;: 2,
        /* 是否启用了调试断言。 */
        &quot;debug_assertions&quot;: true,
        /* 是否启用了溢出检查。 */
        &quot;overflow_checks&quot;: true,
        /* 是否启用了rpath。 */
        &quot;rpath&quot;: false,
        /* 是否启用了增量编译。 */
        &quot;incremental&quot;: true,
        /* 恐慌的策略，&quot;unwind&quot; 或 &quot;abort&quot; 。 */
        &quot;panic&quot;: &quot;unwind&quot;
      },
      /* 为哪个平台建立的目标。如果值为 `null` ，则表明它是为主机建立的。
         否则，它是目标三元组的字符串(如 &quot;x86_64-unknown-linux-gnu&quot; )。 */
      &quot;platform&quot;: null,
      /* 该单元的 &quot;mode&quot; 。有效值:

         * &quot;test&quot; — 使用 `rustc` 作为测试来构建。
         * &quot;build&quot; — 使用 `rustc` 构建。
         * &quot;check&quot; — 在 &quot;check&quot; 模式下使用 `rustc` 构建。
         * &quot;doc&quot; — 使用 `rustdoc` 构建。
         * &quot;doctest&quot; — 使用 `rustdoc` 进行测试。
         * &quot;run-custom-build&quot; — 表示构建脚本的执行。
      */
      &quot;mode&quot;: &quot;build&quot;,
      /* 在这个单元上启用的特性数组字符串。 */
      &quot;features&quot;: [&quot;somefeat&quot;],
      /* 这是否是一个标准库单元，是不稳定的 build-std 功能的一部分。如果没有设置，视为 `false` 。 */
      &quot;is_std&quot;: false,
      /* 该单元的依赖数组。 */
      &quot;dependencies&quot;: [
        {
          /* 依赖的 &quot;单位&quot; 数组中的索引。 */
          &quot;index&quot;: 1,
          /* 此依赖项将被称为的名称。 */
          &quot;extern_crate_name&quot;: &quot;unicode_xid&quot;,
          /* 这个依赖是否是 &quot;public&quot; 的，是不稳定的公共依赖特性的一部分。如果没有设置，则不启用公共依赖特性。*/
          &quot;public&quot;: false,
          /* 该依赖是否被注入到 prelude 中，目前由 build-std 功能使用。如果没有设置，视为 `false` 。 */
          &quot;noprelude&quot;: false
        }
      ]
    },
    // ...
  ],
  /* &quot;单位&quot; 数组中作为依赖图 &quot;根&quot; 的索引数组。 */
  &quot;roots&quot;: [0],
}
</code></pre>
<h3 id="profile-rustflags-option"><a class="header" href="#profile-rustflags-option">Profile <code>rustflags</code> option</a></h3>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/7878">rust-lang/cargo#7878</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/10271">rust-lang/cargo#10271</a></li>
</ul>
<p>这个特性在 &quot;[profile]&quot; 部分提供了新的选项，用来指定直接传递给rustc的标志。可以像这样启用:</p>
<pre><code class="language-toml">cargo-features = [&quot;profile-rustflags&quot;]

[package]
# ...

[profile.release]
rustflags = [ &quot;-C&quot;, &quot;...&quot; ]
</code></pre>
<h3 id="rustdoc-map"><a class="header" href="#rustdoc-map">rustdoc-map</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/8296">#8296</a></li>
</ul>
<p>这个特性增加了传递给 <code>rustdoc</code> 的配置，这样它就可以在依赖没有文档的情况下，
生成指向文档托管在其他地方的依赖的链接。首先，将其添加到 <code>.cargo/config</code> 中。</p>
<pre><code class="language-toml">[doc.extern-map.registries]
crates-io = &quot;https://docs.rs/&quot;
</code></pre>
<p>然后，在构建文档时，使用以下标志，使链接的依赖链接到 <a href="https://docs.rs/">docs.rs</a> 。</p>
<pre><code>cargo +nightly doc --no-deps -Zrustdoc-map
</code></pre>
<p><code>registries</code> 表包含了注册中心名称与要链接的URL的映射。URL可以有 <code>{pkg_name}</code> 和 <code>{version}</code> 的标记，
这些标记会被替换成相应的值。如果两者都没有指定，那么Cargo默认会在URL的末尾添加 <code>{pkg_name}/{version}/</code> 。</p>
<p>另一个配置设置可用于重定向标准库链接。默认情况下，rustdoc 创建链接到 <a href="https://doc.rust-lang.org/nightly/">https://doc.rust-lang.org/nightly/</a> 。
要改变这种行为，请使用 <code>doc.extern-map.std</code> 设置。</p>
<pre><code class="language-toml">[doc.extern-map]
std = &quot;local&quot;
</code></pre>
<p>值为 <code>&quot;local&quot;</code> 意味着链接到在 <code>rustc</code> 系统根中找到的文档。如果你使用的是rustup，这个文档可以用 <code>rustup component add rust-docs</code> 来安装。</p>
<p>默认值是 <code>&quot;remote&quot;</code> 。</p>
<p>该值也可以接受一个自定义位置的URL。</p>
<h3 id="per-package-target"><a class="header" href="#per-package-target">per-package-target</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/pull/9406">#9406</a></li>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/9030">#9030</a></li>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/pull/7004">#7004</a></li>
</ul>
<p><code>per-package-target</code> 特性在配置清单中增加了两个键：<code>package.default-target</code> 和  <code>package.forced-target</code> 。
第一个键使包在默认情况下 (即没有传递 <code>--target</code> 参数时)为某个目标进行编译。第二种是使包总是为该目标编译。</p>
<p>Example:</p>
<pre><code class="language-toml">[package]
forced-target = &quot;wasm32-unknown-unknown&quot;
</code></pre>
<p>在这个例子中，crate总是为 <code>wasm32-unknown-unknown</code> 构建的，例如，因为它将被用作运行在主机(或在命令行上提供)目标上的主程序的插件。</p>
<h3 id="artifact-dependencies"><a class="header" href="#artifact-dependencies">artifact-dependencies</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/pull/9096">#9096</a></li>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/9992">#9992</a></li>
</ul>
<p>允许 Cargo 包依赖 <code>bin</code> 、 <code>cdylib</code> 和 <code>staticlib</code> crate，并在编译时使用这些crate构建的制品。</p>
<p>使用 <code>-Z bindeps</code> 运行 <code>cargo</code> 来启用这一功能。</p>
<p><strong>示例:</strong> 在构建脚本中使用 <em>cdylib</em> 制品</p>
<p>消耗包中的 <code>Cargo.toml</code> ，为特定的构建目标将 <code>bar</code> 库构建为 <code>cdylib</code> </p>
<pre><code class="language-toml">[build-dependencies]
bar = { artifact = &quot;cdylib&quot;, version = &quot;1.0&quot;, target = &quot;wasm32-unknown-unknown&quot; }
</code></pre>
<p>和 <code>build.rs</code> 中的构建脚本一起。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  wasm::run_file(std::env::var(&quot;CARGO_CDYLIB_FILE_BAR&quot;).unwrap());
}</code></pre></pre>
<p><strong>示例:</strong> 在二进制文件中使用 <em>binary</em> 制品和它的库。</p>
<p>消耗包中的 <code>Cargo.toml</code> ，构建 <code>bar</code> 二进制文件作为制品，同时将其作为库提供…</p>
<pre><code class="language-toml">[dependencies]
bar = { artifact = &quot;bin&quot;, version = &quot;1.0&quot;, lib = true }
</code></pre>
<p>与可执行文件一起使用 <code>main.rs</code> 。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  bar::init();
  command::run(env!(&quot;CARGO_BIN_FILE_BAR&quot;));
}</code></pre></pre>
<h3 id="sparse-registry"><a class="header" href="#sparse-registry">sparse-registry</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9069">9069</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/2789">#2789</a></li>
</ul>
<p><code>sparse-registry</code> 特性允许cargo与通过普通HTTP而不是git提供的远程注册中心进行交互。这些注册中心可以通过以 <code>sparse+http://</code> 或 <code>sparse+https://</code> 开头的URL识别。</p>
<p>当通过HTTP获取索引元数据时，Cargo 只下载相关crate的元数据，这可以节省大量时间和带宽。</p>
<p>sparse索引格式与基于git的索引的签出是一样的。</p>
<p><code>registries.crates-io.protocol</code> 配置选项可以用来设置 crates.io 的默认协议。这个选项需要启用 <code>-Z sparse-registry</code> 。</p>
<ul>
<li><code>sparse</code> — 使用 sparse 索引。</li>
<li><code>git</code> — 使用 git 索引。</li>
<li>如果选项没有设置，若启用 <code>-Z sparse-registry</code> ，它将是sparse索引，否则它将是git索引。</li>
</ul>
<p>Cargo在本地缓存crate元数据文件，并从服务器上捕获每个条目的 <code>ETag</code> 或 <code>Last-Modified</code> HTTP头。
当刷新crate元数据时，Cargo会发送 <code>If-None-Match</code> 或 <code>If-Modified-Since</code> 头，如果本地缓存有效，则允许服务器以HTTP 304响应，以节省时间和带宽。</p>
<h3 id="publish-timeout"><a class="header" href="#publish-timeout">publish-timeout</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/11222">11222</a></li>
</ul>
<p>配置文件中的 <code>publish.timeout</code> 键可以用来控制 <code>cargo publish</code> 在将包发布到注册中心和它在本地索引中可用之间的等待时间。</p>
<p>如果超时为 <code>0</code> 就不会发生任何检查。</p>
<p>它需要设置 <code>-Zpublish-timeout</code> 命令行选项。</p>
<pre><code class="language-toml"># config.toml
[publish]
timeout = 300  # 按秒
</code></pre>
<h3 id="registry-auth"><a class="header" href="#registry-auth">registry-auth</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/10474">10474</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3139">#3139</a></li>
</ul>
<p>通过在注册中心索引的config.json中添加配置选项，使Cargo在API请求、crate下载和sparse索引更新中包含授权令牌。</p>
<p>要使用这个特性，注册中心服务器必须在 <code>config.json</code> 中包含 <code>&quot;auth-required&quot;: true</code> ，并且必须在Cargo命令行中传递 <code>-Z registry-auth</code> 标志。</p>
<p>当使用sparse协议时，Cargo会在获取任何其他文件之前尝试获取 <code>config.json</code> 文件。
如果服务器的回应是HTTP 401，那么Cargo将认为注册中心需要认证，并重新尝试请求 <code>config.json</code> ，其中包含认证令牌。</p>
<p>在认证失败 (或缺少认证令牌) 时，服务器可能包括 <code>WWW-Authenticate</code> 头和 <code>Cargo login_url</code> 信息，以表明用户可以去哪里获得令牌。</p>
<pre><code>WWW-Authenticate: Cargo login_url=&quot;https://test-registry-login/me
</code></pre>
<p>This same flag is also used to enable asymmetric authentication tokens.</p>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/10519">10519</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3231">#3231</a></li>
</ul>
<p>增加对Cargo的支持，以便在不通过网络发送私密信息的情况下对用户进行认证。</p>
<p>在 <a href="reference/config.html"><code>config.toml</code></a> 和 <code>credentials.toml</code> 文件中，有名为 <code>private-key</code> 的字段，它是以秘密的 <a href="https://github.com/paseto-standard/paserk/blob/master/types/secret.md">subset of <code>PASERK</code></a>格式的私钥，用于签署非对称令牌。</p>
<p>可以用 <code>cargo login --generate-keypair</code> 生成密钥对，这将:</p>
<ul>
<li>以目前推荐的方式生成公钥/私钥对。</li>
<li>保存私钥在 <code>credentials.toml</code> 。</li>
<li>格式打印公钥 <a href="https://github.com/paseto-standard/paserk/blob/master/types/public.md">PASERK public</a> 。</li>
</ul>
<p>建议将 <code>private-key</code> 保存在 <code>credentials.toml</code> 中。在 <code>config.toml</code> 中也支持，主要是为了使用相关的环境变量来设置，这也是在CI背景下提供的推荐方式。这种设置就是为 <code>token</code> 字段设置秘密令牌的方式。</p>
<p>还有可选字段 <code>private-key-subject</code> ，是由注册中心选择的字符串。
这个字符串将作为非对称令牌的一部分，不应该是秘密的。
是为 &quot;中央CA服务器授权此行为的加密证明&quot; 这样的极少用例准备的。
Cargo要求它为非空格可打印的ASCII。需要非ASCII数据的注册中心应该对其进行base64编码。 </p>
<p>这两个字段都可以用 <code>cargo login --registry=name --private-key --private-key-subject=&quot;subject&quot;</code> 来设置，它将提示你输入密钥值。</p>
<p>注册中心最多可以设置  <code>private-key</code> 、<code>token</code> 、 <code>credential-process</code> 之一。</p>
<p>所有PASETO将包含  <code>iat</code> ，即ISO 8601格式的当前时间。Cargo将酌情包含以下内容:</p>
<ul>
<li><code>sub</code>一个可选的、非秘密的字符串，由注册中心选择，预期在每次请求时都会被取得。该值将是 <code>config.toml</code> 文件中的 <code>private-key-subject</code> 。</li>
<li><code>mutation</code> 如果存在, 表示该请求是一个改变操作(如果不存在，则是一个只读操作)，必须是字符串 <code>publish</code> 、 <code>yank</code> 、 <code>unyank</code> 之一。
<ul>
<li><code>name</code> 与此请求有关的crate的名称。</li>
<li><code>vers</code> 与此请求相关的包的版本字符串。</li>
<li><code>cksum</code> 箱子内容的SHA256哈希值，是由64个小写的十六进制数字组成的字符串，只有当 <code>mutation</code> 等于 <code>publish</code> 时才必须出现。 </li>
</ul>
</li>
<li><code>challenge</code> 从该服务器的session 401/403中收到的质询字符串。发出质询的注册中心必须跟踪哪些质询已经 issued/used ，并且在同一有效期内不接受特定的质询超过一次(避免跟踪每一个曾经发出的质询)。</li>
</ul>
<p>&quot;footer&quot; (这是签名的一部分)将是一个UTF-8格式的JSON字符串，包括:</p>
<ul>
<li><code>url</code> 符合RFC 3986标准的URL，cargo从那里得到config.json文件。
<ul>
<li>如果这是有HTTP索引的注册中心，那么这就是所有索引查询相对的基本URL。</li>
<li>如果这是有GIT索引的注册中心，它是Cargo用来克隆索引的URL。</li>
</ul>
</li>
<li><code>kid</code> 用于签署请求的私钥的标识，使用<a href="https://github.com/paseto-standard/paserk/blob/master/operations/ID.md">PASERK IDs</a> 标准。</li>
</ul>
<p>PASETO包括被签名的信息，因而服务器不必为了检查签名而从请求中重构确切字符串。
服务器需要检查签名比对PASETO中的字符串是否有效，以及该字符串的内容是否与请求相符。
如果该请求应该有一个声明，但在PASETO中没有，那么该请求必须被拒绝。</p>
<h3 id="credential-process"><a class="header" href="#credential-process">credential-process</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/8933">#8933</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/2730">#2730</a></li>
</ul>
<p><code>credential-process</code> 特性增加了一个配置设置，通过调用一个外部进程来获取注册中心认证令牌。</p>
<p>Token认证被 <a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> 、 <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> 、 <a href="reference/../commands/cargo-owner.html"><code>cargo owner</code></a> 和 <a href="reference/../commands/cargo-yank.html"><code>cargo yank</code></a> 命令所使用。此外，该特性增加新的 <code>cargo logout</code> 命令。</p>
<p>要使用这个特性，你必须在命令行中传递 <code>-Z credential-process</code> 标志。
此外，你必须删除当前保存在 <a href="reference/config.html#credentials"><code>credentials</code> file</a> 中的任何当前令牌(这可以通过新的 <code>logout</code> 命令来完成)。</p>
<h4 id="credential-process-配置"><a class="header" href="#credential-process-配置"><code>credential-process</code> 配置</a></h4>
<p>要配置运行哪个进程来获取令牌，在 <a href="reference/config.html">config file</a> 的 <code>registry</code> 表中指定进程:</p>
<pre><code class="language-toml">[registry]
credential-process = &quot;/usr/bin/cargo-creds&quot;
</code></pre>
<p>如果你想对一个特定的注册中心使用不同的进程，可以在 <code>registries</code> 表中指定。</p>
<pre><code class="language-toml">[registries.my-registry]
credential-process = &quot;/usr/bin/cargo-creds&quot;
</code></pre>
<p>该值可以是用空格分隔参数的字符串，也可以是TOML字符串数组。</p>
<p>命令行参数允许特殊的占位符，这些占位符将被替换成相应的值:</p>
<ul>
<li><code>{name}</code> — 注册中心的名称。</li>
<li><code>{api_url}</code> —  注册中心 API 端点的基本URL。</li>
<li><code>{action}</code> — 认证动作(如下所述)。</li>
</ul>
<p>带有 <code>cargo:</code> 前缀的进程名称会从cargo下的 <code>libexec</code> 目录中加载。Cargo中包含了几个实验性的证书包装器，以提供对它们的便利访问:</p>
<pre><code class="language-toml">[registry]
credential-process = &quot;cargo:macos-keychain&quot;
</code></pre>
<p>目前的包装器是:</p>
<ul>
<li><code>cargo:macos-keychain</code>: 使用macOS Keychain来存储令牌。</li>
<li><code>cargo:wincred</code>: 使用Windows证书管理器来存储令牌。</li>
<li><code>cargo:1password</code>: 使用1password <code>op</code> CLI来存储令牌。你必须从 <a href="https://1password.com/downloads/command-line/">1password 网站</a>安装 <code>op</code> CLI。你必须至少运行一次<code>op signin</code>，并加上适当的参数(如 <code>op signin my.1password.com user@example.com</code> )，除非你提供地址和电子邮件参数。除非设置了适当的 <code>OP_SESSION</code> 环境变量，否则每次请求时都需要主密码。它支持以下命令行参数。
<ul>
<li><code>--account</code>: 使用的账户简写名称。</li>
<li><code>--vault</code>:  使用的保险名称。</li>
<li><code>--sign-in-address</code>: 登录地址，是一个网址，如 <code>my.1password.com</code> 。</li>
<li><code>--email</code>: 用来登录的电子邮件地址。</li>
</ul>
</li>
</ul>
<p>GNOME <a href="https://wiki.gnome.org/Projects/Libsecret">libsecret</a> 有包装器，可以在Linux系统上存储令牌。由于构建的限制，这个包装器不能作为预编译的二进制文件使用。
这可以手动构建和安装。首先，使用你的系统包管理器安装 libsecret (例如，<code>sudo apt install libsecret-1-dev</code>)。
然后用<code>cargo install cargo-credential-gnome-secret</code> 构建并安装包装器。在配置中，使用二进制文件的路径，如下所示:</p>
<pre><code class="language-toml">[registry]
credential-process = &quot;cargo-credential-gnome-secret {action}&quot;
</code></pre>
<h4 id="credential-process-接口"><a class="header" href="#credential-process-接口"><code>credential-process</code> 接口</a></h4>
<p>Cargo支持两种不同的token进程。简单的 &quot;basic&quot; 类型只在Cargo需要令牌时才会被调用。
这是为了与密码管理器进行简单而方便的集成，通常可以使用已有的工具。
更高级的 &quot;Cargo&quot; 类型支持作为命令行参数传递的不同动作。
这样做的目的是为了获得更好的集成体验，代价是需要一个Cargo特定的进程来粘合到密码管理器上。
Cargo会根据 &quot;credential-process&quot; 的定义来决定支持哪种类型。
如果它包含 <code>{action}</code> 参数，那么它就会使用高级样式，否则它就假定它只支持 &quot;basic&quot; 样式。</p>
<h5 id="基础认证器"><a class="header" href="#基础认证器">基础认证器</a></h5>
<p>基础认证器是在stdout上返回一个令牌的进程。新行将被修整。该进程继承了用户的 stdin 和 stderr 。它应在成功时退出0，在错误时退出非零。</p>
<p>在这种形式下，不支持 <a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> 和 <code>cargo logout</code> ，如果使用，会返回一个错误。</p>
<h5 id="cargo认证器"><a class="header" href="#cargo认证器">Cargo认证器</a></h5>
<p>Cargo和进程之间的协议是非常基本的，目的是确保认证过程尽可能简单。
Cargo将执行进程，其 <code>{action}</code> 参数表明要执行的动作。</p>
<ul>
<li><code>store</code> — 将给定令牌可靠存储。</li>
<li><code>get</code> —从存储中获取令牌。</li>
<li><code>erase</code> — 从存储中移除令牌。</li>
</ul>
<p><code>cargo login</code> 命令使用 <code>store</code> 来保存令牌。需要认证的命令，如 <code>cargo publish</code> ，使用 <code>get</code> 检索令牌。 <code>cargo logout</code> 使用 <code>erase</code> 命令来删除令牌。</p>
<p>进程继承了用户的stderr，所以进程可以显示信息。
有些值是通过环境变量传递进来(见下文)。预期的交互作用是:</p>
<ul>
<li>
<p><code>store</code> — 令牌被发送到进程的stdin中，以换行结束。进程应该根据注册中心的名称来存储令牌。如果进程失败，它应该以非零的退出状态退出。</p>
</li>
<li>
<p><code>get</code> — 进程应将令牌发送到其stdout(尾部的换行将被修整)。进程继承用户的stdin，如果它需要接收输入的话。</p>
<p>如果进程无法完成请求，它应该以非零退出代码退出。</p>
</li>
<li>
<p><code>erase</code> — 该进程应该删除与注册中心名称相关联的令牌。如果没有找到令牌，进程应该以0状态退出。</p>
</li>
</ul>
<h5 id="环境"><a class="header" href="#环境">环境</a></h5>
<p>以下环境变量提供给被执行的命令:</p>
<ul>
<li><code>CARGO</code> — 执行命令的 <code>cargo</code> 二进制文件的路径。</li>
<li><code>CARGO_REGISTRY_INDEX_URL</code> — 注册中心索引的URL。</li>
<li><code>CARGO_REGISTRY_NAME_OPT</code> — 注册中心的可选名称。不应作为存储键使用。并不总是可用的。</li>
</ul>
<h4 id="cargo-logout"><a class="header" href="#cargo-logout"><code>cargo logout</code></a></h4>
<p>增加新的 <code>cargo logout</code> 命令，使其更容易从存储中删除令牌。这同时支持 <a href="reference/config.html#credentials"><code>credentials</code> file</a> 令牌和 <code>credential-process</code> 令牌。</p>
<p>当与 <code>credentials</code> 文件令牌一起使用时，它需要 <code>-Z unstable-options</code> 命令行选项:</p>
<pre><code class="language-console">cargo logout -Z unstable-options
</code></pre>
<p>当与 <code>credential-process</code> 配置一起使用时，使用 <code>-Z credential-process</code> 命令行选项:</p>
<pre><code class="language-console">cargo logout -Z credential-process
</code></pre>
<h3 id="cargo-config"><a class="header" href="#cargo-config"><code>cargo config</code></a></h3>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/2362">#2362</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9301">#9301</a></li>
</ul>
<p><code>cargo config</code> 子命令提供了一种显示cargo加载的配置文件的方法。
它目前包括 <code>get</code> 子命令，可以接受可选的配置文件来显示。</p>
<pre><code class="language-console">cargo +nightly -Zunstable-options config get build.rustflags
</code></pre>
<p>如果不包含配置值，它将显示所有的配置值。参见 <code>--help</code> 输出，了解更多可用的选项。</p>
<h3 id="doctest-in-workspace"><a class="header" href="#doctest-in-workspace"><code>doctest-in-workspace</code></a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9427">#9427</a></li>
</ul>
<p><code>-Z doctest-in-workspace</code> 标志改变了运行文档测试时使用的当前工作目录的行为。
曾经，Cargo运行 <code>rustdoc --test</code> 时是相对于包的根目录，路径相对于根目录。
然而，这与 <code>rustc</code> 和 <code>rustdoc</code> 在工作空间的正常运行方式不一致，它们是相对于工作空间根目录运行。
这种不一致会导致各种问题，比如在传递 RUSTDOCFLAGS 时，使用相对路径，或者处理诊断输出。</p>
<p><code>-Z doctest-in-workspace</code> 标志使cargo切换到从工作空间的根运行 <code>rustdoc</code> 。
它还将 <code>--test-run-directory</code> 传递给 <code>rustdoc</code> ，以便在<em>运行</em>测试时，从包的根目录运行。
这保留了向后的兼容性，并且与正常的单元测试的运行方式一致。</p>
<h3 id="rustc---print"><a class="header" href="#rustc---print">rustc <code>--print</code></a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9357">#9357</a></li>
</ul>
<p><code>cargo rustc --print=VAL</code> 将 <code>--print</code> 标志转发给 <code>rustc</code> ，以便从 <code>rustc</code> 中提取信息。
在运行 <code>rustc</code> 时，会有相应的 <a href="https://doc.rust-lang.org/rustc/command-line-arguments.html#--print-print-compiler-information"><code>--print</code></a> 标志，
然后立即退出，不进行编译。将其作为cargo标志暴露，允许cargo根据当前配置注入正确的目标和RUSTFLAGS。</p>
<p>主要的使用情况是运行 <code>cargo rustc --print=cfg</code> 来获得相应目标的配置值，并受到任何其他RUSTFLAGS的影响。 </p>
<h3 id="不同的二进制名称"><a class="header" href="#不同的二进制名称">不同的二进制名称</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9778">#9778</a></li>
<li>PR: <a href="https://github.com/rust-lang/cargo/pull/9627">#9627</a></li>
</ul>
<p><code>different-binary-name</code> 特性允许设置二进制文件的文件名，而不必遵守对crate名称的限制。比如，crate名称只能使用 <code>alphanumeric</code> 字符或 <code>-</code> 或 <code>_</code> ，并且不能为空。</p>
<p><code>filename</code> 参数 <strong>不</strong> 包含二进制扩展名，<code>cargo</code> 将计算出适当的扩展名并将其用于二进制文件。</p>
<p>参数 <code>filename</code> 只在配置清单的 <code>[[bin]]</code> 部分可用。</p>
<pre><code class="language-toml">cargo-features = [&quot;different-binary-name&quot;]

[package]
name =  &quot;foo&quot;
version = &quot;0.0.1&quot;

[[bin]]
name = &quot;foo&quot;
filename = &quot;007bar&quot;
path = &quot;src/main.rs&quot;
</code></pre>
<h3 id="scrape-examples"><a class="header" href="#scrape-examples">scrape-examples</a></h3>
<ul>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3123">#3123</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/9910">#9910</a></li>
</ul>
<p><code>-Z rustdoc-scrape-examples</code> 标志告诉 Rustdoc 在当前工作空间中搜索crate的函数调用。
然后，这些调用点会被包含在文档中。你可以像这样使用该标志:</p>
<pre><code>cargo doc -Z unstable-options -Z rustdoc-scrape-examples
</code></pre>
<p>默认情况下，Cargo会从记录的包的例子目标中抓取实例。
你可以用 <code>doc-scrape-examples</code> 标志单独启用或禁用目标，例如:</p>
<pre><code class="language-toml"># 启用从库中抓取实例
[lib]
doc-scrape-examples = true

# 禁用从实例目标中抓取实例
[[example]]
name = &quot;my-example&quot;
doc-scrape-examples = false
</code></pre>
<p><strong>关于测试的说明:</strong> 在测试目标上启用 <code>doc-scrape-examples</code> 目前没有任何效果。从测试中抓取例子是一项正在进行的工作。</p>
<p><strong>关于dev-依赖的说明:</strong> 记录库通常不需要crate的dev-依赖。然而，示例目标需要dev-依赖。
为了向后兼容， <code>-Z rustdoc-scrape-examples</code> 将<em>不</em>为 <code>cargo doc</code> 引入dev-依赖要求。
因此，在以下情况下，将 <em>不会</em> 从示例目标中抓取示例:</p>
<ol>
<li>没有被记录的目标需要dev-依赖, AND</li>
<li>至少有一个目标被记录的crate有dev-依赖, AND</li>
<li>对于所有 <code>[[example]]</code> 目标，<code>doc-scrape-examples</code> 参数未设置或为假。</li>
</ol>
<p>如果你想让实例从实例目标中被抓取，那么你必须不满足上述条件之一。
例如，你可以为一个例子目标设置 <code>doc-scrape-examples</code> 为 true，这就向Cargo发出信号，你可以为 <code>cargo doc</code> 建立dev-依赖。</p>
<h3 id="check-cfg"><a class="header" href="#check-cfg">check-cfg</a></h3>
<ul>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3013">#3013</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/10554">#10554</a></li>
</ul>
<p><code>-Z check-cfg</code> 命令行可以在编译时检查 <code>#[cfg]</code> 、 <code>cfg!</code> 中的名称和值。
<code>#[link]</code> 和 <code>#[cfg_attr]</code> 中的名称和值，使用 <code>rustc</code> 和 <code>rustdoc</code> 不稳定的 <code>--check-cfg</code> 命令行。</p>
<p>它的值是:</p>
<ul>
<li><code>features</code>: 通过 <code>--check-cfg=values(feature, ...)</code> 启用特性检查。
注意这个命令行选项可能会成为稳定时的默认选项。</li>
<li><code>names</code>: 通过 <code>--check-cfg=names()</code> 实现众所周知的名称检查。</li>
<li><code>values</code>: 通过 <code>--check-cfg=values()</code> 实现众所周知的值检查。</li>
<li><code>output</code>: 启用构建脚本中的 <code>rustc-check-cfg</code> 。</li>
</ul>
<p>例如:</p>
<pre><code>cargo check -Z unstable-options -Z check-cfg=features
cargo check -Z unstable-options -Z check-cfg=names
cargo check -Z unstable-options -Z check-cfg=values
cargo check -Z unstable-options -Z check-cfg=features,names,values
</code></pre>
<p>Or for <code>output</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// build.rs
println!(&quot;cargo:rustc-check-cfg=names(foo, bar)&quot;);
<span class="boring">}</span></code></pre></pre>
<pre><code>cargo check -Z unstable-options -Z check-cfg=output
</code></pre>
<h3 id="cargorustc-check-cfgcheck_cfg"><a class="header" href="#cargorustc-check-cfgcheck_cfg"><code>cargo:rustc-check-cfg=CHECK_CFG</code></a></h3>
<p><code>rustc-check-cfg</code> 指令告诉Cargo将给定的值传递给编译器 <code>--check-cfg</code> 标志。
这可用于编译时检测意外的条件编译名称或值。</p>
<p>这只能与 <code>-Zcheck-cfg=output</code> 结合使用，否则会被忽略并发出警告。</p>
<p>如果你想集成Cargo的特性，请使用 <code>-Zcheck-cfg=features</code> ，而不是试图用这个选项手动完成。</p>
<h2 id="稳定和删除特性"><a class="header" href="#稳定和删除特性">稳定和删除特性</a></h2>
<h3 id="编译进度"><a class="header" href="#编译进度">编译进度</a></h3>
<p>编译进度功能在1.30版本中得到了稳定。进度条现在是默认启用的。
参见 <a href="reference/config.html#termprogresswhen"><code>term.progress</code></a> 了解更多关于控制该特性的信息。</p>
<h3 id="版次"><a class="header" href="#版次">版次</a></h3>
<p>在 <code>Cargo.toml</code> 中指定 <code>edition</code> 已在1.31版本中得到稳定。
请参阅 <a href="reference/manifest.html#the-edition-field">the edition field</a> 以了解有关指定该字段的更多信息。</p>
<h3 id="重命名依赖"><a class="header" href="#重命名依赖">重命名依赖</a></h3>
<p>在 <code>Cargo.toml</code> 中指定重命名依赖，在1.31版本中已经稳定。
参见 <a href="reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml">renaming dependencies</a> 了解更多关于重命名依赖的信息。</p>
<h3 id="备用注册中心"><a class="header" href="#备用注册中心">备用注册中心</a></h3>
<p>在1.34版本中，对备用注册中心的支持已经稳定下来了。
请参阅 <a href="reference/registries.html">Registries chapter</a> 了解更多关于备用注册中心的信息。</p>
<h3 id="脱机模式"><a class="header" href="#脱机模式">脱机模式</a></h3>
<p>脱机功能在1.36版本中已经稳定下来了。
参见 <a href="reference/../commands/cargo.html#option-cargo---offline"><code>--offline</code> flag</a>，了解更多关于使用脱机模式的信息。</p>
<h3 id="发表锁定文件"><a class="header" href="#发表锁定文件">发表锁定文件</a></h3>
<p>1.37版本中删除了 <code>publish-lockfile</code> 功能。如果包包含二进制目标，则在发布包时总是包括 <code>Cargo.lock</code> 文件。 <code>cargo install</code> 需要 <code>--locked</code> 标志来使用 <code>Cargo.lock</code> 文件。
更多信息见 <a href="reference/../commands/cargo-package.html"><code>cargo package</code></a> 和 <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 。</p>
<h3 id="默认运行"><a class="header" href="#默认运行">默认运行</a></h3>
<p><code>default-run</code> 功能在1.37版本中已经稳定下来。参见 <a href="reference/manifest.html#the-default-run-field">the `default-run'field</a> 以了解更多关于指定默认运行目标的信息。</p>
<h3 id="缓存信息"><a class="header" href="#缓存信息">缓存信息</a></h3>
<p>编译器信息缓存在1.40版本中得到了稳定。编译器警告现在被默认缓存，并在重新运行Cargo时自动回放。</p>
<h3 id="安装升级"><a class="header" href="#安装升级">安装升级</a></h3>
<p><code>install-upgrade</code> 特性在1.41版本中得到了稳定。<a href="reference/../commands/cargo-install.html"><code>cargo install</code></a>现在会在包出现过期时自动升级。更多信息请参见 <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 文档。</p>
<h3 id="profile覆盖"><a class="header" href="#profile覆盖">Profile覆盖</a></h3>
<p>Profile 覆盖已经在1.41版本中得到稳定。请参阅<a href="reference/profiles.html#overrides">Profile Overrides</a>以了解更多关于使用覆盖的信息。</p>
<h3 id="config-profiles"><a class="header" href="#config-profiles">Config Profiles</a></h3>
<p>在Cargo 配置文件和环境变量中指定配置文件的做法在1.43版本中已经稳定下来。
参见 <a href="reference/config.html#profile">config <code>[profile]</code> table</a> 以了解更多关于在配置文件中指定 <a href="reference/profiles.html">profile</a> 的信息。</p>
<h3 id="crate版本"><a class="header" href="#crate版本">crate版本</a></h3>
<p><code>-Z crate-versions</code> 标志在1.47版本中已经稳定。
crate版本现在自动包含在 <a href="reference/../commands/cargo-doc.html"><code>cargo doc</code></a> 文档中。</p>
<h3 id="特性-1"><a class="header" href="#特性-1">特性</a></h3>
<p>在1.51版本中，<code>-Z features</code> 标志已经稳定下来。参见 <a href="reference/feature.html#feature-resolver-version-2">feature resolver version 2</a> 以了解更多关于使用新特性解析器的信息。</p>
<h3 id="包特性"><a class="header" href="#包特性">包特性</a></h3>
<p><code>-Z package-features</code> 标志在1.51版本中已经稳定了。
参见 <a href="reference/features.html#resolver-version-2command-line-flags">resolver version 2 command-line flags</a> 以了解更多关于使用特性 CLI 选项的信息。</p>
<h3 id="解析器"><a class="header" href="#解析器">解析器</a></h3>
<p><code>Cargo.toml</code> 中的 <code>Cargo.toml</code> 特性在1.51版本中已经稳定。
请参阅 <a href="reference/resolver.html#resolver-versions">resolver versions</a> 以了解有关指定解析器的更多信息。</p>
<h3 id="extra-link-arg"><a class="header" href="#extra-link-arg">extra-link-arg</a></h3>
<p>在1.56版本中，用于在构建脚本中指定额外链接器参数的 <code>extra-link-arg</code> 功能已经稳定了。
请参阅 <a href="reference/build-scripts.html#outputs-the-build-script">build script documentation</a> 以了解更多关于指定额外链接器参数的信息。</p>
<h3 id="configurable-env"><a class="header" href="#configurable-env">configurable-env</a></h3>
<p>在Cargo配置中指定环境变量的 <code>configurable-env</code> 功能在1.56版本中已经稳定下来。
关于配置环境变量的更多信息，请参见 <a href="reference/config.html#env">config documentation</a> 。</p>
<h3 id="rust-version"><a class="header" href="#rust-version">rust-version</a></h3>
<p><code>Cargo.toml</code> 中的 <code>rust-version</code> 字段在1.56版本中已经稳定。
请参阅 <a href="reference/manifest.html#the-rust-version-field">rust-version field</a> 以了解更多关于使用 <code>rust-version</code> 字段和 <code>-ignore-rust-version</code> 选项的信息。</p>
<h3 id="codegen-backend"><a class="header" href="#codegen-backend">codegen-backend</a></h3>
<p><code>codegen-backend</code> 特性使我们有可能使用配置文件来选择rustc使用的codegen后端。</p>
<p>Example:</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;

[dependencies]
serde = &quot;1.0.117&quot;

[profile.dev.package.foo]
codegen-backend = &quot;cranelift&quot;
</code></pre>
<h3 id="patch-in-config"><a class="header" href="#patch-in-config">patch-in-config</a></h3>
<p><code>-Z patch-in-config</code> 标志，以及对Cargo配置文件中 <code>[patch]</code> 部分的相应支持，在1.56版本中已经稳定下来。更多信息请参见 <a href="reference/config.html#patch">patch field</a> 。</p>
<h3 id="edition-2021"><a class="header" href="#edition-2021">edition 2021</a></h3>
<p>2021 版次在1.56版本中已经稳定下来了。
参见<a href="reference/manifest.html#the-edition-field"><code>edition</code> field</a>，了解更多关于设置版次的信息。
参见<a href="reference/.../commands/cargo-fix.html"><code>cargo fix --edition</code></a>和<a href="reference/.../.../edition-guide/index.html">The Edition Guide</a>了解更多关于迁移现有项目的信息。</p>
<h3 id="自定义命名的配置文件"><a class="header" href="#自定义命名的配置文件">自定义命名的配置文件</a></h3>
<p>自定义命名的配置文件已经在1.57版本中得到稳定。请参阅 <a href="reference/profiles.html#custom-profiles">profiles chapter</a> 了解更多信息。</p>
<h3 id="profile-strip-option"><a class="header" href="#profile-strip-option">Profile <code>strip</code> option</a></h3>
<p>配置文件 <code>strip</code> 选项在1.59版本中已经稳定了。更多信息请参见 <a href="reference/profiles.html#strip">profiles chapter</a> 。</p>
<h3 id="未来不兼容报告"><a class="header" href="#未来不兼容报告">未来不兼容报告</a></h3>
<p>在1.59版本中，对生成未来不兼容报告的支持已经稳定下来了。
更多信息请参见 <a href="reference/future-incompat-report.html">future incompat report chapter</a>。</p>
<h3 id="名称空间特性"><a class="header" href="#名称空间特性">名称空间特性</a></h3>
<p>在1.60版本中，名称空间特性已经稳定下来了。
更多信息请参见<a href="reference/features.html#optional-dependencies">Features chapter</a>。</p>
<h3 id="弱依赖性特性"><a class="header" href="#弱依赖性特性">弱依赖性特性</a></h3>
<p>弱依赖性特性在1.60版本中已经稳定下来。
更多信息请参见<a href="reference/features.html#dependency-features">Features chapter</a>。</p>
<h3 id="timings"><a class="header" href="#timings">timings</a></h3>
<p><code>-Ztimings</code> 选项在1.60版本中已经稳定为 <code>--timings</code> 。
( <code>--timings=html</code> 和机器可读的 <code>--timings=json</code> 输出仍然不稳定，需要 <code>--Zunstable-options</code> 。)</p>
<h3 id="config-cli"><a class="header" href="#config-cli">config-cli</a></h3>
<p><code>--config</code> CLI选项在1.63版本中已经稳定。更多信息请参见 <a href="reference/config.html#command-line-overrides">config documentation</a>。</p>
<h3 id="multitarget"><a class="header" href="#multitarget">multitarget</a></h3>
<p><code>-Z multitarget</code> 选项在1.64版本中已经稳定了。参见 <a href="reference/config.html#buildtarget"><code>build.target</code></a> 以了解更多关于设置默认目标平台三元组的信息。</p>
<h3 id="crate-type"><a class="header" href="#crate-type">crate-type</a></h3>
<p>在1.64版本中，<code>cargo rustc</code> 的 <code>--crate-type</code> 标志已经稳定。更多信息请参见 <a href="reference/../commands/cargo-rustc.html"><code>cargo rustc</code> documentation</a> 。</p>
<h3 id="工作空间继承"><a class="header" href="#工作空间继承">工作空间继承</a></h3>
<p>工作空间继承在1.64版本中得到了稳定。
参见 <a href="reference/workspaces.html#the-package-table">workspace.package</a>,<a href="reference/workspaces.html#the-dependencies-table">workspace.dependencies</a>,和 <a href="reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace">inheriting-a-dependency-from-a-workspace</a> 获得更多信息。</p>
<h3 id="terminal-width"><a class="header" href="#terminal-width">terminal-width</a></h3>
<p>在1.68版本中， <code>-Z terminal-width</code> 选项已经稳定了。当从Cargo可以自动检测宽度的终端运行时，终端宽度总是被传递给编译器。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-commands"><a class="header" href="#cargo-commands">Cargo Commands</a></h1>
<ul>
<li><a href="commands/general-commands.html">General Commands</a></li>
<li><a href="commands/build-commands.html">Build Commands</a></li>
<li><a href="commands/manifest-commands.html">Manifest Commands</a></li>
<li><a href="commands/package-commands.html">Package Commands</a></li>
<li><a href="commands/publishing-commands.html">Publishing Commands</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-commands"><a class="header" href="#general-commands">General Commands</a></h1>
<ul>
<li><a href="commands/cargo.html">cargo</a></li>
<li><a href="commands/cargo-help.html">cargo help</a></li>
<li><a href="commands/cargo-version.html">cargo version</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo1"><a class="header" href="#cargo1">cargo(1)</a></h1>
<h2 id="name"><a class="header" href="#name">NAME</a></h2>
<p>cargo - The Rust package manager</p>
<h2 id="synopsis"><a class="header" href="#synopsis">SYNOPSIS</a></h2>
<p><code>cargo</code> [<em>options</em>] <em>command</em> [<em>args</em>]<br />
<code>cargo</code> [<em>options</em>] <code>--version</code><br />
<code>cargo</code> [<em>options</em>] <code>--list</code><br />
<code>cargo</code> [<em>options</em>] <code>--help</code><br />
<code>cargo</code> [<em>options</em>] <code>--explain</code> <em>code</em></p>
<h2 id="description"><a class="header" href="#description">DESCRIPTION</a></h2>
<p>This program is a package manager and build tool for the Rust language,
available at <a href="https://rust-lang.org">https://rust-lang.org</a>.</p>
<h2 id="commands"><a class="header" href="#commands">COMMANDS</a></h2>
<h3 id="build-commands"><a class="header" href="#build-commands">Build Commands</a></h3>
<p><a href="commands/cargo-bench.html">cargo-bench(1)</a><br />
    Execute benchmarks of a package.</p>
<p><a href="commands/cargo-build.html">cargo-build(1)</a><br />
    Compile a package.</p>
<p><a href="commands/cargo-check.html">cargo-check(1)</a><br />
    Check a local package and all of its dependencies for errors.</p>
<p><a href="commands/cargo-clean.html">cargo-clean(1)</a><br />
    Remove artifacts that Cargo has generated in the past.</p>
<p><a href="commands/cargo-doc.html">cargo-doc(1)</a><br />
    Build a package's documentation.</p>
<p><a href="commands/cargo-fetch.html">cargo-fetch(1)</a><br />
    Fetch dependencies of a package from the network.</p>
<p><a href="commands/cargo-fix.html">cargo-fix(1)</a><br />
    Automatically fix lint warnings reported by rustc.</p>
<p><a href="commands/cargo-run.html">cargo-run(1)</a><br />
    Run a binary or example of the local package.</p>
<p><a href="commands/cargo-rustc.html">cargo-rustc(1)</a><br />
    Compile a package, and pass extra options to the compiler.</p>
<p><a href="commands/cargo-rustdoc.html">cargo-rustdoc(1)</a><br />
    Build a package's documentation, using specified custom flags.</p>
<p><a href="commands/cargo-test.html">cargo-test(1)</a><br />
    Execute unit and integration tests of a package.</p>
<h3 id="manifest-commands"><a class="header" href="#manifest-commands">Manifest Commands</a></h3>
<p><a href="commands/cargo-generate-lockfile.html">cargo-generate-lockfile(1)</a><br />
    Generate <code>Cargo.lock</code> for a project.</p>
<p><a href="commands/cargo-locate-project.html">cargo-locate-project(1)</a><br />
    Print a JSON representation of a <code>Cargo.toml</code> file's location.</p>
<p><a href="commands/cargo-metadata.html">cargo-metadata(1)</a><br />
    Output the resolved dependencies of a package in machine-readable format.</p>
<p><a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a><br />
    Print a fully qualified package specification.</p>
<p><a href="commands/cargo-tree.html">cargo-tree(1)</a><br />
    Display a tree visualization of a dependency graph.</p>
<p><a href="commands/cargo-update.html">cargo-update(1)</a><br />
    Update dependencies as recorded in the local lock file.</p>
<p><a href="commands/cargo-vendor.html">cargo-vendor(1)</a><br />
    Vendor all dependencies locally.</p>
<p><a href="commands/cargo-verify-project.html">cargo-verify-project(1)</a><br />
    Check correctness of crate manifest.</p>
<h3 id="package-commands"><a class="header" href="#package-commands">Package Commands</a></h3>
<p><a href="commands/cargo-init.html">cargo-init(1)</a><br />
    Create a new Cargo package in an existing directory.</p>
<p><a href="commands/cargo-install.html">cargo-install(1)</a><br />
    Build and install a Rust binary.</p>
<p><a href="commands/cargo-new.html">cargo-new(1)</a><br />
    Create a new Cargo package.</p>
<p><a href="commands/cargo-search.html">cargo-search(1)</a><br />
    Search packages in crates.io.</p>
<p><a href="commands/cargo-uninstall.html">cargo-uninstall(1)</a><br />
    Remove a Rust binary.</p>
<h3 id="publishing-commands"><a class="header" href="#publishing-commands">Publishing Commands</a></h3>
<p><a href="commands/cargo-login.html">cargo-login(1)</a><br />
    Save an API token from the registry locally.</p>
<p><a href="commands/cargo-owner.html">cargo-owner(1)</a><br />
    Manage the owners of a crate on the registry.</p>
<p><a href="commands/cargo-package.html">cargo-package(1)</a><br />
    Assemble the local package into a distributable tarball.</p>
<p><a href="commands/cargo-publish.html">cargo-publish(1)</a><br />
    Upload a package to the registry.</p>
<p><a href="commands/cargo-yank.html">cargo-yank(1)</a><br />
    Remove a pushed crate from the index.</p>
<h3 id="general-commands-1"><a class="header" href="#general-commands-1">General Commands</a></h3>
<p><a href="commands/cargo-help.html">cargo-help(1)</a><br />
    Display help information about Cargo.</p>
<p><a href="commands/cargo-version.html">cargo-version(1)</a><br />
    Show version information.</p>
<h2 id="options"><a class="header" href="#options">OPTIONS</a></h2>
<h3 id="special-options"><a class="header" href="#special-options">Special Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo--V"><a class="option-anchor" href="commands/cargo.html#option-cargo--V"></a><code>-V</code></dt>
<dt class="option-term" id="option-cargo---version"><a class="option-anchor" href="commands/cargo.html#option-cargo---version"></a><code>--version</code></dt>
<dd class="option-desc">Print version info and exit. If used with <code>--verbose</code>, prints extra
information.</dd>
<dt class="option-term" id="option-cargo---list"><a class="option-anchor" href="commands/cargo.html#option-cargo---list"></a><code>--list</code></dt>
<dd class="option-desc">List all installed Cargo subcommands. If used with <code>--verbose</code>, prints extra
information.</dd>
<dt class="option-term" id="option-cargo---explain"><a class="option-anchor" href="commands/cargo.html#option-cargo---explain"></a><code>--explain</code> <em>code</em></dt>
<dd class="option-desc">Run <code>rustc --explain CODE</code> which will print out a detailed explanation of an
error message (for example, <code>E0004</code>).</dd>
</dl>
<h3 id="display-options"><a class="header" href="#display-options">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo--v"><a class="option-anchor" href="commands/cargo.html#option-cargo--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo---verbose"><a class="option-anchor" href="commands/cargo.html#option-cargo---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo--q"><a class="option-anchor" href="commands/cargo.html#option-cargo--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo---quiet"><a class="option-anchor" href="commands/cargo.html#option-cargo---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo---color"><a class="option-anchor" href="commands/cargo.html#option-cargo---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="manifest-options"><a class="header" href="#manifest-options">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo---frozen"><a class="option-anchor" href="commands/cargo.html#option-cargo---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo---locked"><a class="option-anchor" href="commands/cargo.html#option-cargo---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo---offline"><a class="option-anchor" href="commands/cargo.html#option-cargo---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options"><a class="header" href="#common-options">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-+toolchain"><a class="option-anchor" href="commands/cargo.html#option-cargo-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo---config"><a class="option-anchor" href="commands/cargo.html#option-cargo---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo--h"><a class="option-anchor" href="commands/cargo.html#option-cargo--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo---help"><a class="option-anchor" href="commands/cargo.html#option-cargo---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo--Z"><a class="option-anchor" href="commands/cargo.html#option-cargo--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment"><a class="header" href="#environment">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status"><a class="header" href="#exit-status">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="files"><a class="header" href="#files">FILES</a></h2>
<p><code>~/.cargo/</code><br />
    Default location for Cargo's &quot;home&quot; directory where it
stores various files. The location can be changed with the <code>CARGO_HOME</code>
environment variable.</p>
<p><code>$CARGO_HOME/bin/</code><br />
    Binaries installed by <a href="commands/cargo-install.html">cargo-install(1)</a> will be located here. If using
<a href="https://rust-lang.github.io/rustup/">rustup</a>, executables distributed with Rust are also located here.</p>
<p><code>$CARGO_HOME/config.toml</code><br />
    The global configuration file. See <a href="commands/../reference/config.html">the reference</a>
for more information about configuration files.</p>
<p><code>.cargo/config.toml</code><br />
    Cargo automatically searches for a file named <code>.cargo/config.toml</code> in the
current directory, and all parent directories. These configuration files
will be merged with the global configuration file.</p>
<p><code>$CARGO_HOME/credentials.toml</code><br />
    Private authentication information for logging in to a registry.</p>
<p><code>$CARGO_HOME/registry/</code><br />
    This directory contains cached downloads of the registry index and any
downloaded dependencies.</p>
<p><code>$CARGO_HOME/git/</code><br />
    This directory contains cached downloads of git dependencies.</p>
<p>Please note that the internal structure of the <code>$CARGO_HOME</code> directory is not
stable yet and may be subject to change.</p>
<h2 id="examples"><a class="header" href="#examples">EXAMPLES</a></h2>
<ol>
<li>
<p>Build a local package and all of its dependencies:</p>
<pre><code>cargo build
</code></pre>
</li>
<li>
<p>Build a package with optimizations:</p>
<pre><code>cargo build --release
</code></pre>
</li>
<li>
<p>Run tests for a cross-compiled target:</p>
<pre><code>cargo test --target i686-unknown-linux-gnu
</code></pre>
</li>
<li>
<p>Create a new package that builds an executable:</p>
<pre><code>cargo new foobar
</code></pre>
</li>
<li>
<p>Create a package in the current directory:</p>
<pre><code>mkdir foo &amp;&amp; cd foo
cargo init .
</code></pre>
</li>
<li>
<p>Learn about a command's options and usage:</p>
<pre><code>cargo help clean
</code></pre>
</li>
</ol>
<h2 id="bugs"><a class="header" href="#bugs">BUGS</a></h2>
<p>See <a href="https://github.com/rust-lang/cargo/issues">https://github.com/rust-lang/cargo/issues</a> for issues.</p>
<h2 id="see-also"><a class="header" href="#see-also">SEE ALSO</a></h2>
<p><a href="https://doc.rust-lang.org/rustc/index.html">rustc(1)</a>, <a href="https://doc.rust-lang.org/rustdoc/index.html">rustdoc(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-help1"><a class="header" href="#cargo-help1">cargo-help(1)</a></h1>
<h2 id="name-1"><a class="header" href="#name-1">NAME</a></h2>
<p>cargo-help - Get help for a Cargo command</p>
<h2 id="synopsis-1"><a class="header" href="#synopsis-1">SYNOPSIS</a></h2>
<p><code>cargo help</code> [<em>subcommand</em>]</p>
<h2 id="description-1"><a class="header" href="#description-1">DESCRIPTION</a></h2>
<p>Prints a help message for the given command.</p>
<h2 id="examples-1"><a class="header" href="#examples-1">EXAMPLES</a></h2>
<ol>
<li>
<p>Get help for a command:</p>
<pre><code>cargo help build
</code></pre>
</li>
<li>
<p>Help is also available with the <code>--help</code> flag:</p>
<pre><code>cargo build --help
</code></pre>
</li>
</ol>
<h2 id="see-also-1"><a class="header" href="#see-also-1">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-version1"><a class="header" href="#cargo-version1">cargo-version(1)</a></h1>
<h2 id="name-2"><a class="header" href="#name-2">NAME</a></h2>
<p>cargo-version - Show version information</p>
<h2 id="synopsis-2"><a class="header" href="#synopsis-2">SYNOPSIS</a></h2>
<p><code>cargo version</code> [<em>options</em>]</p>
<h2 id="description-2"><a class="header" href="#description-2">DESCRIPTION</a></h2>
<p>Displays the version of Cargo.</p>
<h2 id="options-1"><a class="header" href="#options-1">OPTIONS</a></h2>
<dl>
<dt class="option-term" id="option-cargo-version--v"><a class="option-anchor" href="commands/cargo-version.html#option-cargo-version--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-version---verbose"><a class="option-anchor" href="commands/cargo-version.html#option-cargo-version---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Display additional version information.</dd>
</dl>
<h2 id="examples-2"><a class="header" href="#examples-2">EXAMPLES</a></h2>
<ol>
<li>
<p>Display the version:</p>
<pre><code>cargo version
</code></pre>
</li>
<li>
<p>The version is also available via flags:</p>
<pre><code>cargo --version
cargo -V
</code></pre>
</li>
<li>
<p>Display extra version information:</p>
<pre><code>cargo -Vv
</code></pre>
</li>
</ol>
<h2 id="see-also-2"><a class="header" href="#see-also-2">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-commands-1"><a class="header" href="#build-commands-1">Build Commands</a></h1>
<ul>
<li><a href="commands/cargo-bench.html">cargo bench</a></li>
<li><a href="commands/cargo-build.html">cargo build</a></li>
<li><a href="commands/cargo-check.html">cargo check</a></li>
<li><a href="commands/cargo-clean.html">cargo clean</a></li>
<li><a href="commands/cargo-doc.html">cargo doc</a></li>
<li><a href="commands/cargo-fetch.html">cargo fetch</a></li>
<li><a href="commands/cargo-fix.html">cargo fix</a></li>
<li><a href="commands/cargo-run.html">cargo run</a></li>
<li><a href="commands/cargo-rustc.html">cargo rustc</a></li>
<li><a href="commands/cargo-rustdoc.html">cargo rustdoc</a></li>
<li><a href="commands/cargo-test.html">cargo test</a></li>
<li><a href="commands/cargo-report.html">cargo report</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-bench1"><a class="header" href="#cargo-bench1">cargo-bench(1)</a></h1>
<h2 id="name-3"><a class="header" href="#name-3">NAME</a></h2>
<p>cargo-bench - Execute benchmarks of a package</p>
<h2 id="synopsis-3"><a class="header" href="#synopsis-3">SYNOPSIS</a></h2>
<p><code>cargo bench</code> [<em>options</em>] [<em>benchname</em>] [<code>--</code> <em>bench-options</em>]</p>
<h2 id="description-3"><a class="header" href="#description-3">DESCRIPTION</a></h2>
<p>Compile and execute benchmarks.</p>
<p>The benchmark filtering argument <em>benchname</em> and all the arguments following
the two dashes (<code>--</code>) are passed to the benchmark binaries and thus to
<em>libtest</em> (rustc's built in unit-test and micro-benchmarking framework). If
you are passing arguments to both Cargo and the binary, the ones after <code>--</code> go
to the binary, the ones before go to Cargo. For details about libtest's
arguments see the output of <code>cargo bench -- --help</code> and check out the rustc
book's chapter on how tests work at
<a href="https://doc.rust-lang.org/rustc/tests/index.html">https://doc.rust-lang.org/rustc/tests/index.html</a>.</p>
<p>As an example, this will run only the benchmark named <code>foo</code> (and skip other
similarly named benchmarks like <code>foobar</code>):</p>
<pre><code>cargo bench -- foo --exact
</code></pre>
<p>Benchmarks are built with the <code>--test</code> option to <code>rustc</code> which creates a
special executable by linking your code with libtest. The executable
automatically runs all functions annotated with the <code>#[bench]</code> attribute.
Cargo passes the <code>--bench</code> flag to the test harness to tell it to run
only benchmarks.</p>
<p>The libtest harness may be disabled by setting <code>harness = false</code> in the target
manifest settings, in which case your code will need to provide its own <code>main</code>
function to handle running benchmarks.</p>
<blockquote>
<p><strong>Note</strong>: The
<a href="https://doc.rust-lang.org/nightly/unstable-book/library-features/test.html"><code>#[bench]</code> attribute</a>
is currently unstable and only available on the
<a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly channel</a>.
There are some packages available on
<a href="https://crates.io/keywords/benchmark">crates.io</a> that may help with
running benchmarks on the stable channel, such as
<a href="https://crates.io/crates/criterion">Criterion</a>.</p>
</blockquote>
<p>By default, <code>cargo bench</code> uses the <a href="commands/../reference/profiles.html#bench"><code>bench</code> profile</a>, which enables
optimizations and disables debugging information. If you need to debug a
benchmark, you can use the <code>--profile=dev</code> command-line option to switch to
the dev profile. You can then run the debug-enabled benchmark within a
debugger.</p>
<h2 id="options-2"><a class="header" href="#options-2">OPTIONS</a></h2>
<h3 id="benchmark-options"><a class="header" href="#benchmark-options">Benchmark Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench---no-run"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---no-run"></a><code>--no-run</code></dt>
<dd class="option-desc">Compile, but don't run benchmarks.</dd>
<dt class="option-term" id="option-cargo-bench---no-fail-fast"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---no-fail-fast"></a><code>--no-fail-fast</code></dt>
<dd class="option-desc">Run all benchmarks regardless of failure. Without this flag, Cargo will exit
after the first executable fails. The Rust test harness will run all benchmarks
within the executable to completion, this flag only applies to the executable
as a whole.</dd>
</dl>
<h3 id="package-selection"><a class="header" href="#package-selection">Package Selection</a></h3>
<p>By default, when no package selection options are given, the packages selected
depend on the selected manifest file (based on the current working directory if
<code>--manifest-path</code> is not given). If the manifest is the root of a workspace then
the workspaces default members are selected, otherwise only the package defined
by the manifest will be selected.</p>
<p>The default members of a workspace can be set explicitly with the
<code>workspace.default-members</code> key in the root manifest. If this is not set, a
virtual workspace will include all workspace members (equivalent to passing
<code>--workspace</code>), and a non-virtual workspace will include only the root crate itself.</p>
<dl>
<dt class="option-term" id="option-cargo-bench--p"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-bench---package"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Benchmark only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally 
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</dd>
<dt class="option-term" id="option-cargo-bench---workspace"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Benchmark all members in the workspace.</dd>
<dt class="option-term" id="option-cargo-bench---all"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---all"></a><code>--all</code></dt>
<dd class="option-desc">Deprecated alias for <code>--workspace</code>.</dd>
<dt class="option-term" id="option-cargo-bench---exclude"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</dd>
</dl>
<h3 id="target-selection"><a class="header" href="#target-selection">Target Selection</a></h3>
<p>When no target selection options are given, <code>cargo bench</code> will build the
following targets of the selected packages:</p>
<ul>
<li>lib — used to link with binaries and benchmarks</li>
<li>bins (only if benchmark targets are built and required features are
available)</li>
<li>lib as a benchmark</li>
<li>bins as benchmarks</li>
<li>benchmark targets</li>
</ul>
<p>The default behavior can be changed by setting the <code>bench</code> flag for the target
in the manifest settings. Setting examples to <code>bench = true</code> will build and
run the example as a benchmark. Setting targets to <code>bench = false</code> will stop
them from being benchmarked by default. Target selection options that take a
target by name ignore the <code>bench</code> flag and will always benchmark the given
target.</p>
<p>Binary targets are automatically built if there is an integration test or
benchmark being selected to benchmark. This allows an integration
test to execute the binary to exercise and test its behavior. 
The <code>CARGO_BIN_EXE_&lt;name&gt;</code>
<a href="commands/../reference/environment-variables.html#environment-variables-cargo-sets-for-crates">environment variable</a>
is set when the integration test is built so that it can use the
<a href="https://doc.rust-lang.org/std/macro.env.html"><code>env</code> macro</a> to locate the
executable.</p>
<p>Passing target selection flags will benchmark only the specified
targets. </p>
<p>Note that <code>--bin</code>, <code>--example</code>, <code>--test</code> and <code>--bench</code> flags also 
support common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your 
shell accidentally expanding glob patterns before Cargo handles them, you must 
use single quotes or double quotes around each glob pattern.</p>
<dl>
<dt class="option-term" id="option-cargo-bench---lib"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Benchmark the package's library.</dd>
<dt class="option-term" id="option-cargo-bench---bin"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Benchmark the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-bench---bins"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Benchmark all binary targets.</dd>
<dt class="option-term" id="option-cargo-bench---example"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Benchmark the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-bench---examples"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Benchmark all example targets.</dd>
<dt class="option-term" id="option-cargo-bench---test"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Benchmark the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-bench---tests"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Benchmark all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-bench---bench"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Benchmark the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-bench---benches"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Benchmark all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-bench---all-targets"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Benchmark all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<h3 id="feature-selection"><a class="header" href="#feature-selection">Feature Selection</a></h3>
<p>The feature flags allow you to control which features are enabled. When no
feature options are given, the <code>default</code> feature is activated for every
selected package.</p>
<p>See <a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>
for more details.</p>
<dl>
<dt class="option-term" id="option-cargo-bench--F"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--F"></a><code>-F</code> <em>features</em></dt>
<dt class="option-term" id="option-cargo-bench---features"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-bench---all-features"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-bench---no-default-features"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options"><a class="header" href="#compilation-options">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench---target"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Benchmark for the given architecture. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets. This flag may be specified multiple times.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-bench---profile"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Benchmark with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-bench---ignore-rust-version"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Benchmark the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
<dt class="option-term" id="option-cargo-bench---timings=fmts"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---timings=fmts"></a><code>--timings=</code><em>fmts</em></dt>
<dd class="option-desc">Output information how long each compilation takes, and track concurrency
information over time. Accepts an optional comma-separated list of output
formats; <code>--timings</code> without an argument will default to <code>--timings=html</code>.
Specifying an output format (rather than the default) is unstable and requires
<code>-Zunstable-options</code>. Valid output formats:</p>
<ul>
<li><code>html</code> (unstable, requires <code>-Zunstable-options</code>): Write a human-readable file <code>cargo-timing.html</code> to the
<code>target/cargo-timings</code> directory with a report of the compilation. Also write
a report to the same directory with a timestamp in the filename if you want
to look at older runs. HTML output is suitable for human consumption only,
and does not provide machine-readable timing data.</li>
<li><code>json</code> (unstable, requires <code>-Zunstable-options</code>): Emit machine-readable JSON
information about timing information.</li>
</ul></dd>
</dl>
<h3 id="output-options"><a class="header" href="#output-options">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench---target-dir"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="display-options-1"><a class="header" href="#display-options-1">Display Options</a></h3>
<p>By default the Rust test harness hides output from benchmark execution to keep
results readable. Benchmark output can be recovered (e.g., for debugging) by
passing <code>--nocapture</code> to the benchmark binaries:</p>
<pre><code>cargo bench -- --nocapture
</code></pre>
<dl>
<dt class="option-term" id="option-cargo-bench--v"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-bench---verbose"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-bench--q"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-bench---quiet"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-bench---color"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-bench---message-format"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3 id="manifest-options-1"><a class="header" href="#manifest-options-1">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench---manifest-path"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-bench---frozen"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-bench---locked"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-bench---offline"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-1"><a class="header" href="#common-options-1">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench-+toolchain"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-bench---config"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-bench--h"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-bench---help"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-bench--Z"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3 id="miscellaneous-options"><a class="header" href="#miscellaneous-options">Miscellaneous Options</a></h3>
<p>The <code>--jobs</code> argument affects the building of the benchmark executable but
does not affect how many threads are used when running the benchmarks. The
Rust test harness runs benchmarks serially in a single thread.</p>
<dl>
<dt class="option-term" id="option-cargo-bench--j"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-bench---jobs"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value.
Should not be 0.</dd>
<dt class="option-term" id="option-cargo-bench---keep-going"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---keep-going"></a><code>--keep-going</code></dt>
<dd class="option-desc">Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build. Unstable, requires
<code>-Zunstable-options</code>.</dd>
</dl>
<h2 id="environment-1"><a class="header" href="#environment-1">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-1"><a class="header" href="#exit-status-1">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-3"><a class="header" href="#examples-3">EXAMPLES</a></h2>
<ol>
<li>
<p>Build and execute all the benchmarks of the current package:</p>
<pre><code>cargo bench
</code></pre>
</li>
<li>
<p>Run only a specific benchmark within a specific benchmark target:</p>
<pre><code>cargo bench --bench bench_name -- modname::some_benchmark
</code></pre>
</li>
</ol>
<h2 id="see-also-3"><a class="header" href="#see-also-3">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-test.html">cargo-test(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-build1"><a class="header" href="#cargo-build1">cargo-build(1)</a></h1>
<h2 id="定义"><a class="header" href="#定义">定义</a></h2>
<p>cargo-build - 编译当前package</p>
<h2 id="概要"><a class="header" href="#概要">概要</a></h2>
<p><code>cargo build</code> [<em>options</em>]</p>
<h2 id="说明"><a class="header" href="#说明">说明</a></h2>
<p>编译本地package以及它们的依赖</p>
<h2 id="选项"><a class="header" href="#选项">选项</a></h2>
<h3 id="package-的选择"><a class="header" href="#package-的选择">Package 的选择</a></h3>
<p>默认情况下，当package选择选项没有给出时，package的选择依赖于指定的清单文件(若没有给出 <code>--manifest-path</code> 参数，则为当前目录下的清单文件)。
如果清单文件是workspace的根，那么workspace的默认成员被选择，否则，只有被定义在清单文件中的package会被选择。</p>
<p>workspace默认的成员可以通过根清单文件中的 <code>workspace.default-members</code> 键指定，
如果没有指定该键，则会生成一个虚拟的workspace包含所有的workspace成员
(等同于直接传入 <code>--workspace</code> 参数)，并且非虚拟的workspace将只包含根crate自身。</p>
<dl>
<dt class="option-term" id="option-cargo-build--p"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-build---package"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">只包含特定的package。 要了解SPEC格式，请参阅<a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> 该标识可被指定多次，并且支持通用Unix通配符(common Unix glob patterns),例如:
<code>*</code>, <code>?</code> 和 <code>[]</code>。 然而, 为了避免shell在Cargo处理他们之前将通配符意外的展开
, 必须使用单引号或者双引号将模式串包住。</dd>
<dt class="option-term" id="option-cargo-build---workspace"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">在workspace中构建全部成员。</dd>
<dt class="option-term" id="option-cargo-build---all"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---all"></a><code>--all</code></dt>
<dd class="option-desc">是 <code>--workspace</code>已经弃用的别名。</dd>
<dt class="option-term" id="option-cargo-build---exclude"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">排除指定的package，必须与
<code>--workspace</code> 标识连用。该标识可以被指定多次，并且支持Unix通配符(common Unix glob patterns)，例如<code>*</code>, <code>?</code> 和 <code>[]</code>。 然而, 为了避免shell在Cargo处理他们之前将通配符意外的展开
, 必须使用单引号或者双引号将模式串包住。</dd>
</dl>
<h3 id="构建目标的选择"><a class="header" href="#构建目标的选择">构建目标的选择</a></h3>
<p>当没有目标选择选项给出的时候，<code>cargo build</code> 将构建所有的选定的package中的binary和library目标。
如果Binary的 <code>required-features</code> 有缺失，则Binary构建将被跳过</p>
<p>如果集成测试或者基准测试被指定构建，则Binary目标将被自动构建。这允许了集成测试执行binary用以测试它们的行为。
在构建集成测试时设置 <code>CARGO_BIN_EXE_&lt;name&gt;</code> 
<a href="commands/../reference/environment-variables.html#environment-variables-cargo-sets-for-crates">环境变量</a>
以便于它可以使用<a href="https://doc.rust-lang.org/std/macro.env.html"><code>env</code> 宏</a> 来定位可执行文件。</p>
<p>传入目标选择参数将只构建指定的目标。 </p>
<p>需要注意的是<code>--bin</code>, <code>--example</code>, <code>--test</code> 和 <code>--bench</code> 标志同样支持Unix通配符(common Unix glob patterns)，例如 <code>*</code>, <code>?</code> 和 <code>[]</code>。
然而, 为了避免shell在Cargo处理他们之前将通配符意外的展开, 必须使用单引号或者双引号将模式串包住。</p>
<dl>
<dt class="option-term" id="option-cargo-build---lib"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---lib"></a><code>--lib</code></dt>
<dd class="option-desc">构建package的library。</dd>
<dt class="option-term" id="option-cargo-build---bin"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">构建指定的binary，该标识可以被指定多次，并且支持Unix通配符。</dd>
<dt class="option-term" id="option-cargo-build---bins"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---bins"></a><code>--bins</code></dt>
<dd class="option-desc">构建所有的binary目标。</dd>
<dt class="option-term" id="option-cargo-build---example"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">构建指定的示例，该标识可以被指定多次，并且支持Unix通配符。</dd>
<dt class="option-term" id="option-cargo-build---examples"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---examples"></a><code>--examples</code></dt>
<dd class="option-desc">构建所有的示例。</dd>
<dt class="option-term" id="option-cargo-build---test"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">构建指定的集成测试，该标识可以被指定多次，并且支持Unix通配符。</dd>
<dt class="option-term" id="option-cargo-build---tests"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---tests"></a><code>--tests</code></dt>
<dd class="option-desc">在测试模式下构建所有清单文件中带有 <code>test = true</code> 标识的目标，默认情况下，这将包含作为单元测试和集成测试构建的library和binary
当心这也会构建所需要的依赖，因此，library目标有可能被构建两次(一次作为单元测试，一次作为binary或集成测试等目标的依赖。)。
通过在目标的清单文件设置中设置 <code>test</code> 标志，可以启用或禁用目标。 
</dd>
<dt class="option-term" id="option-cargo-build---bench"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">构建指定的基准测试，该标识可以被指定多次，并且支持Unix通配符。</dd>
<dt class="option-term" id="option-cargo-build---benches"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---benches"></a><code>--benches</code></dt>
<dd class="option-desc">在基准测试模式下构建所有清单文件中带有 <code>bench = true</code> 标识的目标，默认情况下，这将包含作为基准测试或基准测试目标构建的library和binary
当心这也会构建所需要的依赖，因此，library目标有可能被构建两次(一次作为基准测试，一次作为binary或基准测试等目标的依赖。)。
通过在目标的清单文件设置中设置 <code>bench</code> 标志，可以选择是否启用。 </dd>
<dt class="option-term" id="option-cargo-build---all-targets"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">构建所有的目标，等同于 <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<h3 id="特性选择"><a class="header" href="#特性选择">特性选择</a></h3>
<p>特性选择标识可以用来控制哪些特性被启用。当没有设置特性选项时， <code>default</code> 特性将在所有被选择的package中被激活。</p>
<p>查阅 <a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a> 以获取更多细节</p>
<dl>
<dt class="option-term" id="option-cargo-build--F"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--F"></a><code>-F</code> <em>features</em></dt>
<dt class="option-term" id="option-cargo-build---features"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">要激活的特性列表，特性间用空格逗号隔开。workspace的成员的特性可以通过 <code>package-name/feature-name</code> 来启用。
该标志可以被设置多次，将启用所有给出的特性。</dd>
<dt class="option-term" id="option-cargo-build---all-features"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">激活选中package的所有特性</dd>
<dt class="option-term" id="option-cargo-build---no-default-features"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">不激活选中的package的 <code>default</code> 特性</dd>
</dl>
<h3 id="编译选项"><a class="header" href="#编译选项">编译选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build---target"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">为指定的CPU架构构建. 默认情况下是当前主机的架构. 参数中的三元组的一般格式是
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. 运行 <code>rustc --print target-list</code> 来获取支持的架构列表 </p>
<p>也可以通过 <code>build.target</code> 来指定，
<a href="commands/../reference/config.html"> 可能的值 </a>.</p>
<p>需要注意的是，指定该标识将令Cargo在不同的模式下运行，其中目标产物将放到单独的目录中，详情查看
<a href="commands/../guide/build-cache.html">build cache</a></dd>
<dt class="option-term" id="option-cargo-build--r"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-build---release"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---release"></a><code>--release</code></dt>
<dd class="option-desc">通过清单文件中 <code>release</code> 配置项目(profile)，以构建出优化过的产物。
参阅 <code>--profile</code> 选项了解如何按照指定的配置项目构建</dd>
<dt class="option-term" id="option-cargo-build---profile"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">通过给定的profile构建
参阅 <a href="commands/../reference/profiles.html">参考手册</a> 获取更多关于profile的细节。</dd>
<dt class="option-term" id="option-cargo-build---ignore-rust-version"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">即使cargo低于项目中 <code>rust-version</code> 字段要求的cargo最低版本，也继续构建 </dd>
<dt class="option-term" id="option-cargo-build---timings=fmts"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---timings=fmts"></a><code>--timings=</code><em>fmts</em></dt>
<dd class="option-desc">输出每个编译过程所花费的时间，以及随着时间变化的并行执行情况，可以接收通过逗号分隔的可选的参数，来定义输出的格式 <code>--timings</code> 如果后面不跟参数将，将默认看作 <code>--timings=html</code>。
给出输出格式(除了默认)是不稳定的的功能，需要加上
<code>-Zunstable-options</code>。 有效的格式有:</p>
<ul>
<li><code>html</code> (不稳定, 需要 <code>-Zunstable-options</code>): 生成一个适合人类阅读的的耗时报告文件 <code>cargo-timing.html</code> ，保存到
<code>target/cargo-timings</code> 目录下。 同时也在同目录下生成一个相同内容的用时间戳命名的报告，方便再次编译将前者覆盖后查看。
HTML 输出只适合人类阅读，并且不会提供适合机器阅读的耗时数据 </li>
<li><code>json</code> (不稳定, 需要 <code>-Zunstable-options</code>): 生成适合机器阅读的JSON格式的耗时信息</li>
</ul></dd>
</dl>
<h3 id="输出选项"><a class="header" href="#输出选项">输出选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build---target-dir"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc"> 所有生成目标产物以及中间文件存放的目录，也可通过 <code>CARGO_TARGET_DIR</code> 环境变量指定, 又或者通过 <code>build.target-dir</code> <a href="commands/../reference/config.html">配置值</a>。
默认将保存到workspace根目录下的<code>target</code> 目录下 </dd>
<dt class="option-term" id="option-cargo-build---out-dir"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---out-dir"></a><code>--out-dir</code> <em>directory</em></dt>
<dd class="option-desc">复制最终产物到指定目录.</p>
<p>该选项是不稳定的，只在
<a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly channel</a>
以及 <code>-Z unstable-options</code> 标志被设置才能启用。
查阅 <a href="https://github.com/rust-lang/cargo/issues/6790">https://github.com/rust-lang/cargo/issues/6790</a> 获取更多信息。</dd>
</dl>
<h3 id="显示选项"><a class="header" href="#显示选项">显示选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build--v"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-build---verbose"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">输出冗余信息。 指定两次该选项表示 &quot;非常冗长&quot; 输出一些诸如依赖警告或是编译一脚本的输出一类的信息
也可通过 <code>term.verbose</code> 配置项指定
<a href="commands/../reference/config.html">可选值</a>。</dd>
<dt class="option-term" id="option-cargo-build--q"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-build---quiet"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc"> 不输出cargo日志信息。也可通过<code>term.quiet</code> 配置项指定
<a href="commands/../reference/config.html">可选值</a>.</dd>
<dt class="option-term" id="option-cargo-build---color"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制何时输出彩色信息，可选值:</p>
<ul>
<li><code>auto</code> (默认): 自动检测终端是否支持彩色。</li>
<li><code>always</code>: 总是输出彩色信息。</li>
<li><code>never</code>: 从不输出彩色信息。</li>
</ul>
<p>也可通过 <code>term.color</code> 配置项指定
<a href="commands/../reference/config.html">可选值</a>。</dd>
<dt class="option-term" id="option-cargo-build---message-format"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">指定输出诊断信息的格式。可以被指定多次，值由逗号隔开，有效的值有:</p>
<ul>
<li><code>human</code> (default): 显示适合人类阅读的文本信息. 与
<code>short</code> 和 <code>json</code>冲突。</li>
<li><code>short</code>: 输出更短的, 适合人类阅读的信息。 与 <code>human</code>
和 <code>json</code>冲突</li>
<li><code>json</code>: 输出json信息到stdout。 查阅
<a href="commands/../reference/external-tools.html#json-messages">参考手册</a>
以获取详细信息。与 <code>human</code> 和 <code>short</code>冲突。</li>
<li><code>json-diagnostic-short</code>: 确保JSON的 <code>rendered</code> 字段包含 &quot;short&quot; 由rustc渲染。 不可以与 <code>human</code> 或者 <code>short</code>同时使用。</li>
<li><code>json-diagnostic-rendered-ansi</code>: 确保JSON的 <code>rendered</code> 字段包含ANSI颜色码，以符合rustc的默认颜色方案，不可以与 <code>human</code> 或者 <code>short</code>同时使用。</li>
<li><code>json-render-diagnostics</code>: 指导Cargo输出的JSON消息不要包含rustc的诊断信息，而是让Cargo自己渲染rustc的诊断信息， 但是Cargo自己的JSON诊断和来自rustc的其他诊断保留。不可以与<code>human</code> 或者 <code>short</code>同时使用。</li>
</ul></dd>
<dt class="option-term" id="option-cargo-build---build-plan"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---build-plan"></a><code>--build-plan</code></dt>
<dd class="option-desc">输出一系列的JSON消息到指示要运行的命令的stdout</p>
<p>该选项尚且不稳定，只有在
<a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly channel</a>
且<code>-Z unstable-options</code> 被指定时才可以开启。
查阅 <a href="https://github.com/rust-lang/cargo/issues/5579">https://github.com/rust-lang/cargo/issues/5579</a> 以获取更多信息.</dd>
</dl>
<h3 id="清单选项"><a class="header" href="#清单选项">清单选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build---manifest-path"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc"> <code>Cargo.toml</code> 的路径. 默认情况下Cargo将搜索当前目录或所有父目录下的
<code>Cargo.toml</code> 文件。</dd>
<dt class="option-term" id="option-cargo-build---frozen"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-build---locked"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这些标志中的每一个都要求 <code>Cargo.lock</code> 文件是最新的。
如果lock文件丢失, 或是需要被更新, Cargo会返回错误并退出， <code>--frozen</code> 选项还会阻止cargo通过网络来判断它是否过期。</p>
<p> 这些可能用于你希望断言 <code>Cargo.lock</code> 文件是最新的(例如CI构建)或希望避免网络访问的环境。</dd>
<dt class="option-term" id="option-cargo-build---offline"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---offline"></a><code>--offline</code></dt>
<dd class="option-desc">组织Cargo以任何原因访问互联网。如果不指定该选项，Cargo将会在需要使用网络但网络不可用时停止构建并返回错误。该标识被设置时，Cargo将尽可能不使用网络完成构建。 </p>
<p>需要注意的是，这样可能会导致在不同于online模式的依赖处理，Cargo将限制只使用已经下载到本地的crate，即使索引的本地副本中可能有更新版本。
查阅 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 命令在脱机前下载依赖。 </p>
<p>也可以使用 <code>net.offline</code> 配置 <a href="commands/../reference/config.html">可选值</a>。</dd>
</dl>
<h3 id="一般选项"><a class="header" href="#一般选项">一般选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build-+toolchain"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">如果Cargo已经通过rustup安装，并且第一个传入 <code>cargo</code> 的参数以 <code>+</code> 开头，
则它将被视作rustup的一个工具链名称。（例如 <code>+stable</code> 或者 <code>+nightly</code>).
查阅 <a href="https://rust-lang.github.io/rustup/overrides.html">rustup 文档</a>
获取关于工具链重载如何工作的信息。</dd>
<dt class="option-term" id="option-cargo-build---config"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">重写一个Cargo配置项的值，该参数应当为TOML的 <code>KEY=VALUE</code> 的语法，
或者提供一个附加的配置文件的路径，该标识可以被指定多次，
查阅 <a href="commands/../reference/config.html#command-line-overrides">命令行重写部分</a> 获取更多信息</dd>
<dt class="option-term" id="option-cargo-build--h"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-build---help"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---help"></a><code>--help</code></dt>
<dd class="option-desc">输出帮助信息。</dd>
<dt class="option-term" id="option-cargo-build--Z"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">不稳定的(只在nightly下可用的)标志。运行 <code>cargo -Z help</code> 获取细节。</dd>
</dl>
<h3 id="杂项"><a class="header" href="#杂项">杂项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build--j"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-build---jobs"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">并行执行的数量。也可以通过 <code>build.jobs</code> 配置 <a href="commands/../reference/config.html">可选值</a> 
默认为逻辑CPU个数。如果是给出负数，将采用逻辑逻辑CPU数量+传入的负数。</dd>
<dt class="option-term" id="option-cargo-build---keep-going"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---keep-going"></a><code>--keep-going</code></dt>
<dd class="option-desc">在依赖关系图中构建尽可能多的crate，而不是在遇到第一个构建失败的crate就中止构建，不稳定，需要
<code>-Zunstable-options</code>选项。</dd>
<dt class="option-term" id="option-cargo-build---future-incompat-report"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---future-incompat-report"></a><code>--future-incompat-report</code></dt>
<dd class="option-desc">显示一个未来兼容性报告，包含在执行命令时输出的所有的“未来不可用的”(future-incompatible)警告信息。</p>
<p>查阅 <a href="commands/cargo-report.html">cargo-report(1)</a>获取更多信息</dd>
</dl>
<h2 id="环境-1"><a class="header" href="#环境-1">环境</a></h2>
<p>查阅 <a href="commands/../reference/environment-variables.html">参考手册</a> 获取Cargo会读取的环境变量。</p>
<h2 id="退出状态"><a class="header" href="#退出状态">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo 成功退出。</li>
<li><code>101</code>: Cargo 未能完成。</li>
</ul>
<h2 id="例子-1"><a class="header" href="#例子-1">例子</a></h2>
<ol>
<li>
<p>构建本地package以及它的全部依赖。</p>
<pre><code>cargo build
</code></pre>
</li>
<li>
<p>带有编译优化的构建:</p>
<pre><code>cargo build --release
</code></pre>
</li>
</ol>
<h2 id="请参阅"><a class="header" href="#请参阅">请参阅</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-rustc.html">cargo-rustc(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-check1"><a class="header" href="#cargo-check1">cargo-check(1)</a></h1>
<h2 id="name-4"><a class="header" href="#name-4">NAME</a></h2>
<p>cargo-check - Check the current package</p>
<h2 id="synopsis-4"><a class="header" href="#synopsis-4">SYNOPSIS</a></h2>
<p><code>cargo check</code> [<em>options</em>]</p>
<h2 id="description-4"><a class="header" href="#description-4">DESCRIPTION</a></h2>
<p>Check a local package and all of its dependencies for errors. This will
essentially compile the packages without performing the final step of code
generation, which is faster than running <code>cargo build</code>. The compiler will save
metadata files to disk so that future runs will reuse them if the source has
not been modified. Some diagnostics and errors are only emitted during code
generation, so they inherently won't be reported with <code>cargo check</code>.</p>
<h2 id="options-3"><a class="header" href="#options-3">OPTIONS</a></h2>
<h3 id="package-selection-1"><a class="header" href="#package-selection-1">Package Selection</a></h3>
<p>By default, when no package selection options are given, the packages selected
depend on the selected manifest file (based on the current working directory if
<code>--manifest-path</code> is not given). If the manifest is the root of a workspace then
the workspaces default members are selected, otherwise only the package defined
by the manifest will be selected.</p>
<p>The default members of a workspace can be set explicitly with the
<code>workspace.default-members</code> key in the root manifest. If this is not set, a
virtual workspace will include all workspace members (equivalent to passing
<code>--workspace</code>), and a non-virtual workspace will include only the root crate itself.</p>
<dl>
<dt class="option-term" id="option-cargo-check--p"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-check---package"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Check only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally 
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</dd>
<dt class="option-term" id="option-cargo-check---workspace"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Check all members in the workspace.</dd>
<dt class="option-term" id="option-cargo-check---all"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---all"></a><code>--all</code></dt>
<dd class="option-desc">Deprecated alias for <code>--workspace</code>.</dd>
<dt class="option-term" id="option-cargo-check---exclude"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</dd>
</dl>
<h3 id="target-selection-1"><a class="header" href="#target-selection-1">Target Selection</a></h3>
<p>When no target selection options are given, <code>cargo check</code> will check all
binary and library targets of the selected packages. Binaries are skipped if
they have <code>required-features</code> that are missing.</p>
<p>Passing target selection flags will check only the specified
targets. </p>
<p>Note that <code>--bin</code>, <code>--example</code>, <code>--test</code> and <code>--bench</code> flags also 
support common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your 
shell accidentally expanding glob patterns before Cargo handles them, you must 
use single quotes or double quotes around each glob pattern.</p>
<dl>
<dt class="option-term" id="option-cargo-check---lib"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Check the package's library.</dd>
<dt class="option-term" id="option-cargo-check---bin"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Check the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-check---bins"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Check all binary targets.</dd>
<dt class="option-term" id="option-cargo-check---example"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Check the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-check---examples"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Check all example targets.</dd>
<dt class="option-term" id="option-cargo-check---test"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Check the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-check---tests"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Check all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-check---bench"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Check the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-check---benches"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Check all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-check---all-targets"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Check all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<h3 id="feature-selection-1"><a class="header" href="#feature-selection-1">Feature Selection</a></h3>
<p>The feature flags allow you to control which features are enabled. When no
feature options are given, the <code>default</code> feature is activated for every
selected package.</p>
<p>See <a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>
for more details.</p>
<dl>
<dt class="option-term" id="option-cargo-check--F"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--F"></a><code>-F</code> <em>features</em></dt>
<dt class="option-term" id="option-cargo-check---features"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-check---all-features"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-check---no-default-features"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options-1"><a class="header" href="#compilation-options-1">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check---target"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Check for the given architecture. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets. This flag may be specified multiple times.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-check--r"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-check---release"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---release"></a><code>--release</code></dt>
<dd class="option-desc">Check optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-check---profile"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Check with the given profile.</p>
<p>As a special case, specifying the <code>test</code> profile will also enable checking in
test mode which will enable checking tests and enable the <code>test</code> cfg option.
See <a href="https://doc.rust-lang.org/rustc/tests/index.html">rustc tests</a> for more
detail.</p>
<p>See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-check---ignore-rust-version"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Check the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
<dt class="option-term" id="option-cargo-check---timings=fmts"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---timings=fmts"></a><code>--timings=</code><em>fmts</em></dt>
<dd class="option-desc">Output information how long each compilation takes, and track concurrency
information over time. Accepts an optional comma-separated list of output
formats; <code>--timings</code> without an argument will default to <code>--timings=html</code>.
Specifying an output format (rather than the default) is unstable and requires
<code>-Zunstable-options</code>. Valid output formats:</p>
<ul>
<li><code>html</code> (unstable, requires <code>-Zunstable-options</code>): Write a human-readable file <code>cargo-timing.html</code> to the
<code>target/cargo-timings</code> directory with a report of the compilation. Also write
a report to the same directory with a timestamp in the filename if you want
to look at older runs. HTML output is suitable for human consumption only,
and does not provide machine-readable timing data.</li>
<li><code>json</code> (unstable, requires <code>-Zunstable-options</code>): Emit machine-readable JSON
information about timing information.</li>
</ul></dd>
</dl>
<h3 id="output-options-1"><a class="header" href="#output-options-1">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check---target-dir"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="display-options-2"><a class="header" href="#display-options-2">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check--v"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-check---verbose"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-check--q"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-check---quiet"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-check---color"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-check---message-format"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3 id="manifest-options-2"><a class="header" href="#manifest-options-2">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check---manifest-path"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-check---frozen"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-check---locked"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-check---offline"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-2"><a class="header" href="#common-options-2">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check-+toolchain"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-check---config"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-check--h"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-check---help"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-check--Z"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3 id="miscellaneous-options-1"><a class="header" href="#miscellaneous-options-1">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check--j"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-check---jobs"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value.
Should not be 0.</dd>
<dt class="option-term" id="option-cargo-check---keep-going"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---keep-going"></a><code>--keep-going</code></dt>
<dd class="option-desc">Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build. Unstable, requires
<code>-Zunstable-options</code>.</dd>
<dt class="option-term" id="option-cargo-check---future-incompat-report"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---future-incompat-report"></a><code>--future-incompat-report</code></dt>
<dd class="option-desc">Displays a future-incompat report for any future-incompatible warnings
produced during execution of this command</p>
<p>See <a href="commands/cargo-report.html">cargo-report(1)</a></dd>
</dl>
<h2 id="environment-2"><a class="header" href="#environment-2">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-2"><a class="header" href="#exit-status-2">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-4"><a class="header" href="#examples-4">EXAMPLES</a></h2>
<ol>
<li>
<p>Check the local package for errors:</p>
<pre><code>cargo check
</code></pre>
</li>
<li>
<p>Check all targets, including unit tests:</p>
<pre><code>cargo check --all-targets --profile=test
</code></pre>
</li>
</ol>
<h2 id="see-also-4"><a class="header" href="#see-also-4">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-build.html">cargo-build(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-clean1"><a class="header" href="#cargo-clean1">cargo-clean(1)</a></h1>
<h2 id="name-5"><a class="header" href="#name-5">NAME</a></h2>
<p>cargo-clean - Remove generated artifacts</p>
<h2 id="synopsis-5"><a class="header" href="#synopsis-5">SYNOPSIS</a></h2>
<p><code>cargo clean</code> [<em>options</em>]</p>
<h2 id="description-5"><a class="header" href="#description-5">DESCRIPTION</a></h2>
<p>Remove artifacts from the target directory that Cargo has generated in the
past.</p>
<p>With no options, <code>cargo clean</code> will delete the entire target directory.</p>
<h2 id="options-4"><a class="header" href="#options-4">OPTIONS</a></h2>
<h3 id="package-selection-2"><a class="header" href="#package-selection-2">Package Selection</a></h3>
<p>When no packages are selected, all packages and all dependencies in the
workspace are cleaned.</p>
<dl>
<dt class="option-term" id="option-cargo-clean--p"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-clean---package"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Clean only the specified packages. This flag may be specified
multiple times. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC format.</dd>
</dl>
<h3 id="clean-options"><a class="header" href="#clean-options">Clean Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-clean---doc"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---doc"></a><code>--doc</code></dt>
<dd class="option-desc">This option will cause <code>cargo clean</code> to remove only the <code>doc</code> directory in
the target directory.</dd>
<dt class="option-term" id="option-cargo-clean---release"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---release"></a><code>--release</code></dt>
<dd class="option-desc">Remove all artifacts in the <code>release</code> directory.</dd>
<dt class="option-term" id="option-cargo-clean---profile"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Remove all artifacts in the directory with the given profile name.</dd>
<dt class="option-term" id="option-cargo-clean---target-dir"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
<dt class="option-term" id="option-cargo-clean---target"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Clean for the given architecture. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets. This flag may be specified multiple times.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
</dl>
<h3 id="display-options-3"><a class="header" href="#display-options-3">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-clean--v"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-clean---verbose"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-clean--q"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-clean---quiet"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-clean---color"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="manifest-options-3"><a class="header" href="#manifest-options-3">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-clean---manifest-path"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-clean---frozen"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-clean---locked"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-clean---offline"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-3"><a class="header" href="#common-options-3">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-clean-+toolchain"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-clean---config"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-clean--h"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-clean---help"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-clean--Z"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-3"><a class="header" href="#environment-3">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-3"><a class="header" href="#exit-status-3">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-5"><a class="header" href="#examples-5">EXAMPLES</a></h2>
<ol>
<li>
<p>Remove the entire target directory:</p>
<pre><code>cargo clean
</code></pre>
</li>
<li>
<p>Remove only the release artifacts:</p>
<pre><code>cargo clean --release
</code></pre>
</li>
</ol>
<h2 id="see-also-5"><a class="header" href="#see-also-5">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-build.html">cargo-build(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-doc1"><a class="header" href="#cargo-doc1">cargo-doc(1)</a></h1>
<h2 id="name-6"><a class="header" href="#name-6">NAME</a></h2>
<p>cargo-doc - Build a package's documentation</p>
<h2 id="synopsis-6"><a class="header" href="#synopsis-6">SYNOPSIS</a></h2>
<p><code>cargo doc</code> [<em>options</em>]</p>
<h2 id="description-6"><a class="header" href="#description-6">DESCRIPTION</a></h2>
<p>Build the documentation for the local package and all dependencies. The output
is placed in <code>target/doc</code> in rustdoc's usual format.</p>
<h2 id="options-5"><a class="header" href="#options-5">OPTIONS</a></h2>
<h3 id="documentation-options"><a class="header" href="#documentation-options">Documentation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc---open"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---open"></a><code>--open</code></dt>
<dd class="option-desc">Open the docs in a browser after building them. This will use your default
browser unless you define another one in the <code>BROWSER</code> environment variable
or use the <a href="commands/../reference/config.html#docbrowser"><code>doc.browser</code></a> configuration
option.</dd>
<dt class="option-term" id="option-cargo-doc---no-deps"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---no-deps"></a><code>--no-deps</code></dt>
<dd class="option-desc">Do not build documentation for dependencies.</dd>
<dt class="option-term" id="option-cargo-doc---document-private-items"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---document-private-items"></a><code>--document-private-items</code></dt>
<dd class="option-desc">Include non-public items in the documentation. This will be enabled by default if documenting a binary target.</dd>
</dl>
<h3 id="package-selection-3"><a class="header" href="#package-selection-3">Package Selection</a></h3>
<p>By default, when no package selection options are given, the packages selected
depend on the selected manifest file (based on the current working directory if
<code>--manifest-path</code> is not given). If the manifest is the root of a workspace then
the workspaces default members are selected, otherwise only the package defined
by the manifest will be selected.</p>
<p>The default members of a workspace can be set explicitly with the
<code>workspace.default-members</code> key in the root manifest. If this is not set, a
virtual workspace will include all workspace members (equivalent to passing
<code>--workspace</code>), and a non-virtual workspace will include only the root crate itself.</p>
<dl>
<dt class="option-term" id="option-cargo-doc--p"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-doc---package"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Document only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally 
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</dd>
<dt class="option-term" id="option-cargo-doc---workspace"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Document all members in the workspace.</dd>
<dt class="option-term" id="option-cargo-doc---all"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---all"></a><code>--all</code></dt>
<dd class="option-desc">Deprecated alias for <code>--workspace</code>.</dd>
<dt class="option-term" id="option-cargo-doc---exclude"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</dd>
</dl>
<h3 id="target-selection-2"><a class="header" href="#target-selection-2">Target Selection</a></h3>
<p>When no target selection options are given, <code>cargo doc</code> will document all
binary and library targets of the selected package. The binary will be skipped
if its name is the same as the lib target. Binaries are skipped if they have
<code>required-features</code> that are missing.</p>
<p>The default behavior can be changed by setting <code>doc = false</code> for the target in
the manifest settings. Using target selection options will ignore the <code>doc</code>
flag and will always document the given target.</p>
<dl>
<dt class="option-term" id="option-cargo-doc---lib"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Document the package's library.</dd>
<dt class="option-term" id="option-cargo-doc---bin"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Document the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-doc---bins"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Document all binary targets.</dd>
<dt class="option-term" id="option-cargo-doc---example"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Document the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-doc---examples"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Document all example targets.</dd>
</dl>
<h3 id="feature-selection-2"><a class="header" href="#feature-selection-2">Feature Selection</a></h3>
<p>The feature flags allow you to control which features are enabled. When no
feature options are given, the <code>default</code> feature is activated for every
selected package.</p>
<p>See <a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>
for more details.</p>
<dl>
<dt class="option-term" id="option-cargo-doc--F"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--F"></a><code>-F</code> <em>features</em></dt>
<dt class="option-term" id="option-cargo-doc---features"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-doc---all-features"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-doc---no-default-features"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options-2"><a class="header" href="#compilation-options-2">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc---target"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Document for the given architecture. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets. This flag may be specified multiple times.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-doc--r"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-doc---release"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---release"></a><code>--release</code></dt>
<dd class="option-desc">Document optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-doc---profile"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Document with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-doc---ignore-rust-version"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Document the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
<dt class="option-term" id="option-cargo-doc---timings=fmts"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---timings=fmts"></a><code>--timings=</code><em>fmts</em></dt>
<dd class="option-desc">Output information how long each compilation takes, and track concurrency
information over time. Accepts an optional comma-separated list of output
formats; <code>--timings</code> without an argument will default to <code>--timings=html</code>.
Specifying an output format (rather than the default) is unstable and requires
<code>-Zunstable-options</code>. Valid output formats:</p>
<ul>
<li><code>html</code> (unstable, requires <code>-Zunstable-options</code>): Write a human-readable file <code>cargo-timing.html</code> to the
<code>target/cargo-timings</code> directory with a report of the compilation. Also write
a report to the same directory with a timestamp in the filename if you want
to look at older runs. HTML output is suitable for human consumption only,
and does not provide machine-readable timing data.</li>
<li><code>json</code> (unstable, requires <code>-Zunstable-options</code>): Emit machine-readable JSON
information about timing information.</li>
</ul></dd>
</dl>
<h3 id="output-options-2"><a class="header" href="#output-options-2">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc---target-dir"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="display-options-4"><a class="header" href="#display-options-4">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc--v"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-doc---verbose"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-doc--q"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-doc---quiet"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-doc---color"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-doc---message-format"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3 id="manifest-options-4"><a class="header" href="#manifest-options-4">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc---manifest-path"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-doc---frozen"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-doc---locked"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-doc---offline"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-4"><a class="header" href="#common-options-4">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc-+toolchain"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-doc---config"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-doc--h"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-doc---help"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-doc--Z"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3 id="miscellaneous-options-2"><a class="header" href="#miscellaneous-options-2">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc--j"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-doc---jobs"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value.
Should not be 0.</dd>
<dt class="option-term" id="option-cargo-doc---keep-going"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---keep-going"></a><code>--keep-going</code></dt>
<dd class="option-desc">Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build. Unstable, requires
<code>-Zunstable-options</code>.</dd>
</dl>
<h2 id="environment-4"><a class="header" href="#environment-4">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-4"><a class="header" href="#exit-status-4">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-6"><a class="header" href="#examples-6">EXAMPLES</a></h2>
<ol>
<li>
<p>Build the local package documentation and its dependencies and output to
<code>target/doc</code>.</p>
<pre><code>cargo doc
</code></pre>
</li>
</ol>
<h2 id="see-also-6"><a class="header" href="#see-also-6">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-rustdoc.html">cargo-rustdoc(1)</a>, <a href="https://doc.rust-lang.org/rustdoc/index.html">rustdoc(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-fetch1"><a class="header" href="#cargo-fetch1">cargo-fetch(1)</a></h1>
<h2 id="name-7"><a class="header" href="#name-7">NAME</a></h2>
<p>cargo-fetch - Fetch dependencies of a package from the network</p>
<h2 id="synopsis-7"><a class="header" href="#synopsis-7">SYNOPSIS</a></h2>
<p><code>cargo fetch</code> [<em>options</em>]</p>
<h2 id="description-7"><a class="header" href="#description-7">DESCRIPTION</a></h2>
<p>If a <code>Cargo.lock</code> file is available, this command will ensure that all of the
git dependencies and/or registry dependencies are downloaded and locally
available. Subsequent Cargo commands will be able to run offline after a <code>cargo fetch</code> unless the lock file changes.</p>
<p>If the lock file is not available, then this command will generate the lock
file before fetching the dependencies.</p>
<p>If <code>--target</code> is not specified, then all target dependencies are fetched.</p>
<p>See also the <a href="https://crates.io/crates/cargo-prefetch">cargo-prefetch</a>
plugin which adds a command to download popular crates. This may be useful if
you plan to use Cargo without a network with the <code>--offline</code> flag.</p>
<h2 id="options-6"><a class="header" href="#options-6">OPTIONS</a></h2>
<h3 id="fetch-options"><a class="header" href="#fetch-options">Fetch options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fetch---target"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Fetch for the given architecture. The default is all architectures. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets. This flag may be specified multiple times.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
</dl>
<h3 id="display-options-5"><a class="header" href="#display-options-5">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fetch--v"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-fetch---verbose"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-fetch--q"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-fetch---quiet"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-fetch---color"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="manifest-options-5"><a class="header" href="#manifest-options-5">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fetch---manifest-path"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-fetch---frozen"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-fetch---locked"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-fetch---offline"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-5"><a class="header" href="#common-options-5">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fetch-+toolchain"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-fetch---config"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-fetch--h"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-fetch---help"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-fetch--Z"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-5"><a class="header" href="#environment-5">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-5"><a class="header" href="#exit-status-5">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-7"><a class="header" href="#examples-7">EXAMPLES</a></h2>
<ol>
<li>
<p>Fetch all dependencies:</p>
<pre><code>cargo fetch
</code></pre>
</li>
</ol>
<h2 id="see-also-7"><a class="header" href="#see-also-7">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-update.html">cargo-update(1)</a>, <a href="commands/cargo-generate-lockfile.html">cargo-generate-lockfile(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-fix1"><a class="header" href="#cargo-fix1">cargo-fix(1)</a></h1>
<h2 id="name-8"><a class="header" href="#name-8">NAME</a></h2>
<p>cargo-fix - Automatically fix lint warnings reported by rustc</p>
<h2 id="synopsis-8"><a class="header" href="#synopsis-8">SYNOPSIS</a></h2>
<p><code>cargo fix</code> [<em>options</em>]</p>
<h2 id="description-8"><a class="header" href="#description-8">DESCRIPTION</a></h2>
<p>This Cargo subcommand will automatically take rustc's suggestions from
diagnostics like warnings and apply them to your source code. This is intended
to help automate tasks that rustc itself already knows how to tell you to fix!</p>
<p>Executing <code>cargo fix</code> will under the hood execute <a href="commands/cargo-check.html">cargo-check(1)</a>. Any warnings
applicable to your crate will be automatically fixed (if possible) and all
remaining warnings will be displayed when the check process is finished. For
example if you'd like to apply all fixes to the current package, you can run:</p>
<pre><code>cargo fix
</code></pre>
<p>which behaves the same as <code>cargo check --all-targets</code>.</p>
<p><code>cargo fix</code> is only capable of fixing code that is normally compiled with
<code>cargo check</code>. If code is conditionally enabled with optional features, you
will need to enable those features for that code to be analyzed:</p>
<pre><code>cargo fix --features foo
</code></pre>
<p>Similarly, other <code>cfg</code> expressions like platform-specific code will need to
pass <code>--target</code> to fix code for the given target.</p>
<pre><code>cargo fix --target x86_64-pc-windows-gnu
</code></pre>
<p>If you encounter any problems with <code>cargo fix</code> or otherwise have any questions
or feature requests please don't hesitate to file an issue at
<a href="https://github.com/rust-lang/cargo">https://github.com/rust-lang/cargo</a>.</p>
<h3 id="edition-migration"><a class="header" href="#edition-migration">Edition migration</a></h3>
<p>The <code>cargo fix</code> subcommand can also be used to migrate a package from one
<a href="https://doc.rust-lang.org/edition-guide/editions/transitioning-an-existing-project-to-a-new-edition.html">edition</a> to the next. The general procedure is:</p>
<ol>
<li>Run <code>cargo fix --edition</code>. Consider also using the <code>--all-features</code> flag if
your project has multiple features. You may also want to run <code>cargo fix --edition</code> multiple times with different <code>--target</code> flags if your project
has platform-specific code gated by <code>cfg</code> attributes.</li>
<li>Modify <code>Cargo.toml</code> to set the <a href="commands/../reference/manifest.html#the-edition-field">edition field</a> to the new edition.</li>
<li>Run your project tests to verify that everything still works. If new
warnings are issued, you may want to consider running <code>cargo fix</code> again
(without the <code>--edition</code> flag) to apply any suggestions given by the
compiler.</li>
</ol>
<p>And hopefully that's it! Just keep in mind of the caveats mentioned above that
<code>cargo fix</code> cannot update code for inactive features or <code>cfg</code> expressions.
Also, in some rare cases the compiler is unable to automatically migrate all
code to the new edition, and this may require manual changes after building
with the new edition.</p>
<h2 id="options-7"><a class="header" href="#options-7">OPTIONS</a></h2>
<h3 id="fix-options"><a class="header" href="#fix-options">Fix options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix---broken-code"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---broken-code"></a><code>--broken-code</code></dt>
<dd class="option-desc">Fix code even if it already has compiler errors. This is useful if <code>cargo fix</code>
fails to apply the changes. It will apply the changes and leave the broken
code in the working directory for you to inspect and manually fix.</dd>
<dt class="option-term" id="option-cargo-fix---edition"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---edition"></a><code>--edition</code></dt>
<dd class="option-desc">Apply changes that will update the code to the next edition. This will not
update the edition in the <code>Cargo.toml</code> manifest, which must be updated
manually after <code>cargo fix --edition</code> has finished.</dd>
<dt class="option-term" id="option-cargo-fix---edition-idioms"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---edition-idioms"></a><code>--edition-idioms</code></dt>
<dd class="option-desc">Apply suggestions that will update code to the preferred style for the current
edition.</dd>
<dt class="option-term" id="option-cargo-fix---allow-no-vcs"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---allow-no-vcs"></a><code>--allow-no-vcs</code></dt>
<dd class="option-desc">Fix code even if a VCS was not detected.</dd>
<dt class="option-term" id="option-cargo-fix---allow-dirty"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---allow-dirty"></a><code>--allow-dirty</code></dt>
<dd class="option-desc">Fix code even if the working directory has changes.</dd>
<dt class="option-term" id="option-cargo-fix---allow-staged"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---allow-staged"></a><code>--allow-staged</code></dt>
<dd class="option-desc">Fix code even if the working directory has staged changes.</dd>
</dl>
<h3 id="package-selection-4"><a class="header" href="#package-selection-4">Package Selection</a></h3>
<p>By default, when no package selection options are given, the packages selected
depend on the selected manifest file (based on the current working directory if
<code>--manifest-path</code> is not given). If the manifest is the root of a workspace then
the workspaces default members are selected, otherwise only the package defined
by the manifest will be selected.</p>
<p>The default members of a workspace can be set explicitly with the
<code>workspace.default-members</code> key in the root manifest. If this is not set, a
virtual workspace will include all workspace members (equivalent to passing
<code>--workspace</code>), and a non-virtual workspace will include only the root crate itself.</p>
<dl>
<dt class="option-term" id="option-cargo-fix--p"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-fix---package"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Fix only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally 
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</dd>
<dt class="option-term" id="option-cargo-fix---workspace"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Fix all members in the workspace.</dd>
<dt class="option-term" id="option-cargo-fix---all"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---all"></a><code>--all</code></dt>
<dd class="option-desc">Deprecated alias for <code>--workspace</code>.</dd>
<dt class="option-term" id="option-cargo-fix---exclude"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</dd>
</dl>
<h3 id="target-selection-3"><a class="header" href="#target-selection-3">Target Selection</a></h3>
<p>When no target selection options are given, <code>cargo fix</code> will fix all targets
(<code>--all-targets</code> implied). Binaries are skipped if they have
<code>required-features</code> that are missing.</p>
<p>Passing target selection flags will fix only the specified
targets. </p>
<p>Note that <code>--bin</code>, <code>--example</code>, <code>--test</code> and <code>--bench</code> flags also 
support common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your 
shell accidentally expanding glob patterns before Cargo handles them, you must 
use single quotes or double quotes around each glob pattern.</p>
<dl>
<dt class="option-term" id="option-cargo-fix---lib"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Fix the package's library.</dd>
<dt class="option-term" id="option-cargo-fix---bin"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Fix the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-fix---bins"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Fix all binary targets.</dd>
<dt class="option-term" id="option-cargo-fix---example"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Fix the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-fix---examples"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Fix all example targets.</dd>
<dt class="option-term" id="option-cargo-fix---test"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Fix the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-fix---tests"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Fix all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-fix---bench"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Fix the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-fix---benches"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Fix all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-fix---all-targets"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Fix all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<h3 id="feature-selection-3"><a class="header" href="#feature-selection-3">Feature Selection</a></h3>
<p>The feature flags allow you to control which features are enabled. When no
feature options are given, the <code>default</code> feature is activated for every
selected package.</p>
<p>See <a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>
for more details.</p>
<dl>
<dt class="option-term" id="option-cargo-fix--F"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--F"></a><code>-F</code> <em>features</em></dt>
<dt class="option-term" id="option-cargo-fix---features"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-fix---all-features"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-fix---no-default-features"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options-3"><a class="header" href="#compilation-options-3">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix---target"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Fix for the given architecture. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets. This flag may be specified multiple times.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-fix--r"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-fix---release"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---release"></a><code>--release</code></dt>
<dd class="option-desc">Fix optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-fix---profile"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Fix with the given profile.</p>
<p>As a special case, specifying the <code>test</code> profile will also enable checking in
test mode which will enable checking tests and enable the <code>test</code> cfg option.
See <a href="https://doc.rust-lang.org/rustc/tests/index.html">rustc tests</a> for more
detail.</p>
<p>See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-fix---ignore-rust-version"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Fix the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
<dt class="option-term" id="option-cargo-fix---timings=fmts"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---timings=fmts"></a><code>--timings=</code><em>fmts</em></dt>
<dd class="option-desc">Output information how long each compilation takes, and track concurrency
information over time. Accepts an optional comma-separated list of output
formats; <code>--timings</code> without an argument will default to <code>--timings=html</code>.
Specifying an output format (rather than the default) is unstable and requires
<code>-Zunstable-options</code>. Valid output formats:</p>
<ul>
<li><code>html</code> (unstable, requires <code>-Zunstable-options</code>): Write a human-readable file <code>cargo-timing.html</code> to the
<code>target/cargo-timings</code> directory with a report of the compilation. Also write
a report to the same directory with a timestamp in the filename if you want
to look at older runs. HTML output is suitable for human consumption only,
and does not provide machine-readable timing data.</li>
<li><code>json</code> (unstable, requires <code>-Zunstable-options</code>): Emit machine-readable JSON
information about timing information.</li>
</ul></dd>
</dl>
<h3 id="output-options-3"><a class="header" href="#output-options-3">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix---target-dir"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="display-options-6"><a class="header" href="#display-options-6">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix--v"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-fix---verbose"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-fix--q"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-fix---quiet"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-fix---color"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-fix---message-format"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3 id="manifest-options-6"><a class="header" href="#manifest-options-6">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix---manifest-path"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-fix---frozen"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-fix---locked"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-fix---offline"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-6"><a class="header" href="#common-options-6">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix-+toolchain"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-fix---config"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-fix--h"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-fix---help"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-fix--Z"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3 id="miscellaneous-options-3"><a class="header" href="#miscellaneous-options-3">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix--j"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-fix---jobs"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value.
Should not be 0.</dd>
<dt class="option-term" id="option-cargo-fix---keep-going"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---keep-going"></a><code>--keep-going</code></dt>
<dd class="option-desc">Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build. Unstable, requires
<code>-Zunstable-options</code>.</dd>
</dl>
<h2 id="environment-6"><a class="header" href="#environment-6">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-6"><a class="header" href="#exit-status-6">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-8"><a class="header" href="#examples-8">EXAMPLES</a></h2>
<ol>
<li>
<p>Apply compiler suggestions to the local package:</p>
<pre><code>cargo fix
</code></pre>
</li>
<li>
<p>Update a package to prepare it for the next edition:</p>
<pre><code>cargo fix --edition
</code></pre>
</li>
<li>
<p>Apply suggested idioms for the current edition:</p>
<pre><code>cargo fix --edition-idioms
</code></pre>
</li>
</ol>
<h2 id="see-also-8"><a class="header" href="#see-also-8">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-check.html">cargo-check(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-run1"><a class="header" href="#cargo-run1">cargo-run(1)</a></h1>
<h2 id="name-9"><a class="header" href="#name-9">NAME</a></h2>
<p>cargo-run - Run the current package</p>
<h2 id="synopsis-9"><a class="header" href="#synopsis-9">SYNOPSIS</a></h2>
<p><code>cargo run</code> [<em>options</em>] [<code>--</code> <em>args</em>]</p>
<h2 id="description-9"><a class="header" href="#description-9">DESCRIPTION</a></h2>
<p>Run a binary or example of the local package.</p>
<p>All the arguments following the two dashes (<code>--</code>) are passed to the binary to
run. If you're passing arguments to both Cargo and the binary, the ones after
<code>--</code> go to the binary, the ones before go to Cargo.</p>
<h2 id="options-8"><a class="header" href="#options-8">OPTIONS</a></h2>
<h3 id="package-selection-5"><a class="header" href="#package-selection-5">Package Selection</a></h3>
<p>By default, the package in the current working directory is selected. The <code>-p</code>
flag can be used to choose a different package in a workspace.</p>
<dl>
<dt class="option-term" id="option-cargo-run--p"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--p"></a><code>-p</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-run---package"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---package"></a><code>--package</code> <em>spec</em></dt>
<dd class="option-desc">The package to run. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC
format.</dd>
</dl>
<h3 id="target-selection-4"><a class="header" href="#target-selection-4">Target Selection</a></h3>
<p>When no target selection options are given, <code>cargo run</code> will run the binary
target. If there are multiple binary targets, you must pass a target flag to
choose one. Or, the <code>default-run</code> field may be specified in the <code>[package]</code>
section of <code>Cargo.toml</code> to choose the name of the binary to run by default.</p>
<dl>
<dt class="option-term" id="option-cargo-run---bin"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---bin"></a><code>--bin</code> <em>name</em></dt>
<dd class="option-desc">Run the specified binary.</dd>
<dt class="option-term" id="option-cargo-run---example"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---example"></a><code>--example</code> <em>name</em></dt>
<dd class="option-desc">Run the specified example.</dd>
</dl>
<h3 id="feature-selection-4"><a class="header" href="#feature-selection-4">Feature Selection</a></h3>
<p>The feature flags allow you to control which features are enabled. When no
feature options are given, the <code>default</code> feature is activated for every
selected package.</p>
<p>See <a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>
for more details.</p>
<dl>
<dt class="option-term" id="option-cargo-run--F"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--F"></a><code>-F</code> <em>features</em></dt>
<dt class="option-term" id="option-cargo-run---features"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-run---all-features"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-run---no-default-features"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options-4"><a class="header" href="#compilation-options-4">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run---target"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Run for the given architecture. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-run--r"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-run---release"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---release"></a><code>--release</code></dt>
<dd class="option-desc">Run optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-run---profile"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Run with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-run---ignore-rust-version"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Run the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
<dt class="option-term" id="option-cargo-run---timings=fmts"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---timings=fmts"></a><code>--timings=</code><em>fmts</em></dt>
<dd class="option-desc">Output information how long each compilation takes, and track concurrency
information over time. Accepts an optional comma-separated list of output
formats; <code>--timings</code> without an argument will default to <code>--timings=html</code>.
Specifying an output format (rather than the default) is unstable and requires
<code>-Zunstable-options</code>. Valid output formats:</p>
<ul>
<li><code>html</code> (unstable, requires <code>-Zunstable-options</code>): Write a human-readable file <code>cargo-timing.html</code> to the
<code>target/cargo-timings</code> directory with a report of the compilation. Also write
a report to the same directory with a timestamp in the filename if you want
to look at older runs. HTML output is suitable for human consumption only,
and does not provide machine-readable timing data.</li>
<li><code>json</code> (unstable, requires <code>-Zunstable-options</code>): Emit machine-readable JSON
information about timing information.</li>
</ul></dd>
</dl>
<h3 id="output-options-4"><a class="header" href="#output-options-4">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run---target-dir"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="display-options-7"><a class="header" href="#display-options-7">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run--v"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-run---verbose"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-run--q"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-run---quiet"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-run---color"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-run---message-format"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3 id="manifest-options-7"><a class="header" href="#manifest-options-7">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run---manifest-path"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-run---frozen"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-run---locked"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-run---offline"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-7"><a class="header" href="#common-options-7">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run-+toolchain"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-run---config"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-run--h"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-run---help"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-run--Z"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3 id="miscellaneous-options-4"><a class="header" href="#miscellaneous-options-4">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run--j"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-run---jobs"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value.
Should not be 0.</dd>
<dt class="option-term" id="option-cargo-run---keep-going"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---keep-going"></a><code>--keep-going</code></dt>
<dd class="option-desc">Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build. Unstable, requires
<code>-Zunstable-options</code>.</dd>
</dl>
<h2 id="environment-7"><a class="header" href="#environment-7">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-7"><a class="header" href="#exit-status-7">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-9"><a class="header" href="#examples-9">EXAMPLES</a></h2>
<ol>
<li>
<p>Build the local package and run its main target (assuming only one binary):</p>
<pre><code>cargo run
</code></pre>
</li>
<li>
<p>Run an example with extra arguments:</p>
<pre><code>cargo run --example exname -- --exoption exarg1 exarg2
</code></pre>
</li>
</ol>
<h2 id="see-also-9"><a class="header" href="#see-also-9">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-build.html">cargo-build(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-rustc1"><a class="header" href="#cargo-rustc1">cargo-rustc(1)</a></h1>
<h2 id="name-10"><a class="header" href="#name-10">NAME</a></h2>
<p>cargo-rustc - Compile the current package, and pass extra options to the compiler</p>
<h2 id="synopsis-10"><a class="header" href="#synopsis-10">SYNOPSIS</a></h2>
<p><code>cargo rustc</code> [<em>options</em>] [<code>--</code> <em>args</em>]</p>
<h2 id="description-10"><a class="header" href="#description-10">DESCRIPTION</a></h2>
<p>The specified target for the current package (or package specified by <code>-p</code> if
provided) will be compiled along with all of its dependencies. The specified
<em>args</em> will all be passed to the final compiler invocation, not any of the
dependencies. Note that the compiler will still unconditionally receive
arguments such as <code>-L</code>, <code>--extern</code>, and <code>--crate-type</code>, and the specified
<em>args</em> will simply be added to the compiler invocation.</p>
<p>See <a href="https://doc.rust-lang.org/rustc/index.html">https://doc.rust-lang.org/rustc/index.html</a> for documentation on rustc
flags.</p>
<p>This command requires that only one target is being compiled when additional
arguments are provided. If more than one target is available for the current
package the filters of <code>--lib</code>, <code>--bin</code>, etc, must be used to select which
target is compiled.</p>
<p>To pass flags to all compiler processes spawned by Cargo, use the <code>RUSTFLAGS</code>
<a href="commands/../reference/environment-variables.html">environment variable</a> or the
<code>build.rustflags</code> <a href="commands/../reference/config.html">config value</a>.</p>
<h2 id="options-9"><a class="header" href="#options-9">OPTIONS</a></h2>
<h3 id="package-selection-6"><a class="header" href="#package-selection-6">Package Selection</a></h3>
<p>By default, the package in the current working directory is selected. The <code>-p</code>
flag can be used to choose a different package in a workspace.</p>
<dl>
<dt class="option-term" id="option-cargo-rustc--p"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--p"></a><code>-p</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-rustc---package"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---package"></a><code>--package</code> <em>spec</em></dt>
<dd class="option-desc">The package to build. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC
format.</dd>
</dl>
<h3 id="target-selection-5"><a class="header" href="#target-selection-5">Target Selection</a></h3>
<p>When no target selection options are given, <code>cargo rustc</code> will build all
binary and library targets of the selected package.</p>
<p>Binary targets are automatically built if there is an integration test or
benchmark being selected to build. This allows an integration
test to execute the binary to exercise and test its behavior. 
The <code>CARGO_BIN_EXE_&lt;name&gt;</code>
<a href="commands/../reference/environment-variables.html#environment-variables-cargo-sets-for-crates">environment variable</a>
is set when the integration test is built so that it can use the
<a href="https://doc.rust-lang.org/std/macro.env.html"><code>env</code> macro</a> to locate the
executable.</p>
<p>Passing target selection flags will build only the specified
targets. </p>
<p>Note that <code>--bin</code>, <code>--example</code>, <code>--test</code> and <code>--bench</code> flags also 
support common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your 
shell accidentally expanding glob patterns before Cargo handles them, you must 
use single quotes or double quotes around each glob pattern.</p>
<dl>
<dt class="option-term" id="option-cargo-rustc---lib"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Build the package's library.</dd>
<dt class="option-term" id="option-cargo-rustc---bin"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustc---bins"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Build all binary targets.</dd>
<dt class="option-term" id="option-cargo-rustc---example"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustc---examples"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Build all example targets.</dd>
<dt class="option-term" id="option-cargo-rustc---test"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustc---tests"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Build all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-rustc---bench"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustc---benches"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Build all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-rustc---all-targets"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Build all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<h3 id="feature-selection-5"><a class="header" href="#feature-selection-5">Feature Selection</a></h3>
<p>The feature flags allow you to control which features are enabled. When no
feature options are given, the <code>default</code> feature is activated for every
selected package.</p>
<p>See <a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>
for more details.</p>
<dl>
<dt class="option-term" id="option-cargo-rustc--F"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--F"></a><code>-F</code> <em>features</em></dt>
<dt class="option-term" id="option-cargo-rustc---features"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-rustc---all-features"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-rustc---no-default-features"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options-5"><a class="header" href="#compilation-options-5">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc---target"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Build for the given architecture. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets. This flag may be specified multiple times.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-rustc--r"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-rustc---release"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---release"></a><code>--release</code></dt>
<dd class="option-desc">Build optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-rustc---profile"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Build with the given profile.</p>
<p>The <code>rustc</code> subcommand will treat the following named profiles with special behaviors:</p>
<ul>
<li><code>check</code> — Builds in the same way as the <a href="commands/cargo-check.html">cargo-check(1)</a> command with
the <code>dev</code> profile.</li>
<li><code>test</code> — Builds in the same way as the <a href="commands/cargo-test.html">cargo-test(1)</a> command,
enabling building in test mode which will enable tests and enable the <code>test</code>
cfg option. See <a href="https://doc.rust-lang.org/rustc/tests/index.html">rustc
tests</a> for more detail.</li>
<li><code>bench</code> — Builds in the same was as the <a href="commands/cargo-bench.html">cargo-bench(1)</a> command,
similar to the <code>test</code> profile.</li>
</ul>
<p>See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-rustc---ignore-rust-version"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Build the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
<dt class="option-term" id="option-cargo-rustc---timings=fmts"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---timings=fmts"></a><code>--timings=</code><em>fmts</em></dt>
<dd class="option-desc">Output information how long each compilation takes, and track concurrency
information over time. Accepts an optional comma-separated list of output
formats; <code>--timings</code> without an argument will default to <code>--timings=html</code>.
Specifying an output format (rather than the default) is unstable and requires
<code>-Zunstable-options</code>. Valid output formats:</p>
<ul>
<li><code>html</code> (unstable, requires <code>-Zunstable-options</code>): Write a human-readable file <code>cargo-timing.html</code> to the
<code>target/cargo-timings</code> directory with a report of the compilation. Also write
a report to the same directory with a timestamp in the filename if you want
to look at older runs. HTML output is suitable for human consumption only,
and does not provide machine-readable timing data.</li>
<li><code>json</code> (unstable, requires <code>-Zunstable-options</code>): Emit machine-readable JSON
information about timing information.</li>
</ul></dd>
<dt class="option-term" id="option-cargo-rustc---crate-type"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---crate-type"></a><code>--crate-type</code> <em>crate-type</em></dt>
<dd class="option-desc">Build for the given crate type. This flag accepts a comma-separated list of
1 or more crate types, of which the allowed values are the same as <code>crate-type</code>
field in the manifest for configurating a Cargo target. See
<a href="commands/../reference/cargo-targets.html#the-crate-type-field"><code>crate-type</code> field</a>
for possible values.</p>
<p>If the manifest contains a list, and <code>--crate-type</code> is provided,
the command-line argument value will override what is in the manifest.</p>
<p>This flag only works when building a <code>lib</code> or <code>example</code> library target.</dd>
</dl>
<h3 id="output-options-5"><a class="header" href="#output-options-5">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc---target-dir"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="display-options-8"><a class="header" href="#display-options-8">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc--v"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-rustc---verbose"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-rustc--q"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-rustc---quiet"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-rustc---color"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-rustc---message-format"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3 id="manifest-options-8"><a class="header" href="#manifest-options-8">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc---manifest-path"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-rustc---frozen"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-rustc---locked"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-rustc---offline"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-8"><a class="header" href="#common-options-8">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc-+toolchain"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-rustc---config"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-rustc--h"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-rustc---help"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-rustc--Z"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3 id="miscellaneous-options-5"><a class="header" href="#miscellaneous-options-5">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc--j"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-rustc---jobs"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value.
Should not be 0.</dd>
<dt class="option-term" id="option-cargo-rustc---keep-going"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---keep-going"></a><code>--keep-going</code></dt>
<dd class="option-desc">Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build. Unstable, requires
<code>-Zunstable-options</code>.</dd>
<dt class="option-term" id="option-cargo-rustc---future-incompat-report"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---future-incompat-report"></a><code>--future-incompat-report</code></dt>
<dd class="option-desc">Displays a future-incompat report for any future-incompatible warnings
produced during execution of this command</p>
<p>See <a href="commands/cargo-report.html">cargo-report(1)</a></dd>
</dl>
<h2 id="environment-8"><a class="header" href="#environment-8">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-8"><a class="header" href="#exit-status-8">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-10"><a class="header" href="#examples-10">EXAMPLES</a></h2>
<ol>
<li>
<p>Check if your package (not including dependencies) uses unsafe code:</p>
<pre><code>cargo rustc --lib -- -D unsafe-code
</code></pre>
</li>
<li>
<p>Try an experimental flag on the nightly compiler, such as this which prints
the size of every type:</p>
<pre><code>cargo rustc --lib -- -Z print-type-sizes
</code></pre>
</li>
<li>
<p>Override <code>crate-type</code> field in Cargo.toml with command-line option:</p>
<pre><code>cargo rustc --lib --crate-type lib,cdylib
</code></pre>
</li>
</ol>
<h2 id="see-also-10"><a class="header" href="#see-also-10">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-build.html">cargo-build(1)</a>, <a href="https://doc.rust-lang.org/rustc/index.html">rustc(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-rustdoc1"><a class="header" href="#cargo-rustdoc1">cargo-rustdoc(1)</a></h1>
<h2 id="name-11"><a class="header" href="#name-11">NAME</a></h2>
<p>cargo-rustdoc - Build a package's documentation, using specified custom flags</p>
<h2 id="synopsis-11"><a class="header" href="#synopsis-11">SYNOPSIS</a></h2>
<p><code>cargo rustdoc</code> [<em>options</em>] [<code>--</code> <em>args</em>]</p>
<h2 id="description-11"><a class="header" href="#description-11">DESCRIPTION</a></h2>
<p>The specified target for the current package (or package specified by <code>-p</code> if
provided) will be documented with the specified <em>args</em> being passed to the
final rustdoc invocation. Dependencies will not be documented as part of this
command. Note that rustdoc will still unconditionally receive arguments such
as <code>-L</code>, <code>--extern</code>, and <code>--crate-type</code>, and the specified <em>args</em> will simply
be added to the rustdoc invocation.</p>
<p>See <a href="https://doc.rust-lang.org/rustdoc/index.html">https://doc.rust-lang.org/rustdoc/index.html</a> for documentation on rustdoc
flags.</p>
<p>This command requires that only one target is being compiled when additional
arguments are provided. If more than one target is available for the current
package the filters of <code>--lib</code>, <code>--bin</code>, etc, must be used to select which
target is compiled.</p>
<p>To pass flags to all rustdoc processes spawned by Cargo, use the
<code>RUSTDOCFLAGS</code> <a href="commands/../reference/environment-variables.html">environment variable</a>
or the <code>build.rustdocflags</code> <a href="commands/../reference/config.html">config value</a>.</p>
<h2 id="options-10"><a class="header" href="#options-10">OPTIONS</a></h2>
<h3 id="documentation-options-1"><a class="header" href="#documentation-options-1">Documentation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---open"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---open"></a><code>--open</code></dt>
<dd class="option-desc">Open the docs in a browser after building them. This will use your default
browser unless you define another one in the <code>BROWSER</code> environment variable
or use the <a href="commands/../reference/config.html#docbrowser"><code>doc.browser</code></a> configuration
option.</dd>
</dl>
<h3 id="package-selection-7"><a class="header" href="#package-selection-7">Package Selection</a></h3>
<p>By default, the package in the current working directory is selected. The <code>-p</code>
flag can be used to choose a different package in a workspace.</p>
<dl>
<dt class="option-term" id="option-cargo-rustdoc--p"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--p"></a><code>-p</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-rustdoc---package"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---package"></a><code>--package</code> <em>spec</em></dt>
<dd class="option-desc">The package to document. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC
format.</dd>
</dl>
<h3 id="target-selection-6"><a class="header" href="#target-selection-6">Target Selection</a></h3>
<p>When no target selection options are given, <code>cargo rustdoc</code> will document all
binary and library targets of the selected package. The binary will be skipped
if its name is the same as the lib target. Binaries are skipped if they have
<code>required-features</code> that are missing.</p>
<p>Passing target selection flags will document only the specified
targets. </p>
<p>Note that <code>--bin</code>, <code>--example</code>, <code>--test</code> and <code>--bench</code> flags also 
support common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your 
shell accidentally expanding glob patterns before Cargo handles them, you must 
use single quotes or double quotes around each glob pattern.</p>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---lib"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Document the package's library.</dd>
<dt class="option-term" id="option-cargo-rustdoc---bin"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Document the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustdoc---bins"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Document all binary targets.</dd>
<dt class="option-term" id="option-cargo-rustdoc---example"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Document the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustdoc---examples"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Document all example targets.</dd>
<dt class="option-term" id="option-cargo-rustdoc---test"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Document the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustdoc---tests"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Document all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-rustdoc---bench"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Document the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustdoc---benches"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Document all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-rustdoc---all-targets"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Document all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<h3 id="feature-selection-6"><a class="header" href="#feature-selection-6">Feature Selection</a></h3>
<p>The feature flags allow you to control which features are enabled. When no
feature options are given, the <code>default</code> feature is activated for every
selected package.</p>
<p>See <a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>
for more details.</p>
<dl>
<dt class="option-term" id="option-cargo-rustdoc--F"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--F"></a><code>-F</code> <em>features</em></dt>
<dt class="option-term" id="option-cargo-rustdoc---features"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-rustdoc---all-features"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-rustdoc---no-default-features"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options-6"><a class="header" href="#compilation-options-6">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---target"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Document for the given architecture. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets. This flag may be specified multiple times.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-rustdoc--r"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-rustdoc---release"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---release"></a><code>--release</code></dt>
<dd class="option-desc">Document optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-rustdoc---profile"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Document with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-rustdoc---ignore-rust-version"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Document the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
<dt class="option-term" id="option-cargo-rustdoc---timings=fmts"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---timings=fmts"></a><code>--timings=</code><em>fmts</em></dt>
<dd class="option-desc">Output information how long each compilation takes, and track concurrency
information over time. Accepts an optional comma-separated list of output
formats; <code>--timings</code> without an argument will default to <code>--timings=html</code>.
Specifying an output format (rather than the default) is unstable and requires
<code>-Zunstable-options</code>. Valid output formats:</p>
<ul>
<li><code>html</code> (unstable, requires <code>-Zunstable-options</code>): Write a human-readable file <code>cargo-timing.html</code> to the
<code>target/cargo-timings</code> directory with a report of the compilation. Also write
a report to the same directory with a timestamp in the filename if you want
to look at older runs. HTML output is suitable for human consumption only,
and does not provide machine-readable timing data.</li>
<li><code>json</code> (unstable, requires <code>-Zunstable-options</code>): Emit machine-readable JSON
information about timing information.</li>
</ul></dd>
</dl>
<h3 id="output-options-6"><a class="header" href="#output-options-6">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---target-dir"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="display-options-9"><a class="header" href="#display-options-9">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc--v"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-rustdoc---verbose"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-rustdoc--q"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-rustdoc---quiet"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-rustdoc---color"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-rustdoc---message-format"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3 id="manifest-options-9"><a class="header" href="#manifest-options-9">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---manifest-path"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-rustdoc---frozen"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-rustdoc---locked"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-rustdoc---offline"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-9"><a class="header" href="#common-options-9">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc-+toolchain"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-rustdoc---config"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-rustdoc--h"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-rustdoc---help"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-rustdoc--Z"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3 id="miscellaneous-options-6"><a class="header" href="#miscellaneous-options-6">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc--j"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-rustdoc---jobs"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value.
Should not be 0.</dd>
<dt class="option-term" id="option-cargo-rustdoc---keep-going"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---keep-going"></a><code>--keep-going</code></dt>
<dd class="option-desc">Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build. Unstable, requires
<code>-Zunstable-options</code>.</dd>
</dl>
<h2 id="environment-9"><a class="header" href="#environment-9">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-9"><a class="header" href="#exit-status-9">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-11"><a class="header" href="#examples-11">EXAMPLES</a></h2>
<ol>
<li>
<p>Build documentation with custom CSS included from a given file:</p>
<pre><code>cargo rustdoc --lib -- --extend-css extra.css
</code></pre>
</li>
</ol>
<h2 id="see-also-11"><a class="header" href="#see-also-11">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-doc.html">cargo-doc(1)</a>, <a href="https://doc.rust-lang.org/rustdoc/index.html">rustdoc(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-test1"><a class="header" href="#cargo-test1">cargo-test(1)</a></h1>
<h2 id="name-12"><a class="header" href="#name-12">NAME</a></h2>
<p>cargo-test - Execute unit and integration tests of a package</p>
<h2 id="synopsis-12"><a class="header" href="#synopsis-12">SYNOPSIS</a></h2>
<p><code>cargo test</code> [<em>options</em>] [<em>testname</em>] [<code>--</code> <em>test-options</em>]</p>
<h2 id="description-12"><a class="header" href="#description-12">DESCRIPTION</a></h2>
<p>Compile and execute unit, integration, and documentation tests.</p>
<p>The test filtering argument <code>TESTNAME</code> and all the arguments following the two
dashes (<code>--</code>) are passed to the test binaries and thus to <em>libtest</em> (rustc's
built in unit-test and micro-benchmarking framework).  If you're passing
arguments to both Cargo and the binary, the ones after <code>--</code> go to the binary,
the ones before go to Cargo.  For details about libtest's arguments see the
output of <code>cargo test -- --help</code> and check out the rustc book's chapter on
how tests work at <a href="https://doc.rust-lang.org/rustc/tests/index.html">https://doc.rust-lang.org/rustc/tests/index.html</a>.</p>
<p>As an example, this will filter for tests with <code>foo</code> in their name and run them
on 3 threads in parallel:</p>
<pre><code>cargo test foo -- --test-threads 3
</code></pre>
<p>Tests are built with the <code>--test</code> option to <code>rustc</code> which creates a special
executable by linking your code with libtest. The executable automatically
runs all functions annotated with the <code>#[test]</code> attribute in multiple threads.
<code>#[bench]</code> annotated functions will also be run with one iteration to verify
that they are functional.</p>
<p>If the package contains multiple test targets, each target compiles to a
special executable as aforementioned, and then is run serially.</p>
<p>The libtest harness may be disabled by setting <code>harness = false</code> in the target
manifest settings, in which case your code will need to provide its own <code>main</code>
function to handle running tests.</p>
<h3 id="documentation-tests"><a class="header" href="#documentation-tests">Documentation tests</a></h3>
<p>Documentation tests are also run by default, which is handled by <code>rustdoc</code>. It
extracts code samples from documentation comments of the library target, and
then executes them.</p>
<p>Different from normal test targets, each code block compiles to a doctest
executable on the fly with <code>rustc</code>. These executables run in parallel in
separate processes. The compilation of a code block is in fact a part of test
function controlled by libtest, so some options such as <code>--jobs</code> might not
take effect. Note that this execution model of doctests is not guaranteed
and may change in the future; beware of depending on it.</p>
<p>See the <a href="https://doc.rust-lang.org/rustdoc/">rustdoc book</a> for more information
on writing doc tests.</p>
<h2 id="options-11"><a class="header" href="#options-11">OPTIONS</a></h2>
<h3 id="test-options"><a class="header" href="#test-options">Test Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test---no-run"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---no-run"></a><code>--no-run</code></dt>
<dd class="option-desc">Compile, but don't run tests.</dd>
<dt class="option-term" id="option-cargo-test---no-fail-fast"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---no-fail-fast"></a><code>--no-fail-fast</code></dt>
<dd class="option-desc">Run all tests regardless of failure. Without this flag, Cargo will exit
after the first executable fails. The Rust test harness will run all tests
within the executable to completion, this flag only applies to the executable
as a whole.</dd>
</dl>
<h3 id="package-selection-8"><a class="header" href="#package-selection-8">Package Selection</a></h3>
<p>By default, when no package selection options are given, the packages selected
depend on the selected manifest file (based on the current working directory if
<code>--manifest-path</code> is not given). If the manifest is the root of a workspace then
the workspaces default members are selected, otherwise only the package defined
by the manifest will be selected.</p>
<p>The default members of a workspace can be set explicitly with the
<code>workspace.default-members</code> key in the root manifest. If this is not set, a
virtual workspace will include all workspace members (equivalent to passing
<code>--workspace</code>), and a non-virtual workspace will include only the root crate itself.</p>
<dl>
<dt class="option-term" id="option-cargo-test--p"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-test---package"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Test only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally 
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</dd>
<dt class="option-term" id="option-cargo-test---workspace"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Test all members in the workspace.</dd>
<dt class="option-term" id="option-cargo-test---all"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---all"></a><code>--all</code></dt>
<dd class="option-desc">Deprecated alias for <code>--workspace</code>.</dd>
<dt class="option-term" id="option-cargo-test---exclude"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</dd>
</dl>
<h3 id="target-selection-7"><a class="header" href="#target-selection-7">Target Selection</a></h3>
<p>When no target selection options are given, <code>cargo test</code> will build the
following targets of the selected packages:</p>
<ul>
<li>lib — used to link with binaries, examples, integration tests, and doc tests</li>
<li>bins (only if integration tests are built and required features are
available)</li>
<li>examples — to ensure they compile</li>
<li>lib as a unit test</li>
<li>bins as unit tests</li>
<li>integration tests</li>
<li>doc tests for the lib target</li>
</ul>
<p>The default behavior can be changed by setting the <code>test</code> flag for the target
in the manifest settings. Setting examples to <code>test = true</code> will build and run
the example as a test. Setting targets to <code>test = false</code> will stop them from
being tested by default. Target selection options that take a target by name
ignore the <code>test</code> flag and will always test the given target.</p>
<p>Doc tests for libraries may be disabled by setting <code>doctest = false</code> for the
library in the manifest.</p>
<p>Binary targets are automatically built if there is an integration test or
benchmark being selected to test. This allows an integration
test to execute the binary to exercise and test its behavior. 
The <code>CARGO_BIN_EXE_&lt;name&gt;</code>
<a href="commands/../reference/environment-variables.html#environment-variables-cargo-sets-for-crates">environment variable</a>
is set when the integration test is built so that it can use the
<a href="https://doc.rust-lang.org/std/macro.env.html"><code>env</code> macro</a> to locate the
executable.</p>
<p>Passing target selection flags will test only the specified
targets. </p>
<p>Note that <code>--bin</code>, <code>--example</code>, <code>--test</code> and <code>--bench</code> flags also 
support common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your 
shell accidentally expanding glob patterns before Cargo handles them, you must 
use single quotes or double quotes around each glob pattern.</p>
<dl>
<dt class="option-term" id="option-cargo-test---lib"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Test the package's library.</dd>
<dt class="option-term" id="option-cargo-test---bin"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Test the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-test---bins"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Test all binary targets.</dd>
<dt class="option-term" id="option-cargo-test---example"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Test the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-test---examples"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Test all example targets.</dd>
<dt class="option-term" id="option-cargo-test---test"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Test the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-test---tests"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Test all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-test---bench"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Test the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-test---benches"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Test all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-test---all-targets"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Test all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<dl>
<dt class="option-term" id="option-cargo-test---doc"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---doc"></a><code>--doc</code></dt>
<dd class="option-desc">Test only the library's documentation. This cannot be mixed with other
target options.</dd>
</dl>
<h3 id="feature-selection-7"><a class="header" href="#feature-selection-7">Feature Selection</a></h3>
<p>The feature flags allow you to control which features are enabled. When no
feature options are given, the <code>default</code> feature is activated for every
selected package.</p>
<p>See <a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>
for more details.</p>
<dl>
<dt class="option-term" id="option-cargo-test--F"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--F"></a><code>-F</code> <em>features</em></dt>
<dt class="option-term" id="option-cargo-test---features"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-test---all-features"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-test---no-default-features"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options-7"><a class="header" href="#compilation-options-7">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test---target"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Test for the given architecture. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets. This flag may be specified multiple times.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-test--r"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-test---release"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---release"></a><code>--release</code></dt>
<dd class="option-desc">Test optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-test---profile"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Test with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-test---ignore-rust-version"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Test the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
<dt class="option-term" id="option-cargo-test---timings=fmts"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---timings=fmts"></a><code>--timings=</code><em>fmts</em></dt>
<dd class="option-desc">Output information how long each compilation takes, and track concurrency
information over time. Accepts an optional comma-separated list of output
formats; <code>--timings</code> without an argument will default to <code>--timings=html</code>.
Specifying an output format (rather than the default) is unstable and requires
<code>-Zunstable-options</code>. Valid output formats:</p>
<ul>
<li><code>html</code> (unstable, requires <code>-Zunstable-options</code>): Write a human-readable file <code>cargo-timing.html</code> to the
<code>target/cargo-timings</code> directory with a report of the compilation. Also write
a report to the same directory with a timestamp in the filename if you want
to look at older runs. HTML output is suitable for human consumption only,
and does not provide machine-readable timing data.</li>
<li><code>json</code> (unstable, requires <code>-Zunstable-options</code>): Emit machine-readable JSON
information about timing information.</li>
</ul></dd>
</dl>
<h3 id="output-options-7"><a class="header" href="#output-options-7">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test---target-dir"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="display-options-10"><a class="header" href="#display-options-10">Display Options</a></h3>
<p>By default the Rust test harness hides output from test execution to keep
results readable. Test output can be recovered (e.g., for debugging) by passing
<code>--nocapture</code> to the test binaries:</p>
<pre><code>cargo test -- --nocapture
</code></pre>
<dl>
<dt class="option-term" id="option-cargo-test--v"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-test---verbose"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-test--q"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-test---quiet"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-test---color"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-test---message-format"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3 id="manifest-options-10"><a class="header" href="#manifest-options-10">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test---manifest-path"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-test---frozen"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-test---locked"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-test---offline"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-10"><a class="header" href="#common-options-10">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test-+toolchain"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-test---config"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-test--h"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-test---help"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-test--Z"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3 id="miscellaneous-options-7"><a class="header" href="#miscellaneous-options-7">Miscellaneous Options</a></h3>
<p>The <code>--jobs</code> argument affects the building of the test executable but does not
affect how many threads are used when running the tests. The Rust test harness
includes an option to control the number of threads used:</p>
<pre><code>cargo test -j 2 -- --test-threads=2
</code></pre>
<dl>
<dt class="option-term" id="option-cargo-test--j"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-test---jobs"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value.
Should not be 0.</dd>
<dt class="option-term" id="option-cargo-test---keep-going"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---keep-going"></a><code>--keep-going</code></dt>
<dd class="option-desc">Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build. Unstable, requires
<code>-Zunstable-options</code>.</dd>
<dt class="option-term" id="option-cargo-test---future-incompat-report"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---future-incompat-report"></a><code>--future-incompat-report</code></dt>
<dd class="option-desc">Displays a future-incompat report for any future-incompatible warnings
produced during execution of this command</p>
<p>See <a href="commands/cargo-report.html">cargo-report(1)</a></dd>
</dl>
<h2 id="environment-10"><a class="header" href="#environment-10">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-10"><a class="header" href="#exit-status-10">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-12"><a class="header" href="#examples-12">EXAMPLES</a></h2>
<ol>
<li>
<p>Execute all the unit and integration tests of the current package:</p>
<pre><code>cargo test
</code></pre>
</li>
<li>
<p>Run only tests whose names match against a filter string:</p>
<pre><code>cargo test name_filter
</code></pre>
</li>
<li>
<p>Run only a specific test within a specific integration test:</p>
<pre><code>cargo test --test int_test_name -- modname::test_name
</code></pre>
</li>
</ol>
<h2 id="see-also-12"><a class="header" href="#see-also-12">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-bench.html">cargo-bench(1)</a>, <a href="commands/../reference/cargo-targets.html#tests">types of tests</a>, <a href="https://doc.rust-lang.org/rustc/tests/index.html">how to write tests</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-report1"><a class="header" href="#cargo-report1">cargo-report(1)</a></h1>
<h2 id="name-13"><a class="header" href="#name-13">NAME</a></h2>
<p>cargo-report - Generate and display various kinds of reports</p>
<h2 id="synopsis-13"><a class="header" href="#synopsis-13">SYNOPSIS</a></h2>
<p><code>cargo report</code> <em>type</em> [<em>options</em>]</p>
<h3 id="description-13"><a class="header" href="#description-13">DESCRIPTION</a></h3>
<p>Displays a report of the given <em>type</em> - currently, only <code>future-incompat</code> is supported</p>
<h2 id="options-12"><a class="header" href="#options-12">OPTIONS</a></h2>
<dl>
<dt class="option-term" id="option-cargo-report---id"><a class="option-anchor" href="commands/cargo-report.html#option-cargo-report---id"></a><code>--id</code> <em>id</em></dt>
<dd class="option-desc">Show the report with the specified Cargo-generated id</dd>
<dt class="option-term" id="option-cargo-report--p"><a class="option-anchor" href="commands/cargo-report.html#option-cargo-report--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-report---package"><a class="option-anchor" href="commands/cargo-report.html#option-cargo-report---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Only display a report for the specified package</dd>
</dl>
<h2 id="examples-13"><a class="header" href="#examples-13">EXAMPLES</a></h2>
<ol>
<li>
<p>Display the latest future-incompat report:</p>
<pre><code>cargo report future-incompat
</code></pre>
</li>
<li>
<p>Display the latest future-incompat report for a specific package:</p>
<pre><code>cargo report future-incompat --package my-dep:0.0.1
</code></pre>
</li>
</ol>
<h2 id="see-also-13"><a class="header" href="#see-also-13">SEE ALSO</a></h2>
<p><a href="commands/../reference/future-incompat-report.html">Future incompat report</a></p>
<p><a href="commands/cargo.html">cargo(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manifest-commands-1"><a class="header" href="#manifest-commands-1">Manifest Commands</a></h1>
<ul>
<li><a href="commands/cargo-add.html">cargo add</a></li>
<li><a href="commands/cargo-generate-lockfile.html">cargo generate-lockfile</a></li>
<li><a href="commands/cargo-locate-project.html">cargo locate-project</a></li>
<li><a href="commands/cargo-metadata.html">cargo metadata</a></li>
<li><a href="commands/cargo-pkgid.html">cargo pkgid</a></li>
<li><a href="commands/cargo-remove.html">cargo remove</a></li>
<li><a href="commands/cargo-tree.html">cargo tree</a></li>
<li><a href="commands/cargo-update.html">cargo update</a></li>
<li><a href="commands/cargo-vendor.html">cargo vendor</a></li>
<li><a href="commands/cargo-verify-project.html">cargo verify-project</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-add1"><a class="header" href="#cargo-add1">cargo-add(1)</a></h1>
<h2 id="名称"><a class="header" href="#名称">名称</a></h2>
<p>cargo-add -向Cargo.toml清单文件添加依赖项</p>
<h2 id="摘要"><a class="header" href="#摘要">摘要</a></h2>
<p><code>cargo add</code> [<em>options</em>] <em>crate</em>...<br />
<code>cargo add</code> [<em>options</em>] <code>--path</code> <em>path</em><br />
<code>cargo add</code> [<em>options</em>] <code>--git</code> <em>url</em> [<em>crate</em>...]</p>
<h2 id="描述"><a class="header" href="#描述">描述</a></h2>
<p>此命令可以添加或修改依赖关系。</p>
<p>依赖项的源可以通过以下内容指定：</p>
<ul>
<li><em>crate</em><code>@</code><em>version</em>: 以&quot;<em>version</em>&quot;的约束从注册中心取（包）</li>
<li><code>--path</code> <em>path</em>: 从指定的 <em>path</em> 取（包）</li>
<li><code>--git</code> <em>url</em>: 从给定 <em>url</em> 的git仓库拉取</li>
</ul>
<p>如果没有指定源，那么尽最大努力选择一个，包括：</p>
<ul>
<li>其他表中存在的依赖 (例如 <code>dev-dependencies</code>)</li>
<li>工作空间成员</li>
<li>注册中心中的最新发行版</li>
</ul>
<p>当您添加一个已经存在的包时，将使用指定的标志更新现有条目。</p>
<p>一旦成功调用，指定的依赖中的启用的 (<code>+</code>) 和 禁用的 (<code>-</code>) <a href="commands/../reference/features.html">特性</a>  将在命令输出中被列出</p>
<h2 id="选项-1"><a class="header" href="#选项-1">选项</a></h2>
<h3 id="源选项"><a class="header" href="#源选项">源选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-add---git"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---git"></a><code>--git</code> <em>url</em></dt>
<dd class="option-desc"><a href="commands/../reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories">从Git URL添加指定的crate</a>。</dd>
<dt class="option-term" id="option-cargo-add---branch"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---branch"></a><code>--branch</code> <em>branch</em></dt>
<dd class="option-desc">从git添加时使用的分支。</dd>
<dt class="option-term" id="option-cargo-add---tag"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---tag"></a><code>--tag</code> <em>tag</em></dt>
<dd class="option-desc">从git添加时使用的标签。</dd>
<dt class="option-term" id="option-cargo-add---rev"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---rev"></a><code>--rev</code> <em>sha</em></dt>
<dd class="option-desc">从git添加时使用的特定提交</dd>
<dt class="option-term" id="option-cargo-add---path"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---path"></a><code>--path</code> <em>path</em></dt>
<dd class="option-desc">要添加的本地crate的<a href="commands/../reference/specifying-dependencies.html#specifying-path-dependencies">文件系统路径</a>。</dd>
<dt class="option-term" id="option-cargo-add---registry"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">注册中心所使用的名称。注册中心名称被定义在<a href="commands/../reference/config.html">Cargo配置文件</a>中。如果未指定将会使用默认注册中心，该注册中心由registry.default配置项定义，默认为<code>crates-io</code>。</dd>
</dl>
<h3 id="部分选项"><a class="header" href="#部分选项">部分选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-add---dev"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---dev"></a><code>--dev</code></dt>
<dd class="option-desc">作为<a href="commands/../reference/specifying-dependencies.html#development-dependencies">开发依赖</a>添加。</dd>
<dt class="option-term" id="option-cargo-add---build"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---build"></a><code>--build</code></dt>
<dd class="option-desc">作为<a href="commands/../reference/specifying-dependencies.html#build-dependencies">构建依赖</a>添加。</dd>
<dt class="option-term" id="option-cargo-add---target"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---target"></a><code>--target</code> <em>target</em></dt>
<dd class="option-desc">作为<a href="commands/../reference/specifying-dependencies.html#platform-specific-dependencies">给定目标平台</a>的依赖添加。</dd>
</dl>
</dl>
<h3 id="依赖选项"><a class="header" href="#依赖选项">依赖选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-add---dry-run"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---dry-run"></a><code>--dry-run</code></dt>
<dd class="option-desc">不真的写入清单</dd>
<dt class="option-term" id="option-cargo-add---rename"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---rename"></a><code>--rename</code> <em>name</em></dt>
<dd class="option-desc"><a href="commands/../reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml">重命名</a>依赖项。</dd>
<dt class="option-term" id="option-cargo-add---optional"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---optional"></a><code>--optional</code></dt>
<dd class="option-desc">标记依赖为<a href="commands/../reference/features.html#optional-dependencies">可选的</a>。</dd>
<dt class="option-term" id="option-cargo-add---no-optional"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---no-optional"></a><code>--no-optional</code></dt>
<dd class="option-desc">标记依赖为<a href="commands/../reference/features.html#optional-dependencies">必需的</a>。</dd>
<dt class="option-term" id="option-cargo-add---no-default-features"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">禁用<a href="commands/../reference/features.html#dependency-features">默认特性</a></dd>
<dt class="option-term" id="option-cargo-add---default-features"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---default-features"></a><code>--default-features</code></dt>
<dd class="option-desc">重新启用<a href="commands/../reference/features.html#dependency-features">默认特性</a></dd>
<dt class="option-term" id="option-cargo-add---features"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">要激活的以逗号或空格分隔的<a href="commands/../reference/features.html#dependency-features">特性</a>。添加多个crate时，特定板条箱的功能可通过<code>包名称/功能名称</code>语法启用。可以多次指定该标志，从而启用所有指定的功能。</dd>
</dl>
<h3 id="显示选项-1"><a class="header" href="#显示选项-1">显示选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-add--v"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-add---verbose"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">使用详细输出。对于包括额外输出(如依赖关系警告和构建脚本输出)的“非常详细”输出，可以指定两次。也可以用<code>term.verbose</code><a href="commands/../reference/config.html">配置值</a>指定。</dd>
<dt class="option-term" id="option-cargo-add--q"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-add---quiet"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不要打印cargo日志信息。也可以用<code>term.quiet</code><a href="commands/../reference/config.html">配置值</a>指定。</dd>
<dt class="option-term" id="option-cargo-add---color"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制何时使用彩色输出。有效值：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持颜色。</li>
<li><code>always</code>: 总是显示颜色</li>
<li><code>never</code>: 从不显示颜色</li>
</ul>
<p>也可以用<code>term.quiet</code><a href="commands/../reference/config.html">配置值</a>指定。</dd>
</dl>
<h3 id="清单选项-1"><a class="header" href="#清单选项-1">清单选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-add---manifest-path"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc"><code>Cargo.toml</code>文件的路径。默认情况下，Cargo在当前目录或任何父目录中搜索<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-add--p"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add--p"></a><code>-p</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-add---package"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---package"></a><code>--package</code> <em>spec</em></dt>
<dd class="option-desc">仅向指定的包添加依赖项。</dd>
<dt class="option-term" id="option-cargo-add---frozen"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-add---locked"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个标志都要求<code>Cargo.lock</code>文件是最新的。如果lock文件丢失，或者需要更新，Cargo将出错退出。<code>--frozen</code>标志还防止cargo试图访问网络来确定它是否过期。
在您希望断言<code>Cargo.lock</code>文件是最新的(例如CI构建)或希望避免网络访问的环境中，可以使用这些文件。</dd>
<dt class="option-term" id="option-cargo-add---offline"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---offline"></a><code>--offline</code></dt>
<dd class="option-desc">防止 Cargo 以任何理由访问网络。如果没有这个标志，当 Cargo 需要访问网络而网络不可用时，Cargo 将出错停止。有了这个标志，如果可能的话，Cargo 将试图在没有网络的情况下前进。</p>
请注意，这可能会导致与在线模式不同的依赖关系解析。Cargo 将自己限制在本地下载的 crate 中，即使在索引的本地副本中可能有更新的版本。请参阅 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 命令，以便在脱机之前下载依赖项。</p>
也可以用 <code>net.offline</code> <a href="commands/../reference/config.html">配置值</a>指定。</dd>
</dl>
<h3 id="common-options-11"><a class="header" href="#common-options-11">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-add-+toolchain"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">如果cargo已经安装了rustup，并且 <code>cargo</code> 的第一个参数以 <code>cargo</code> 开头，它将被解释为 rustup 工具链名称(例如 <code>+stable</code> 或 <code>+nightly</code> )。有关工具链覆盖如何工作的更多信息，请参见 <a href="https://rust-lang.github.io/rustup/overrides.html">rustup 文档</a>。</dd>
<dt class="option-term" id="option-cargo-add---config"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">覆盖 Cargo 配置值。该参数应该采用 <code>KEY=VALUE</code> 的 TOML 语法，或者作为额外配置文件的路径提供。可以多次指定该标志。有关更多信息，请参见 <a href="commands/../reference/config.html#command-line-overrides">命令行覆盖部分</a>。</dd>
<dt class="option-term" id="option-cargo-add--h"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-add---help"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---help"></a><code>--help</code></dt>
<dd class="option-desc">打印帮助信息。</dd>
<dt class="option-term" id="option-cargo-add--Z"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Cargo 的不稳定 (nightly-only) 标志。运行 <code>cargo -Z help</code> 获取详细信息。</dd>
</dl>
<h2 id="环境-2"><a class="header" href="#环境-2">环境</a></h2>
<p>有关Cargo读取的环境变量的详细信息，请参见 <a href="commands/../reference/environment-variables.html">the reference</a>。</p>
<h2 id="退出状态-1"><a class="header" href="#退出状态-1">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo 成功.</li>
<li><code>101</code>: Cargo 未能完成.</li>
</ul>
<h2 id="示例"><a class="header" href="#示例">示例</a></h2>
<ol>
<li>
<p>添加 <code>regex</code> 作为依赖项</p>
<pre><code>cargo add regex
</code></pre>
</li>
<li>
<p>添加 <code>trybuild</code> 作为开发依赖项</p>
<pre><code>cargo add --dev trybuild
</code></pre>
</li>
<li>
<p>添加旧版本的 <code>nom</code> 作为依赖项</p>
<pre><code>cargo add nom@5
</code></pre>
</li>
<li>
<p>添加对使用 <code>derive</code> 将数据结构序列化到json的支持</p>
<pre><code>cargo add serde serde_json -F serde/derive
</code></pre>
</li>
</ol>
<h2 id="另见"><a class="header" href="#另见">另见</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-remove.html">cargo-remove(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-generate-lockfile1"><a class="header" href="#cargo-generate-lockfile1">cargo-generate-lockfile(1)</a></h1>
<h2 id="name-14"><a class="header" href="#name-14">NAME</a></h2>
<p>cargo-generate-lockfile - Generate the lockfile for a package</p>
<h2 id="synopsis-14"><a class="header" href="#synopsis-14">SYNOPSIS</a></h2>
<p><code>cargo generate-lockfile</code> [<em>options</em>]</p>
<h2 id="description-14"><a class="header" href="#description-14">DESCRIPTION</a></h2>
<p>This command will create the <code>Cargo.lock</code> lockfile for the current package or
workspace. If the lockfile already exists, it will be rebuilt with the latest
available version of every package.</p>
<p>See also <a href="commands/cargo-update.html">cargo-update(1)</a> which is also capable of creating a <code>Cargo.lock</code>
lockfile and has more options for controlling update behavior.</p>
<h2 id="options-13"><a class="header" href="#options-13">OPTIONS</a></h2>
<h3 id="display-options-11"><a class="header" href="#display-options-11">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-generate-lockfile--v"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-generate-lockfile---verbose"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-generate-lockfile--q"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-generate-lockfile---quiet"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-generate-lockfile---color"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="manifest-options-11"><a class="header" href="#manifest-options-11">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-generate-lockfile---manifest-path"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-generate-lockfile---frozen"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-generate-lockfile---locked"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-generate-lockfile---offline"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-12"><a class="header" href="#common-options-12">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-generate-lockfile-+toolchain"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-generate-lockfile---config"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-generate-lockfile--h"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-generate-lockfile---help"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-generate-lockfile--Z"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-11"><a class="header" href="#environment-11">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-11"><a class="header" href="#exit-status-11">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-14"><a class="header" href="#examples-14">EXAMPLES</a></h2>
<ol>
<li>
<p>Create or update the lockfile for the current package or workspace:</p>
<pre><code>cargo generate-lockfile
</code></pre>
</li>
</ol>
<h2 id="see-also-14"><a class="header" href="#see-also-14">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-update.html">cargo-update(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-locate-project1"><a class="header" href="#cargo-locate-project1">cargo-locate-project(1)</a></h1>
<h2 id="name-15"><a class="header" href="#name-15">NAME</a></h2>
<p>cargo-locate-project - Print a JSON representation of a Cargo.toml file's location</p>
<h2 id="synopsis-15"><a class="header" href="#synopsis-15">SYNOPSIS</a></h2>
<p><code>cargo locate-project</code> [<em>options</em>]</p>
<h2 id="description-15"><a class="header" href="#description-15">DESCRIPTION</a></h2>
<p>This command will print a JSON object to stdout with the full path to the manifest. The
manifest is found by searching upward for a file named <code>Cargo.toml</code> starting from the current
working directory.</p>
<p>If the project happens to be a part of a workspace, the manifest of the project, rather than
the workspace root, is output. This can be overriden by the <code>--workspace</code> flag. The root
workspace is found by traversing further upward or by using the field <code>package.workspace</code> after
locating the manifest of a workspace member.</p>
<h2 id="options-14"><a class="header" href="#options-14">OPTIONS</a></h2>
<dl>
<dt class="option-term" id="option-cargo-locate-project---workspace"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Locate the <code>Cargo.toml</code> at the root of the workspace, as opposed to the current
workspace member.</dd>
</dl>
<h3 id="display-options-12"><a class="header" href="#display-options-12">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-locate-project---message-format"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The representation in which to print the project location. Valid values:</p>
<ul>
<li><code>json</code> (default): JSON object with the path under the key &quot;root&quot;.</li>
<li><code>plain</code>: Just the path.</li>
</ul></dd>
<dt class="option-term" id="option-cargo-locate-project--v"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-locate-project---verbose"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-locate-project--q"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-locate-project---quiet"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-locate-project---color"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="manifest-options-12"><a class="header" href="#manifest-options-12">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-locate-project---manifest-path"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
</dl>
<h3 id="common-options-13"><a class="header" href="#common-options-13">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-locate-project-+toolchain"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-locate-project---config"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-locate-project--h"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-locate-project---help"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-locate-project--Z"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-12"><a class="header" href="#environment-12">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-12"><a class="header" href="#exit-status-12">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-15"><a class="header" href="#examples-15">EXAMPLES</a></h2>
<ol>
<li>
<p>Display the path to the manifest based on the current directory:</p>
<pre><code>cargo locate-project
</code></pre>
</li>
</ol>
<h2 id="see-also-15"><a class="header" href="#see-also-15">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-metadata.html">cargo-metadata(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-metadata1"><a class="header" href="#cargo-metadata1">cargo-metadata(1)</a></h1>
<h2 id="name-16"><a class="header" href="#name-16">NAME</a></h2>
<p>cargo-metadata - Machine-readable metadata about the current package</p>
<h2 id="synopsis-16"><a class="header" href="#synopsis-16">SYNOPSIS</a></h2>
<p><code>cargo metadata</code> [<em>options</em>]</p>
<h2 id="description-16"><a class="header" href="#description-16">DESCRIPTION</a></h2>
<p>Output JSON to stdout containing information about the workspace members and
resolved dependencies of the current package.</p>
<p>It is recommended to include the <code>--format-version</code> flag to future-proof
your code to ensure the output is in the format you are expecting.</p>
<p>See the <a href="https://crates.io/crates/cargo_metadata">cargo_metadata crate</a>
for a Rust API for reading the metadata.</p>
<h2 id="output-format"><a class="header" href="#output-format">OUTPUT FORMAT</a></h2>
<p>The output has the following format:</p>
<pre><code class="language-javascript">{
    /* Array of all packages in the workspace.
       It also includes all feature-enabled dependencies unless --no-deps is used.
    */
    &quot;packages&quot;: [
        {
            /* The name of the package. */
            &quot;name&quot;: &quot;my-package&quot;,
            /* The version of the package. */
            &quot;version&quot;: &quot;0.1.0&quot;,
            /* The Package ID, a unique identifier for referring to the package. */
            &quot;id&quot;: &quot;my-package 0.1.0 (path+file:///path/to/my-package)&quot;,
            /* The license value from the manifest, or null. */
            &quot;license&quot;: &quot;MIT/Apache-2.0&quot;,
            /* The license-file value from the manifest, or null. */
            &quot;license_file&quot;: &quot;LICENSE&quot;,
            /* The description value from the manifest, or null. */
            &quot;description&quot;: &quot;Package description.&quot;,
            /* The source ID of the package. This represents where
               a package is retrieved from.
               This is null for path dependencies and workspace members.
               For other dependencies, it is a string with the format:
               - &quot;registry+URL&quot; for registry-based dependencies.
                 Example: &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
               - &quot;git+URL&quot; for git-based dependencies.
                 Example: &quot;git+https://github.com/rust-lang/cargo?rev=5e85ba14aaa20f8133863373404cb0af69eeef2c#5e85ba14aaa20f8133863373404cb0af69eeef2c&quot;
            */
            &quot;source&quot;: null,
            /* Array of dependencies declared in the package's manifest. */
            &quot;dependencies&quot;: [
                {
                    /* The name of the dependency. */
                    &quot;name&quot;: &quot;bitflags&quot;,
                    /* The source ID of the dependency. May be null, see
                       description for the package source.
                    */
                    &quot;source&quot;: &quot;registry+https://github.com/rust-lang/crates.io-index&quot;,
                    /* The version requirement for the dependency.
                       Dependencies without a version requirement have a value of &quot;*&quot;.
                    */
                    &quot;req&quot;: &quot;^1.0&quot;,
                    /* The dependency kind.
                       &quot;dev&quot;, &quot;build&quot;, or null for a normal dependency.
                    */
                    &quot;kind&quot;: null,
                    /* If the dependency is renamed, this is the new name for
                       the dependency as a string.  null if it is not renamed.
                    */
                    &quot;rename&quot;: null,
                    /* Boolean of whether or not this is an optional dependency. */
                    &quot;optional&quot;: false,
                    /* Boolean of whether or not default features are enabled. */
                    &quot;uses_default_features&quot;: true,
                    /* Array of features enabled. */
                    &quot;features&quot;: [],
                    /* The target platform for the dependency.
                       null if not a target dependency.
                    */
                    &quot;target&quot;: &quot;cfg(windows)&quot;,
                    /* The file system path for a local path dependency.
                       not present if not a path dependency.
                    */
                    &quot;path&quot;: &quot;/path/to/dep&quot;,
                    /* A string of the URL of the registry this dependency is from.
                       If not specified or null, the dependency is from the default
                       registry (crates.io).
                    */
                    &quot;registry&quot;: null
                }
            ],
            /* Array of Cargo targets. */
            &quot;targets&quot;: [
                {
                    /* Array of target kinds.
                       - lib targets list the `crate-type` values from the
                         manifest such as &quot;lib&quot;, &quot;rlib&quot;, &quot;dylib&quot;,
                         &quot;proc-macro&quot;, etc. (default [&quot;lib&quot;])
                       - binary is [&quot;bin&quot;]
                       - example is [&quot;example&quot;]
                       - integration test is [&quot;test&quot;]
                       - benchmark is [&quot;bench&quot;]
                       - build script is [&quot;custom-build&quot;]
                    */
                    &quot;kind&quot;: [
                        &quot;bin&quot;
                    ],
                    /* Array of crate types.
                       - lib and example libraries list the `crate-type` values
                         from the manifest such as &quot;lib&quot;, &quot;rlib&quot;, &quot;dylib&quot;,
                         &quot;proc-macro&quot;, etc. (default [&quot;lib&quot;])
                       - all other target kinds are [&quot;bin&quot;]
                    */
                    &quot;crate_types&quot;: [
                        &quot;bin&quot;
                    ],
                    /* The name of the target. */
                    &quot;name&quot;: &quot;my-package&quot;,
                    /* Absolute path to the root source file of the target. */
                    &quot;src_path&quot;: &quot;/path/to/my-package/src/main.rs&quot;,
                    /* The Rust edition of the target.
                       Defaults to the package edition.
                    */
                    &quot;edition&quot;: &quot;2018&quot;,
                    /* Array of required features.
                       This property is not included if no required features are set.
                    */
                    &quot;required-features&quot;: [&quot;feat1&quot;],
                    /* Whether the target should be documented by `cargo doc`. */
                    &quot;doc&quot;: true,
                    /* Whether or not this target has doc tests enabled, and
                       the target is compatible with doc testing.
                    */
                    &quot;doctest&quot;: false,
                    /* Whether or not this target should be built and run with `--test`
                    */
                    &quot;test&quot;: true
                }
            ],
            /* Set of features defined for the package.
               Each feature maps to an array of features or dependencies it
               enables.
            */
            &quot;features&quot;: {
                &quot;default&quot;: [
                    &quot;feat1&quot;
                ],
                &quot;feat1&quot;: [],
                &quot;feat2&quot;: []
            },
            /* Absolute path to this package's manifest. */
            &quot;manifest_path&quot;: &quot;/path/to/my-package/Cargo.toml&quot;,
            /* Package metadata.
               This is null if no metadata is specified.
            */
            &quot;metadata&quot;: {
                &quot;docs&quot;: {
                    &quot;rs&quot;: {
                        &quot;all-features&quot;: true
                    }
                }
            },
            /* List of registries to which this package may be published.
               Publishing is unrestricted if null, and forbidden if an empty array. */
            &quot;publish&quot;: [
                &quot;crates-io&quot;
            ],
            /* Array of authors from the manifest.
               Empty array if no authors specified.
            */
            &quot;authors&quot;: [
                &quot;Jane Doe &lt;user@example.com&gt;&quot;
            ],
            /* Array of categories from the manifest. */
            &quot;categories&quot;: [
                &quot;command-line-utilities&quot;
            ],
            /* Optional string that is the default binary picked by cargo run. */
            &quot;default_run&quot;: null,
            /* Optional string that is the minimum supported rust version */
            &quot;rust_version&quot;: &quot;1.56&quot;,
            /* Array of keywords from the manifest. */
            &quot;keywords&quot;: [
                &quot;cli&quot;
            ],
            /* The readme value from the manifest or null if not specified. */
            &quot;readme&quot;: &quot;README.md&quot;,
            /* The repository value from the manifest or null if not specified. */
            &quot;repository&quot;: &quot;https://github.com/rust-lang/cargo&quot;,
            /* The homepage value from the manifest or null if not specified. */
            &quot;homepage&quot;: &quot;https://rust-lang.org&quot;,
            /* The documentation value from the manifest or null if not specified. */
            &quot;documentation&quot;: &quot;https://doc.rust-lang.org/stable/std&quot;,
            /* The default edition of the package.
               Note that individual targets may have different editions.
            */
            &quot;edition&quot;: &quot;2018&quot;,
            /* Optional string that is the name of a native library the package
               is linking to.
            */
            &quot;links&quot;: null,
        }
    ],
    /* Array of members of the workspace.
       Each entry is the Package ID for the package.
    */
    &quot;workspace_members&quot;: [
        &quot;my-package 0.1.0 (path+file:///path/to/my-package)&quot;,
    ],
    // The resolved dependency graph for the entire workspace. The enabled
    // features are based on the enabled features for the &quot;current&quot; package.
    // Inactivated optional dependencies are not listed.
    //
    // This is null if --no-deps is specified.
    //
    // By default, this includes all dependencies for all target platforms.
    // The `--filter-platform` flag may be used to narrow to a specific
    // target triple.
    &quot;resolve&quot;: {
        /* Array of nodes within the dependency graph.
           Each node is a package.
        */
        &quot;nodes&quot;: [
            {
                /* The Package ID of this node. */
                &quot;id&quot;: &quot;my-package 0.1.0 (path+file:///path/to/my-package)&quot;,
                /* The dependencies of this package, an array of Package IDs. */
                &quot;dependencies&quot;: [
                    &quot;bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)&quot;
                ],
                /* The dependencies of this package. This is an alternative to
                   &quot;dependencies&quot; which contains additional information. In
                   particular, this handles renamed dependencies.
                */
                &quot;deps&quot;: [
                    {
                        /* The name of the dependency's library target.
                           If this is a renamed dependency, this is the new
                           name.
                        */
                        &quot;name&quot;: &quot;bitflags&quot;,
                        /* The Package ID of the dependency. */
                        &quot;pkg&quot;: &quot;bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)&quot;,
                        /* Array of dependency kinds. Added in Cargo 1.40. */
                        &quot;dep_kinds&quot;: [
                            {
                                /* The dependency kind.
                                   &quot;dev&quot;, &quot;build&quot;, or null for a normal dependency.
                                */
                                &quot;kind&quot;: null,
                                /* The target platform for the dependency.
                                   null if not a target dependency.
                                */
                                &quot;target&quot;: &quot;cfg(windows)&quot;
                            }
                        ]
                    }
                ],
                /* Array of features enabled on this package. */
                &quot;features&quot;: [
                    &quot;default&quot;
                ]
            }
        ],
        /* The root package of the workspace.
           This is null if this is a virtual workspace. Otherwise it is
           the Package ID of the root package.
        */
        &quot;root&quot;: &quot;my-package 0.1.0 (path+file:///path/to/my-package)&quot;
    },
    /* The absolute path to the build directory where Cargo places its output. */
    &quot;target_directory&quot;: &quot;/path/to/my-package/target&quot;,
    /* The version of the schema for this metadata structure.
       This will be changed if incompatible changes are ever made.
    */
    &quot;version&quot;: 1,
    /* The absolute path to the root of the workspace. */
    &quot;workspace_root&quot;: &quot;/path/to/my-package&quot;
    /* Workspace metadata.
       This is null if no metadata is specified. */
    &quot;metadata&quot;: {
        &quot;docs&quot;: {
            &quot;rs&quot;: {
                &quot;all-features&quot;: true
            }
        }
    }
}
</code></pre>
<h2 id="options-15"><a class="header" href="#options-15">OPTIONS</a></h2>
<h3 id="output-options-8"><a class="header" href="#output-options-8">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-metadata---no-deps"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---no-deps"></a><code>--no-deps</code></dt>
<dd class="option-desc">Output information only about the workspace members and don't fetch
dependencies.</dd>
<dt class="option-term" id="option-cargo-metadata---format-version"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---format-version"></a><code>--format-version</code> <em>version</em></dt>
<dd class="option-desc">Specify the version of the output format to use. Currently <code>1</code> is the only
possible value.</dd>
<dt class="option-term" id="option-cargo-metadata---filter-platform"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---filter-platform"></a><code>--filter-platform</code> <em>triple</em></dt>
<dd class="option-desc">This filters the <code>resolve</code> output to only include dependencies for the
given target triple. Without this flag, the resolve includes all targets.</p>
<p>Note that the dependencies listed in the &quot;packages&quot; array still includes all
dependencies. Each package definition is intended to be an unaltered
reproduction of the information within <code>Cargo.toml</code>.</dd>
</dl>
<h3 id="feature-selection-8"><a class="header" href="#feature-selection-8">Feature Selection</a></h3>
<p>The feature flags allow you to control which features are enabled. When no
feature options are given, the <code>default</code> feature is activated for every
selected package.</p>
<p>See <a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>
for more details.</p>
<dl>
<dt class="option-term" id="option-cargo-metadata--F"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata--F"></a><code>-F</code> <em>features</em></dt>
<dt class="option-term" id="option-cargo-metadata---features"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-metadata---all-features"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-metadata---no-default-features"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="display-options-13"><a class="header" href="#display-options-13">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-metadata--v"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-metadata---verbose"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-metadata--q"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-metadata---quiet"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-metadata---color"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="manifest-options-13"><a class="header" href="#manifest-options-13">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-metadata---manifest-path"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-metadata---frozen"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-metadata---locked"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-metadata---offline"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-14"><a class="header" href="#common-options-14">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-metadata-+toolchain"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-metadata---config"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-metadata--h"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-metadata---help"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-metadata--Z"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-13"><a class="header" href="#environment-13">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-13"><a class="header" href="#exit-status-13">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-16"><a class="header" href="#examples-16">EXAMPLES</a></h2>
<ol>
<li>
<p>Output JSON about the current package:</p>
<pre><code>cargo metadata --format-version=1
</code></pre>
</li>
</ol>
<h2 id="see-also-16"><a class="header" href="#see-also-16">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-pkgid1"><a class="header" href="#cargo-pkgid1">cargo-pkgid(1)</a></h1>
<h2 id="name-17"><a class="header" href="#name-17">NAME</a></h2>
<p>cargo-pkgid - Print a fully qualified package specification</p>
<h2 id="synopsis-17"><a class="header" href="#synopsis-17">SYNOPSIS</a></h2>
<p><code>cargo pkgid</code> [<em>options</em>] [<em>spec</em>]</p>
<h2 id="description-17"><a class="header" href="#description-17">DESCRIPTION</a></h2>
<p>Given a <em>spec</em> argument, print out the fully qualified package ID specifier
for a package or dependency in the current workspace. This command will
generate an error if <em>spec</em> is ambiguous as to which package it refers to in
the dependency graph. If no <em>spec</em> is given, then the specifier for the local
package is printed.</p>
<p>This command requires that a lockfile is available and dependencies have been
fetched.</p>
<p>A package specifier consists of a name, version, and source URL. You are
allowed to use partial specifiers to succinctly match a specific package as
long as it matches only one package. The format of a <em>spec</em> can be one of the
following:</p>
<div class="table-wrapper"><table><thead><tr><th>SPEC Structure</th><th>Example SPEC</th></tr></thead><tbody>
<tr><td><em>name</em></td><td><code>bitflags</code></td></tr>
<tr><td><em>name</em><code>@</code><em>version</em></td><td><code>bitflags@1.0.4</code></td></tr>
<tr><td><em>url</em></td><td><code>https://github.com/rust-lang/cargo</code></td></tr>
<tr><td><em>url</em><code>#</code><em>version</em></td><td><code>https://github.com/rust-lang/cargo#0.33.0</code></td></tr>
<tr><td><em>url</em><code>#</code><em>name</em></td><td><code>https://github.com/rust-lang/crates.io-index#bitflags</code></td></tr>
<tr><td><em>url</em><code>#</code><em>name</em><code>:</code><em>version</em></td><td><code>https://github.com/rust-lang/cargo#crates-io@0.21.0</code></td></tr>
</tbody></table>
</div>
<h2 id="options-16"><a class="header" href="#options-16">OPTIONS</a></h2>
<h3 id="package-selection-9"><a class="header" href="#package-selection-9">Package Selection</a></h3>
<dl>
<dt class="option-term" id="option-cargo-pkgid--p"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid--p"></a><code>-p</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-pkgid---package"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---package"></a><code>--package</code> <em>spec</em></dt>
<dd class="option-desc">Get the package ID for the given package instead of the current package.</dd>
</dl>
<h3 id="display-options-14"><a class="header" href="#display-options-14">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-pkgid--v"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-pkgid---verbose"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-pkgid--q"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-pkgid---quiet"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-pkgid---color"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="manifest-options-14"><a class="header" href="#manifest-options-14">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-pkgid---manifest-path"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-pkgid---frozen"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-pkgid---locked"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-pkgid---offline"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-15"><a class="header" href="#common-options-15">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-pkgid-+toolchain"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-pkgid---config"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-pkgid--h"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-pkgid---help"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-pkgid--Z"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-14"><a class="header" href="#environment-14">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-14"><a class="header" href="#exit-status-14">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-17"><a class="header" href="#examples-17">EXAMPLES</a></h2>
<ol>
<li>
<p>Retrieve package specification for <code>foo</code> package:</p>
<pre><code>cargo pkgid foo
</code></pre>
</li>
<li>
<p>Retrieve package specification for version 1.0.0 of <code>foo</code>:</p>
<pre><code>cargo pkgid foo@1.0.0
</code></pre>
</li>
<li>
<p>Retrieve package specification for <code>foo</code> from crates.io:</p>
<pre><code>cargo pkgid https://github.com/rust-lang/crates.io-index#foo
</code></pre>
</li>
<li>
<p>Retrieve package specification for <code>foo</code> from a local package:</p>
<pre><code>cargo pkgid file:///path/to/local/package#foo
</code></pre>
</li>
</ol>
<h2 id="see-also-17"><a class="header" href="#see-also-17">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-generate-lockfile.html">cargo-generate-lockfile(1)</a>, <a href="commands/cargo-metadata.html">cargo-metadata(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-remove1"><a class="header" href="#cargo-remove1">cargo-remove(1)</a></h1>
<h2 id="name-18"><a class="header" href="#name-18">NAME</a></h2>
<p>cargo-remove - Remove dependencies from a Cargo.toml manifest file</p>
<h2 id="synopsis-18"><a class="header" href="#synopsis-18">SYNOPSIS</a></h2>
<p><code>cargo remove</code> [<em>options</em>] <em>dependency</em>...</p>
<h2 id="description-18"><a class="header" href="#description-18">DESCRIPTION</a></h2>
<p>Remove one or more dependencies from a <code>Cargo.toml</code> manifest.</p>
<h2 id="options-17"><a class="header" href="#options-17">OPTIONS</a></h2>
<h3 id="section-options"><a class="header" href="#section-options">Section options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-remove---dev"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---dev"></a><code>--dev</code></dt>
<dd class="option-desc">Remove as a <a href="commands/../reference/specifying-dependencies.html#development-dependencies">development dependency</a>.</dd>
<dt class="option-term" id="option-cargo-remove---build"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---build"></a><code>--build</code></dt>
<dd class="option-desc">Remove as a <a href="commands/../reference/specifying-dependencies.html#build-dependencies">build dependency</a>.</dd>
<dt class="option-term" id="option-cargo-remove---target"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---target"></a><code>--target</code> <em>target</em></dt>
<dd class="option-desc">Remove as a dependency to the <a href="commands/../reference/specifying-dependencies.html#platform-specific-dependencies">given target platform</a>.</dd>
</dl>
<h3 id="miscellaneous-options-8"><a class="header" href="#miscellaneous-options-8">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-remove---dry-run"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---dry-run"></a><code>--dry-run</code></dt>
<dd class="option-desc">Don't actually write to the manifest.</dd>
</dl>
<h3 id="display-options-15"><a class="header" href="#display-options-15">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-remove--v"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-remove---verbose"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-remove--q"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-remove---quiet"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-remove---color"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="manifest-options-15"><a class="header" href="#manifest-options-15">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-remove---manifest-path"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-remove---frozen"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-remove---locked"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-remove---offline"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="package-selection-10"><a class="header" href="#package-selection-10">Package Selection</a></h3>
<dl>
<dt class="option-term" id="option-cargo-remove--p"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-remove---package"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Package to remove from.</dd>
</dl>
<h3 id="common-options-16"><a class="header" href="#common-options-16">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-remove-+toolchain"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-remove---config"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-remove--h"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-remove---help"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-remove--Z"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-15"><a class="header" href="#environment-15">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-15"><a class="header" href="#exit-status-15">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-18"><a class="header" href="#examples-18">EXAMPLES</a></h2>
<ol>
<li>
<p>Remove <code>regex</code> as a dependency</p>
<pre><code>cargo remove regex
</code></pre>
</li>
<li>
<p>Remove <code>trybuild</code> as a dev-dependency</p>
<pre><code>cargo remove --dev trybuild
</code></pre>
</li>
<li>
<p>Remove <code>nom</code> from the <code>x86_64-pc-windows-gnu</code> dependencies table</p>
<pre><code>cargo remove --target x86_64-pc-windows-gnu nom
</code></pre>
</li>
</ol>
<h2 id="see-also-18"><a class="header" href="#see-also-18">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-add.html">cargo-add(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-tree1"><a class="header" href="#cargo-tree1">cargo-tree(1)</a></h1>
<h2 id="name-19"><a class="header" href="#name-19">NAME</a></h2>
<p>cargo-tree - Display a tree visualization of a dependency graph</p>
<h2 id="synopsis-19"><a class="header" href="#synopsis-19">SYNOPSIS</a></h2>
<p><code>cargo tree</code> [<em>options</em>]</p>
<h2 id="description-19"><a class="header" href="#description-19">DESCRIPTION</a></h2>
<p>This command will display a tree of dependencies to the terminal. An example
of a simple project that depends on the &quot;rand&quot; package:</p>
<pre><code>myproject v0.1.0 (/myproject)
└── rand v0.7.3
    ├── getrandom v0.1.14
    │   ├── cfg-if v0.1.10
    │   └── libc v0.2.68
    ├── libc v0.2.68 (*)
    ├── rand_chacha v0.2.2
    │   ├── ppv-lite86 v0.2.6
    │   └── rand_core v0.5.1
    │       └── getrandom v0.1.14 (*)
    └── rand_core v0.5.1 (*)
[build-dependencies]
└── cc v1.0.50
</code></pre>
<p>Packages marked with <code>(*)</code> have been &quot;de-duplicated&quot;. The dependencies for the
package have already been shown elsewhere in the graph, and so are not
repeated. Use the <code>--no-dedupe</code> option to repeat the duplicates.</p>
<p>The <code>-e</code> flag can be used to select the dependency kinds to display. The
&quot;features&quot; kind changes the output to display the features enabled by
each dependency. For example, <code>cargo tree -e features</code>:</p>
<pre><code>myproject v0.1.0 (/myproject)
└── log feature &quot;serde&quot;
    └── log v0.4.8
        ├── serde v1.0.106
        └── cfg-if feature &quot;default&quot;
            └── cfg-if v0.1.10
</code></pre>
<p>In this tree, <code>myproject</code> depends on <code>log</code> with the <code>serde</code> feature. <code>log</code> in
turn depends on <code>cfg-if</code> with &quot;default&quot; features. When using <code>-e features</code> it
can be helpful to use <code>-i</code> flag to show how the features flow into a package.
See the examples below for more detail.</p>
<h3 id="feature-unification"><a class="header" href="#feature-unification">Feature Unification</a></h3>
<p>This command shows a graph much closer to a feature-unified graph Cargo will
build, rather than what you list in <code>Cargo.toml</code>. For instance, if you specify
the same dependency in both <code>[dependencies]</code> and <code>[dev-dependencies]</code> but with
different features on. This command may merge all features and show a <code>(*)</code> on
one of the dependency to indicate the duplicate.</p>
<p>As a result, for a mostly equivalent overview of what <code>cargo build</code> does,
<code>cargo tree -e normal,build</code> is pretty close; for a mostly equivalent overview
of what <code>cargo test</code> does, <code>cargo tree</code> is pretty close. However, it doesn't
guarantee the exact equivalence to what Cargo is going to build, since a
compilation is complex and depends on lots of different factors.</p>
<p>To learm more about feature unification, check out this
<a href="commands/../reference/features.html#feature-unification">dedicated section</a>.</p>
<h2 id="options-18"><a class="header" href="#options-18">OPTIONS</a></h2>
<h3 id="tree-options"><a class="header" href="#tree-options">Tree Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree--i"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--i"></a><code>-i</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-tree---invert"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---invert"></a><code>--invert</code> <em>spec</em></dt>
<dd class="option-desc">Show the reverse dependencies for the given package. This flag will invert
the tree and display the packages that depend on the given package.</p>
<p>Note that in a workspace, by default it will only display the package's
reverse dependencies inside the tree of the workspace member in the current
directory. The <code>--workspace</code> flag can be used to extend it so that it will
show the package's reverse dependencies across the entire workspace. The <code>-p</code>
flag can be used to display the package's reverse dependencies only with the
subtree of the package given to <code>-p</code>.</dd>
<dt class="option-term" id="option-cargo-tree---prune"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---prune"></a><code>--prune</code> <em>spec</em></dt>
<dd class="option-desc">Prune the given package from the display of the dependency tree.</dd>
<dt class="option-term" id="option-cargo-tree---depth"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---depth"></a><code>--depth</code> <em>depth</em></dt>
<dd class="option-desc">Maximum display depth of the dependency tree. A depth of 1 displays the direct
dependencies, for example.</dd>
<dt class="option-term" id="option-cargo-tree---no-dedupe"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---no-dedupe"></a><code>--no-dedupe</code></dt>
<dd class="option-desc">Do not de-duplicate repeated dependencies. Usually, when a package has already
displayed its dependencies, further occurrences will not re-display its
dependencies, and will include a <code>(*)</code> to indicate it has already been shown.
This flag will cause those duplicates to be repeated.</dd>
<dt class="option-term" id="option-cargo-tree--d"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--d"></a><code>-d</code></dt>
<dt class="option-term" id="option-cargo-tree---duplicates"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---duplicates"></a><code>--duplicates</code></dt>
<dd class="option-desc">Show only dependencies which come in multiple versions (implies <code>--invert</code>).
When used with the <code>-p</code> flag, only shows duplicates within the subtree of the
given package.</p>
<p>It can be beneficial for build times and executable sizes to avoid building
that same package multiple times. This flag can help identify the offending
packages. You can then investigate if the package that depends on the
duplicate with the older version can be updated to the newer version so that
only one instance is built.</dd>
<dt class="option-term" id="option-cargo-tree--e"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--e"></a><code>-e</code> <em>kinds</em></dt>
<dt class="option-term" id="option-cargo-tree---edges"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---edges"></a><code>--edges</code> <em>kinds</em></dt>
<dd class="option-desc">The dependency kinds to display. Takes a comma separated list of values:</p>
<ul>
<li><code>all</code> — Show all edge kinds.</li>
<li><code>normal</code> — Show normal dependencies.</li>
<li><code>build</code> — Show build dependencies.</li>
<li><code>dev</code> — Show development dependencies.</li>
<li><code>features</code> — Show features enabled by each dependency. If this is the only
kind given, then it will automatically include the other dependency kinds.</li>
<li><code>no-normal</code> — Do not include normal dependencies.</li>
<li><code>no-build</code> — Do not include build dependencies.</li>
<li><code>no-dev</code> — Do not include development dependencies.</li>
<li><code>no-proc-macro</code> — Do not include procedural macro dependencies.</li>
</ul>
<p>The <code>normal</code>, <code>build</code>, <code>dev</code>, and <code>all</code> dependency kinds cannot be mixed with
<code>no-normal</code>, <code>no-build</code>, or <code>no-dev</code> dependency kinds.</p>
<p>The default is <code>normal,build,dev</code>.</dd>
<dt class="option-term" id="option-cargo-tree---target"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Filter dependencies matching the given target-triple. The default is the host
platform. Use the value <code>all</code> to include <em>all</em> targets.</dd>
</dl>
<h3 id="tree-formatting-options"><a class="header" href="#tree-formatting-options">Tree Formatting Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree---charset"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---charset"></a><code>--charset</code> <em>charset</em></dt>
<dd class="option-desc">Chooses the character set to use for the tree. Valid values are &quot;utf8&quot; or
&quot;ascii&quot;. Default is &quot;utf8&quot;.</dd>
<dt class="option-term" id="option-cargo-tree--f"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--f"></a><code>-f</code> <em>format</em></dt>
<dt class="option-term" id="option-cargo-tree---format"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---format"></a><code>--format</code> <em>format</em></dt>
<dd class="option-desc">Set the format string for each package. The default is &quot;{p}&quot;.</p>
<p>This is an arbitrary string which will be used to display each package. The following
strings will be replaced with the corresponding value:</p>
<ul>
<li><code>{p}</code> — The package name.</li>
<li><code>{l}</code> — The package license.</li>
<li><code>{r}</code> — The package repository URL.</li>
<li><code>{f}</code> — Comma-separated list of package features that are enabled.</li>
<li><code>{lib}</code> — The name, as used in a <code>use</code> statement, of the package's library.</li>
</ul></dd>
<dt class="option-term" id="option-cargo-tree---prefix"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---prefix"></a><code>--prefix</code> <em>prefix</em></dt>
<dd class="option-desc">Sets how each line is displayed. The <em>prefix</em> value can be one of:</p>
<ul>
<li><code>indent</code> (default) — Shows each line indented as a tree.</li>
<li><code>depth</code> — Show as a list, with the numeric depth printed before each entry.</li>
<li><code>none</code> — Show as a flat list.</li>
</ul></dd>
</dl>
<h3 id="package-selection-11"><a class="header" href="#package-selection-11">Package Selection</a></h3>
<p>By default, when no package selection options are given, the packages selected
depend on the selected manifest file (based on the current working directory if
<code>--manifest-path</code> is not given). If the manifest is the root of a workspace then
the workspaces default members are selected, otherwise only the package defined
by the manifest will be selected.</p>
<p>The default members of a workspace can be set explicitly with the
<code>workspace.default-members</code> key in the root manifest. If this is not set, a
virtual workspace will include all workspace members (equivalent to passing
<code>--workspace</code>), and a non-virtual workspace will include only the root crate itself.</p>
<dl>
<dt class="option-term" id="option-cargo-tree--p"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-tree---package"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Display only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally 
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</dd>
<dt class="option-term" id="option-cargo-tree---workspace"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Display all members in the workspace.</dd>
<dt class="option-term" id="option-cargo-tree---exclude"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</dd>
</dl>
<h3 id="manifest-options-16"><a class="header" href="#manifest-options-16">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree---manifest-path"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-tree---frozen"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-tree---locked"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-tree---offline"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="feature-selection-9"><a class="header" href="#feature-selection-9">Feature Selection</a></h3>
<p>The feature flags allow you to control which features are enabled. When no
feature options are given, the <code>default</code> feature is activated for every
selected package.</p>
<p>See <a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>
for more details.</p>
<dl>
<dt class="option-term" id="option-cargo-tree--F"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--F"></a><code>-F</code> <em>features</em></dt>
<dt class="option-term" id="option-cargo-tree---features"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-tree---all-features"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-tree---no-default-features"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="display-options-16"><a class="header" href="#display-options-16">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree--v"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-tree---verbose"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-tree--q"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-tree---quiet"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-tree---color"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-17"><a class="header" href="#common-options-17">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree-+toolchain"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-tree---config"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-tree--h"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-tree---help"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-tree--Z"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-16"><a class="header" href="#environment-16">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-16"><a class="header" href="#exit-status-16">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-19"><a class="header" href="#examples-19">EXAMPLES</a></h2>
<ol>
<li>
<p>Display the tree for the package in the current directory:</p>
<pre><code>cargo tree
</code></pre>
</li>
<li>
<p>Display all the packages that depend on the <code>syn</code> package:</p>
<pre><code>cargo tree -i syn
</code></pre>
</li>
<li>
<p>Show the features enabled on each package:</p>
<pre><code>cargo tree --format &quot;{p} {f}&quot;
</code></pre>
</li>
<li>
<p>Show all packages that are built multiple times. This can happen if multiple
semver-incompatible versions appear in the tree (like 1.0.0 and 2.0.0).</p>
<pre><code>cargo tree -d
</code></pre>
</li>
<li>
<p>Explain why features are enabled for the <code>syn</code> package:</p>
<pre><code>cargo tree -e features -i syn
</code></pre>
<p>The <code>-e features</code> flag is used to show features. The <code>-i</code> flag is used to
invert the graph so that it displays the packages that depend on <code>syn</code>. An
example of what this would display:</p>
<pre><code>syn v1.0.17
├── syn feature &quot;clone-impls&quot;
│   └── syn feature &quot;default&quot;
│       └── rustversion v1.0.2
│           └── rustversion feature &quot;default&quot;
│               └── myproject v0.1.0 (/myproject)
│                   └── myproject feature &quot;default&quot; (command-line)
├── syn feature &quot;default&quot; (*)
├── syn feature &quot;derive&quot;
│   └── syn feature &quot;default&quot; (*)
├── syn feature &quot;full&quot;
│   └── rustversion v1.0.2 (*)
├── syn feature &quot;parsing&quot;
│   └── syn feature &quot;default&quot; (*)
├── syn feature &quot;printing&quot;
│   └── syn feature &quot;default&quot; (*)
├── syn feature &quot;proc-macro&quot;
│   └── syn feature &quot;default&quot; (*)
└── syn feature &quot;quote&quot;
    ├── syn feature &quot;printing&quot; (*)
    └── syn feature &quot;proc-macro&quot; (*)
</code></pre>
<p>To read this graph, you can follow the chain for each feature from the root
to see why it is included. For example, the &quot;full&quot; feature is added by the
<code>rustversion</code> crate which is included from <code>myproject</code> (with the default
features), and <code>myproject</code> is the package selected on the command-line. All
of the other <code>syn</code> features are added by the &quot;default&quot; feature (&quot;quote&quot; is
added by &quot;printing&quot; and &quot;proc-macro&quot;, both of which are default features).</p>
<p>If you're having difficulty cross-referencing the de-duplicated <code>(*)</code>
entries, try with the <code>--no-dedupe</code> flag to get the full output.</p>
</li>
</ol>
<h2 id="see-also-19"><a class="header" href="#see-also-19">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-metadata.html">cargo-metadata(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-update1"><a class="header" href="#cargo-update1">cargo-update(1)</a></h1>
<h2 id="name-20"><a class="header" href="#name-20">NAME</a></h2>
<p>cargo-update - Update dependencies as recorded in the local lock file</p>
<h2 id="synopsis-20"><a class="header" href="#synopsis-20">SYNOPSIS</a></h2>
<p><code>cargo update</code> [<em>options</em>]</p>
<h2 id="description-20"><a class="header" href="#description-20">DESCRIPTION</a></h2>
<p>This command will update dependencies in the <code>Cargo.lock</code> file to the latest
version. If the <code>Cargo.lock</code> file does not exist, it will be created with the
latest available versions.</p>
<h2 id="options-19"><a class="header" href="#options-19">OPTIONS</a></h2>
<h3 id="update-options"><a class="header" href="#update-options">Update Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-update--p"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-update---package"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Update only the specified packages. This flag may be specified
multiple times. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC format.</p>
<p>If packages are specified with the <code>-p</code> flag, then a conservative update of
the lockfile will be performed. This means that only the dependency specified
by SPEC will be updated. Its transitive dependencies will be updated only if
SPEC cannot be updated without updating dependencies.  All other dependencies
will remain locked at their currently recorded versions.</p>
<p>If <code>-p</code> is not specified, all dependencies are updated.</dd>
<dt class="option-term" id="option-cargo-update---aggressive"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---aggressive"></a><code>--aggressive</code></dt>
<dd class="option-desc">When used with <code>-p</code>, dependencies of <em>spec</em> are forced to update as well.
Cannot be used with <code>--precise</code>.</dd>
<dt class="option-term" id="option-cargo-update---precise"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---precise"></a><code>--precise</code> <em>precise</em></dt>
<dd class="option-desc">When used with <code>-p</code>, allows you to specify a specific version number to set
the package to. If the package comes from a git repository, this can be a git
revision (such as a SHA hash or tag).</dd>
<dt class="option-term" id="option-cargo-update--w"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update--w"></a><code>-w</code></dt>
<dt class="option-term" id="option-cargo-update---workspace"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Attempt to update only packages defined in the workspace. Other packages
are updated only if they don't already exist in the lockfile. This
option is useful for updating <code>Cargo.lock</code> after you've changed version
numbers in <code>Cargo.toml</code>.</dd>
<dt class="option-term" id="option-cargo-update---dry-run"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---dry-run"></a><code>--dry-run</code></dt>
<dd class="option-desc">Displays what would be updated, but doesn't actually write the lockfile.</dd>
</dl>
<h3 id="display-options-17"><a class="header" href="#display-options-17">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-update--v"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-update---verbose"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-update--q"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-update---quiet"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-update---color"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="manifest-options-17"><a class="header" href="#manifest-options-17">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-update---manifest-path"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-update---frozen"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-update---locked"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-update---offline"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-18"><a class="header" href="#common-options-18">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-update-+toolchain"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-update---config"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-update--h"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-update---help"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-update--Z"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-17"><a class="header" href="#environment-17">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-17"><a class="header" href="#exit-status-17">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-20"><a class="header" href="#examples-20">EXAMPLES</a></h2>
<ol>
<li>
<p>Update all dependencies in the lockfile:</p>
<pre><code>cargo update
</code></pre>
</li>
<li>
<p>Update only specific dependencies:</p>
<pre><code>cargo update -p foo -p bar
</code></pre>
</li>
<li>
<p>Set a specific dependency to a specific version:</p>
<pre><code>cargo update -p foo --precise 1.2.3
</code></pre>
</li>
</ol>
<h2 id="see-also-20"><a class="header" href="#see-also-20">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-generate-lockfile.html">cargo-generate-lockfile(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-vendor1"><a class="header" href="#cargo-vendor1">cargo-vendor(1)</a></h1>
<h2 id="name-21"><a class="header" href="#name-21">NAME</a></h2>
<p>cargo-vendor - Vendor all dependencies locally</p>
<h2 id="synopsis-21"><a class="header" href="#synopsis-21">SYNOPSIS</a></h2>
<p><code>cargo vendor</code> [<em>options</em>] [<em>path</em>]</p>
<h2 id="description-21"><a class="header" href="#description-21">DESCRIPTION</a></h2>
<p>This cargo subcommand will vendor all crates.io and git dependencies for a
project into the specified directory at <code>&lt;path&gt;</code>. After this command completes
the vendor directory specified by <code>&lt;path&gt;</code> will contain all remote sources from
dependencies specified. Additional manifests beyond the default one can be
specified with the <code>-s</code> option.</p>
<p>The <code>cargo vendor</code> command will also print out the configuration necessary
to use the vendored sources, which you will need to add to <code>.cargo/config.toml</code>.</p>
<h2 id="options-20"><a class="header" href="#options-20">OPTIONS</a></h2>
<h3 id="vendor-options"><a class="header" href="#vendor-options">Vendor Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-vendor--s"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor--s"></a><code>-s</code> <em>manifest</em></dt>
<dt class="option-term" id="option-cargo-vendor---sync"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---sync"></a><code>--sync</code> <em>manifest</em></dt>
<dd class="option-desc">Specify an extra <code>Cargo.toml</code> manifest to workspaces which should also be
vendored and synced to the output. May be specified multiple times.</dd>
<dt class="option-term" id="option-cargo-vendor---no-delete"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---no-delete"></a><code>--no-delete</code></dt>
<dd class="option-desc">Don't delete the &quot;vendor&quot; directory when vendoring, but rather keep all
existing contents of the vendor directory</dd>
<dt class="option-term" id="option-cargo-vendor---respect-source-config"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---respect-source-config"></a><code>--respect-source-config</code></dt>
<dd class="option-desc">Instead of ignoring <code>[source]</code> configuration by default in <code>.cargo/config.toml</code>
read it and use it when downloading crates from crates.io, for example</dd>
<dt class="option-term" id="option-cargo-vendor---versioned-dirs"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---versioned-dirs"></a><code>--versioned-dirs</code></dt>
<dd class="option-desc">Normally versions are only added to disambiguate multiple versions of the
same package. This option causes all directories in the &quot;vendor&quot; directory
to be versioned, which makes it easier to track the history of vendored
packages over time, and can help with the performance of re-vendoring when
only a subset of the packages have changed.</dd>
</dl>
<h3 id="manifest-options-18"><a class="header" href="#manifest-options-18">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-vendor---manifest-path"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-vendor---frozen"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-vendor---locked"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-vendor---offline"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="display-options-18"><a class="header" href="#display-options-18">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-vendor--v"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-vendor---verbose"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-vendor--q"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-vendor---quiet"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-vendor---color"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-19"><a class="header" href="#common-options-19">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-vendor-+toolchain"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-vendor---config"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-vendor--h"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-vendor---help"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-vendor--Z"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-18"><a class="header" href="#environment-18">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-18"><a class="header" href="#exit-status-18">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-21"><a class="header" href="#examples-21">EXAMPLES</a></h2>
<ol>
<li>
<p>Vendor all dependencies into a local &quot;vendor&quot; folder</p>
<pre><code>cargo vendor
</code></pre>
</li>
<li>
<p>Vendor all dependencies into a local &quot;third-party/vendor&quot; folder</p>
<pre><code>cargo vendor third-party/vendor
</code></pre>
</li>
<li>
<p>Vendor the current workspace as well as another to &quot;vendor&quot;</p>
<pre><code>cargo vendor -s ../path/to/Cargo.toml
</code></pre>
</li>
</ol>
<h2 id="see-also-21"><a class="header" href="#see-also-21">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-verify-project1"><a class="header" href="#cargo-verify-project1">cargo-verify-project(1)</a></h1>
<h2 id="name-22"><a class="header" href="#name-22">NAME</a></h2>
<p>cargo-verify-project - Check correctness of crate manifest</p>
<h2 id="synopsis-22"><a class="header" href="#synopsis-22">SYNOPSIS</a></h2>
<p><code>cargo verify-project</code> [<em>options</em>]</p>
<h2 id="description-22"><a class="header" href="#description-22">DESCRIPTION</a></h2>
<p>This command will parse the local manifest and check its validity. It emits a
JSON object with the result. A successful validation will display:</p>
<pre><code>{&quot;success&quot;:&quot;true&quot;}
</code></pre>
<p>An invalid workspace will display:</p>
<pre><code>{&quot;invalid&quot;:&quot;human-readable error message&quot;}
</code></pre>
<h2 id="options-21"><a class="header" href="#options-21">OPTIONS</a></h2>
<h3 id="display-options-19"><a class="header" href="#display-options-19">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-verify-project--v"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-verify-project---verbose"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-verify-project--q"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-verify-project---quiet"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-verify-project---color"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="manifest-options-19"><a class="header" href="#manifest-options-19">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-verify-project---manifest-path"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-verify-project---frozen"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-verify-project---locked"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-verify-project---offline"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-20"><a class="header" href="#common-options-20">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-verify-project-+toolchain"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-verify-project---config"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-verify-project--h"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-verify-project---help"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-verify-project--Z"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-19"><a class="header" href="#environment-19">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-19"><a class="header" href="#exit-status-19">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: The workspace is OK.</li>
<li><code>1</code>: The workspace is invalid.</li>
</ul>
<h2 id="examples-22"><a class="header" href="#examples-22">EXAMPLES</a></h2>
<ol>
<li>
<p>Check the current workspace for errors:</p>
<pre><code>cargo verify-project
</code></pre>
</li>
</ol>
<h2 id="see-also-22"><a class="header" href="#see-also-22">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-package.html">cargo-package(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-commands-1"><a class="header" href="#package-commands-1">Package Commands</a></h1>
<ul>
<li><a href="commands/cargo-init.html">cargo init</a></li>
<li><a href="commands/cargo-install.html">cargo install</a></li>
<li><a href="commands/cargo-new.html">cargo new</a></li>
<li><a href="commands/cargo-search.html">cargo search</a></li>
<li><a href="commands/cargo-uninstall.html">cargo uninstall</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-init1"><a class="header" href="#cargo-init1">cargo-init(1)</a></h1>
<h2 id="name-23"><a class="header" href="#name-23">NAME</a></h2>
<p>cargo-init - Create a new Cargo package in an existing directory</p>
<h2 id="synopsis-23"><a class="header" href="#synopsis-23">SYNOPSIS</a></h2>
<p><code>cargo init</code> [<em>options</em>] [<em>path</em>]</p>
<h2 id="description-23"><a class="header" href="#description-23">DESCRIPTION</a></h2>
<p>This command will create a new Cargo manifest in the current directory. Give a
path as an argument to create in the given directory.</p>
<p>If there are typically-named Rust source files already in the directory, those
will be used. If not, then a sample <code>src/main.rs</code> file will be created, or
<code>src/lib.rs</code> if <code>--lib</code> is passed.</p>
<p>If the directory is not already in a VCS repository, then a new repository
is created (see <code>--vcs</code> below).</p>
<p>See <a href="commands/cargo-new.html">cargo-new(1)</a> for a similar command which will create a new package in
a new directory.</p>
<h2 id="options-22"><a class="header" href="#options-22">OPTIONS</a></h2>
<h3 id="init-options"><a class="header" href="#init-options">Init Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-init---bin"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---bin"></a><code>--bin</code></dt>
<dd class="option-desc">Create a package with a binary target (<code>src/main.rs</code>).
This is the default behavior.</dd>
<dt class="option-term" id="option-cargo-init---lib"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Create a package with a library target (<code>src/lib.rs</code>).</dd>
<dt class="option-term" id="option-cargo-init---edition"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---edition"></a><code>--edition</code> <em>edition</em></dt>
<dd class="option-desc">Specify the Rust edition to use. Default is 2021.
Possible values: 2015, 2018, 2021</dd>
<dt class="option-term" id="option-cargo-init---name"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---name"></a><code>--name</code> <em>name</em></dt>
<dd class="option-desc">Set the package name. Defaults to the directory name.</dd>
<dt class="option-term" id="option-cargo-init---vcs"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---vcs"></a><code>--vcs</code> <em>vcs</em></dt>
<dd class="option-desc">Initialize a new VCS repository for the given version control system (git,
hg, pijul, or fossil) or do not initialize any version control at all
(none). If not specified, defaults to <code>git</code> or the configuration value
<code>cargo-new.vcs</code>, or <code>none</code> if already inside a VCS repository.</dd>
<dt class="option-term" id="option-cargo-init---registry"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">This sets the <code>publish</code> field in <code>Cargo.toml</code> to the given registry name
which will restrict publishing only to that registry.</p>
<p>Registry names are defined in <a href="commands/../reference/config.html">Cargo config files</a>.
If not specified, the default registry defined by the <code>registry.default</code>
config key is used. If the default registry is not set and <code>--registry</code> is not
used, the <code>publish</code> field will not be set which means that publishing will not
be restricted.</dd>
</dl>
<h3 id="display-options-20"><a class="header" href="#display-options-20">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-init--v"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-init---verbose"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-init--q"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-init---quiet"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-init---color"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-21"><a class="header" href="#common-options-21">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-init-+toolchain"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-init---config"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-init--h"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-init---help"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-init--Z"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-20"><a class="header" href="#environment-20">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-20"><a class="header" href="#exit-status-20">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-23"><a class="header" href="#examples-23">EXAMPLES</a></h2>
<ol>
<li>
<p>Create a binary Cargo package in the current directory:</p>
<pre><code>cargo init
</code></pre>
</li>
</ol>
<h2 id="see-also-23"><a class="header" href="#see-also-23">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-new.html">cargo-new(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-install1"><a class="header" href="#cargo-install1">cargo-install(1)</a></h1>
<h2 id="name-24"><a class="header" href="#name-24">NAME</a></h2>
<p>cargo-install - Build and install a Rust binary</p>
<h2 id="synopsis-24"><a class="header" href="#synopsis-24">SYNOPSIS</a></h2>
<p><code>cargo install</code> [<em>options</em>] <em>crate</em>[@<em>version</em>]...<br />
<code>cargo install</code> [<em>options</em>] <code>--path</code> <em>path</em><br />
<code>cargo install</code> [<em>options</em>] <code>--git</code> <em>url</em> [<em>crate</em>...]<br />
<code>cargo install</code> [<em>options</em>] <code>--list</code></p>
<h2 id="description-24"><a class="header" href="#description-24">DESCRIPTION</a></h2>
<p>This command manages Cargo's local set of installed binary crates. Only
packages which have executable <code>[[bin]]</code> or <code>[[example]]</code> targets can be
installed, and all executables are installed into the installation root's
<code>bin</code> folder.</p>
<p>The installation root is determined, in order of precedence:</p>
<ul>
<li><code>--root</code> option</li>
<li><code>CARGO_INSTALL_ROOT</code> environment variable</li>
<li><code>install.root</code> Cargo <a href="commands/../reference/config.html">config value</a></li>
<li><code>CARGO_HOME</code> environment variable</li>
<li><code>$HOME/.cargo</code></li>
</ul>
<p>There are multiple sources from which a crate can be installed. The default
location is crates.io but the <code>--git</code>, <code>--path</code>, and <code>--registry</code> flags can
change this source. If the source contains more than one package (such as
crates.io or a git repository with multiple crates) the <em>crate</em> argument is
required to indicate which crate should be installed.</p>
<p>Crates from crates.io can optionally specify the version they wish to install
via the <code>--version</code> flags, and similarly packages from git repositories can
optionally specify the branch, tag, or revision that should be installed. If a
crate has multiple binaries, the <code>--bin</code> argument can selectively install only
one of them, and if you'd rather install examples the <code>--example</code> argument can
be used as well.</p>
<p>If the package is already installed, Cargo will reinstall it if the installed
version does not appear to be up-to-date. If any of the following values
change, then Cargo will reinstall the package:</p>
<ul>
<li>The package version and source.</li>
<li>The set of binary names installed.</li>
<li>The chosen features.</li>
<li>The profile (<code>--profile</code>).</li>
<li>The target (<code>--target</code>).</li>
</ul>
<p>Installing with <code>--path</code> will always build and install, unless there are
conflicting binaries from another package. The <code>--force</code> flag may be used to
force Cargo to always reinstall the package.</p>
<p>If the source is crates.io or <code>--git</code> then by default the crate will be built
in a temporary target directory. To avoid this, the target directory can be
specified by setting the <code>CARGO_TARGET_DIR</code> environment variable to a relative
path. In particular, this can be useful for caching build artifacts on
continuous integration systems.</p>
<p>By default, the <code>Cargo.lock</code> file that is included with the package will be
ignored. This means that Cargo will recompute which versions of dependencies
to use, possibly using newer versions that have been released since the
package was published. The <code>--locked</code> flag can be used to force Cargo to use
the packaged <code>Cargo.lock</code> file if it is available. This may be useful for
ensuring reproducible builds, to use the exact same set of dependencies that
were available when the package was published. It may also be useful if a
newer version of a dependency is published that no longer builds on your
system, or has other problems. The downside to using <code>--locked</code> is that you
will not receive any fixes or updates to any dependency. Note that Cargo did
not start publishing <code>Cargo.lock</code> files until version 1.37, which means
packages published with prior versions will not have a <code>Cargo.lock</code> file
available.</p>
<h2 id="options-23"><a class="header" href="#options-23">OPTIONS</a></h2>
<h3 id="install-options"><a class="header" href="#install-options">Install Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install---vers"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---vers"></a><code>--vers</code> <em>version</em></dt>
<dt class="option-term" id="option-cargo-install---version"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---version"></a><code>--version</code> <em>version</em></dt>
<dd class="option-desc">Specify a version to install. This may be a <a href="commands/../reference/specifying-dependencies.html">version
requirement</a>, like <code>~1.2</code>, to have Cargo
select the newest version from the given requirement. If the version does not
have a requirement operator (such as <code>^</code> or <code>~</code>), then it must be in the form
<em>MAJOR.MINOR.PATCH</em>, and will install exactly that version; it is <em>not</em>
treated as a caret requirement like Cargo dependencies are.</dd>
<dt class="option-term" id="option-cargo-install---git"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---git"></a><code>--git</code> <em>url</em></dt>
<dd class="option-desc">Git URL to install the specified crate from.</dd>
<dt class="option-term" id="option-cargo-install---branch"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---branch"></a><code>--branch</code> <em>branch</em></dt>
<dd class="option-desc">Branch to use when installing from git.</dd>
<dt class="option-term" id="option-cargo-install---tag"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---tag"></a><code>--tag</code> <em>tag</em></dt>
<dd class="option-desc">Tag to use when installing from git.</dd>
<dt class="option-term" id="option-cargo-install---rev"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---rev"></a><code>--rev</code> <em>sha</em></dt>
<dd class="option-desc">Specific commit to use when installing from git.</dd>
<dt class="option-term" id="option-cargo-install---path"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---path"></a><code>--path</code> <em>path</em></dt>
<dd class="option-desc">Filesystem path to local crate to install.</dd>
<dt class="option-term" id="option-cargo-install---list"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---list"></a><code>--list</code></dt>
<dd class="option-desc">List all installed packages and their versions.</dd>
<dt class="option-term" id="option-cargo-install--f"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--f"></a><code>-f</code></dt>
<dt class="option-term" id="option-cargo-install---force"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---force"></a><code>--force</code></dt>
<dd class="option-desc">Force overwriting existing crates or binaries. This can be used if a package
has installed a binary with the same name as another package. This is also
useful if something has changed on the system that you want to rebuild with,
such as a newer version of <code>rustc</code>.</dd>
<dt class="option-term" id="option-cargo-install---no-track"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---no-track"></a><code>--no-track</code></dt>
<dd class="option-desc">By default, Cargo keeps track of the installed packages with a metadata file
stored in the installation root directory. This flag tells Cargo not to use or
create that file. With this flag, Cargo will refuse to overwrite any existing
files unless the <code>--force</code> flag is used. This also disables Cargo's ability to
protect against multiple concurrent invocations of Cargo installing at the
same time.</dd>
<dt class="option-term" id="option-cargo-install---bin"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Install only the specified binary.</dd>
<dt class="option-term" id="option-cargo-install---bins"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Install all binaries.</dd>
<dt class="option-term" id="option-cargo-install---example"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Install only the specified example.</dd>
<dt class="option-term" id="option-cargo-install---examples"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Install all examples.</dd>
<dt class="option-term" id="option-cargo-install---root"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---root"></a><code>--root</code> <em>dir</em></dt>
<dd class="option-desc">Directory to install packages into.</dd>
<dt class="option-term" id="option-cargo-install---registry"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</dd>
<dt class="option-term" id="option-cargo-install---index"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---index"></a><code>--index</code> <em>index</em></dt>
<dd class="option-desc">The URL of the registry index to use.</dd>
</dl>
<h3 id="feature-selection-10"><a class="header" href="#feature-selection-10">Feature Selection</a></h3>
<p>The feature flags allow you to control which features are enabled. When no
feature options are given, the <code>default</code> feature is activated for every
selected package.</p>
<p>See <a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>
for more details.</p>
<dl>
<dt class="option-term" id="option-cargo-install--F"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--F"></a><code>-F</code> <em>features</em></dt>
<dt class="option-term" id="option-cargo-install---features"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-install---all-features"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-install---no-default-features"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="compilation-options-8"><a class="header" href="#compilation-options-8">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install---target"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Install for the given architecture. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-install---target-dir"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to a new temporary folder located in the
temporary directory of the platform. </p>
<p>When using <code>--path</code>, by default it will use <code>target</code> directory in the workspace
of the local crate unless <code>--target-dir</code>
is specified.</dd>
<dt class="option-term" id="option-cargo-install---debug"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---debug"></a><code>--debug</code></dt>
<dd class="option-desc">Build with the <code>dev</code> profile instead the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-install---profile"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Install with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-install---timings=fmts"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---timings=fmts"></a><code>--timings=</code><em>fmts</em></dt>
<dd class="option-desc">Output information how long each compilation takes, and track concurrency
information over time. Accepts an optional comma-separated list of output
formats; <code>--timings</code> without an argument will default to <code>--timings=html</code>.
Specifying an output format (rather than the default) is unstable and requires
<code>-Zunstable-options</code>. Valid output formats:</p>
<ul>
<li><code>html</code> (unstable, requires <code>-Zunstable-options</code>): Write a human-readable file <code>cargo-timing.html</code> to the
<code>target/cargo-timings</code> directory with a report of the compilation. Also write
a report to the same directory with a timestamp in the filename if you want
to look at older runs. HTML output is suitable for human consumption only,
and does not provide machine-readable timing data.</li>
<li><code>json</code> (unstable, requires <code>-Zunstable-options</code>): Emit machine-readable JSON
information about timing information.</li>
</ul></dd>
</dl>
<h3 id="manifest-options-20"><a class="header" href="#manifest-options-20">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install---frozen"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-install---locked"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-install---offline"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="miscellaneous-options-9"><a class="header" href="#miscellaneous-options-9">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install--j"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-install---jobs"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value.
Should not be 0.</dd>
<dt class="option-term" id="option-cargo-install---keep-going"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---keep-going"></a><code>--keep-going</code></dt>
<dd class="option-desc">Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build. Unstable, requires
<code>-Zunstable-options</code>.</dd>
</dl>
<h3 id="display-options-21"><a class="header" href="#display-options-21">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install--v"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-install---verbose"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-install--q"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-install---quiet"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-install---color"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-install---message-format"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3 id="common-options-22"><a class="header" href="#common-options-22">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install-+toolchain"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-install---config"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-install--h"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-install---help"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-install--Z"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-21"><a class="header" href="#environment-21">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-21"><a class="header" href="#exit-status-21">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-24"><a class="header" href="#examples-24">EXAMPLES</a></h2>
<ol>
<li>
<p>Install or upgrade a package from crates.io:</p>
<pre><code>cargo install ripgrep
</code></pre>
</li>
<li>
<p>Install or reinstall the package in the current directory:</p>
<pre><code>cargo install --path .
</code></pre>
</li>
<li>
<p>View the list of installed packages:</p>
<pre><code>cargo install --list
</code></pre>
</li>
</ol>
<h2 id="see-also-24"><a class="header" href="#see-also-24">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-uninstall.html">cargo-uninstall(1)</a>, <a href="commands/cargo-search.html">cargo-search(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-new1"><a class="header" href="#cargo-new1">cargo-new(1)</a></h1>
<h2 id="定义-1"><a class="header" href="#定义-1">定义</a></h2>
<p>cargo-new - 创建一个新的cargo package</p>
<h2 id="概要-1"><a class="header" href="#概要-1">概要</a></h2>
<p><code>cargo new</code> [<em>options</em>] <em>path</em></p>
<h2 id="说明-1"><a class="header" href="#说明-1">说明</a></h2>
<p>该命令会在给定的目录下新建一个cargo package，将创建一个简单的名为<code>Cargo.toml</code>的清单文件模板，
示例源文件，以及一个版本控制系统的忽略清单文件，如果该目录不在版本控制系统仓库下，那么将会创建一个仓库(详情查看下文中的 <code>--vcs</code> 说明)</p>
<p>查阅 <a href="commands/cargo-init.html">cargo-init(1)</a> 来了解类似的命令，用它可以在一个已经存在的目录下创建一个清单文件。</p>
<h2 id="选项-2"><a class="header" href="#选项-2">选项</a></h2>
<h3 id="新建选项"><a class="header" href="#新建选项">新建选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-new---bin"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---bin"></a><code>--bin</code></dt>
<dd class="option-desc">创建一个以binary为目标的package (<code>src/main.rs</code>).
This is the default behavior.</dd>
<dt class="option-term" id="option-cargo-new---lib"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---lib"></a><code>--lib</code></dt>
<dd class="option-desc">创建一个以library为目标的package (<code>src/lib.rs</code>).</dd>
<dt class="option-term" id="option-cargo-new---edition"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---edition"></a><code>--edition</code> <em>edition</em></dt>
<dd class="option-desc">指定使用的Rust的版本. 默认是 2021，
可能的值有: 2015, 2018, 2021</dd>
<dt class="option-term" id="option-cargo-new---name"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---name"></a><code>--name</code> <em>name</em></dt>
<dd class="option-desc">设置package的名称，默认为给定的目录的名称。</dd>
<dt class="option-term" id="option-cargo-new---vcs"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---vcs"></a><code>--vcs</code> <em>vcs</em></dt>
<dd class="option-desc">为版本控制系统(git, hg, pijul, 或者fossil)初始化一个仓库，否则将不会使用任何版本控制(none)。
如果该选项未被指定，则默认为 <code>git</code> 或者是在配置文件
<code>cargo-new.vcs</code>中指定的值，如果已经在一个版本控制系统仓库下面则相当于传入了 <code>none</code> 。</dd>
<dt class="option-term" id="option-cargo-new---registry"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">指定该选项将找指定的注册项，并将 <code>Cargo.toml</code> 中的 <code>publish</code> 字段设置成它的值。</p>
<p>注册项的定义在 <a href="commands/../reference/config.html">Cargo 配置文件</a>中。
如果未指定该选项，那么配置文件中 <code>registry.default</code> 块中的配置项将会被采用，
如果 <code>registry.default</code> 未被配置，并且 <code>--registry</code> 也未被指定, 那么 <code>publish</code> 就不会被设置，
这意味着发布将不受限制。
</dd>
</dl>
<h3 id="输出选项-1"><a class="header" href="#输出选项-1">输出选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-new--v"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-new---verbose"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">采用冗长的输出. 可以被设置两次用来表示 &quot;非常冗长&quot; ，这将包含额外的输出信息，例如依赖的警告以及构建脚本的输出。
也可以通过 <code>term.verbose</code> 来配置 <a href="commands/../reference/config.html">可选值</a>。</dd>
<dt class="option-term" id="option-cargo-new--q"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-new---quiet"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">表示不输出任何cargo日志信息，
也可以通过 <code>term.quiet</code> 来配置<a href="commands/../reference/config.html">可选值</a>。</dd>
<dt class="option-term" id="option-cargo-new---color"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">用来控制何时使用彩色的输出，有效值有:</p>
<ul>
<li><code>auto</code> (默认): 自动检测该终端是否支持彩色输出。</li>
<li><code>always</code>: 总是使用彩色输出。</li>
<li><code>never</code>: 从不使用彩色输出。</li>
</ul>
<p>也可以通过 <code>term.color</code> 来配置<a href="commands/../reference/config.html">可选值</a>。</dd>
</dl>
<h3 id="一般选项-1"><a class="header" href="#一般选项-1">一般选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-new-+toolchain"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">如果Cargo是通过rustup安装的，如果第一个传给 <code>cargo</code> 的参数是以 <code>+</code> 开头的话，
它将被理解为rustup的工具链名称(例如 <code>+stable</code> 或者 <code>+nightly</code>).
查阅 <a href="https://rust-lang.github.io/rustup/overrides.html">rustup文档</a>获取更多关于重载工具链的工作原理的信息</dd>
<dt class="option-term" id="option-cargo-new---config"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">表示覆盖一个Cargo配置项的值. 传入的参数应当遵循 <code>KEY=VALUE</code> 的TOML语法或者是
一个额外的配置文件的路径。 该选项可以被配置多次.
查阅 <a href="commands/../reference/config.html#command-line-overrides">命令行重写部分</a> 获取更多信息。</dd>
<dt class="option-term" id="option-cargo-new--h"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-new---help"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---help"></a><code>--help</code></dt>
<dd class="option-desc">输出帮助信息。</dd>
<dt class="option-term" id="option-cargo-new--Z"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">不稳定的 (只在nightly下可用) 标识，执行 <code>cargo -Z help</code> 获取更多信息。</dd>
</dl>
<h2 id="环境-3"><a class="header" href="#环境-3">环境</a></h2>
<p>查阅 <a href="commands/../reference/environment-variables.html">参考手册</a> 获取Cargo将读取的环境变量的资料 </p>
<h2 id="退出状态-2"><a class="header" href="#退出状态-2">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo 成功退出.</li>
<li><code>101</code>: Cargo 错误退出.</li>
</ul>
<h2 id="示例-1"><a class="header" href="#示例-1">示例</a></h2>
<ol>
<li>
<p>在给定的目录下创建一个cargo package:</p>
<pre><code>cargo new foo
</code></pre>
</li>
</ol>
<h2 id="另请参见"><a class="header" href="#另请参见">另请参见</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-init.html">cargo-init(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-search1"><a class="header" href="#cargo-search1">cargo-search(1)</a></h1>
<h2 id="name-25"><a class="header" href="#name-25">NAME</a></h2>
<p>cargo-search - Search packages in crates.io</p>
<h2 id="synopsis-25"><a class="header" href="#synopsis-25">SYNOPSIS</a></h2>
<p><code>cargo search</code> [<em>options</em>] [<em>query</em>...]</p>
<h2 id="description-25"><a class="header" href="#description-25">DESCRIPTION</a></h2>
<p>This performs a textual search for crates on <a href="https://crates.io">https://crates.io</a>. The matching
crates will be displayed along with their description in TOML format suitable
for copying into a <code>Cargo.toml</code> manifest.</p>
<h2 id="options-24"><a class="header" href="#options-24">OPTIONS</a></h2>
<h3 id="search-options"><a class="header" href="#search-options">Search Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-search---limit"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---limit"></a><code>--limit</code> <em>limit</em></dt>
<dd class="option-desc">Limit the number of results (default: 10, max: 100).</dd>
<dt class="option-term" id="option-cargo-search---index"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---index"></a><code>--index</code> <em>index</em></dt>
<dd class="option-desc">The URL of the registry index to use.</dd>
<dt class="option-term" id="option-cargo-search---registry"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</dd>
</dl>
<h3 id="display-options-22"><a class="header" href="#display-options-22">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-search--v"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-search---verbose"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-search--q"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-search---quiet"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-search---color"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-23"><a class="header" href="#common-options-23">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-search-+toolchain"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-search---config"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-search--h"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-search---help"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-search--Z"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-22"><a class="header" href="#environment-22">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-22"><a class="header" href="#exit-status-22">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-25"><a class="header" href="#examples-25">EXAMPLES</a></h2>
<ol>
<li>
<p>Search for a package from crates.io:</p>
<pre><code>cargo search serde
</code></pre>
</li>
</ol>
<h2 id="see-also-25"><a class="header" href="#see-also-25">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-install.html">cargo-install(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-uninstall1"><a class="header" href="#cargo-uninstall1">cargo-uninstall(1)</a></h1>
<h2 id="name-26"><a class="header" href="#name-26">NAME</a></h2>
<p>cargo-uninstall - Remove a Rust binary</p>
<h2 id="synopsis-26"><a class="header" href="#synopsis-26">SYNOPSIS</a></h2>
<p><code>cargo uninstall</code> [<em>options</em>] [<em>spec</em>...]</p>
<h2 id="description-26"><a class="header" href="#description-26">DESCRIPTION</a></h2>
<p>This command removes a package installed with <a href="commands/cargo-install.html">cargo-install(1)</a>. The <em>spec</em>
argument is a package ID specification of the package to remove (see
<a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a>).</p>
<p>By default all binaries are removed for a crate but the <code>--bin</code> and
<code>--example</code> flags can be used to only remove particular binaries.</p>
<p>The installation root is determined, in order of precedence:</p>
<ul>
<li><code>--root</code> option</li>
<li><code>CARGO_INSTALL_ROOT</code> environment variable</li>
<li><code>install.root</code> Cargo <a href="commands/../reference/config.html">config value</a></li>
<li><code>CARGO_HOME</code> environment variable</li>
<li><code>$HOME/.cargo</code></li>
</ul>
<h2 id="options-25"><a class="header" href="#options-25">OPTIONS</a></h2>
<h3 id="install-options-1"><a class="header" href="#install-options-1">Install Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-uninstall--p"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall--p"></a><code>-p</code></dt>
<dt class="option-term" id="option-cargo-uninstall---package"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Package to uninstall.</dd>
<dt class="option-term" id="option-cargo-uninstall---bin"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Only uninstall the binary <em>name</em>.</dd>
<dt class="option-term" id="option-cargo-uninstall---root"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---root"></a><code>--root</code> <em>dir</em></dt>
<dd class="option-desc">Directory to uninstall packages from.</dd>
</dl>
<h3 id="display-options-23"><a class="header" href="#display-options-23">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-uninstall--v"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-uninstall---verbose"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-uninstall--q"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-uninstall---quiet"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-uninstall---color"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-24"><a class="header" href="#common-options-24">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-uninstall-+toolchain"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-uninstall---config"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-uninstall--h"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-uninstall---help"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-uninstall--Z"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-23"><a class="header" href="#environment-23">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-23"><a class="header" href="#exit-status-23">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-26"><a class="header" href="#examples-26">EXAMPLES</a></h2>
<ol>
<li>
<p>Uninstall a previously installed package.</p>
<pre><code>cargo uninstall ripgrep
</code></pre>
</li>
</ol>
<h2 id="see-also-26"><a class="header" href="#see-also-26">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-install.html">cargo-install(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing-commands-1"><a class="header" href="#publishing-commands-1">Publishing Commands</a></h1>
<ul>
<li><a href="commands/cargo-login.html">cargo login</a></li>
<li><a href="commands/cargo-owner.html">cargo owner</a></li>
<li><a href="commands/cargo-package.html">cargo package</a></li>
<li><a href="commands/cargo-publish.html">cargo publish</a></li>
<li><a href="commands/cargo-yank.html">cargo yank</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-login1"><a class="header" href="#cargo-login1">cargo-login(1)</a></h1>
<h2 id="name-27"><a class="header" href="#name-27">NAME</a></h2>
<p>cargo-login - Save an API token from the registry locally</p>
<h2 id="synopsis-27"><a class="header" href="#synopsis-27">SYNOPSIS</a></h2>
<p><code>cargo login</code> [<em>options</em>] [<em>token</em>]</p>
<h2 id="description-27"><a class="header" href="#description-27">DESCRIPTION</a></h2>
<p>This command will save the API token to disk so that commands that require
authentication, such as <a href="commands/cargo-publish.html">cargo-publish(1)</a>, will be automatically
authenticated. The token is saved in <code>$CARGO_HOME/credentials.toml</code>. <code>CARGO_HOME</code>
defaults to <code>.cargo</code> in your home directory.</p>
<p>If the <em>token</em> argument is not specified, it will be read from stdin.</p>
<p>The API token for crates.io may be retrieved from <a href="https://crates.io/me">https://crates.io/me</a>.</p>
<p>Take care to keep the token secret, it should not be shared with anyone else.</p>
<h2 id="options-26"><a class="header" href="#options-26">OPTIONS</a></h2>
<h3 id="login-options"><a class="header" href="#login-options">Login Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-login---registry"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</dd>
</dl>
<h3 id="display-options-24"><a class="header" href="#display-options-24">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-login--v"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-login---verbose"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-login--q"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-login---quiet"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-login---color"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-25"><a class="header" href="#common-options-25">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-login-+toolchain"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-login---config"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-login--h"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-login---help"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-login--Z"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-24"><a class="header" href="#environment-24">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-24"><a class="header" href="#exit-status-24">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-27"><a class="header" href="#examples-27">EXAMPLES</a></h2>
<ol>
<li>
<p>Save the API token to disk:</p>
<pre><code>cargo login
</code></pre>
</li>
</ol>
<h2 id="see-also-27"><a class="header" href="#see-also-27">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-owner1"><a class="header" href="#cargo-owner1">cargo-owner(1)</a></h1>
<h2 id="name-28"><a class="header" href="#name-28">NAME</a></h2>
<p>cargo-owner - Manage the owners of a crate on the registry</p>
<h2 id="synopsis-28"><a class="header" href="#synopsis-28">SYNOPSIS</a></h2>
<p><code>cargo owner</code> [<em>options</em>] <code>--add</code> <em>login</em> [<em>crate</em>]<br />
<code>cargo owner</code> [<em>options</em>] <code>--remove</code> <em>login</em> [<em>crate</em>]<br />
<code>cargo owner</code> [<em>options</em>] <code>--list</code> [<em>crate</em>]</p>
<h2 id="description-28"><a class="header" href="#description-28">DESCRIPTION</a></h2>
<p>This command will modify the owners for a crate on the registry. Owners of a
crate can upload new versions and yank old versions. Non-team owners can also
modify the set of owners, so take care!</p>
<p>This command requires you to be authenticated with either the <code>--token</code> option
or using <a href="commands/cargo-login.html">cargo-login(1)</a>.</p>
<p>If the crate name is not specified, it will use the package name from the
current directory.</p>
<p>See <a href="commands/../reference/publishing.html#cargo-owner">the reference</a> for more
information about owners and publishing.</p>
<h2 id="options-27"><a class="header" href="#options-27">OPTIONS</a></h2>
<h3 id="owner-options"><a class="header" href="#owner-options">Owner Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-owner--a"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--a"></a><code>-a</code></dt>
<dt class="option-term" id="option-cargo-owner---add"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---add"></a><code>--add</code> <em>login</em>...</dt>
<dd class="option-desc">Invite the given user or team as an owner.</dd>
<dt class="option-term" id="option-cargo-owner--r"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-owner---remove"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---remove"></a><code>--remove</code> <em>login</em>...</dt>
<dd class="option-desc">Remove the given user or team as an owner.</dd>
<dt class="option-term" id="option-cargo-owner--l"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--l"></a><code>-l</code></dt>
<dt class="option-term" id="option-cargo-owner---list"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---list"></a><code>--list</code></dt>
<dd class="option-desc">List owners of a crate.</dd>
<dt class="option-term" id="option-cargo-owner---token"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---token"></a><code>--token</code> <em>token</em></dt>
<dd class="option-desc">API token to use when authenticating. This overrides the token stored in
the credentials file (which is created by <a href="commands/cargo-login.html">cargo-login(1)</a>).</p>
<p><a href="commands/../reference/config.html">Cargo config</a> environment variables can be
used to override the tokens stored in the credentials file. The token for
crates.io may be specified with the <code>CARGO_REGISTRY_TOKEN</code> environment
variable. Tokens for other registries may be specified with environment
variables of the form <code>CARGO_REGISTRIES_NAME_TOKEN</code> where <code>NAME</code> is the name
of the registry in all capital letters.</dd>
<dt class="option-term" id="option-cargo-owner---index"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---index"></a><code>--index</code> <em>index</em></dt>
<dd class="option-desc">The URL of the registry index to use.</dd>
<dt class="option-term" id="option-cargo-owner---registry"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</dd>
</dl>
<h3 id="display-options-25"><a class="header" href="#display-options-25">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-owner--v"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-owner---verbose"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-owner--q"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-owner---quiet"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-owner---color"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-26"><a class="header" href="#common-options-26">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-owner-+toolchain"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-owner---config"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-owner--h"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-owner---help"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-owner--Z"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-25"><a class="header" href="#environment-25">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-25"><a class="header" href="#exit-status-25">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-28"><a class="header" href="#examples-28">EXAMPLES</a></h2>
<ol>
<li>
<p>List owners of a package:</p>
<pre><code>cargo owner --list foo
</code></pre>
</li>
<li>
<p>Invite an owner to a package:</p>
<pre><code>cargo owner --add username foo
</code></pre>
</li>
<li>
<p>Remove an owner from a package:</p>
<pre><code>cargo owner --remove username foo
</code></pre>
</li>
</ol>
<h2 id="see-also-28"><a class="header" href="#see-also-28">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-login.html">cargo-login(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-package1"><a class="header" href="#cargo-package1">cargo-package(1)</a></h1>
<h2 id="name-29"><a class="header" href="#name-29">NAME</a></h2>
<p>cargo-package - Assemble the local package into a distributable tarball</p>
<h2 id="synopsis-29"><a class="header" href="#synopsis-29">SYNOPSIS</a></h2>
<p><code>cargo package</code> [<em>options</em>]</p>
<h2 id="description-29"><a class="header" href="#description-29">DESCRIPTION</a></h2>
<p>This command will create a distributable, compressed <code>.crate</code> file with the
source code of the package in the current directory. The resulting file will
be stored in the <code>target/package</code> directory. This performs the following
steps:</p>
<ol>
<li>Load and check the current workspace, performing some basic checks.
<ul>
<li>Path dependencies are not allowed unless they have a version key. Cargo
will ignore the path key for dependencies in published packages.
<code>dev-dependencies</code> do not have this restriction.</li>
</ul>
</li>
<li>Create the compressed <code>.crate</code> file.
<ul>
<li>The original <code>Cargo.toml</code> file is rewritten and normalized.</li>
<li><code>[patch]</code>, <code>[replace]</code>, and <code>[workspace]</code> sections are removed from the
manifest.</li>
<li><code>Cargo.lock</code> is automatically included if the package contains an
executable binary or example target. <a href="commands/cargo-install.html">cargo-install(1)</a> will use the
packaged lock file if the <code>--locked</code> flag is used.</li>
<li>A <code>.cargo_vcs_info.json</code> file is included that contains information
about the current VCS checkout hash if available (not included with
<code>--allow-dirty</code>).</li>
</ul>
</li>
<li>Extract the <code>.crate</code> file and build it to verify it can build.
<ul>
<li>This will rebuild your package from scratch to ensure that it can be
built from a pristine state. The <code>--no-verify</code> flag can be used to skip
this step.</li>
</ul>
</li>
<li>Check that build scripts did not modify any source files.</li>
</ol>
<p>The list of files included can be controlled with the <code>include</code> and <code>exclude</code>
fields in the manifest.</p>
<p>See <a href="commands/../reference/publishing.html">the reference</a> for more details about
packaging and publishing.</p>
<h3 id="cargo_vcs_infojson-format"><a class="header" href="#cargo_vcs_infojson-format">.cargo_vcs_info.json format</a></h3>
<p>Will generate a <code>.cargo_vcs_info.json</code> in the following format</p>
<pre><code class="language-javascript">{
 &quot;git&quot;: {
   &quot;sha1&quot;: &quot;aac20b6e7e543e6dd4118b246c77225e3a3a1302&quot;
 },
 &quot;path_in_vcs&quot;: &quot;&quot;
}
</code></pre>
<p><code>path_in_vcs</code> will be set to a repo-relative path for packages
in subdirectories of the version control repository.</p>
<h2 id="options-28"><a class="header" href="#options-28">OPTIONS</a></h2>
<h3 id="package-options"><a class="header" href="#package-options">Package Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package--l"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--l"></a><code>-l</code></dt>
<dt class="option-term" id="option-cargo-package---list"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---list"></a><code>--list</code></dt>
<dd class="option-desc">Print files included in a package without making one.</dd>
<dt class="option-term" id="option-cargo-package---no-verify"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---no-verify"></a><code>--no-verify</code></dt>
<dd class="option-desc">Don't verify the contents by building them.</dd>
<dt class="option-term" id="option-cargo-package---no-metadata"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---no-metadata"></a><code>--no-metadata</code></dt>
<dd class="option-desc">Ignore warnings about a lack of human-usable metadata (such as the description
or the license).</dd>
<dt class="option-term" id="option-cargo-package---allow-dirty"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---allow-dirty"></a><code>--allow-dirty</code></dt>
<dd class="option-desc">Allow working directories with uncommitted VCS changes to be packaged.</dd>
</dl>
<h3 id="package-selection-12"><a class="header" href="#package-selection-12">Package Selection</a></h3>
<p>By default, when no package selection options are given, the packages selected
depend on the selected manifest file (based on the current working directory if
<code>--manifest-path</code> is not given). If the manifest is the root of a workspace then
the workspaces default members are selected, otherwise only the package defined
by the manifest will be selected.</p>
<p>The default members of a workspace can be set explicitly with the
<code>workspace.default-members</code> key in the root manifest. If this is not set, a
virtual workspace will include all workspace members (equivalent to passing
<code>--workspace</code>), and a non-virtual workspace will include only the root crate itself.</p>
<dl>
<dt class="option-term" id="option-cargo-package--p"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-package---package"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Package only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally 
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</dd>
<dt class="option-term" id="option-cargo-package---workspace"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Package all members in the workspace.</dd>
<dt class="option-term" id="option-cargo-package---exclude"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</dd>
</dl>
<h3 id="compilation-options-9"><a class="header" href="#compilation-options-9">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package---target"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Package for the given architecture. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets. This flag may be specified multiple times.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-package---target-dir"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="feature-selection-11"><a class="header" href="#feature-selection-11">Feature Selection</a></h3>
<p>The feature flags allow you to control which features are enabled. When no
feature options are given, the <code>default</code> feature is activated for every
selected package.</p>
<p>See <a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>
for more details.</p>
<dl>
<dt class="option-term" id="option-cargo-package--F"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--F"></a><code>-F</code> <em>features</em></dt>
<dt class="option-term" id="option-cargo-package---features"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-package---all-features"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-package---no-default-features"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="manifest-options-21"><a class="header" href="#manifest-options-21">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package---manifest-path"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-package---frozen"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-package---locked"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-package---offline"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="miscellaneous-options-10"><a class="header" href="#miscellaneous-options-10">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package--j"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-package---jobs"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value.
Should not be 0.</dd>
<dt class="option-term" id="option-cargo-package---keep-going"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---keep-going"></a><code>--keep-going</code></dt>
<dd class="option-desc">Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build. Unstable, requires
<code>-Zunstable-options</code>.</dd>
</dl>
<h3 id="display-options-26"><a class="header" href="#display-options-26">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package--v"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-package---verbose"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-package--q"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-package---quiet"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-package---color"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-27"><a class="header" href="#common-options-27">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package-+toolchain"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-package---config"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-package--h"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-package---help"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-package--Z"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-26"><a class="header" href="#environment-26">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-26"><a class="header" href="#exit-status-26">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-29"><a class="header" href="#examples-29">EXAMPLES</a></h2>
<ol>
<li>
<p>Create a compressed <code>.crate</code> file of the current package:</p>
<pre><code>cargo package
</code></pre>
</li>
</ol>
<h2 id="see-also-29"><a class="header" href="#see-also-29">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-publish1"><a class="header" href="#cargo-publish1">cargo-publish(1)</a></h1>
<h2 id="name-30"><a class="header" href="#name-30">NAME</a></h2>
<p>cargo-publish - Upload a package to the registry</p>
<h2 id="synopsis-30"><a class="header" href="#synopsis-30">SYNOPSIS</a></h2>
<p><code>cargo publish</code> [<em>options</em>]</p>
<h2 id="description-30"><a class="header" href="#description-30">DESCRIPTION</a></h2>
<p>This command will create a distributable, compressed <code>.crate</code> file with the
source code of the package in the current directory and upload it to a
registry. The default registry is <a href="https://crates.io">https://crates.io</a>. This performs the
following steps:</p>
<ol>
<li>Performs a few checks, including:
<ul>
<li>Checks the <code>package.publish</code> key in the manifest for restrictions on
which registries you are allowed to publish to.</li>
</ul>
</li>
<li>Create a <code>.crate</code> file by following the steps in <a href="commands/cargo-package.html">cargo-package(1)</a>.</li>
<li>Upload the crate to the registry. Note that the server will perform
additional checks on the crate.</li>
</ol>
<p>This command requires you to be authenticated with either the <code>--token</code> option
or using <a href="commands/cargo-login.html">cargo-login(1)</a>.</p>
<p>See <a href="commands/../reference/publishing.html">the reference</a> for more details about
packaging and publishing.</p>
<h2 id="options-29"><a class="header" href="#options-29">OPTIONS</a></h2>
<h3 id="publish-options"><a class="header" href="#publish-options">Publish Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish---dry-run"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---dry-run"></a><code>--dry-run</code></dt>
<dd class="option-desc">Perform all checks without uploading.</dd>
<dt class="option-term" id="option-cargo-publish---token"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---token"></a><code>--token</code> <em>token</em></dt>
<dd class="option-desc">API token to use when authenticating. This overrides the token stored in
the credentials file (which is created by <a href="commands/cargo-login.html">cargo-login(1)</a>).</p>
<p><a href="commands/../reference/config.html">Cargo config</a> environment variables can be
used to override the tokens stored in the credentials file. The token for
crates.io may be specified with the <code>CARGO_REGISTRY_TOKEN</code> environment
variable. Tokens for other registries may be specified with environment
variables of the form <code>CARGO_REGISTRIES_NAME_TOKEN</code> where <code>NAME</code> is the name
of the registry in all capital letters.</dd>
<dt class="option-term" id="option-cargo-publish---no-verify"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---no-verify"></a><code>--no-verify</code></dt>
<dd class="option-desc">Don't verify the contents by building them.</dd>
<dt class="option-term" id="option-cargo-publish---allow-dirty"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---allow-dirty"></a><code>--allow-dirty</code></dt>
<dd class="option-desc">Allow working directories with uncommitted VCS changes to be packaged.</dd>
<dt class="option-term" id="option-cargo-publish---index"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---index"></a><code>--index</code> <em>index</em></dt>
<dd class="option-desc">The URL of the registry index to use.</dd>
<dt class="option-term" id="option-cargo-publish---registry"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">Name of the registry to publish to. Registry names are defined in <a href="commands/../reference/config.html">Cargo
config files</a>. If not specified, and there is a
<a href="commands/../reference/manifest.html#the-publish-field"><code>package.publish</code></a> field in
<code>Cargo.toml</code> with a single registry, then it will publish to that registry.
Otherwise it will use the default registry, which is defined by the
<a href="commands/../reference/config.html#registrydefault"><code>registry.default</code></a> config key
which defaults to <code>crates-io</code>.</dd>
</dl>
<h3 id="package-selection-13"><a class="header" href="#package-selection-13">Package Selection</a></h3>
<p>By default, the package in the current working directory is selected. The <code>-p</code>
flag can be used to choose a different package in a workspace.</p>
<dl>
<dt class="option-term" id="option-cargo-publish--p"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--p"></a><code>-p</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-publish---package"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---package"></a><code>--package</code> <em>spec</em></dt>
<dd class="option-desc">The package to publish. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC
format.</dd>
</dl>
<h3 id="compilation-options-10"><a class="header" href="#compilation-options-10">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish---target"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Publish for the given architecture. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. Run <code>rustc --print target-list</code> for a
list of supported targets. This flag may be specified multiple times.</p>
<p>This may also be specified with the <code>build.target</code>
<a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../guide/build-cache.html">build cache</a> documentation for more details.</dd>
<dt class="option-term" id="option-cargo-publish---target-dir"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</dd>
</dl>
<h3 id="feature-selection-12"><a class="header" href="#feature-selection-12">Feature Selection</a></h3>
<p>The feature flags allow you to control which features are enabled. When no
feature options are given, the <code>default</code> feature is activated for every
selected package.</p>
<p>See <a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>
for more details.</p>
<dl>
<dt class="option-term" id="option-cargo-publish--F"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--F"></a><code>-F</code> <em>features</em></dt>
<dt class="option-term" id="option-cargo-publish---features"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</dd>
<dt class="option-term" id="option-cargo-publish---all-features"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">Activate all available features of all selected packages.</dd>
<dt class="option-term" id="option-cargo-publish---no-default-features"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">Do not activate the <code>default</code> feature of the selected packages.</dd>
</dl>
<h3 id="manifest-options-22"><a class="header" href="#manifest-options-22">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish---manifest-path"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</dd>
<dt class="option-term" id="option-cargo-publish---frozen"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-publish---locked"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---locked"></a><code>--locked</code></dt>
<dd class="option-desc">Either of these flags requires that the <code>Cargo.lock</code> file is
up-to-date. If the lock file is missing, or it needs to be updated, Cargo will
exit with an error. The <code>--frozen</code> flag also prevents Cargo from
attempting to access the network to determine if it is out-of-date.</p>
<p>These may be used in environments where you want to assert that the
<code>Cargo.lock</code> file is up-to-date (such as a CI build) or want to avoid network
access.</dd>
<dt class="option-term" id="option-cargo-publish---offline"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---offline"></a><code>--offline</code></dt>
<dd class="option-desc">Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="miscellaneous-options-11"><a class="header" href="#miscellaneous-options-11">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish--j"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-publish---jobs"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value.
Should not be 0.</dd>
<dt class="option-term" id="option-cargo-publish---keep-going"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---keep-going"></a><code>--keep-going</code></dt>
<dd class="option-desc">Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build. Unstable, requires
<code>-Zunstable-options</code>.</dd>
</dl>
<h3 id="display-options-27"><a class="header" href="#display-options-27">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish--v"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-publish---verbose"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-publish--q"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-publish---quiet"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-publish---color"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-28"><a class="header" href="#common-options-28">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish-+toolchain"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-publish---config"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-publish--h"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-publish---help"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-publish--Z"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-27"><a class="header" href="#environment-27">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-27"><a class="header" href="#exit-status-27">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-30"><a class="header" href="#examples-30">EXAMPLES</a></h2>
<ol>
<li>
<p>Publish the current package:</p>
<pre><code>cargo publish
</code></pre>
</li>
</ol>
<h2 id="see-also-30"><a class="header" href="#see-also-30">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-package.html">cargo-package(1)</a>, <a href="commands/cargo-login.html">cargo-login(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-yank1"><a class="header" href="#cargo-yank1">cargo-yank(1)</a></h1>
<h2 id="name-31"><a class="header" href="#name-31">NAME</a></h2>
<p>cargo-yank - Remove a pushed crate from the index</p>
<h2 id="synopsis-31"><a class="header" href="#synopsis-31">SYNOPSIS</a></h2>
<p><code>cargo yank</code> [<em>options</em>] <em>crate</em>@<em>version</em><br />
<code>cargo yank</code> [<em>options</em>] <code>--version</code> <em>version</em> [<em>crate</em>]</p>
<h2 id="description-31"><a class="header" href="#description-31">DESCRIPTION</a></h2>
<p>The yank command removes a previously published crate's version from the
server's index. This command does not delete any data, and the crate will
still be available for download via the registry's download link.</p>
<p>Note that existing crates locked to a yanked version will still be able to
download the yanked version to use it. Cargo will, however, not allow any new
crates to be locked to any yanked version.</p>
<p>This command requires you to be authenticated with either the <code>--token</code> option
or using <a href="commands/cargo-login.html">cargo-login(1)</a>.</p>
<p>If the crate name is not specified, it will use the package name from the
current directory.</p>
<h2 id="options-30"><a class="header" href="#options-30">OPTIONS</a></h2>
<h3 id="yank-options"><a class="header" href="#yank-options">Yank Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-yank---vers"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---vers"></a><code>--vers</code> <em>version</em></dt>
<dt class="option-term" id="option-cargo-yank---version"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---version"></a><code>--version</code> <em>version</em></dt>
<dd class="option-desc">The version to yank or un-yank.</dd>
<dt class="option-term" id="option-cargo-yank---undo"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---undo"></a><code>--undo</code></dt>
<dd class="option-desc">Undo a yank, putting a version back into the index.</dd>
<dt class="option-term" id="option-cargo-yank---token"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---token"></a><code>--token</code> <em>token</em></dt>
<dd class="option-desc">API token to use when authenticating. This overrides the token stored in
the credentials file (which is created by <a href="commands/cargo-login.html">cargo-login(1)</a>).</p>
<p><a href="commands/../reference/config.html">Cargo config</a> environment variables can be
used to override the tokens stored in the credentials file. The token for
crates.io may be specified with the <code>CARGO_REGISTRY_TOKEN</code> environment
variable. Tokens for other registries may be specified with environment
variables of the form <code>CARGO_REGISTRIES_NAME_TOKEN</code> where <code>NAME</code> is the name
of the registry in all capital letters.</dd>
<dt class="option-term" id="option-cargo-yank---index"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---index"></a><code>--index</code> <em>index</em></dt>
<dd class="option-desc">The URL of the registry index to use.</dd>
<dt class="option-term" id="option-cargo-yank---registry"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</dd>
</dl>
<h3 id="display-options-28"><a class="header" href="#display-options-28">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-yank--v"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-yank---verbose"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Use verbose output. May be specified twice for &quot;very verbose&quot; output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-yank--q"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-yank---quiet"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-yank---color"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3 id="common-options-29"><a class="header" href="#common-options-29">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-yank-+toolchain"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-yank---config"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---config"></a><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></dt>
<dd class="option-desc">Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</dd>
<dt class="option-term" id="option-cargo-yank--h"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-yank---help"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-yank--Z"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2 id="environment-28"><a class="header" href="#environment-28">ENVIRONMENT</a></h2>
<p>See <a href="commands/../reference/environment-variables.html">the reference</a> for
details on environment variables that Cargo reads.</p>
<h2 id="exit-status-28"><a class="header" href="#exit-status-28">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: Cargo succeeded.</li>
<li><code>101</code>: Cargo failed to complete.</li>
</ul>
<h2 id="examples-31"><a class="header" href="#examples-31">EXAMPLES</a></h2>
<ol>
<li>
<p>Yank a crate from the index:</p>
<pre><code>cargo yank foo@1.0.7
</code></pre>
</li>
</ol>
<h2 id="see-also-31"><a class="header" href="#see-also-31">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-login.html">cargo-login(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h2>
<h3 id="is-the-plan-to-use-github-as-a-package-repository"><a class="header" href="#is-the-plan-to-use-github-as-a-package-repository">Is the plan to use GitHub as a package repository?</a></h3>
<p>No. The plan for Cargo is to use <a href="https://crates.io/">crates.io</a>, like npm or Rubygems do with
<a href="https://www.npmjs.com">npmjs.com</a> and <a href="https://rubygems.org">rubygems.org</a>.</p>
<p>We plan to support git repositories as a source of packages forever,
because they can be used for early development and temporary patches,
even when people use the registry as the primary source of packages.</p>
<h3 id="why-build-cratesio-rather-than-use-github-as-a-registry"><a class="header" href="#why-build-cratesio-rather-than-use-github-as-a-registry">Why build crates.io rather than use GitHub as a registry?</a></h3>
<p>We think that it’s very important to support multiple ways to download
packages, including downloading from GitHub and copying packages into
your package itself.</p>
<p>That said, we think that <a href="https://crates.io/">crates.io</a> offers a number of important benefits, and
will likely become the primary way that people download packages in Cargo.</p>
<p>For precedent, both Node.js’s <a href="https://www.npmjs.com">npm</a> and Ruby’s <a href="https://bundler.io">bundler</a> support both a
central registry model as well as a Git-based model, and most packages
are downloaded through the registry in those ecosystems, with an
important minority of packages making use of git-based packages.</p>
<p>Some of the advantages that make a central registry popular in other
languages include:</p>
<ul>
<li><strong>Discoverability</strong>. A central registry provides an easy place to look
for existing packages. Combined with tagging, this also makes it
possible for a registry to provide ecosystem-wide information, such as a
list of the most popular or most-depended-on packages.</li>
<li><strong>Speed</strong>. A central registry makes it possible to easily fetch just
the metadata for packages quickly and efficiently, and then to
efficiently download just the published package, and not other bloat
that happens to exist in the repository. This adds up to a significant
improvement in the speed of dependency resolution and fetching. As
dependency graphs scale up, downloading all of the git repositories bogs
down fast. Also remember that not everybody has a high-speed,
low-latency Internet connection.</li>
</ul>
<h3 id="will-cargo-work-with-c-code-or-other-languages"><a class="header" href="#will-cargo-work-with-c-code-or-other-languages">Will Cargo work with C code (or other languages)?</a></h3>
<p>Yes!</p>
<p>Cargo handles compiling Rust code, but we know that many Rust packages
link against C code. We also know that there are decades of tooling
built up around compiling languages other than Rust.</p>
<p>Our solution: Cargo allows a package to <a href="reference/build-scripts.html">specify a script</a>
(written in Rust) to run before invoking <code>rustc</code>. Rust is leveraged to
implement platform-specific configuration and refactor out common build
functionality among packages.</p>
<h3 id="can-cargo-be-used-inside-of-make-or-ninja-or-"><a class="header" href="#can-cargo-be-used-inside-of-make-or-ninja-or-">Can Cargo be used inside of <code>make</code> (or <code>ninja</code>, or ...)</a></h3>
<p>Indeed. While we intend Cargo to be useful as a standalone way to
compile Rust packages at the top-level, we know that some people will
want to invoke Cargo from other build tools.</p>
<p>We have designed Cargo to work well in those contexts, paying attention
to things like error codes and machine-readable output modes. We still
have some work to do on those fronts, but using Cargo in the context of
conventional scripts is something we designed for from the beginning and
will continue to prioritize.</p>
<h3 id="does-cargo-handle-multi-platform-packages-or-cross-compilation"><a class="header" href="#does-cargo-handle-multi-platform-packages-or-cross-compilation">Does Cargo handle multi-platform packages or cross-compilation?</a></h3>
<p>Rust itself provides facilities for configuring sections of code based
on the platform. Cargo also supports <a href="reference/specifying-dependencies.html#platform-specific-dependencies">platform-specific
dependencies</a>, and we plan to support more per-platform
configuration in <code>Cargo.toml</code> in the future.</p>
<p>In the longer-term, we’re looking at ways to conveniently cross-compile
packages using Cargo.</p>
<h3 id="does-cargo-support-environments-like-production-or-test"><a class="header" href="#does-cargo-support-environments-like-production-or-test">Does Cargo support environments, like <code>production</code> or <code>test</code>?</a></h3>
<p>We support environments through the use of <a href="reference/profiles.html">profiles</a> to support:</p>
<ul>
<li>environment-specific flags (like <code>-g --opt-level=0</code> for development
and <code>--opt-level=3</code> for production).</li>
<li>environment-specific dependencies (like <code>hamcrest</code> for test assertions).</li>
<li>environment-specific <code>#[cfg]</code></li>
<li>a <code>cargo test</code> command</li>
</ul>
<h3 id="does-cargo-work-on-windows"><a class="header" href="#does-cargo-work-on-windows">Does Cargo work on Windows?</a></h3>
<p>Yes!</p>
<p>All commits to Cargo are required to pass the local test suite on Windows.
If you encounter an issue while running on Windows, we consider it a bug, so <a href="https://rubygems.org">please file an
issue</a>.</p>
<h3 id="why-do-binaries-have-cargolock-in-version-control-but-not-libraries"><a class="header" href="#why-do-binaries-have-cargolock-in-version-control-but-not-libraries">Why do binaries have <code>Cargo.lock</code> in version control, but not libraries?</a></h3>
<p>The purpose of a <code>Cargo.lock</code> lockfile is to describe the state of the world at
the time of a successful build. Cargo uses the lockfile to provide
deterministic builds on different times and different systems, by ensuring that
the exact same dependencies and versions are used as when the <code>Cargo.lock</code> file
was originally generated.</p>
<p>This property is most desirable from applications and packages which are at the
very end of the dependency chain (binaries). As a result, it is recommended that
all binaries check in their <code>Cargo.lock</code>.</p>
<p>For libraries the situation is somewhat different. A library is not only used by
the library developers, but also any downstream consumers of the library. Users
dependent on the library will not inspect the library’s <code>Cargo.lock</code> (even if it
exists). This is precisely because a library should <strong>not</strong> be deterministically
recompiled for all users of the library.</p>
<p>If a library ends up being used transitively by several dependencies, it’s
likely that just a single copy of the library is desired (based on semver
compatibility). If Cargo used all of the dependencies' <code>Cargo.lock</code> files,
then multiple copies of the library could be used, and perhaps even a version
conflict.</p>
<p>In other words, libraries specify SemVer requirements for their dependencies but
cannot see the full picture. Only end products like binaries have a full
picture to decide what versions of dependencies should be used.</p>
<h3 id="can-libraries-use--as-a-version-for-their-dependencies"><a class="header" href="#can-libraries-use--as-a-version-for-their-dependencies">Can libraries use <code>*</code> as a version for their dependencies?</a></h3>
<p><strong>As of January 22nd, 2016, <a href="https://crates.io/">crates.io</a> rejects all packages (not just libraries)
with wildcard dependency constraints.</strong></p>
<p>While libraries <em>can</em>, strictly speaking, they should not. A version requirement
of <code>*</code> says “This will work with every version ever”, which is never going
to be true. Libraries should always specify the range that they do work with,
even if it’s something as general as “every 1.x.y version”.</p>
<h3 id="why-cargotoml"><a class="header" href="#why-cargotoml">Why <code>Cargo.toml</code>?</a></h3>
<p>As one of the most frequent interactions with Cargo, the question of why the
configuration file is named <code>Cargo.toml</code> arises from time to time. The leading
capital-<code>C</code> was chosen to ensure that the manifest was grouped with other
similar configuration files in directory listings. Sorting files often puts
capital letters before lowercase letters, ensuring files like <code>Makefile</code> and
<code>Cargo.toml</code> are placed together. The trailing <code>.toml</code> was chosen to emphasize
the fact that the file is in the <a href="https://toml.io/">TOML configuration
format</a>.</p>
<p>Cargo does not allow other names such as <code>cargo.toml</code> or <code>Cargofile</code> to
emphasize the ease of how a Cargo repository can be identified. An option of
many possible names has historically led to confusion where one case was handled
but others were accidentally forgotten.</p>
<h3 id="how-can-cargo-work-offline"><a class="header" href="#how-can-cargo-work-offline">How can Cargo work offline?</a></h3>
<p>Cargo is often used in situations with limited or no network access such as
airplanes, CI environments, or embedded in large production deployments. Users
are often surprised when Cargo attempts to fetch resources from the network, and
hence the request for Cargo to work offline comes up frequently.</p>
<p>Cargo, at its heart, will not attempt to access the network unless told to do
so. That is, if no crates come from crates.io, a git repository, or some other
network location, Cargo will never attempt to make a network connection. As a
result, if Cargo attempts to touch the network, then it's because it needs to
fetch a required resource.</p>
<p>Cargo is also quite aggressive about caching information to minimize the amount
of network activity. It will guarantee, for example, that if <code>cargo build</code> (or
an equivalent) is run to completion then the next <code>cargo build</code> is guaranteed to
not touch the network so long as <code>Cargo.toml</code> has not been modified in the
meantime. This avoidance of the network boils down to a <code>Cargo.lock</code> existing
and a populated cache of the crates reflected in the lock file. If either of
these components are missing, then they're required for the build to succeed and
must be fetched remotely.</p>
<p>As of Rust 1.11.0, Cargo understands a new flag, <code>--frozen</code>, which is an
assertion that it shouldn't touch the network. When passed, Cargo will
immediately return an error if it would otherwise attempt a network request.
The error should include contextual information about why the network request is
being made in the first place to help debug as well. Note that this flag <em>does
not change the behavior of Cargo</em>, it simply asserts that Cargo shouldn't touch
the network as a previous command has been run to ensure that network activity
shouldn't be necessary.</p>
<p>The <code>--offline</code> flag was added in Rust 1.36.0. This flag tells Cargo to not
access the network, and try to proceed with available cached data if possible.
You can use <a href="commands/cargo-fetch.html"><code>cargo fetch</code></a> in one project to download dependencies before
going offline, and then use those same dependencies in another project with
the <code>--offline</code> flag (or <a href="reference/config.html#netoffline">configuration value</a>).</p>
<p>For more information about vendoring, see documentation on <a href="reference/source-replacement.html">source
replacement</a>.</p>
<h3 id="why-is-cargo-rebuilding-my-code"><a class="header" href="#why-is-cargo-rebuilding-my-code">Why is Cargo rebuilding my code?</a></h3>
<p>Cargo is responsible for incrementally compiling crates in your project. This
means that if you type <code>cargo build</code> twice the second one shouldn't rebuild your
crates.io dependencies, for example. Nevertheless bugs arise and Cargo can
sometimes rebuild code when you're not expecting it!</p>
<p>We've long <a href="https://github.com/rust-lang/cargo/issues/2904">wanted to provide better diagnostics about
this</a> but unfortunately haven't
been able to make progress on that issue in quite some time. In the meantime,
however, you can debug a rebuild at least a little by setting the <code>CARGO_LOG</code>
environment variable:</p>
<pre><code class="language-sh">$ CARGO_LOG=cargo::core::compiler::fingerprint=info cargo build
</code></pre>
<p>This will cause Cargo to print out a lot of information about diagnostics and
rebuilding. This can often contain clues as to why your project is getting
rebuilt, although you'll often need to connect some dots yourself since this
output isn't super easy to read just yet. Note that the <code>CARGO_LOG</code> needs to be
set for the command that rebuilds when you think it should not. Unfortunately
Cargo has no way right now of after-the-fact debugging &quot;why was that rebuilt?&quot;</p>
<p>Some issues we've seen historically which can cause crates to get rebuilt are:</p>
<ul>
<li>
<p>A build script prints <code>cargo:rerun-if-changed=foo</code> where <code>foo</code> is a file that
doesn't exist and nothing generates it. In this case Cargo will keep running
the build script thinking it will generate the file but nothing ever does. The
fix is to avoid printing <code>rerun-if-changed</code> in this scenario.</p>
</li>
<li>
<p>Two successive Cargo builds may differ in the set of features enabled for some
dependencies. For example if the first build command builds the whole
workspace and the second command builds only one crate, this may cause a
dependency on crates.io to have a different set of features enabled, causing
it and everything that depends on it to get rebuilt. There's unfortunately not
really a great fix for this, although if possible it's best to have the set of
features enabled on a crate constant regardless of what you're building in
your workspace.</p>
</li>
<li>
<p>Some filesystems exhibit unusual behavior around timestamps. Cargo primarily
uses timestamps on files to govern whether rebuilding needs to happen, but if
you're using a nonstandard filesystem it may be affecting the timestamps
somehow (e.g. truncating them, causing them to drift, etc). In this scenario,
feel free to open an issue and we can see if we can accommodate the filesystem
somehow.</p>
</li>
<li>
<p>A concurrent build process is either deleting artifacts or modifying files.
Sometimes you might have a background process that either tries to build or
check your project. These background processes might surprisingly delete some
build artifacts or touch files (or maybe just by accident), which can cause
rebuilds to look spurious! The best fix here would be to wrangle the
background process to avoid clashing with your work.</p>
</li>
</ul>
<p>If after trying to debug your issue, however, you're still running into problems
then feel free to <a href="https://github.com/rust-lang/cargo/issues/new">open an
issue</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="词汇表"><a class="header" href="#词汇表">词汇表</a></h1>
<h3 id="制品"><a class="header" href="#制品">制品</a></h3>
<p><em>artifact</em> &quot;制品&quot;是指编译进程最终创建的文件或文件集，包括可链接库、可执行的二进制文件和生成的文档。</p>
<h3 id="cargo-1"><a class="header" href="#cargo-1">Cargo</a></h3>
<p><em>Cargo</em> 是Rust的<a href="appendix/glossary.html#package-manager"><em>包管理器</em></a>，也是本书涉及的主要内容。</p>
<h3 id="cargolock"><a class="header" href="#cargolock">Cargo.lock</a></h3>
<p>参阅 <a href="appendix/glossary.html#lock-file"><em>lock 文件</em></a>。</p>
<h3 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h3>
<p>参阅 <a href="appendix/glossary.html#manifest"><em>配置清单</em></a>。</p>
<h3 id="crate"><a class="header" href="#crate">Crate</a></h3>
<p>Rust <em>crate</em> 是指一个库或一个可执行程序，分别称为 <em>library crate</em> 或 <em>binary crate</em> 。</p>
<p>Cargo <a href="appendix/glossary.html#package">package</a>定义的每个<a href="appendix/glossary.html#target">target</a>都是<em>crate</em>。</p>
<p>广义来说，术语 <em>crate</em> 可以指目标源代码或目标产生的编译制品，也可以指从<a href="appendix/glossary.html#registry">注册中心</a>获取的压缩包。</p>
<p>指定crate源代码可以细分为<a href="appendix/glossary.html#module"><em>modules</em></a> &quot;模块&quot;。</p>
<h3 id="版本"><a class="header" href="#版本">版本</a></h3>
<p><em>Rust版本</em> 是Rust语言的发展标志。<a href="appendix/../reference/manifest.html#the-edition-field">包的版本</a>是在 <code>Cargo.toml</code> <a href="appendix/glossary.html#manifest">配置清单</a>中指定的，不同的目标可以指定对应版本来使用。更多信息请参阅<a href="appendix/../../edition-guide/index.html">版本指南</a>。</p>
<h3 id="特性-2"><a class="header" href="#特性-2">特性</a></h3>
<p><em>feature</em> &quot;特性&quot; 的含义取决于上下文:</p>
<ul>
<li>
<p><a href="appendix/../reference/features.html"><em>feature</em></a>是一个命名的标志，允许有条件的编译。一个特性可以指一个可选的依赖，也可以指一个任意的名字，在 <code>Cargo.toml</code> <a href="appendix/glossary.html#manifest">manifest</a> 中定义，可在源代码中检查。</p>
</li>
<li>
<p>Cargo有<a href="appendix/../reference/unstable.html"><em>不稳定特性标记</em></a>，可以用来启用Cargo本身的实验性特性。</p>
</li>
<li>
<p>Rust编译器和Rustdoc有自己的不稳定特性标志 (参阅<a href="https://doc.rust-lang.org/nightly/unstable-book/index.html">不稳定篇</a>和<a href="https://doc.rust-lang.org/nightly/rustdoc/unstable-features.html">Rustdoc篇</a>）。</p>
</li>
<li>
<p>CPU 目标有<a href="appendix/../../reference/attributes/codegen.html#the-target_feature-attribute"><em>目标特性</em></a>，指定CPU的性能。</p>
</li>
</ul>
<h3 id="索引"><a class="header" href="#索引">索引</a></h3>
<p><em>index</em> &quot;索引&quot; 是<a href="appendix/glossary.html#registry"><em>注册中心</em></a>中 <a href="appendix/glossary.html#crate"><em>crates</em></a> 的可搜索列表。</p>
<h3 id="lock-文件"><a class="header" href="#lock-文件">Lock 文件</a></h3>
<p><code>Cargo.lock</code> <em>lock文件</em> 记录 <a href="appendix/glossary.html#workspace"><em>workspace</em></a>或<a href="appendix/glossary.html#package"><em>package</em></a>中使用的每个依赖的确切版本。它是由Cargo自动生成的。参阅 <a href="appendix/../guide/cargo-toml-vs-cargo-lock.html">Cargo.toml vs Cargo.lock</a> 。</p>
<h3 id="配置清单"><a class="header" href="#配置清单">配置清单</a></h3>
<p>其名为 <code>Cargo.toml</code> 的文件中，<a href="appendix/../reference/manifest.html"><em>配置清单</em></a>是对<a href="appendix/glossary.html#package">package</a>或<a href="appendix/glossary.html#workspace">workspace</a>的描述。</p>
<p>[<em>虚拟配置清单</em>][virtual manifest] <code>Cargo.toml</code> 文件，仅描述一个工作空间，不包含包。</p>
<h3 id="成员"><a class="header" href="#成员">成员</a></h3>
<p><em>member</em> &quot;成员&quot;是属于<a href="appendix/glossary.html#workspace"><em>workspace</em></a> 的 <a href="appendix/glossary.html#package"><em>package</em></a>。</p>
<h3 id="模块"><a class="header" href="#模块">模块</a></h3>
<p>Rust的模块系统将代码组织成称为 <em>modules</em> &quot;模块&quot;的逻辑单元，在代码中提供独立的命名空间。</p>
<p>指定的 <a href="appendix/glossary.html#crate">crate</a> 的源代码可以被细分为一个或多个独立的模块。这样做通常是为了将代码组织在相关的功能区域，或者来控制源代码中的标识符(结构体、函数等)的可见性(public/private) &quot;公共/私有&quot;。</p>
<p><a href="appendix/glossary.html#manifest"><code>Cargo.toml</code></a>文件主要关注它所定义的<a href="appendix/glossary.html#package">package</a>、crates、它们所依赖的crates的包。尽管如此，在使用Rust时，你会经常注意到 &quot;模块&quot; 这个术语，所以你应该了解模块与crate的关系。</p>
<h3 id="包"><a class="header" href="#包">包</a></h3>
<p><em>package</em> &quot;包&quot; 是对源文件集合和 <code>Cargo.toml</code> <a href="appendix/glossary.html#manifest"><em>manifest</em></a> 文件的描述。包对应的名称和版本，用来指定包之间的依赖关系。</p>
<p>package &quot;包&quot; 包含多个<a href="appendix/glossary.html#target"><em>target</em></a>，每个都是一个<a href="appendix/glossary.html#crate"><em>crate</em></a>。 <code>Cargo.toml</code> 文件描述了包内的crate的二进制或库的类型，以及每个crate的一些元数据--如何构建每个crate，它们的直接依赖是什么，等等，这正是本书所描述的。</p>
<p><em>package root</em> &quot;包的根&quot; 是指包的 <code>Cargo.toml</code> 配置清单所在的目录。(相对于<a href="appendix/glossary.html#workspace"><em>工作区根</em></a>)。</p>
<p><a href="appendix/../reference/pkgid-spec.html"><em>package ID specification</em></a>，或 <em>SPEC</em> ，是一个字符串，用来唯一地引用一个特定来源包的特定版本。</p>
<p>尽管多个crates是很常见的，但往往中小型的Rust项目只需要一个包。</p>
<p>较大的项目可能涉及多个软件包，在这种情况下，Cargo <a href="appendix/glossary.html#workspace"><em>workspaces</em></a> 可以用来管理软件包之间的共同依赖和其他相关元数据。</p>
<h3 id="包管理"><a class="header" href="#包管理">包管理</a></h3>
<p>广义上讲，<em>包管理器</em> 是软件生态系统中的一个程序(或相关程序的集合)，它可以自动获取、安装和升级制品。在编程语言的生态系统中，软件包管理器是以开发者为中心的工具，其主要功能是从一些中心存储库中下载库的制品和它们的依赖；这种功能通常与执行软件构建的功能相结合(通过调用特定语言的编译器)。</p>
<p><a href="appendix/glossary.html#cargo"><em>Cargo</em></a>是Rust生态系统中的软件包管理器。Cargo下载 Rust <a href="appendix/glossary.html#package">package</a>的依赖项(<a href="appendix/glossary.html#artifact"><em>artifacts</em></a>被称为<a href="appendix/glossary.html#crate"><em>crates</em></a>)、编译包、制作可分享的包，并(可选择)将它们上传到Rust社区的 <a href="appendix/glossary.html#registry"><em>package 注册中心</em></a>。</p>
<h3 id="包注册中心"><a class="header" href="#包注册中心">包注册中心</a></h3>
<p>参阅 <a href="appendix/glossary.html#registry"><em>注册中心</em></a>。</p>
<h3 id="项目"><a class="header" href="#项目">项目</a></h3>
<p><a href="appendix/glossary.html#package">package</a> 的另一个名称。</p>
<h3 id="注册中心-1"><a class="header" href="#注册中心-1">注册中心</a></h3>
<p><em>registry</em> &quot;注册中心&quot; 服务，拥有可下载的<a href="appendix/glossary.html#crate"><em>crates</em></a>集合，可以作为<a href="appendix/glossary.html#package"><em>package</em></a>的依赖而被安装使用。Rust生态系统中的默认注册中心是<a href="https://crates.io">crates.io</a>。
该注册中心有一个<a href="appendix/glossary.html#index"><em>index</em></a>，包含了所有crate的列表，并告知Cargo如何下载需要的crate。</p>
<h3 id="源"><a class="header" href="#源">源</a></h3>
<p>一个<em>source</em> &quot;源&quot; 是拥有<a href="appendix/glossary.html#crate"><em>crates</em></a>的提供者，它可以作为 <a href="appendix/glossary.html#package"><em>package</em></a> 的依赖项。源有以下几种类型:</p>
<ul>
<li><strong>注册中心源</strong> — 参阅 <a href="appendix/glossary.html#registry">注册中心</a>。</li>
<li><strong>本地注册源</strong> — 一组以压缩文件形式存储在文件系统中的crates。参阅 <a href="appendix/../reference/source-replacement.html#local-registry-sources">本地注册源</a> 。</li>
<li><strong>目录源</strong> — 一组以压缩文件形式存储在文件系统中的crates。参阅 <a href="appendix/../reference/source-replacement.html#directory-sources">目录源</a>.</li>
<li><strong>路径源</strong> — 在文件系统是独立包(如<a href="appendix/../reference/specifying-dependencies.html#specifying-path-dependencies">路径依赖</a>)或多个软件包的集合(比如[路径覆盖])。</li>
<li><strong>Git源</strong> — 位于git仓库中的包(比如<a href="appendix/../reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories">git 依赖</a>或<a href="appendix/../reference/source-replacement.html">git 源</a>)。</li>
</ul>
<p>详见 <a href="appendix/../reference/source-replacement.html">源替换</a>。</p>
<h3 id="spec"><a class="header" href="#spec">Spec</a></h3>
<p>参阅 <a href="appendix/glossary.html#package">package ID specification</a> 。</p>
<h3 id="目标"><a class="header" href="#目标">目标</a></h3>
<p><em>target</em> &quot;目标&quot;术语的含义取决于上下文:</p>
<ul>
<li>
<p><strong>Cargo 目标</strong> — Cargo <a href="appendix/glossary.html#package"><em>packages</em></a> <em>targets</em> ，对应于将要生成的 <a href="appendix/glossary.html#artifact"><em>制品</em></a>。包可以有库、二进制、示例、测试和基准目标。在 <code>Cargo.toml</code> <a href="appendix/glossary.html#manifest"><em>manifest</em></a>中配置<a href="appendix/../reference/cargo-targets.html#configuring-a-target">目标列表</a>，通常由源文件的<a href="appendix/../guide/project-layout.html">目录层级</a>自动推断。</p>
</li>
<li>
<p><strong>目标目录</strong> — Cargo将所有构建的制品和中间文件放在 <em>目标</em> 目录中。默认情况下是一个名称为 <code>target</code> 的目录，位于 <a href="appendix/glossary.html#workspace"><em>workspace</em></a> 根目录下，如果不使用工作区，则为包的根目录。该目录可以通过 <code>--target-dir</code> 命令行选项、<code>CARGO_TARGET_DIR</code><a href="appendix/../reference/environment-variables.html">环境变量</a>或 <code>build.target-dir</code> <a href="appendix/../reference/config.html">配置选项</a> 来改变。</p>
</li>
<li>
<p><strong>目标架构</strong> — 操作系统以及机器架构中所构建的制品通常被称为 <em>目标</em> 。</p>
</li>
<li>
<p><strong>目标三元组</strong> — 三元组架构是指定目标体系结构的特定格式。三元组可以被称为 <em>目标三元组</em> ，它是生成制品的体系结构，而 <em>host triple</em> 是编译器运行的体系结构。目标三元组可以通过命令行选项 <code>--target</code> 或 <code>build.target</code> <a href="appendix/../reference/config.html">配置选项</a> 指定。三元组的一般格式是 <code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code> :</p>
<ul>
<li><code>arch</code> = CPU基础架构, 例如 <code>x86_64</code>, <code>i686</code>, <code>arm</code>, <code>thumb</code>, <code>mips</code> 等。</li>
<li><code>sub</code> = CPU子架构, 例如 <code>arm</code> has <code>v7</code>, <code>v7s</code>, <code>v5te</code> 等。</li>
<li><code>vendor</code> = 供应商 , 例如 <code>unknown</code>, <code>apple</code>, <code>pc</code>, <code>nvidia</code> 等.</li>
<li><code>sys</code> = 系统名称, 例如 <code>linux</code>, <code>windows</code>, <code>darwin</code> 等。 <code>none</code> 是没有操作系统的裸机.</li>
<li><code>abi</code> = ABI, 例如 <code>gnu</code>, <code>android</code>, <code>eabi</code> 等。</li>
</ul>
<p>一些可省略参数。运行 <code>rustc --print target-list</code> 获取列表。</p>
</li>
</ul>
<h3 id="测试目标"><a class="header" href="#测试目标">测试目标</a></h3>
<p>Cargo <em>测试目标</em> 生成的二进制文件有助于验证代码的正确操作和准确性。有两种类型的测试制品:</p>
<ul>
<li><strong>单元测试</strong> — <em>单元测试</em>是可执行的二进制文件，由库或二进制目标直接编译生成。它包含库或二进制代码的全部内容，并运行 <code>#[test]</code> 注解的函数，旨在验证各个单元的代码。</li>
<li><strong>集成测试目标</strong> — <a href="appendix/../reference/cargo-targets.html#integration-tests"><em>集成测试目标</em></a> 是由 <em>测试目标</em> 编译的可执行二进制文件，该目标是一个独立的 <a href="appendix/glossary.html#crate"><em>crate</em></a> ，其来源位于 <code>tests</code> 目录下或由 <code>Cargo.toml</code> <a href="appendix/glossary.html#manifest"><em>manifest</em></a> 中的 <a href="appendix/../reference/cargo-targets.html#configuring-a-target"><code>[[test]]</code> table</a> 指定。它的目的是只测试一个库的公共API，或执行一个二进制文件以验证操作。</li>
</ul>
<h3 id="工作空间-1"><a class="header" href="#工作空间-1">工作空间</a></h3>
<p><a href="appendix/../reference/workspaces.html"><em>workspace</em></a> 是一个或多个 <a href="appendix/glossary.html#package"><em>packages</em></a> 的集合，它们共享共同的依赖(拥有共享的<code>Cargo.lock</code> <a href="appendix/glossary.html#lock-file"><em>lock file</em></a>)、输出目录，各项设置，如配置文件。</p>
<p><a href="appendix/../reference/workspaces.html"><em>虚拟工作区</em></a> 根 <code>Cargo.toml</code> <a href="appendix/glossary.html#manifest"><em>manifest</em></a> 没有定义包，只列出工作区 <a href="appendix/glossary.html#member"><em>成员</em></a> 。</p>
<p><em>工作区根</em> 是工作区的 <code>Cargo.toml</code> 配置清单所在的目录。 (相对于<a href="appendix/glossary.html#package"><em>package root</em></a>)。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-认证"><a class="header" href="#git-认证">Git 认证</a></h1>
<p>在使用git依赖和注册中心时，Cargo支持一些形式的认证。本附录包含一些关于设置git认证的内容，以便与Cargo配合使用。</p>
<p>如果你需要其他的认证方法，可以设置 <a href="appendix/../reference/config.html#netgit-fetch-with-cli"><code>net.git-fetch-with-cli</code></a> 配置值，使Cargo执行 <code>git</code> 可执行文件来处理获取远程仓库，而不是使用内置支持。
这可以通过 <code>CARGO_NET_GIT_FETCH_WITH_CLI=true</code> 环境变量来启用。</p>
<h2 id="https-认证"><a class="header" href="#https-认证">HTTPS 认证</a></h2>
<p>HTTPS认证需要 <a href="https://git-scm.com/book/en/v2/Git-Tools-Credential-Storage"><code>credential.helper</code></a> 机制。有多个凭证辅助工具，你在全局git配置文件中指定你要使用那个。</p>
<pre><code class="language-ini"># ~/.gitconfig

[credential]
helper = store
</code></pre>
<p>Cargo不要求密码，所以对于大多数辅助工具来说，你需要在运行Cargo之前给辅助工具提供用户名及密码。一种方式是运行私有git仓库的 <code>git clone</code> 并输入用户名及密码。</p>
<blockquote>
<p><strong>提示:</strong><br>
macOS用户可能要考虑使用osxkeychain辅助工具。<br>
Windows用户可能要考虑使用<a href="https://github.com/microsoft/Git-Credential-Manager-Core/">GCM</a>辅助工具。</p>
</blockquote>
<blockquote>
<p><strong>注意:</strong> Windows用户需要确保 <code>sh</code> shell在你的 <code>PATH</code> 中可用。
这通常是在安装Git for Windows时才有。</p>
</blockquote>
<h2 id="ssh-认证"><a class="header" href="#ssh-认证">SSH 认证</a></h2>
<p>SSH 认证需要运行 <code>ssh-agent</code> 来获取 SSH 密钥。确保设置了适当的环境变量(在大多数类似 Unix 的系统上为 <code>SSH_AUTH_SOCK</code>)，并添加了正确的密钥(用 <code>ssh-add</code>)。</p>
<p>Windows可以使用Pageant(<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/">PuTTY</a>的一部分)或 <code>ssh-agent</code> 。要使用 <code>ssh-agent</code> ，Cargo需要使用作为Windows一部分分发的OpenSSH，因为Cargo不支持MinGW或Cygwin使用的模拟Unix-domain套接字。
关于用Windows安装的更多信息可以在<a href="https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse">微软安装文档</a>找到，<a href="https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_keymanagement">密钥管理</a>页面有关于如何启动 <code>ssh-agent</code> 和添加密钥的说明。</p>
<blockquote>
<p><strong>注意:</strong> Cargo不支持git的简化SSH URL，如 <code>git@example.com:user/repo.git</code> 。
使用完整的SSH URL 如 <code>ssh://git@example.com/user/repo.git</code> .</p>
</blockquote>
<blockquote>
<p><strong>注意:</strong> Cargo的内置SSH库不使用SSH配置文件(如OpenSSH的<code>~/.ssh/config</code>)。
高级选项应使用 <a href="appendix/../reference/config.html#netgit-fetch-with-cli"><code>net.git-fetch-with-cli</code></a> 。</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
